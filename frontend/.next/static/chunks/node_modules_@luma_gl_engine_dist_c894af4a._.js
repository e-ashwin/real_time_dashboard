(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_@luma_gl_engine_dist_c894af4a._.js", {

"[project]/node_modules/@luma.gl/engine/dist/animation/timeline.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "Timeline": (()=>Timeline)
});
let channelHandles = 1;
let animationHandles = 1;
class Timeline {
    time = 0;
    channels = new Map();
    animations = new Map();
    playing = false;
    lastEngineTime = -1;
    constructor(){}
    addChannel(props) {
        const { delay = 0, duration = Number.POSITIVE_INFINITY, rate = 1, repeat = 1 } = props;
        const channelId = channelHandles++;
        const channel = {
            time: 0,
            delay,
            duration,
            rate,
            repeat
        };
        this._setChannelTime(channel, this.time);
        this.channels.set(channelId, channel);
        return channelId;
    }
    removeChannel(channelId) {
        this.channels.delete(channelId);
        for (const [animationHandle, animation] of this.animations){
            if (animation.channel === channelId) {
                this.detachAnimation(animationHandle);
            }
        }
    }
    isFinished(channelId) {
        const channel = this.channels.get(channelId);
        if (channel === undefined) {
            return false;
        }
        return this.time >= channel.delay + channel.duration * channel.repeat;
    }
    getTime(channelId) {
        if (channelId === undefined) {
            return this.time;
        }
        const channel = this.channels.get(channelId);
        if (channel === undefined) {
            return -1;
        }
        return channel.time;
    }
    setTime(time) {
        this.time = Math.max(0, time);
        const channels = this.channels.values();
        for (const channel of channels){
            this._setChannelTime(channel, this.time);
        }
        const animations = this.animations.values();
        for (const animationData of animations){
            const { animation, channel } = animationData;
            animation.setTime(this.getTime(channel));
        }
    }
    play() {
        this.playing = true;
    }
    pause() {
        this.playing = false;
        this.lastEngineTime = -1;
    }
    reset() {
        this.setTime(0);
    }
    attachAnimation(animation, channelHandle) {
        const animationHandle = animationHandles++;
        this.animations.set(animationHandle, {
            animation,
            channel: channelHandle
        });
        animation.setTime(this.getTime(channelHandle));
        return animationHandle;
    }
    detachAnimation(channelId) {
        this.animations.delete(channelId);
    }
    update(engineTime) {
        if (this.playing) {
            if (this.lastEngineTime === -1) {
                this.lastEngineTime = engineTime;
            }
            this.setTime(this.time + (engineTime - this.lastEngineTime));
            this.lastEngineTime = engineTime;
        }
    }
    _setChannelTime(channel, time) {
        const offsetTime = time - channel.delay;
        const totalDuration = channel.duration * channel.repeat;
        // Note(Tarek): Don't loop on final repeat.
        if (offsetTime >= totalDuration) {
            channel.time = channel.duration * channel.rate;
        } else {
            channel.time = Math.max(0, offsetTime) % channel.duration;
            channel.time *= channel.rate;
        }
    }
} //# sourceMappingURL=timeline.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/animation-loop/request-animation-frame.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/* global window, setTimeout, clearTimeout */ /** Node.js polyfill for requestAnimationFrame */ // / <reference types="@types/node" />
__turbopack_context__.s({
    "cancelAnimationFramePolyfill": (()=>cancelAnimationFramePolyfill),
    "requestAnimationFramePolyfill": (()=>requestAnimationFramePolyfill)
});
function requestAnimationFramePolyfill(callback) {
    return typeof window !== 'undefined' && window.requestAnimationFrame ? window.requestAnimationFrame(callback) : setTimeout(callback, 1000 / 60);
}
function cancelAnimationFramePolyfill(timerId) {
    return typeof window !== 'undefined' && window.cancelAnimationFrame ? window.cancelAnimationFrame(timerId) : clearTimeout(timerId);
} //# sourceMappingURL=request-animation-frame.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/animation-loop/animation-loop.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "AnimationLoop": (()=>AnimationLoop)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$luma$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/core/dist/adapter/luma.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$animation$2d$loop$2f$request$2d$animation$2d$frame$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/engine/dist/animation-loop/request-animation-frame.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/stats/dist/index.js [client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$lib$2f$stats$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Stats$3e$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/stats/dist/lib/stats.js [client] (ecmascript) <export default as Stats>");
;
;
;
let statIdCounter = 0;
const DEFAULT_ANIMATION_LOOP_PROPS = {
    device: null,
    onAddHTML: ()=>'',
    onInitialize: async ()=>{
        return null;
    },
    onRender: ()=>{},
    onFinalize: ()=>{},
    onError: (error)=>console.error(error),
    stats: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$luma$2e$js__$5b$client$5d$__$28$ecmascript$29$__["luma"].stats.get(`animation-loop-${statIdCounter++}`),
    // view parameters
    useDevicePixels: true,
    autoResizeViewport: false,
    autoResizeDrawingBuffer: false
};
class AnimationLoop {
    device = null;
    canvas = null;
    props;
    animationProps = null;
    timeline = null;
    stats;
    cpuTime;
    gpuTime;
    frameRate;
    display;
    needsRedraw = 'initialized';
    _initialized = false;
    _running = false;
    _animationFrameId = null;
    _nextFramePromise = null;
    _resolveNextFrame = null;
    _cpuStartTime = 0;
    _error = null;
    // _gpuTimeQuery: Query | null = null;
    /*
     * @param {HTMLCanvasElement} canvas - if provided, width and height will be passed to context
     */ constructor(props){
        this.props = {
            ...DEFAULT_ANIMATION_LOOP_PROPS,
            ...props
        };
        props = this.props;
        if (!props.device) {
            throw new Error('No device provided');
        }
        const { useDevicePixels = true } = this.props;
        // state
        this.stats = props.stats || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$lib$2f$stats$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Stats$3e$__["Stats"]({
            id: 'animation-loop-stats'
        });
        this.cpuTime = this.stats.get('CPU Time');
        this.gpuTime = this.stats.get('GPU Time');
        this.frameRate = this.stats.get('Frame Rate');
        this.setProps({
            autoResizeViewport: props.autoResizeViewport,
            autoResizeDrawingBuffer: props.autoResizeDrawingBuffer,
            useDevicePixels
        });
        // Bind methods
        this.start = this.start.bind(this);
        this.stop = this.stop.bind(this);
        this._onMousemove = this._onMousemove.bind(this);
        this._onMouseleave = this._onMouseleave.bind(this);
    }
    destroy() {
        this.stop();
        this._setDisplay(null);
    }
    /** @deprecated Use .destroy() */ delete() {
        this.destroy();
    }
    setError(error) {
        this.props.onError(error);
        this._error = Error();
        const canvas = this.device?.canvasContext?.canvas;
        if (canvas instanceof HTMLCanvasElement) {
            const errorDiv = document.createElement('h1');
            errorDiv.innerHTML = error.message;
            errorDiv.style.position = 'absolute';
            errorDiv.style.top = '20%'; // left: 50%; transform: translate(-50%, -50%);';
            errorDiv.style.left = '10px';
            errorDiv.style.color = 'black';
            errorDiv.style.backgroundColor = 'red';
            document.body.appendChild(errorDiv);
        // canvas.style.position = 'absolute';
        }
    }
    /** Flags this animation loop as needing redraw */ setNeedsRedraw(reason) {
        this.needsRedraw = this.needsRedraw || reason;
        return this;
    }
    /** TODO - move these props to CanvasContext? */ setProps(props) {
        if ('autoResizeViewport' in props) {
            this.props.autoResizeViewport = props.autoResizeViewport || false;
        }
        if ('autoResizeDrawingBuffer' in props) {
            this.props.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer || false;
        }
        if ('useDevicePixels' in props) {
            this.props.useDevicePixels = props.useDevicePixels || false;
        }
        return this;
    }
    /** Starts a render loop if not already running */ async start() {
        if (this._running) {
            return this;
        }
        this._running = true;
        try {
            let appContext;
            if (!this._initialized) {
                this._initialized = true;
                // Create the WebGL context
                await this._initDevice();
                this._initialize();
                // Note: onIntialize can return a promise (e.g. in case app needs to load resources)
                await this.props.onInitialize(this._getAnimationProps());
            }
            // check that we haven't been stopped
            if (!this._running) {
                return null;
            }
            // Start the loop
            if (appContext !== false) {
                // cancel any pending renders to ensure only one loop can ever run
                this._cancelAnimationFrame();
                this._requestAnimationFrame();
            }
            return this;
        } catch (err) {
            const error = err instanceof Error ? err : new Error('Unknown error');
            this.props.onError(error);
            // this._running = false; // TODO
            throw error;
        }
    }
    /** Stops a render loop if already running, finalizing */ stop() {
        // console.debug(`Stopping ${this.constructor.name}`);
        if (this._running) {
            // call callback
            // If stop is called immediately, we can end up in a state where props haven't been initialized...
            if (this.animationProps && !this._error) {
                this.props.onFinalize(this.animationProps);
            }
            this._cancelAnimationFrame();
            this._nextFramePromise = null;
            this._resolveNextFrame = null;
            this._running = false;
        }
        return this;
    }
    /** Explicitly draw a frame */ redraw() {
        if (this.device?.isLost || this._error) {
            return this;
        }
        this._beginFrameTimers();
        this._setupFrame();
        this._updateAnimationProps();
        this._renderFrame(this._getAnimationProps());
        // clear needsRedraw flag
        this._clearNeedsRedraw();
        if (this._resolveNextFrame) {
            this._resolveNextFrame(this);
            this._nextFramePromise = null;
            this._resolveNextFrame = null;
        }
        this._endFrameTimers();
        return this;
    }
    /** Add a timeline, it will be automatically updated by the animation loop. */ attachTimeline(timeline) {
        this.timeline = timeline;
        return this.timeline;
    }
    /** Remove a timeline */ detachTimeline() {
        this.timeline = null;
    }
    /** Wait until a render completes */ waitForRender() {
        this.setNeedsRedraw('waitForRender');
        if (!this._nextFramePromise) {
            this._nextFramePromise = new Promise((resolve)=>{
                this._resolveNextFrame = resolve;
            });
        }
        return this._nextFramePromise;
    }
    /** TODO - should use device.deviceContext */ async toDataURL() {
        this.setNeedsRedraw('toDataURL');
        await this.waitForRender();
        if (this.canvas instanceof HTMLCanvasElement) {
            return this.canvas.toDataURL();
        }
        throw new Error('OffscreenCanvas');
    }
    // PRIVATE METHODS
    _initialize() {
        this._startEventHandling();
        // Initialize the callback data
        this._initializeAnimationProps();
        this._updateAnimationProps();
        // Default viewport setup, in case onInitialize wants to render
        this._resizeCanvasDrawingBuffer();
        this._resizeViewport();
    // this._gpuTimeQuery = Query.isSupported(this.gl, ['timers']) ? new Query(this.gl) : null;
    }
    _setDisplay(display) {
        if (this.display) {
            this.display.destroy();
            this.display.animationLoop = null;
        }
        // store animation loop on the display
        if (display) {
            display.animationLoop = this;
        }
        this.display = display;
    }
    _requestAnimationFrame() {
        if (!this._running) {
            return;
        }
        // VR display has a separate animation frame to sync with headset
        // TODO WebVR API discontinued, replaced by WebXR: https://immersive-web.github.io/webxr/
        // See https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/requestAnimationFrame
        // if (this.display && this.display.requestAnimationFrame) {
        //   this._animationFrameId = this.display.requestAnimationFrame(this._animationFrame.bind(this));
        // }
        this._animationFrameId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$animation$2d$loop$2f$request$2d$animation$2d$frame$2e$js__$5b$client$5d$__$28$ecmascript$29$__["requestAnimationFramePolyfill"])(this._animationFrame.bind(this));
    }
    _cancelAnimationFrame() {
        if (this._animationFrameId === null) {
            return;
        }
        // VR display has a separate animation frame to sync with headset
        // TODO WebVR API discontinued, replaced by WebXR: https://immersive-web.github.io/webxr/
        // See https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/requestAnimationFrame
        // if (this.display && this.display.cancelAnimationFramePolyfill) {
        //   this.display.cancelAnimationFrame(this._animationFrameId);
        // }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$animation$2d$loop$2f$request$2d$animation$2d$frame$2e$js__$5b$client$5d$__$28$ecmascript$29$__["cancelAnimationFramePolyfill"])(this._animationFrameId);
        this._animationFrameId = null;
    }
    _animationFrame() {
        if (!this._running) {
            return;
        }
        this.redraw();
        this._requestAnimationFrame();
    }
    // Called on each frame, can be overridden to call onRender multiple times
    // to support e.g. stereoscopic rendering
    _renderFrame(animationProps) {
        // Allow e.g. VR display to render multiple frames.
        if (this.display) {
            this.display._renderFrame(animationProps);
            return;
        }
        // call callback
        this.props.onRender(this._getAnimationProps());
        // end callback
        // Submit commands (necessary on WebGPU)
        this.device?.submit();
    }
    _clearNeedsRedraw() {
        this.needsRedraw = false;
    }
    _setupFrame() {
        this._resizeCanvasDrawingBuffer();
        this._resizeViewport();
    }
    // Initialize the  object that will be passed to app callbacks
    _initializeAnimationProps() {
        const canvas = this.device?.canvasContext?.canvas;
        if (!this.device || !canvas) {
            throw new Error('loop');
        }
        this.animationProps = {
            animationLoop: this,
            device: this.device,
            canvas,
            timeline: this.timeline,
            // Initial values
            useDevicePixels: this.props.useDevicePixels,
            needsRedraw: false,
            // Placeholders
            width: 1,
            height: 1,
            aspect: 1,
            // Animation props
            time: 0,
            startTime: Date.now(),
            engineTime: 0,
            tick: 0,
            tock: 0,
            // Experimental
            _mousePosition: null // Event props
        };
    }
    _getAnimationProps() {
        if (!this.animationProps) {
            throw new Error('animationProps');
        }
        return this.animationProps;
    }
    // Update the context object that will be passed to app callbacks
    _updateAnimationProps() {
        if (!this.animationProps) {
            return;
        }
        // Can this be replaced with canvas context?
        const { width, height, aspect } = this._getSizeAndAspect();
        if (width !== this.animationProps.width || height !== this.animationProps.height) {
            this.setNeedsRedraw('drawing buffer resized');
        }
        if (aspect !== this.animationProps.aspect) {
            this.setNeedsRedraw('drawing buffer aspect changed');
        }
        this.animationProps.width = width;
        this.animationProps.height = height;
        this.animationProps.aspect = aspect;
        this.animationProps.needsRedraw = this.needsRedraw;
        // Update time properties
        this.animationProps.engineTime = Date.now() - this.animationProps.startTime;
        if (this.timeline) {
            this.timeline.update(this.animationProps.engineTime);
        }
        this.animationProps.tick = Math.floor(this.animationProps.time / 1000 * 60);
        this.animationProps.tock++;
        // For back compatibility
        this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;
    }
    /** Wait for supplied device */ async _initDevice() {
        this.device = await this.props.device;
        if (!this.device) {
            throw new Error('No device provided');
        }
        this.canvas = this.device.canvasContext?.canvas || null;
    // this._createInfoDiv();
    }
    _createInfoDiv() {
        if (this.canvas && this.props.onAddHTML) {
            const wrapperDiv = document.createElement('div');
            document.body.appendChild(wrapperDiv);
            wrapperDiv.style.position = 'relative';
            const div = document.createElement('div');
            div.style.position = 'absolute';
            div.style.left = '10px';
            div.style.bottom = '10px';
            div.style.width = '300px';
            div.style.background = 'white';
            if (this.canvas instanceof HTMLCanvasElement) {
                wrapperDiv.appendChild(this.canvas);
            }
            wrapperDiv.appendChild(div);
            const html = this.props.onAddHTML(div);
            if (html) {
                div.innerHTML = html;
            }
        }
    }
    _getSizeAndAspect() {
        if (!this.device) {
            return {
                width: 1,
                height: 1,
                aspect: 1
            };
        }
        // https://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
        const [width, height] = this.device?.canvasContext?.getPixelSize() || [
            1,
            1
        ];
        // https://webglfundamentals.org/webgl/lessons/webgl-anti-patterns.html
        let aspect = 1;
        const canvas = this.device?.canvasContext?.canvas;
        // @ts-expect-error
        if (canvas && canvas.clientHeight) {
            // @ts-expect-error
            aspect = canvas.clientWidth / canvas.clientHeight;
        } else if (width > 0 && height > 0) {
            aspect = width / height;
        }
        return {
            width,
            height,
            aspect
        };
    }
    /** Default viewport setup */ _resizeViewport() {
        // TODO can we use canvas context to code this in a portable way?
        // @ts-expect-error Expose on canvasContext
        if (this.props.autoResizeViewport && this.device.gl) {
            // @ts-expect-error Expose canvasContext
            this.device.gl.viewport(0, 0, // @ts-expect-error Expose canvasContext
            this.device.gl.drawingBufferWidth, // @ts-expect-error Expose canvasContext
            this.device.gl.drawingBufferHeight);
        }
    }
    /**
     * Resize the render buffer of the canvas to match canvas client size
     * Optionally multiplying with devicePixel ratio
     */ _resizeCanvasDrawingBuffer() {
        if (this.props.autoResizeDrawingBuffer) {
            this.device?.canvasContext?.resize({
                useDevicePixels: this.props.useDevicePixels
            });
        }
    }
    _beginFrameTimers() {
        this.frameRate.timeEnd();
        this.frameRate.timeStart();
        // Check if timer for last frame has completed.
        // GPU timer results are never available in the same
        // frame they are captured.
        // if (
        //   this._gpuTimeQuery &&
        //   this._gpuTimeQuery.isResultAvailable() &&
        //   !this._gpuTimeQuery.isTimerDisjoint()
        // ) {
        //   this.stats.get('GPU Time').addTime(this._gpuTimeQuery.getTimerMilliseconds());
        // }
        // if (this._gpuTimeQuery) {
        //   // GPU time query start
        //   this._gpuTimeQuery.beginTimeElapsedQuery();
        // }
        this.cpuTime.timeStart();
    }
    _endFrameTimers() {
        this.cpuTime.timeEnd();
    // if (this._gpuTimeQuery) {
    //   // GPU time query end. Results will be available on next frame.
    //   this._gpuTimeQuery.end();
    // }
    }
    // Event handling
    _startEventHandling() {
        if (this.canvas) {
            this.canvas.addEventListener('mousemove', this._onMousemove.bind(this));
            this.canvas.addEventListener('mouseleave', this._onMouseleave.bind(this));
        }
    }
    _onMousemove(event) {
        if (event instanceof MouseEvent) {
            this._getAnimationProps()._mousePosition = [
                event.offsetX,
                event.offsetY
            ];
        }
    }
    _onMouseleave(event) {
        this._getAnimationProps()._mousePosition = null;
    }
} //# sourceMappingURL=animation-loop.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/utils/uid.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "uid": (()=>uid)
});
const uidCounters = {};
function uid(id = 'id') {
    uidCounters[id] = uidCounters[id] || 1;
    const count = uidCounters[id]++;
    return `${id}-${count}`;
} //# sourceMappingURL=uid.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/geometry/gpu-geometry.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "GPUGeometry": (()=>GPUGeometry),
    "getAttributeBuffersFromGeometry": (()=>getAttributeBuffersFromGeometry),
    "getIndexBufferFromGeometry": (()=>getIndexBufferFromGeometry),
    "makeGPUGeometry": (()=>makeGPUGeometry)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$buffer$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/core/dist/adapter/resources/buffer.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$gpu$2d$type$2d$utils$2f$vertex$2d$format$2d$from$2d$attribute$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/core/dist/gpu-type-utils/vertex-format-from-attribute.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$utils$2f$uid$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/engine/dist/utils/uid.js [client] (ecmascript)");
;
;
class GPUGeometry {
    id;
    userData = {};
    /** Determines how vertices are read from the 'vertex' attributes */ topology;
    bufferLayout = [];
    vertexCount;
    indices;
    attributes;
    constructor(props){
        this.id = props.id || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$utils$2f$uid$2e$js__$5b$client$5d$__$28$ecmascript$29$__["uid"])('geometry');
        this.topology = props.topology;
        this.indices = props.indices || null;
        this.attributes = props.attributes;
        this.vertexCount = props.vertexCount;
        this.bufferLayout = props.bufferLayout || [];
        if (this.indices) {
            if (!(this.indices.usage & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$buffer$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"].INDEX)) {
                throw new Error('Index buffer must have INDEX usage');
            }
        }
    }
    destroy() {
        this.indices?.destroy();
        for (const attribute of Object.values(this.attributes)){
            attribute.destroy();
        }
    }
    getVertexCount() {
        return this.vertexCount;
    }
    getAttributes() {
        return this.attributes;
    }
    getIndexes() {
        return this.indices || null;
    }
    _calculateVertexCount(positions) {
        // Assume that positions is a fully packed float32x3 buffer
        const vertexCount = positions.byteLength / 12;
        return vertexCount;
    }
}
function makeGPUGeometry(device, geometry) {
    if (geometry instanceof GPUGeometry) {
        return geometry;
    }
    const indices = getIndexBufferFromGeometry(device, geometry);
    const { attributes, bufferLayout } = getAttributeBuffersFromGeometry(device, geometry);
    return new GPUGeometry({
        topology: geometry.topology || 'triangle-list',
        bufferLayout,
        vertexCount: geometry.vertexCount,
        indices,
        attributes
    });
}
function getIndexBufferFromGeometry(device, geometry) {
    if (!geometry.indices) {
        return undefined;
    }
    const data = geometry.indices.value;
    return device.createBuffer({
        usage: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$buffer$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"].INDEX,
        data
    });
}
function getAttributeBuffersFromGeometry(device, geometry) {
    const bufferLayout = [];
    const attributes = {};
    for (const [attributeName, attribute] of Object.entries(geometry.attributes)){
        let name = attributeName;
        // TODO Map some GLTF attribute names (is this still needed?)
        switch(attributeName){
            case 'POSITION':
                name = 'positions';
                break;
            case 'NORMAL':
                name = 'normals';
                break;
            case 'TEXCOORD_0':
                name = 'texCoords';
                break;
            case 'COLOR_0':
                name = 'colors';
                break;
        }
        if (attribute) {
            attributes[name] = device.createBuffer({
                data: attribute.value,
                id: `${attributeName}-buffer`
            });
            const { value, size, normalized } = attribute;
            // @ts-expect-error
            bufferLayout.push({
                name,
                format: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$gpu$2d$type$2d$utils$2f$vertex$2d$format$2d$from$2d$attribute$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getVertexFormatFromAttribute"])(value, size, normalized)
            });
        }
    }
    const vertexCount = geometry._calculateVertexCount(geometry.attributes, geometry.indices);
    return {
        attributes,
        bufferLayout,
        vertexCount
    };
} //# sourceMappingURL=gpu-geometry.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/factories/pipeline-factory.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "PipelineFactory": (()=>PipelineFactory)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$render$2d$pipeline$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/core/dist/adapter/resources/render-pipeline.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$compute$2d$pipeline$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/core/dist/adapter/resources/compute-pipeline.js [client] (ecmascript)");
;
class PipelineFactory {
    static defaultProps = {
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$render$2d$pipeline$2e$js__$5b$client$5d$__$28$ecmascript$29$__["RenderPipeline"].defaultProps
    };
    /** Get the singleton default pipeline factory for the specified device */ static getDefaultPipelineFactory(device) {
        device._lumaData.defaultPipelineFactory = device._lumaData.defaultPipelineFactory || new PipelineFactory(device);
        return device._lumaData.defaultPipelineFactory;
    }
    device;
    destroyPolicy;
    _hashCounter = 0;
    _hashes = {};
    _renderPipelineCache = {};
    _computePipelineCache = {};
    constructor(device){
        this.device = device;
        this.destroyPolicy = device.props._factoryDestroyPolicy;
    }
    /** Return a RenderPipeline matching props. Reuses a similar pipeline if already created. */ createRenderPipeline(props) {
        const allProps = {
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$render$2d$pipeline$2e$js__$5b$client$5d$__$28$ecmascript$29$__["RenderPipeline"].defaultProps,
            ...props
        };
        const hash = this._hashRenderPipeline(allProps);
        if (!this._renderPipelineCache[hash]) {
            const pipeline = this.device.createRenderPipeline({
                ...allProps,
                id: allProps.id ? `${allProps.id}-cached` : undefined
            });
            pipeline.hash = hash;
            this._renderPipelineCache[hash] = {
                pipeline,
                useCount: 0
            };
        }
        this._renderPipelineCache[hash].useCount++;
        return this._renderPipelineCache[hash].pipeline;
    }
    createComputePipeline(props) {
        const allProps = {
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$compute$2d$pipeline$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ComputePipeline"].defaultProps,
            ...props
        };
        const hash = this._hashComputePipeline(allProps);
        if (!this._computePipelineCache[hash]) {
            const pipeline = this.device.createComputePipeline({
                ...allProps,
                id: allProps.id ? `${allProps.id}-cached` : undefined
            });
            pipeline.hash = hash;
            this._computePipelineCache[hash] = {
                pipeline,
                useCount: 0
            };
        }
        this._computePipelineCache[hash].useCount++;
        return this._computePipelineCache[hash].pipeline;
    }
    release(pipeline) {
        const hash = pipeline.hash;
        const cache = pipeline instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$compute$2d$pipeline$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ComputePipeline"] ? this._computePipelineCache : this._renderPipelineCache;
        cache[hash].useCount--;
        if (cache[hash].useCount === 0) {
            if (this.destroyPolicy === 'unused') {
                cache[hash].pipeline.destroy();
                delete cache[hash];
            }
        }
    }
    // PRIVATE
    _hashComputePipeline(props) {
        const shaderHash = this._getHash(props.shader.source);
        return `${shaderHash}`;
    }
    /** Calculate a hash based on all the inputs for a render pipeline */ _hashRenderPipeline(props) {
        const vsHash = props.vs ? this._getHash(props.vs.source) : 0;
        const fsHash = props.fs ? this._getHash(props.fs.source) : 0;
        // WebGL specific
        // const {varyings = [], bufferMode = {}} = props;
        // const varyingHashes = varyings.map((v) => this._getHash(v));
        const varyingHash = '-'; // `${varyingHashes.join('/')}B${bufferMode}`
        const bufferLayoutHash = this._getHash(JSON.stringify(props.bufferLayout));
        switch(this.device.type){
            case 'webgl':
                // WebGL is more dynamic
                return `${vsHash}/${fsHash}V${varyingHash}BL${bufferLayoutHash}`;
            default:
                // On WebGPU we need to rebuild the pipeline if topology, parameters or bufferLayout change
                const parameterHash = this._getHash(JSON.stringify(props.parameters));
                // TODO - Can json.stringify() generate different strings for equivalent objects if order of params is different?
                // create a deepHash() to deduplicate?
                return `${vsHash}/${fsHash}V${varyingHash}T${props.topology}P${parameterHash}BL${bufferLayoutHash}`;
        }
    }
    _getHash(key) {
        if (this._hashes[key] === undefined) {
            this._hashes[key] = this._hashCounter++;
        }
        return this._hashes[key];
    }
} //# sourceMappingURL=pipeline-factory.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/factories/shader-factory.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "ShaderFactory": (()=>ShaderFactory)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$shader$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/core/dist/adapter/resources/shader.js [client] (ecmascript)");
;
class ShaderFactory {
    static defaultProps = {
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$shader$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Shader"].defaultProps
    };
    /** Returns the default ShaderFactory for the given {@link Device}, creating one if necessary. */ static getDefaultShaderFactory(device) {
        device._lumaData.defaultShaderFactory ||= new ShaderFactory(device);
        return device._lumaData.defaultShaderFactory;
    }
    device;
    destroyPolicy;
    _cache = {};
    /** @internal */ constructor(device){
        this.device = device;
        this.destroyPolicy = device.props._factoryDestroyPolicy;
    }
    /** Requests a {@link Shader} from the cache, creating a new Shader only if necessary. */ createShader(props) {
        const key = this._hashShader(props);
        let cacheEntry = this._cache[key];
        if (!cacheEntry) {
            const shader = this.device.createShader({
                ...props,
                id: props.id ? `${props.id}-cached` : undefined
            });
            this._cache[key] = cacheEntry = {
                shader,
                useCount: 0
            };
        }
        cacheEntry.useCount++;
        return cacheEntry.shader;
    }
    /** Releases a previously-requested {@link Shader}, destroying it if no users remain. */ release(shader) {
        const key = this._hashShader(shader);
        const cacheEntry = this._cache[key];
        if (cacheEntry) {
            cacheEntry.useCount--;
            if (cacheEntry.useCount === 0) {
                if (this.destroyPolicy === 'unused') {
                    delete this._cache[key];
                    cacheEntry.shader.destroy();
                }
            }
        }
    }
    // PRIVATE
    _hashShader(value) {
        return `${value.stage}:${value.source}`;
    }
} //# sourceMappingURL=shader-factory.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/debug/debug-shader-layout.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/**
 * Extracts a table suitable for `console.table()` from a shader layout to assist in debugging.
 * @param layout shader layout
 * @param name app should provide the most meaningful name, usually the model or pipeline name / id.
 * @returns
 */ __turbopack_context__.s({
    "getDebugTableForShaderLayout": (()=>getDebugTableForShaderLayout)
});
function getDebugTableForShaderLayout(layout, name) {
    const table = {};
    const header = 'Values'; // '`Shader Layout for ${name}`;
    if (layout.attributes.length === 0 && !layout.varyings?.length) {
        return {
            'No attributes or varyings': {
                [header]: 'N/A'
            }
        };
    }
    for (const attributeDeclaration of layout.attributes){
        if (attributeDeclaration) {
            const glslDeclaration = `${attributeDeclaration.location} ${attributeDeclaration.name}: ${attributeDeclaration.type}`;
            table[`in ${glslDeclaration}`] = {
                [header]: attributeDeclaration.stepMode || 'vertex'
            };
        }
    }
    for (const varyingDeclaration of layout.varyings || []){
        const glslDeclaration = `${varyingDeclaration.location} ${varyingDeclaration.name}`;
        table[`out ${glslDeclaration}`] = {
            [header]: JSON.stringify(varyingDeclaration)
        };
    }
    return table;
} //# sourceMappingURL=debug-shader-layout.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/debug/debug-framebuffer.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// import {copyTextureToImage} from '../debug/copy-texture-to-image';
/** Only works with 1st device? */ __turbopack_context__.s({
    "debugFramebuffer": (()=>debugFramebuffer)
});
let canvas = null;
let ctx = null;
function debugFramebuffer(fbo, { id, minimap, opaque, top = '0', left = '0', rgbaScale = 1 }) {
    if (!canvas) {
        canvas = document.createElement('canvas');
        canvas.id = id;
        canvas.title = id;
        canvas.style.zIndex = '100';
        canvas.style.position = 'absolute';
        canvas.style.top = top; // ⚠️
        canvas.style.left = left; // ⚠️
        canvas.style.border = 'blue 5px solid';
        canvas.style.transform = 'scaleY(-1)';
        document.body.appendChild(canvas);
        ctx = canvas.getContext('2d');
    // targetImage = new Image();
    }
    // const canvasHeight = (minimap ? 2 : 1) * fbo.height;
    if (canvas.width !== fbo.width || canvas.height !== fbo.height) {
        canvas.width = fbo.width / 2;
        canvas.height = fbo.height / 2;
        canvas.style.width = '400px';
        canvas.style.height = '400px';
    }
    // const image = copyTextureToImage(fbo, {targetMaxHeight: 100, targetImage});
    // ctx.drawImage(image, 0, 0);
    const color = fbo.device.readPixelsToArrayWebGL(fbo);
    const imageData = ctx?.createImageData(fbo.width, fbo.height);
    if (imageData) {
        // Full map
        const offset = 0;
        // if (color.some((v) => v > 0)) {
        //   console.error('THERE IS NON-ZERO DATA IN THE FBO!');
        // }
        for(let i = 0; i < color.length; i += 4){
            imageData.data[offset + i + 0] = color[i + 0] * rgbaScale;
            imageData.data[offset + i + 1] = color[i + 1] * rgbaScale;
            imageData.data[offset + i + 2] = color[i + 2] * rgbaScale;
            imageData.data[offset + i + 3] = opaque ? 255 : color[i + 3] * rgbaScale;
        }
        ctx?.putImageData(imageData, 0, 0);
    }
} //# sourceMappingURL=debug-framebuffer.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/utils/deep-equal.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/**
 * Fast partial deep equal for prop.
 *
 * @param a Prop
 * @param b Prop to compare against `a`
 * @param depth Depth to which to recurse in nested Objects/Arrays. Use 0 (default) for shallow comparison, -1 for infinite depth
 */ /* eslint-disable complexity */ __turbopack_context__.s({
    "deepEqual": (()=>deepEqual)
});
function deepEqual(a, b, depth) {
    if (a === b) {
        return true;
    }
    if (!depth || !a || !b) {
        return false;
    }
    if (Array.isArray(a)) {
        if (!Array.isArray(b) || a.length !== b.length) {
            return false;
        }
        for(let i = 0; i < a.length; i++){
            if (!deepEqual(a[i], b[i], depth - 1)) {
                return false;
            }
        }
        return true;
    }
    if (Array.isArray(b)) {
        return false;
    }
    if (typeof a === 'object' && typeof b === 'object') {
        const aKeys = Object.keys(a);
        const bKeys = Object.keys(b);
        if (aKeys.length !== bKeys.length) {
            return false;
        }
        for (const key of aKeys){
            if (!b.hasOwnProperty(key)) {
                return false;
            }
            if (!deepEqual(a[key], b[key], depth - 1)) {
                return false;
            }
        }
        return true;
    }
    return false;
} //# sourceMappingURL=deep-equal.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/model/split-uniforms-and-bindings.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "isUniformValue": (()=>isUniformValue),
    "splitUniformsAndBindings": (()=>splitUniformsAndBindings)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$types$2f$dist$2f$is$2d$array$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/types/dist/is-array.js [client] (ecmascript)");
;
function isUniformValue(value) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$types$2f$dist$2f$is$2d$array$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isNumericArray"])(value) || typeof value === 'number' || typeof value === 'boolean';
}
function splitUniformsAndBindings(uniforms) {
    const result = {
        bindings: {},
        uniforms: {}
    };
    Object.keys(uniforms).forEach((name)=>{
        const uniform = uniforms[name];
        if (isUniformValue(uniform)) {
            result.uniforms[name] = uniform;
        } else {
            result.bindings[name] = uniform;
        }
    });
    return result;
} //# sourceMappingURL=split-uniforms-and-bindings.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/shader-inputs.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "ShaderInputs": (()=>ShaderInputs)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/core/dist/utils/log.js [client] (ecmascript)");
// import type {ShaderUniformType, UniformValue, UniformFormat, UniformInfoDevice, Texture, Sampler} from '@luma.gl/core';
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$module$2f$shader$2d$module$2d$dependencies$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-module/shader-module-dependencies.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$model$2f$split$2d$uniforms$2d$and$2d$bindings$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/engine/dist/model/split-uniforms-and-bindings.js [client] (ecmascript)");
;
;
;
class ShaderInputs {
    options = {
        disableWarnings: false
    };
    /**
     * The map of modules
     * @todo should should this include the resolved dependencies?
     */ // @ts-ignore Fix typings
    modules;
    /** Stores the uniform values for each module */ moduleUniforms;
    /** Stores the uniform bindings for each module  */ moduleBindings;
    /** Tracks if uniforms have changed */ // moduleUniformsChanged: Record<keyof ShaderPropsT, false | string>;
    /**
     * Create a new UniformStore instance
     * @param modules
     */ constructor(// @ts-ignore Fix typings
    modules, options){
        Object.assign(this.options, options);
        // Extract modules with dependencies
        const resolvedModules = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$module$2f$shader$2d$module$2d$dependencies$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getShaderModuleDependencies"])(Object.values(modules).filter((module)=>module.dependencies));
        for (const resolvedModule of resolvedModules){
            // @ts-ignore
            modules[resolvedModule.name] = resolvedModule;
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].log(1, 'Creating ShaderInputs with modules', Object.keys(modules))();
        // Store the module definitions and create storage for uniform values and binding values, per module
        // @ts-ignore Fix typings
        this.modules = modules;
        this.moduleUniforms = {};
        this.moduleBindings = {};
        // Initialize the modules
        for (const [name, module] of Object.entries(modules)){
            this._addModule(module);
            if (module.name && name !== module.name && !this.options.disableWarnings) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].warn(`Module name: ${name} vs ${module.name}`)();
            }
        }
    }
    /** Destroy */ destroy() {}
    /**
     * Set module props
     */ setProps(props) {
        for (const name of Object.keys(props)){
            const moduleName = name;
            const moduleProps = props[moduleName] || {};
            const module = this.modules[moduleName];
            if (!module) {
                // Ignore props for unregistered modules
                if (!this.options.disableWarnings) {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].warn(`Module ${name} not found`)();
                }
                continue; // eslint-disable-line no-continue
            }
            const oldUniforms = this.moduleUniforms[moduleName];
            const oldBindings = this.moduleBindings[moduleName];
            const uniformsAndBindings = module.getUniforms?.(moduleProps, oldUniforms) || moduleProps;
            const { uniforms, bindings } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$model$2f$split$2d$uniforms$2d$and$2d$bindings$2e$js__$5b$client$5d$__$28$ecmascript$29$__["splitUniformsAndBindings"])(uniformsAndBindings);
            this.moduleUniforms[moduleName] = {
                ...oldUniforms,
                ...uniforms
            };
            this.moduleBindings[moduleName] = {
                ...oldBindings,
                ...bindings
            };
        // this.moduleUniformsChanged ||= moduleName;
        // console.log(`setProps(${String(moduleName)}`, moduleName, this.moduleUniforms[moduleName])
        }
    }
    /**
     * Return the map of modules
     * @todo should should this include the resolved dependencies?
     */ getModules() {
        return Object.values(this.modules);
    }
    /** Get all uniform values for all modules */ getUniformValues() {
        return this.moduleUniforms;
    }
    /** Merges all bindings for the shader (from the various modules) */ getBindingValues() {
        const bindings = {};
        for (const moduleBindings of Object.values(this.moduleBindings)){
            Object.assign(bindings, moduleBindings);
        }
        return bindings;
    }
    // INTERNAL
    /** Return a debug table that can be used for console.table() or log.table() */ getDebugTable() {
        const table = {};
        for (const [moduleName, module] of Object.entries(this.moduleUniforms)){
            for (const [key, value] of Object.entries(module)){
                table[`${moduleName}.${key}`] = {
                    type: this.modules[moduleName].uniformTypes?.[key],
                    value: String(value)
                };
            }
        }
        return table;
    }
    _addModule(module) {
        const moduleName = module.name;
        // Get default uniforms from module
        this.moduleUniforms[moduleName] = module.defaultUniforms || {};
        this.moduleBindings[moduleName] = {};
    }
} //# sourceMappingURL=shader-inputs.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/application-utils/load-file.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "loadImage": (()=>loadImage),
    "loadImageBitmap": (()=>loadImageBitmap),
    "setPathPrefix": (()=>setPathPrefix)
});
let pathPrefix = '';
function setPathPrefix(prefix) {
    pathPrefix = prefix;
}
async function loadImageBitmap(url, opts) {
    const image = new Image();
    image.crossOrigin = opts?.crossOrigin || 'anonymous';
    image.src = url.startsWith('http') ? url : pathPrefix + url;
    await image.decode();
    return opts ? await createImageBitmap(image, opts) : await createImageBitmap(image);
}
async function loadImage(url, opts) {
    return await new Promise((resolve, reject)=>{
        try {
            const image = new Image();
            image.onload = ()=>resolve(image);
            image.onerror = ()=>reject(new Error(`Could not load image ${url}.`));
            image.crossOrigin = opts?.crossOrigin || 'anonymous';
            image.src = url.startsWith('http') ? url : pathPrefix + url;
        } catch (error) {
            reject(error);
        }
    });
} //# sourceMappingURL=load-file.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/async-texture/async-texture.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl, MIT license
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "AsyncTexture": (()=>AsyncTexture)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$application$2d$utils$2f$load$2d$file$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/engine/dist/application-utils/load-file.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$utils$2f$uid$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/engine/dist/utils/uid.js [client] (ecmascript)");
;
;
class AsyncTexture {
    device;
    id;
    // TODO - should we type these as possibly `null`? It will make usage harder?
    // @ts-expect-error
    texture;
    // @ts-expect-error
    sampler;
    // @ts-expect-error
    view;
    ready;
    isReady = false;
    destroyed = false;
    resolveReady = ()=>{};
    rejectReady = ()=>{};
    get [Symbol.toStringTag]() {
        return 'AsyncTexture';
    }
    toString() {
        return `AsyncTexture:"${this.id}"(${this.isReady ? 'ready' : 'loading'})`;
    }
    constructor(device, props){
        this.device = device;
        this.id = props.id || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$utils$2f$uid$2e$js__$5b$client$5d$__$28$ecmascript$29$__["uid"])('async-texture');
        // this.id = typeof props?.data === 'string' ? props.data.slice(-20) : uid('async-texture');
        // Signature: new AsyncTexture(device, {data: url})
        if (typeof props?.data === 'string' && props.dimension === '2d') {
            props = {
                ...props,
                data: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$application$2d$utils$2f$load$2d$file$2e$js__$5b$client$5d$__$28$ecmascript$29$__["loadImageBitmap"])(props.data)
            };
        }
        this.ready = new Promise((resolve, reject)=>{
            this.resolveReady = ()=>{
                this.isReady = true;
                resolve();
            };
            this.rejectReady = reject;
        });
        this.initAsync(props);
    }
    async initAsync(props) {
        let resolveReady;
        let rejectReady;
        const asyncData = props.data;
        const data = await awaitAllPromises(asyncData).then(resolveReady, rejectReady);
        // Check that we haven't been destroyed while waiting for texture data to load
        if (this.destroyed) {
            return;
        }
        // Now we can actually create the texture
        // @ts-expect-error Discriminated union
        const syncProps = {
            ...props,
            data
        };
        this.texture = this.device.createTexture(syncProps);
        this.sampler = this.texture.sampler;
        this.view = this.texture.view;
        this.isReady = true;
    }
    destroy() {
        if (this.texture) {
            this.texture.destroy();
            // @ts-expect-error
            this.texture = null;
        }
        this.destroyed = true;
    }
    /**
     * Textures are immutable and cannot be resized after creation,
     * but we can create a similar texture with the same parameters but a new size.
     * @note Does not copy contents of the texture
     * @todo Abort pending promise and create a texture with the new size?
     */ resize(size) {
        if (!this.isReady) {
            throw new Error('Cannot resize texture before it is ready');
        }
        if (size.width === this.texture.width && size.height === this.texture.height) {
            return false;
        }
        if (this.texture) {
            const texture = this.texture;
            this.texture = texture.clone(size);
            texture.destroy();
        }
        return true;
    }
}
// HELPERS
/** Resolve all promises in a nested data structure */ async function awaitAllPromises(x) {
    x = await x;
    if (Array.isArray(x)) {
        return await Promise.all(x.map(awaitAllPromises));
    }
    if (x && typeof x === 'object' && x.constructor === Object) {
        const object = x;
        const values = await Promise.all(Object.values(object));
        const keys = Object.keys(object);
        const resolvedObject = {};
        for(let i = 0; i < keys.length; i++){
            resolvedObject[keys[i]] = values[i];
        }
        return resolvedObject;
    }
    return x;
} //# sourceMappingURL=async-texture.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/model/model.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "Model": (()=>Model),
    "getPlatformInfo": (()=>getPlatformInfo)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$buffer$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/core/dist/adapter/resources/buffer.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$texture$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/core/dist/adapter/resources/texture.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$texture$2d$view$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/core/dist/adapter/resources/texture-view.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$sampler$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/core/dist/adapter/resources/sampler.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$render$2d$pipeline$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/core/dist/adapter/resources/render-pipeline.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$portable$2f$uniform$2d$store$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/core/dist/portable/uniform-store.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/core/dist/utils/log.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$gpu$2d$type$2d$utils$2f$vertex$2d$format$2d$from$2d$attribute$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/core/dist/gpu-type-utils/vertex-format-from-attribute.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2d$utils$2f$get$2d$attribute$2d$from$2d$layouts$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/core/dist/adapter-utils/get-attribute-from-layouts.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2d$utils$2f$buffer$2d$layout$2d$helper$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__BufferLayoutHelper__as__$5f$BufferLayoutHelper$3e$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/core/dist/adapter-utils/buffer-layout-helper.js [client] (ecmascript) <export BufferLayoutHelper as _BufferLayoutHelper>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembler$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-assembler.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$wgsl$2f$get$2d$shader$2d$layout$2d$wgsl$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/shadertools/dist/lib/wgsl/get-shader-layout-wgsl.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$geometry$2f$gpu$2d$geometry$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/engine/dist/geometry/gpu-geometry.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$factories$2f$pipeline$2d$factory$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/engine/dist/factories/pipeline-factory.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$factories$2f$shader$2d$factory$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/engine/dist/factories/shader-factory.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$debug$2f$debug$2d$shader$2d$layout$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/engine/dist/debug/debug-shader-layout.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$debug$2f$debug$2d$framebuffer$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/engine/dist/debug/debug-framebuffer.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$utils$2f$deep$2d$equal$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/engine/dist/utils/deep-equal.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$utils$2f$uid$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/engine/dist/utils/uid.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$shader$2d$inputs$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/engine/dist/shader-inputs.js [client] (ecmascript)");
// import type {AsyncTextureProps} from '../async-texture/async-texture';
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$async$2d$texture$2f$async$2d$texture$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/engine/dist/async-texture/async-texture.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$model$2f$split$2d$uniforms$2d$and$2d$bindings$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/engine/dist/model/split-uniforms-and-bindings.js [client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
const LOG_DRAW_PRIORITY = 2;
const LOG_DRAW_TIMEOUT = 10000;
class Model {
    static defaultProps = {
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$render$2d$pipeline$2e$js__$5b$client$5d$__$28$ecmascript$29$__["RenderPipeline"].defaultProps,
        source: undefined,
        vs: null,
        fs: null,
        id: 'unnamed',
        handle: undefined,
        userData: {},
        defines: {},
        modules: [],
        moduleSettings: undefined,
        geometry: null,
        indexBuffer: null,
        attributes: {},
        constantAttributes: {},
        varyings: [],
        isInstanced: undefined,
        instanceCount: 0,
        vertexCount: 0,
        shaderInputs: undefined,
        pipelineFactory: undefined,
        shaderFactory: undefined,
        transformFeedback: undefined,
        shaderAssembler: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembler$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ShaderAssembler"].getDefaultShaderAssembler(),
        debugShaders: undefined,
        disableWarnings: undefined
    };
    device;
    id;
    // @ts-expect-error assigned in function called from constructor
    source;
    // @ts-expect-error assigned in function called from constructor
    vs;
    // @ts-expect-error assigned in function called from constructor
    fs;
    pipelineFactory;
    shaderFactory;
    userData = {};
    // Fixed properties (change can trigger pipeline rebuild)
    /** The render pipeline GPU parameters, depth testing etc */ parameters;
    /** The primitive topology */ topology;
    /** Buffer layout */ bufferLayout;
    // Dynamic properties
    /** Use instanced rendering */ isInstanced = undefined;
    /** instance count. `undefined` means not instanced */ instanceCount = 0;
    /** Vertex count */ vertexCount;
    /** Index buffer */ indexBuffer = null;
    /** Buffer-valued attributes */ bufferAttributes = {};
    /** Constant-valued attributes */ constantAttributes = {};
    /** Bindings (textures, samplers, uniform buffers) */ bindings = {};
    /** Sets uniforms @deprecated Use uniform buffers and setBindings() for portability*/ uniforms = {};
    /**
     * VertexArray
     * @note not implemented: if bufferLayout is updated, vertex array has to be rebuilt!
     * @todo - allow application to define multiple vertex arrays?
     * */ vertexArray;
    /** TransformFeedback, WebGL 2 only. */ transformFeedback = null;
    /** The underlying GPU "program". @note May be recreated if parameters change */ pipeline;
    /** ShaderInputs instance */ // @ts-expect-error Assigned in function called by constructor
    shaderInputs;
    // @ts-expect-error Assigned in function called by constructor
    _uniformStore;
    _attributeInfos = {};
    _gpuGeometry = null;
    _getModuleUniforms;
    props;
    _pipelineNeedsUpdate = 'newly created';
    _needsRedraw = 'initializing';
    _destroyed = false;
    /** "Time" of last draw. Monotonically increasing timestamp */ _lastDrawTimestamp = -1;
    get [Symbol.toStringTag]() {
        return 'Model';
    }
    toString() {
        return `Model(${this.id})`;
    }
    constructor(device, props){
        this.props = {
            ...Model.defaultProps,
            ...props
        };
        props = this.props;
        this.id = props.id || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$utils$2f$uid$2e$js__$5b$client$5d$__$28$ecmascript$29$__["uid"])('model');
        this.device = device;
        Object.assign(this.userData, props.userData);
        // Setup shader module inputs
        const moduleMap = Object.fromEntries(this.props.modules?.map((module)=>[
                module.name,
                module
            ]) || []);
        const shaderInputs = props.shaderInputs || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$shader$2d$inputs$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ShaderInputs"](moduleMap, {
            disableWarnings: this.props.disableWarnings
        });
        // @ts-ignore
        this.setShaderInputs(shaderInputs);
        // Setup shader assembler
        const platformInfo = getPlatformInfo(device);
        // Extract modules from shader inputs if not supplied
        const modules = // @ts-ignore shaderInputs is assigned in setShaderInputs above.
        (this.props.modules?.length > 0 ? this.props.modules : this.shaderInputs?.getModules()) || [];
        const isWebGPU = this.device.type === 'webgpu';
        // WebGPU
        // TODO - hack to support unified WGSL shader
        // TODO - this is wrong, compile a single shader
        if (isWebGPU && this.props.source) {
            // WGSL
            const { source, getUniforms } = this.props.shaderAssembler.assembleWGSLShader({
                platformInfo,
                ...this.props,
                modules
            });
            this.source = source;
            // @ts-expect-error
            this._getModuleUniforms = getUniforms;
            // Extract shader layout after modules have been added to WGSL source, to include any bindings added by modules
            this.props.shaderLayout ||= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$wgsl$2f$get$2d$shader$2d$layout$2d$wgsl$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getShaderLayoutFromWGSL"])(this.source);
        } else {
            // GLSL
            const { vs, fs, getUniforms } = this.props.shaderAssembler.assembleGLSLShaderPair({
                platformInfo,
                ...this.props,
                modules
            });
            this.vs = vs;
            this.fs = fs;
            // @ts-expect-error
            this._getModuleUniforms = getUniforms;
        }
        this.vertexCount = this.props.vertexCount;
        this.instanceCount = this.props.instanceCount;
        this.topology = this.props.topology;
        this.bufferLayout = this.props.bufferLayout;
        this.parameters = this.props.parameters;
        // Geometry, if provided, sets topology and vertex cound
        if (props.geometry) {
            this.setGeometry(props.geometry);
        }
        this.pipelineFactory = props.pipelineFactory || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$factories$2f$pipeline$2d$factory$2e$js__$5b$client$5d$__$28$ecmascript$29$__["PipelineFactory"].getDefaultPipelineFactory(this.device);
        this.shaderFactory = props.shaderFactory || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$factories$2f$shader$2d$factory$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ShaderFactory"].getDefaultShaderFactory(this.device);
        // Create the pipeline
        // @note order is important
        this.pipeline = this._updatePipeline();
        this.vertexArray = device.createVertexArray({
            renderPipeline: this.pipeline
        });
        // Now we can apply geometry attributes
        if (this._gpuGeometry) {
            this._setGeometryAttributes(this._gpuGeometry);
        }
        // Apply any dynamic settings that will not trigger pipeline change
        if ('isInstanced' in props) {
            this.isInstanced = props.isInstanced;
        }
        if (props.instanceCount) {
            this.setInstanceCount(props.instanceCount);
        }
        if (props.vertexCount) {
            this.setVertexCount(props.vertexCount);
        }
        if (props.indexBuffer) {
            this.setIndexBuffer(props.indexBuffer);
        }
        if (props.attributes) {
            this.setAttributes(props.attributes);
        }
        if (props.constantAttributes) {
            this.setConstantAttributes(props.constantAttributes);
        }
        if (props.bindings) {
            this.setBindings(props.bindings);
        }
        if (props.uniforms) {
            this.setUniformsWebGL(props.uniforms);
        }
        if (props.moduleSettings) {
            // log.warn('Model.props.moduleSettings is deprecated. Use Model.shaderInputs.setProps()')();
            this.updateModuleSettingsWebGL(props.moduleSettings);
        }
        if (props.transformFeedback) {
            this.transformFeedback = props.transformFeedback;
        }
        // Catch any access to non-standard props
        Object.seal(this);
    }
    destroy() {
        if (this._destroyed) return;
        this.pipelineFactory.release(this.pipeline);
        this.shaderFactory.release(this.pipeline.vs);
        if (this.pipeline.fs) {
            this.shaderFactory.release(this.pipeline.fs);
        }
        this._uniformStore.destroy();
        // TODO - mark resource as managed and destroyIfManaged() ?
        this._gpuGeometry?.destroy();
        this._destroyed = true;
    }
    // Draw call
    /** Query redraw status. Clears the status. */ needsRedraw() {
        // Catch any writes to already bound resources
        if (this._getBindingsUpdateTimestamp() > this._lastDrawTimestamp) {
            this.setNeedsRedraw('contents of bound textures or buffers updated');
        }
        const needsRedraw = this._needsRedraw;
        this._needsRedraw = false;
        return needsRedraw;
    }
    /** Mark the model as needing a redraw */ setNeedsRedraw(reason) {
        this._needsRedraw ||= reason;
    }
    predraw() {
        // Update uniform buffers if needed
        this.updateShaderInputs();
        // Check if the pipeline is invalidated
        this.pipeline = this._updatePipeline();
    }
    draw(renderPass) {
        const loadingBinding = this._areBindingsLoading();
        if (loadingBinding) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].info(LOG_DRAW_PRIORITY, `>>> DRAWING ABORTED ${this.id}: ${loadingBinding} not loaded`)();
            return false;
        }
        try {
            renderPass.pushDebugGroup(`${this}.predraw(${renderPass})`);
            this.predraw();
        } finally{
            renderPass.popDebugGroup();
        }
        let drawSuccess;
        try {
            renderPass.pushDebugGroup(`${this}.draw(${renderPass})`);
            this._logDrawCallStart();
            // Update the pipeline if invalidated
            // TODO - inside RenderPass is likely the worst place to do this from performance perspective.
            // Application can call Model.predraw() to avoid this.
            this.pipeline = this._updatePipeline();
            // Set pipeline state, we may be sharing a pipeline so we need to set all state on every draw
            // Any caching needs to be done inside the pipeline functions
            // TODO this is a busy initialized check for all bindings every frame
            const syncBindings = this._getBindings();
            this.pipeline.setBindings(syncBindings, {
                disableWarnings: this.props.disableWarnings
            });
            if (!isObjectEmpty(this.uniforms)) {
                this.pipeline.setUniformsWebGL(this.uniforms);
            }
            const { indexBuffer } = this.vertexArray;
            const indexCount = indexBuffer ? indexBuffer.byteLength / (indexBuffer.indexType === 'uint32' ? 4 : 2) : undefined;
            drawSuccess = this.pipeline.draw({
                renderPass,
                vertexArray: this.vertexArray,
                isInstanced: this.isInstanced,
                vertexCount: this.vertexCount,
                instanceCount: this.instanceCount,
                indexCount,
                transformFeedback: this.transformFeedback || undefined,
                // WebGL shares underlying cached pipelines even for models that have different parameters and topology,
                // so we must provide our unique parameters to each draw
                // (In WebGPU most parameters are encoded in the pipeline and cannot be changed per draw call)
                parameters: this.parameters,
                topology: this.topology
            });
        } finally{
            renderPass.popDebugGroup();
            this._logDrawCallEnd();
        }
        this._logFramebuffer(renderPass);
        // Update needsRedraw flag
        if (drawSuccess) {
            this._lastDrawTimestamp = this.device.timestamp;
            this._needsRedraw = false;
        } else {
            this._needsRedraw = 'waiting for resource initialization';
        }
        return drawSuccess;
    }
    // Update fixed fields (can trigger pipeline rebuild)
    /**
     * Updates the optional geometry
     * Geometry, set topology and bufferLayout
     * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU
     */ setGeometry(geometry) {
        this._gpuGeometry?.destroy();
        const gpuGeometry = geometry && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$geometry$2f$gpu$2d$geometry$2e$js__$5b$client$5d$__$28$ecmascript$29$__["makeGPUGeometry"])(this.device, geometry);
        if (gpuGeometry) {
            this.setTopology(gpuGeometry.topology || 'triangle-list');
            const bufferLayoutHelper = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2d$utils$2f$buffer$2d$layout$2d$helper$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__BufferLayoutHelper__as__$5f$BufferLayoutHelper$3e$__["_BufferLayoutHelper"](this.bufferLayout);
            this.bufferLayout = bufferLayoutHelper.mergeBufferLayouts(gpuGeometry.bufferLayout, this.bufferLayout);
            if (this.vertexArray) {
                this._setGeometryAttributes(gpuGeometry);
            }
        }
        this._gpuGeometry = gpuGeometry;
    }
    /**
     * Updates the primitive topology ('triangle-list', 'triangle-strip' etc).
     * @note Triggers a pipeline rebuild / pipeline cache fetch on WebGPU
     */ setTopology(topology) {
        if (topology !== this.topology) {
            this.topology = topology;
            this._setPipelineNeedsUpdate('topology');
        }
    }
    /**
     * Updates the buffer layout.
     * @note Triggers a pipeline rebuild / pipeline cache fetch
     */ setBufferLayout(bufferLayout) {
        const bufferLayoutHelper = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2d$utils$2f$buffer$2d$layout$2d$helper$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__BufferLayoutHelper__as__$5f$BufferLayoutHelper$3e$__["_BufferLayoutHelper"](this.bufferLayout);
        this.bufferLayout = this._gpuGeometry ? bufferLayoutHelper.mergeBufferLayouts(bufferLayout, this._gpuGeometry.bufferLayout) : bufferLayout;
        this._setPipelineNeedsUpdate('bufferLayout');
        // Recreate the pipeline
        this.pipeline = this._updatePipeline();
        // vertex array needs to be updated if we update buffer layout,
        // but not if we update parameters
        this.vertexArray = this.device.createVertexArray({
            renderPipeline: this.pipeline
        });
        // Reapply geometry attributes to the new vertex array
        if (this._gpuGeometry) {
            this._setGeometryAttributes(this._gpuGeometry);
        }
    }
    /**
     * Set GPU parameters.
     * @note Can trigger a pipeline rebuild / pipeline cache fetch.
     * @param parameters
     */ setParameters(parameters) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$utils$2f$deep$2d$equal$2e$js__$5b$client$5d$__$28$ecmascript$29$__["deepEqual"])(parameters, this.parameters, 2)) {
            this.parameters = parameters;
            this._setPipelineNeedsUpdate('parameters');
        }
    }
    // Update dynamic fields
    /**
     * Updates the instance count (used in draw calls)
     * @note Any attributes with stepMode=instance need to be at least this big
     */ setInstanceCount(instanceCount) {
        this.instanceCount = instanceCount;
        // luma.gl examples don't set props.isInstanced and rely on auto-detection
        // but deck.gl sets instanceCount even for models that are not instanced.
        if (this.isInstanced === undefined && instanceCount > 0) {
            this.isInstanced = true;
        }
        this.setNeedsRedraw('instanceCount');
    }
    /**
     * Updates the vertex count (used in draw calls)
     * @note Any attributes with stepMode=vertex need to be at least this big
     */ setVertexCount(vertexCount) {
        this.vertexCount = vertexCount;
        this.setNeedsRedraw('vertexCount');
    }
    /** Set the shader inputs */ setShaderInputs(shaderInputs) {
        this.shaderInputs = shaderInputs;
        this._uniformStore = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$portable$2f$uniform$2d$store$2e$js__$5b$client$5d$__$28$ecmascript$29$__["UniformStore"](this.shaderInputs.modules);
        // Create uniform buffer bindings for all modules that actually have uniforms
        for (const [moduleName, module] of Object.entries(this.shaderInputs.modules)){
            if (shaderModuleHasUniforms(module)) {
                const uniformBuffer = this._uniformStore.getManagedUniformBuffer(this.device, moduleName);
                this.bindings[`${moduleName}Uniforms`] = uniformBuffer;
            }
        }
        this.setNeedsRedraw('shaderInputs');
    }
    /** Update uniform buffers from the model's shader inputs */ updateShaderInputs() {
        this._uniformStore.setUniforms(this.shaderInputs.getUniformValues());
        this.setBindings(this.shaderInputs.getBindingValues());
        // TODO - this is already tracked through buffer/texture update times?
        this.setNeedsRedraw('shaderInputs');
    }
    /**
     * Sets bindings (textures, samplers, uniform buffers)
     */ setBindings(bindings) {
        Object.assign(this.bindings, bindings);
        this.setNeedsRedraw('bindings');
    }
    /**
     * Updates optional transform feedback. WebGL only.
     */ setTransformFeedback(transformFeedback) {
        this.transformFeedback = transformFeedback;
        this.setNeedsRedraw('transformFeedback');
    }
    /**
     * Sets the index buffer
     * @todo - how to unset it if we change geometry?
     */ setIndexBuffer(indexBuffer) {
        this.vertexArray.setIndexBuffer(indexBuffer);
        this.setNeedsRedraw('indexBuffer');
    }
    /**
     * Sets attributes (buffers)
     * @note Overrides any attributes previously set with the same name
     */ setAttributes(buffers, options) {
        const disableWarnings = options?.disableWarnings ?? this.props.disableWarnings;
        if (buffers.indices) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].warn(`Model:${this.id} setAttributes() - indexBuffer should be set using setIndexBuffer()`)();
        }
        const bufferLayoutHelper = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2d$utils$2f$buffer$2d$layout$2d$helper$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__BufferLayoutHelper__as__$5f$BufferLayoutHelper$3e$__["_BufferLayoutHelper"](this.bufferLayout);
        // Check if all buffers have a layout
        for (const [bufferName, buffer] of Object.entries(buffers)){
            const bufferLayout = bufferLayoutHelper.getBufferLayout(bufferName);
            if (!bufferLayout) {
                if (!disableWarnings) {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].warn(`Model(${this.id}): Missing layout for buffer "${bufferName}".`)();
                }
                continue; // eslint-disable-line no-continue
            }
            // For an interleaved attribute we may need to set multiple attributes
            const attributeNames = bufferLayoutHelper.getAttributeNamesForBuffer(bufferLayout);
            let set = false;
            for (const attributeName of attributeNames){
                const attributeInfo = this._attributeInfos[attributeName];
                if (attributeInfo) {
                    this.vertexArray.setBuffer(attributeInfo.location, buffer);
                    set = true;
                }
            }
            if (!set && !disableWarnings) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].warn(`Model(${this.id}): Ignoring buffer "${buffer.id}" for unknown attribute "${bufferName}"`)();
            }
        }
        this.setNeedsRedraw('attributes');
    }
    /**
     * Sets constant attributes
     * @note Overrides any attributes previously set with the same name
     * Constant attributes are only supported in WebGL, not in WebGPU
     * Any attribute that is disabled in the current vertex array object
     * is read from the context's global constant value for that attribute location.
     * @param constantAttributes
     */ setConstantAttributes(attributes, options) {
        for (const [attributeName, value] of Object.entries(attributes)){
            const attributeInfo = this._attributeInfos[attributeName];
            if (attributeInfo) {
                this.vertexArray.setConstantWebGL(attributeInfo.location, value);
            } else if (!(options?.disableWarnings ?? this.props.disableWarnings)) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].warn(`Model "${this.id}: Ignoring constant supplied for unknown attribute "${attributeName}"`)();
            }
        }
        this.setNeedsRedraw('constants');
    }
    // DEPRECATED METHODS
    /**
     * Sets individual uniforms
     * @deprecated WebGL only, use uniform buffers for portability
     * @param uniforms
     */ setUniforms(uniforms) {
        this.setUniformsWebGL(uniforms);
    }
    /**
     * Sets individual uniforms
     * @deprecated WebGL only, use uniform buffers for portability
     * @param uniforms
     */ setUniformsWebGL(uniforms) {
        if (!isObjectEmpty(uniforms)) {
            this.pipeline.setUniformsWebGL(uniforms);
            Object.assign(this.uniforms, uniforms);
        }
        this.setNeedsRedraw('uniforms');
    }
    /**
     * @deprecated Updates shader module settings (which results in uniforms being set)
     */ updateModuleSettingsWebGL(props) {
        // log.warn('Model.updateModuleSettings is deprecated. Use Model.shaderInputs.setProps()')();
        const { bindings, uniforms } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$model$2f$split$2d$uniforms$2d$and$2d$bindings$2e$js__$5b$client$5d$__$28$ecmascript$29$__["splitUniformsAndBindings"])(this._getModuleUniforms(props));
        Object.assign(this.bindings, bindings);
        Object.assign(this.uniforms, uniforms);
        this.setNeedsRedraw('moduleSettings');
    }
    // Internal methods
    /** Check that bindings are loaded. Returns id of first binding that is still loading. */ _areBindingsLoading() {
        for (const binding of Object.values(this.bindings)){
            if (binding instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$async$2d$texture$2f$async$2d$texture$2e$js__$5b$client$5d$__$28$ecmascript$29$__["AsyncTexture"] && !binding.isReady) {
                return binding.id;
            }
        }
        return false;
    }
    /** Extracts texture view from loaded async textures. Returns null if any textures have not yet been loaded. */ _getBindings() {
        const validBindings = {};
        for (const [name, binding] of Object.entries(this.bindings)){
            if (binding instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$async$2d$texture$2f$async$2d$texture$2e$js__$5b$client$5d$__$28$ecmascript$29$__["AsyncTexture"]) {
                // Check that async textures are loaded
                if (binding.isReady) {
                    validBindings[name] = binding.texture;
                }
            } else {
                validBindings[name] = binding;
            }
        }
        return validBindings;
    }
    /** Get the timestamp of the latest updated bound GPU memory resource (buffer/texture). */ _getBindingsUpdateTimestamp() {
        let timestamp = 0;
        for (const binding of Object.values(this.bindings)){
            if (binding instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$texture$2d$view$2e$js__$5b$client$5d$__$28$ecmascript$29$__["TextureView"]) {
                timestamp = Math.max(timestamp, binding.texture.updateTimestamp);
            } else if (binding instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$buffer$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"] || binding instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$texture$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Texture"]) {
                timestamp = Math.max(timestamp, binding.updateTimestamp);
            } else if (binding instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$async$2d$texture$2f$async$2d$texture$2e$js__$5b$client$5d$__$28$ecmascript$29$__["AsyncTexture"]) {
                timestamp = binding.texture ? Math.max(timestamp, binding.texture.updateTimestamp) : Infinity;
            } else if (!(binding instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$sampler$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Sampler"])) {
                timestamp = Math.max(timestamp, binding.buffer.updateTimestamp);
            }
        }
        return timestamp;
    }
    /**
     * Updates the optional geometry attributes
     * Geometry, sets several attributes, indexBuffer, and also vertex count
     * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU
     */ _setGeometryAttributes(gpuGeometry) {
        // Filter geometry attribute so that we don't issue warnings for unused attributes
        const attributes = {
            ...gpuGeometry.attributes
        };
        for (const [attributeName] of Object.entries(attributes)){
            if (!this.pipeline.shaderLayout.attributes.find((layout)=>layout.name === attributeName) && attributeName !== 'positions') {
                delete attributes[attributeName];
            }
        }
        // TODO - delete previous geometry?
        this.vertexCount = gpuGeometry.vertexCount;
        this.setIndexBuffer(gpuGeometry.indices || null);
        this.setAttributes(gpuGeometry.attributes, {
            disableWarnings: true
        });
        this.setAttributes(attributes, {
            disableWarnings: this.props.disableWarnings
        });
        this.setNeedsRedraw('geometry attributes');
    }
    /** Mark pipeline as needing update */ _setPipelineNeedsUpdate(reason) {
        this._pipelineNeedsUpdate ||= reason;
        this.setNeedsRedraw(reason);
    }
    /** Update pipeline if needed */ _updatePipeline() {
        if (this._pipelineNeedsUpdate) {
            let prevShaderVs = null;
            let prevShaderFs = null;
            if (this.pipeline) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].log(1, `Model ${this.id}: Recreating pipeline because "${this._pipelineNeedsUpdate}".`)();
                prevShaderVs = this.pipeline.vs;
                prevShaderFs = this.pipeline.fs;
            }
            this._pipelineNeedsUpdate = false;
            const vs = this.shaderFactory.createShader({
                id: `${this.id}-vertex`,
                stage: 'vertex',
                source: this.source || this.vs,
                debugShaders: this.props.debugShaders
            });
            let fs = null;
            if (this.source) {
                fs = vs;
            } else if (this.fs) {
                fs = this.shaderFactory.createShader({
                    id: `${this.id}-fragment`,
                    stage: 'fragment',
                    source: this.source || this.fs,
                    debugShaders: this.props.debugShaders
                });
            }
            this.pipeline = this.pipelineFactory.createRenderPipeline({
                ...this.props,
                bufferLayout: this.bufferLayout,
                topology: this.topology,
                parameters: this.parameters,
                // TODO - why set bindings here when we reset them every frame?
                // Should we expose a BindGroup abstraction?
                bindings: this._getBindings(),
                vs,
                fs
            });
            this._attributeInfos = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2d$utils$2f$get$2d$attribute$2d$from$2d$layouts$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getAttributeInfosFromLayouts"])(this.pipeline.shaderLayout, this.bufferLayout);
            if (prevShaderVs) this.shaderFactory.release(prevShaderVs);
            if (prevShaderFs) this.shaderFactory.release(prevShaderFs);
        }
        return this.pipeline;
    }
    /** Throttle draw call logging */ _lastLogTime = 0;
    _logOpen = false;
    _logDrawCallStart() {
        // IF level is 4 or higher, log every frame.
        const logDrawTimeout = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].level > 3 ? 0 : LOG_DRAW_TIMEOUT;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].level < 2 || Date.now() - this._lastLogTime < logDrawTimeout) {
            return;
        }
        this._lastLogTime = Date.now();
        this._logOpen = true;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, {
            collapsed: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].level <= 2
        })();
    }
    _logDrawCallEnd() {
        if (this._logOpen) {
            const shaderLayoutTable = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$debug$2f$debug$2d$shader$2d$layout$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getDebugTableForShaderLayout"])(this.pipeline.shaderLayout, this.id);
            // log.table(logLevel, attributeTable)();
            // log.table(logLevel, uniformTable)();
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].table(LOG_DRAW_PRIORITY, shaderLayoutTable)();
            const uniformTable = this.shaderInputs.getDebugTable();
            // Add any global uniforms
            for (const [name, value] of Object.entries(this.uniforms)){
                uniformTable[name] = {
                    value
                };
            }
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].table(LOG_DRAW_PRIORITY, uniformTable)();
            const attributeTable = this._getAttributeDebugTable();
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].table(LOG_DRAW_PRIORITY, this._attributeInfos)();
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].table(LOG_DRAW_PRIORITY, attributeTable)();
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].groupEnd(LOG_DRAW_PRIORITY)();
            this._logOpen = false;
        }
    }
    _drawCount = 0;
    _logFramebuffer(renderPass) {
        const debugFramebuffers = this.device.props.debugFramebuffers;
        this._drawCount++;
        // Update first 3 frames and then every 60 frames
        if (!debugFramebuffers) {
            // } || (this._drawCount++ > 3 && this._drawCount % 60)) {
            return;
        }
        // TODO - display framebuffer output in debug window
        const framebuffer = renderPass.props.framebuffer;
        if (framebuffer) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$debug$2f$debug$2d$framebuffer$2e$js__$5b$client$5d$__$28$ecmascript$29$__["debugFramebuffer"])(framebuffer, {
                id: framebuffer.id,
                minimap: true
            });
        // log.image({logLevel: LOG_DRAW_PRIORITY, message: `${framebuffer.id} %c sup?`, image})();
        }
    }
    _getAttributeDebugTable() {
        const table = {};
        for (const [name, attributeInfo] of Object.entries(this._attributeInfos)){
            const values = this.vertexArray.attributes[attributeInfo.location];
            table[attributeInfo.location] = {
                name,
                type: attributeInfo.shaderType,
                values: values ? this._getBufferOrConstantValues(values, attributeInfo.bufferDataType) : 'null'
            };
        }
        if (this.vertexArray.indexBuffer) {
            const { indexBuffer } = this.vertexArray;
            const values = indexBuffer.indexType === 'uint32' ? new Uint32Array(indexBuffer.debugData) : new Uint16Array(indexBuffer.debugData);
            table.indices = {
                name: 'indices',
                type: indexBuffer.indexType,
                values: values.toString()
            };
        }
        return table;
    }
    // TODO - fix typing of luma data types
    _getBufferOrConstantValues(attribute, dataType) {
        const TypedArrayConstructor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$gpu$2d$type$2d$utils$2f$vertex$2d$format$2d$from$2d$attribute$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getTypedArrayFromDataType"])(dataType);
        const typedArray = attribute instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$buffer$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"] ? new TypedArrayConstructor(attribute.debugData) : attribute;
        return typedArray.toString();
    }
}
function shaderModuleHasUniforms(module) {
    return Boolean(module.uniformTypes && !isObjectEmpty(module.uniformTypes));
}
function getPlatformInfo(device) {
    return {
        type: device.type,
        shaderLanguage: device.info.shadingLanguage,
        shaderLanguageVersion: device.info.shadingLanguageVersion,
        gpu: device.info.gpu,
        // HACK - we pretend that the DeviceFeatures is a Set, it has a similar API
        features: device.features
    };
}
/** Returns true if given object is empty, false otherwise. */ function isObjectEmpty(obj) {
    // @ts-ignore key is unused
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    for(const key in obj){
        return false;
    }
    return true;
} //# sourceMappingURL=model.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/compute/buffer-transform.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "BufferTransform": (()=>BufferTransform)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$buffer$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/core/dist/adapter/resources/buffer.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$glsl$2d$utils$2f$shader$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/shadertools/dist/lib/glsl-utils/shader-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$model$2f$model$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/engine/dist/model/model.js [client] (ecmascript)");
;
;
;
class BufferTransform {
    device;
    model;
    transformFeedback;
    static defaultProps = {
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$model$2f$model$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Model"].defaultProps,
        outputs: undefined,
        feedbackBuffers: undefined
    };
    static isSupported(device) {
        return device?.info?.type === 'webgl';
    }
    constructor(device, props = BufferTransform.defaultProps){
        if (!BufferTransform.isSupported(device)) {
            throw new Error('BufferTransform not yet implemented on WebGPU');
        }
        this.device = device;
        this.model = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$model$2f$model$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Model"](this.device, {
            id: props.id || 'buffer-transform-model',
            fs: props.fs || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$glsl$2d$utils$2f$shader$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getPassthroughFS"])(),
            topology: props.topology || 'point-list',
            varyings: props.outputs || props.varyings,
            ...props
        });
        this.transformFeedback = this.device.createTransformFeedback({
            layout: this.model.pipeline.shaderLayout,
            // @ts-expect-error TODO
            buffers: props.feedbackBuffers
        });
        this.model.setTransformFeedback(this.transformFeedback);
        Object.seal(this);
    }
    /** Destroy owned resources. */ destroy() {
        if (this.model) {
            this.model.destroy();
        }
    }
    /** @deprecated Use {@link destroy}. */ delete() {
        this.destroy();
    }
    /** Run one transform loop. */ run(options) {
        if (options?.inputBuffers) {
            this.model.setAttributes(options.inputBuffers);
        }
        if (options?.outputBuffers) {
            this.transformFeedback.setBuffers(options.outputBuffers);
        }
        const renderPass = this.device.beginRenderPass(options);
        this.model.draw(renderPass);
        renderPass.end();
    }
    // DEPRECATED METHODS
    /** @deprecated App knows what buffers it is passing in - Returns the {@link Buffer} or {@link BufferRange} for given varying name. */ getBuffer(varyingName) {
        return this.transformFeedback.getBuffer(varyingName);
    }
    /** @deprecated App knows what buffers it is passing in - Reads the {@link Buffer} or {@link BufferRange} for given varying name. */ readAsync(varyingName) {
        const result = this.getBuffer(varyingName);
        if (!result) {
            throw new Error('BufferTransform#getBuffer');
        }
        if (result instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$buffer$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"]) {
            return result.readAsync();
        }
        const { buffer, byteOffset = 0, byteLength = buffer.byteLength } = result;
        return buffer.readAsync(byteOffset, byteLength);
    }
} //# sourceMappingURL=buffer-transform.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/geometry/geometry.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "Geometry": (()=>Geometry)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$utils$2f$uid$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/engine/dist/utils/uid.js [client] (ecmascript)");
;
class Geometry {
    id;
    /** Determines how vertices are read from the 'vertex' attributes */ topology;
    vertexCount;
    indices;
    attributes;
    userData = {};
    constructor(props){
        const { attributes = {}, indices = null, vertexCount = null } = props;
        this.id = props.id || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$utils$2f$uid$2e$js__$5b$client$5d$__$28$ecmascript$29$__["uid"])('geometry');
        this.topology = props.topology;
        if (indices) {
            this.indices = ArrayBuffer.isView(indices) ? {
                value: indices,
                size: 1
            } : indices;
        }
        // @ts-expect-error
        this.attributes = {};
        for (const [attributeName, attributeValue] of Object.entries(attributes)){
            // Wrap "unwrapped" arrays and try to autodetect their type
            const attribute = ArrayBuffer.isView(attributeValue) ? {
                value: attributeValue
            } : attributeValue;
            if (!ArrayBuffer.isView(attribute.value)) {
                throw new Error(`${this._print(attributeName)}: must be typed array or object with value as typed array`);
            }
            if ((attributeName === 'POSITION' || attributeName === 'positions') && !attribute.size) {
                attribute.size = 3;
            }
            // Move indices to separate field
            if (attributeName === 'indices') {
                if (this.indices) {
                    throw new Error('Multiple indices detected');
                }
                this.indices = attribute;
            } else {
                this.attributes[attributeName] = attribute;
            }
        }
        if (this.indices && this.indices.isIndexed !== undefined) {
            this.indices = Object.assign({}, this.indices);
            delete this.indices.isIndexed;
        }
        this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);
    }
    getVertexCount() {
        return this.vertexCount;
    }
    /**
     * Return an object with all attributes plus indices added as a field.
     * TODO Geometry types are a mess
     */ getAttributes() {
        return this.indices ? {
            indices: this.indices,
            ...this.attributes
        } : this.attributes;
    }
    // PRIVATE
    _print(attributeName) {
        return `Geometry ${this.id} attribute ${attributeName}`;
    }
    /**
     * GeometryAttribute
     * value: typed array
     * type: indices, vertices, uvs
     * size: elements per vertex
     * target: WebGL buffer type (string or constant)
     *
     * @param attributes
     * @param indices
     * @returns
     */ _setAttributes(attributes, indices) {
        return this;
    }
    _calculateVertexCount(attributes, indices) {
        if (indices) {
            return indices.value.length;
        }
        let vertexCount = Infinity;
        for (const attribute of Object.values(attributes)){
            const { value, size, constant } = attribute;
            if (!constant && value && size !== undefined && size >= 1) {
                vertexCount = Math.min(vertexCount, value.length / size);
            }
        }
        // assert(Number.isFinite(vertexCount));
        return vertexCount;
    }
} //# sourceMappingURL=geometry.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/models/clip-space.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "ClipSpace": (()=>ClipSpace)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$model$2f$model$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/engine/dist/model/model.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$geometry$2f$geometry$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/engine/dist/geometry/geometry.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$utils$2f$uid$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/engine/dist/utils/uid.js [client] (ecmascript)");
;
;
;
const CLIPSPACE_VERTEX_SHADER_WGSL = /* wgsl */ `\
struct VertexInputs {
  @location(0) clipSpacePosition: vec2<f32>,
  @location(1) texCoord: vec2<f32>,
  @location(2) coordinate: vec2<f32>  
}

struct FragmentInputs {
  @builtin(position) Position : vec4<f32>,
  @location(0) position : vec2<f32>,
  @location(1) coordinate : vec2<f32>,
  @location(2) uv : vec2<f32>
};

@vertex
fn vertexMain(inputs: VertexInputs) -> FragmentInputs {
  var outputs: FragmentInputs;
  outputs.Position = vec4(inputs.clipSpacePosition, 0., 1.);
  outputs.position = inputs.clipSpacePosition;
  outputs.coordinate = inputs.coordinate;
  outputs.uv = inputs.texCoord;
  return outputs;
}
`;
const CLIPSPACE_VERTEX_SHADER = /* glsl */ `\
#version 300 es
in vec2 clipSpacePositions;
in vec2 texCoords;
in vec2 coordinates;

out vec2 position;
out vec2 coordinate;
out vec2 uv;

void main(void) {
  gl_Position = vec4(clipSpacePositions, 0., 1.);
  position = clipSpacePositions;
  coordinate = coordinates;
  uv = texCoords;
}
`;
/* eslint-disable indent, no-multi-spaces */ const POSITIONS = [
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    1
];
class ClipSpace extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$model$2f$model$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Model"] {
    constructor(device, props){
        const TEX_COORDS = POSITIONS.map((coord)=>coord === -1 ? 0 : coord);
        // For WGSL we need to append the supplied fragment shader to the default vertex shader source
        if (props.source) {
            props = {
                ...props,
                source: `${CLIPSPACE_VERTEX_SHADER_WGSL}\n${props.source}`
            };
        }
        super(device, {
            id: props.id || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$utils$2f$uid$2e$js__$5b$client$5d$__$28$ecmascript$29$__["uid"])('clip-space'),
            ...props,
            vs: CLIPSPACE_VERTEX_SHADER,
            vertexCount: 4,
            geometry: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$geometry$2f$geometry$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Geometry"]({
                topology: 'triangle-strip',
                vertexCount: 4,
                attributes: {
                    clipSpacePositions: {
                        size: 2,
                        value: new Float32Array(POSITIONS)
                    },
                    texCoords: {
                        size: 2,
                        value: new Float32Array(TEX_COORDS)
                    },
                    coordinates: {
                        size: 2,
                        value: new Float32Array(TEX_COORDS)
                    }
                }
            })
        });
    }
} //# sourceMappingURL=clip-space.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/geometries/cube-geometry.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "CUBE_NON_INDEXED_COLORS": (()=>CUBE_NON_INDEXED_COLORS),
    "CUBE_NON_INDEXED_POSITIONS": (()=>CUBE_NON_INDEXED_POSITIONS),
    "CUBE_NON_INDEXED_TEX_COORDS": (()=>CUBE_NON_INDEXED_TEX_COORDS),
    "CubeGeometry": (()=>CubeGeometry)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$geometry$2f$geometry$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/engine/dist/geometry/geometry.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$utils$2f$uid$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/engine/dist/utils/uid.js [client] (ecmascript)");
;
;
class CubeGeometry extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$geometry$2f$geometry$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Geometry"] {
    constructor(props = {}){
        const { id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$utils$2f$uid$2e$js__$5b$client$5d$__$28$ecmascript$29$__["uid"])('cube-geometry'), indices = true } = props;
        super(indices ? {
            ...props,
            id,
            topology: 'triangle-list',
            indices: {
                size: 1,
                value: CUBE_INDICES
            },
            attributes: {
                ...ATTRIBUTES,
                ...props.attributes
            }
        } : {
            ...props,
            id,
            topology: 'triangle-list',
            indices: undefined,
            attributes: {
                ...NON_INDEXED_ATTRIBUTES,
                ...props.attributes
            }
        });
    }
}
// prettier-ignore
const CUBE_INDICES = new Uint16Array([
    0,
    1,
    2,
    0,
    2,
    3,
    4,
    5,
    6,
    4,
    6,
    7,
    8,
    9,
    10,
    8,
    10,
    11,
    12,
    13,
    14,
    12,
    14,
    15,
    16,
    17,
    18,
    16,
    18,
    19,
    20,
    21,
    22,
    20,
    22,
    23
]);
// prettier-ignore
const CUBE_POSITIONS = new Float32Array([
    -1,
    -1,
    1,
    1,
    -1,
    1,
    1,
    1,
    1,
    -1,
    1,
    1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    -1,
    1,
    -1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    -1,
    -1,
    1,
    1,
    -1,
    1,
    1,
    1,
    1,
    -1,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    -1,
    1,
    -1
]);
// TODO - could be Uint8
// prettier-ignore
const CUBE_NORMALS = new Float32Array([
    // Front face
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    // Back face
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    // Top face
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    // Bottom face
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    // Right face
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    // Left face
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0
]);
// prettier-ignore
const CUBE_TEX_COORDS = new Float32Array([
    // Front face
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    1,
    // Back face
    1,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    // Top face
    0,
    1,
    0,
    0,
    1,
    0,
    1,
    1,
    // Bottom face
    1,
    1,
    0,
    1,
    0,
    0,
    1,
    0,
    // Right face
    1,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    // Left face
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    1
]);
const CUBE_NON_INDEXED_POSITIONS = new Float32Array([
    1,
    -1,
    1,
    -1,
    -1,
    1,
    -1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    -1,
    -1,
    -1,
    1,
    1,
    1,
    1,
    -1,
    1,
    1,
    -1,
    -1,
    1,
    1,
    -1,
    1,
    1,
    1,
    1,
    -1,
    -1,
    -1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    1,
    1,
    -1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    -1,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    1,
    -1,
    1,
    1,
    1,
    -1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    -1,
    1,
    1,
    1,
    1,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    -1,
    1,
    -1,
    -1,
    -1,
    1,
    -1
]);
const CUBE_NON_INDEXED_TEX_COORDS = new Float32Array([
    1,
    1,
    0,
    1,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    0
]);
const CUBE_NON_INDEXED_COLORS = new Float32Array([
    1,
    0,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    0,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    0,
    0,
    0,
    1,
    0,
    1,
    0,
    1,
    1,
    1,
    0,
    1,
    1,
    0,
    0,
    1,
    0,
    1,
    0,
    1
]);
const ATTRIBUTES = {
    POSITION: {
        size: 3,
        value: CUBE_POSITIONS
    },
    NORMAL: {
        size: 3,
        value: CUBE_NORMALS
    },
    TEXCOORD_0: {
        size: 2,
        value: CUBE_TEX_COORDS
    }
};
const NON_INDEXED_ATTRIBUTES = {
    POSITION: {
        size: 3,
        value: CUBE_NON_INDEXED_POSITIONS
    },
    // NORMAL: {size: 3, value: CUBE_NON_INDEXED_NORMALS},
    TEXCOORD_0: {
        size: 2,
        value: CUBE_NON_INDEXED_TEX_COORDS
    },
    COLOR_0: {
        size: 3,
        value: CUBE_NON_INDEXED_COLORS
    }
}; //# sourceMappingURL=cube-geometry.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/compute/texture-transform.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "TextureTransform": (()=>TextureTransform)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$model$2f$model$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/engine/dist/model/model.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$glsl$2d$utils$2f$shader$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/shadertools/dist/lib/glsl-utils/shader-utils.js [client] (ecmascript)");
;
;
const FS_OUTPUT_VARIABLE = 'transform_output';
class TextureTransform {
    device;
    model;
    sampler;
    currentIndex = 0;
    samplerTextureMap = null;
    bindings = [];
    resources = {};
    constructor(device, props){
        this.device = device;
        // For precise picking of element IDs.
        this.sampler = device.createSampler({
            addressModeU: 'clamp-to-edge',
            addressModeV: 'clamp-to-edge',
            minFilter: 'nearest',
            magFilter: 'nearest',
            mipmapFilter: 'nearest'
        });
        this.model = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$model$2f$model$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Model"](this.device, {
            id: props.id || 'texture-transform-model',
            fs: props.fs || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$glsl$2d$utils$2f$shader$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getPassthroughFS"])({
                input: props.targetTextureVarying,
                inputChannels: props.targetTextureChannels,
                output: FS_OUTPUT_VARIABLE
            }),
            vertexCount: props.vertexCount,
            ...props
        });
        this._initialize(props);
        Object.seal(this);
    }
    // Delete owned resources.
    destroy() {
        this.model.destroy();
        for (const binding of this.bindings){
            binding.framebuffer?.destroy();
        }
    }
    /** @deprecated Use {@link destroy}. */ delete() {
        this.destroy();
    }
    run(options) {
        const { framebuffer } = this.bindings[this.currentIndex];
        const renderPass = this.device.beginRenderPass({
            framebuffer,
            ...options
        });
        this.model.draw(renderPass);
        renderPass.end();
    }
    getTargetTexture() {
        const { targetTexture } = this.bindings[this.currentIndex];
        return targetTexture;
    }
    getFramebuffer() {
        const currentResources = this.bindings[this.currentIndex];
        return currentResources.framebuffer;
    }
    // Private
    _initialize(props) {
        this._updateBindings(props);
    }
    _updateBindings(props) {
        this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], props);
    }
    _updateBinding(binding, { sourceBuffers, sourceTextures, targetTexture }) {
        if (!binding) {
            binding = {
                sourceBuffers: {},
                sourceTextures: {},
                // @ts-expect-error
                targetTexture: null
            };
        }
        Object.assign(binding.sourceTextures, sourceTextures);
        Object.assign(binding.sourceBuffers, sourceBuffers);
        if (targetTexture) {
            binding.targetTexture = targetTexture;
            const { width, height } = targetTexture;
            // TODO(donmccurdy): When is this called, and is this expected?
            if (binding.framebuffer) {
                binding.framebuffer.destroy();
            }
            binding.framebuffer = this.device.createFramebuffer({
                id: 'transform-framebuffer',
                width,
                height,
                colorAttachments: [
                    targetTexture
                ]
            });
            binding.framebuffer.resize({
                width,
                height
            });
        }
        return binding;
    }
    // set texture filtering parameters on source textures.
    _setSourceTextureParameters() {
        const index = this.currentIndex;
        const { sourceTextures } = this.bindings[index];
        for(const name in sourceTextures){
            sourceTextures[name].sampler = this.sampler;
        }
    }
} //# sourceMappingURL=texture-transform.js.map
}}),
}]);

//# sourceMappingURL=node_modules_%40luma_gl_engine_dist_c894af4a._.js.map