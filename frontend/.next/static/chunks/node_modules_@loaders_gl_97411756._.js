(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_@loaders_gl_97411756._.js", {

"[project]/node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "isAsyncIterable": (()=>isAsyncIterable),
    "isBlob": (()=>isBlob),
    "isBuffer": (()=>isBuffer),
    "isFile": (()=>isFile),
    "isIterable": (()=>isIterable),
    "isIterator": (()=>isIterator),
    "isObject": (()=>isObject),
    "isPromise": (()=>isPromise),
    "isPureObject": (()=>isPureObject),
    "isReadableDOMStream": (()=>isReadableDOMStream),
    "isReadableNodeStream": (()=>isReadableNodeStream),
    "isReadableStream": (()=>isReadableStream),
    "isResponse": (()=>isResponse),
    "isWritableDOMStream": (()=>isWritableDOMStream),
    "isWritableNodeStream": (()=>isWritableNodeStream),
    "isWritableStream": (()=>isWritableStream)
});
const isBoolean = (x)=>typeof x === 'boolean';
const isFunction = (x)=>typeof x === 'function';
const isObject = (x)=>x !== null && typeof x === 'object';
const isPureObject = (x)=>isObject(x) && x.constructor === ({}).constructor;
const isPromise = (x)=>isObject(x) && isFunction(x.then);
const isIterable = (x)=>Boolean(x) && typeof x[Symbol.iterator] === 'function';
const isAsyncIterable = (x)=>x && typeof x[Symbol.asyncIterator] === 'function';
const isIterator = (x)=>x && isFunction(x.next);
const isResponse = (x)=>typeof Response !== 'undefined' && x instanceof Response || x && x.arrayBuffer && x.text && x.json;
const isFile = (x)=>typeof File !== 'undefined' && x instanceof File;
const isBlob = (x)=>typeof Blob !== 'undefined' && x instanceof Blob;
const isBuffer = (x)=>x && typeof x === 'object' && x.isBuffer;
const isWritableDOMStream = (x)=>isObject(x) && isFunction(x.abort) && isFunction(x.getWriter);
const isReadableDOMStream = (x)=>typeof ReadableStream !== 'undefined' && x instanceof ReadableStream || isObject(x) && isFunction(x.tee) && isFunction(x.cancel) && isFunction(x.getReader);
const isWritableNodeStream = (x)=>isObject(x) && isFunction(x.end) && isFunction(x.write) && isBoolean(x.writable);
const isReadableNodeStream = (x)=>isObject(x) && isFunction(x.read) && isFunction(x.pipe) && isBoolean(x.readable);
const isReadableStream = (x)=>isReadableDOMStream(x) || isReadableNodeStream(x);
const isWritableStream = (x)=>isWritableDOMStream(x) || isWritableNodeStream(x);
}}),
"[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/normalize-loader.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "isLoaderObject": (()=>isLoaderObject),
    "normalizeLoader": (()=>normalizeLoader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/assert.js [client] (ecmascript)");
;
function isLoaderObject(loader) {
    if (!loader) {
        return false;
    }
    if (Array.isArray(loader)) {
        loader = loader[0];
    }
    const hasExtensions = Array.isArray(loader?.extensions);
    /* Now handled by types and worker loaders do not have these
    let hasParser =
      loader.parseTextSync ||
      loader.parseSync ||
      loader.parse ||
      loader.parseStream || // TODO Remove, Replace with parseInBatches
      loader.parseInBatches;
    */ return hasExtensions;
}
function normalizeLoader(loader) {
    // This error is fairly easy to trigger by mixing up import statements etc
    // So we make an exception and add a developer error message for this case
    // To help new users from getting stuck here
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(loader, 'null loader');
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(isLoaderObject(loader), 'invalid loader');
    // NORMALIZE [LOADER, OPTIONS] => LOADER
    // If [loader, options], create a new loaders object with options merged in
    let options;
    if (Array.isArray(loader)) {
        options = loader[1];
        loader = loader[0];
        loader = {
            ...loader,
            options: {
                ...loader.options,
                ...options
            }
        };
    }
    // NORMALIZE text and binary flags
    // Ensure at least one of text/binary flags are properly set
    // @ts-expect-error
    if (loader?.parseTextSync || loader?.parseText) {
        loader.text = true;
    }
    if (!loader.text) {
        loader.binary = true;
    }
    return loader;
}
}}),
"[project]/node_modules/@loaders.gl/core/dist/lib/fetch/fetch-error.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "FetchError": (()=>FetchError)
});
class FetchError extends Error {
    constructor(message, info){
        super(message);
        this.reason = info.reason;
        this.url = info.url;
        this.response = info.response;
    }
    /** A best effort reason for why the fetch failed */ reason;
    /** The URL that failed to load. Empty string if not available. */ url;
    /** The Response object, if any. */ response;
}
}}),
"[project]/node_modules/@loaders.gl/core/dist/lib/utils/mime-type-utils.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// TODO - build/integrate proper MIME type parsing
// https://mimesniff.spec.whatwg.org/
__turbopack_context__.s({
    "compareMIMETypes": (()=>compareMIMETypes),
    "parseMIMEType": (()=>parseMIMEType),
    "parseMIMETypeFromURL": (()=>parseMIMETypeFromURL)
});
const DATA_URL_PATTERN = /^data:([-\w.]+\/[-\w.+]+)(;|,)/;
const MIME_TYPE_PATTERN = /^([-\w.]+\/[-\w.+]+)/;
function compareMIMETypes(mimeType1, mimeType2) {
    if (mimeType1.toLowerCase() === mimeType2.toLowerCase()) {
        return true;
    }
    return false;
}
function parseMIMEType(mimeString) {
    // If resource is a data url, extract any embedded mime type
    const matches = MIME_TYPE_PATTERN.exec(mimeString);
    if (matches) {
        return matches[1];
    }
    return mimeString;
}
function parseMIMETypeFromURL(url) {
    // If resource is a data URL, extract any embedded mime type
    const matches = DATA_URL_PATTERN.exec(url);
    if (matches) {
        return matches[1];
    }
    return '';
}
}}),
"[project]/node_modules/@loaders.gl/core/dist/lib/utils/url-utils.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "extractQueryString": (()=>extractQueryString),
    "shortenUrlForDisplay": (()=>shortenUrlForDisplay),
    "stripQueryString": (()=>stripQueryString)
});
const QUERY_STRING_PATTERN = /\?.*/;
function extractQueryString(url) {
    const matches = url.match(QUERY_STRING_PATTERN);
    return matches && matches[0];
}
function stripQueryString(url) {
    return url.replace(QUERY_STRING_PATTERN, '');
}
function shortenUrlForDisplay(url) {
    if (url.length < 50) {
        return url;
    }
    const urlEnd = url.slice(url.length - 15);
    const urlStart = url.substr(0, 32);
    return `${urlStart}...${urlEnd}`;
}
}}),
"[project]/node_modules/@loaders.gl/core/dist/lib/utils/resource-utils.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "getResourceContentLength": (()=>getResourceContentLength),
    "getResourceMIMEType": (()=>getResourceMIMEType),
    "getResourceUrl": (()=>getResourceUrl)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$mime$2d$type$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/utils/mime-type-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$url$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/utils/url-utils.js [client] (ecmascript)");
;
;
;
function getResourceUrl(resource) {
    // If resource is a `Response`, it contains the information directly as a field
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isResponse"])(resource)) {
        const response = resource;
        return response.url;
    }
    // If the resource is a Blob or a File (subclass of Blob)
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBlob"])(resource)) {
        const blob = resource;
        // File objects have a "name" property. Blob objects don't have any
        // url (name) information
        return blob.name || '';
    }
    if (typeof resource === 'string') {
        return resource;
    }
    // Unknown
    return '';
}
function getResourceMIMEType(resource) {
    // If resource is a response, it contains the information directly
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isResponse"])(resource)) {
        const response = resource;
        const contentTypeHeader = response.headers.get('content-type') || '';
        const noQueryUrl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$url$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["stripQueryString"])(response.url);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$mime$2d$type$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseMIMEType"])(contentTypeHeader) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$mime$2d$type$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseMIMETypeFromURL"])(noQueryUrl);
    }
    // If the resource is a Blob or a File (subclass of Blob)
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBlob"])(resource)) {
        const blob = resource;
        return blob.type || '';
    }
    if (typeof resource === 'string') {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$mime$2d$type$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseMIMETypeFromURL"])(resource);
    }
    // Unknown
    return '';
}
function getResourceContentLength(resource) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isResponse"])(resource)) {
        const response = resource;
        return response.headers['content-length'] || -1;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBlob"])(resource)) {
        const blob = resource;
        return blob.size;
    }
    if (typeof resource === 'string') {
        // TODO - handle data URL?
        return resource.length;
    }
    if (resource instanceof ArrayBuffer) {
        return resource.byteLength;
    }
    if (ArrayBuffer.isView(resource)) {
        return resource.byteLength;
    }
    return -1;
}
}}),
"[project]/node_modules/@loaders.gl/core/dist/lib/utils/response-utils.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "checkResponse": (()=>checkResponse),
    "checkResponseSync": (()=>checkResponseSync),
    "makeResponse": (()=>makeResponse)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$fetch$2f$fetch$2d$error$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/fetch/fetch-error.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$resource$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/utils/resource-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$url$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/utils/url-utils.js [client] (ecmascript)");
;
;
;
;
async function makeResponse(resource) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isResponse"])(resource)) {
        return resource;
    }
    // Add content-length header if possible
    const headers = {};
    const contentLength = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$resource$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getResourceContentLength"])(resource);
    if (contentLength >= 0) {
        headers['content-length'] = String(contentLength);
    }
    // `new Response(File)` does not preserve content-type and URL
    // so we add them here
    const url = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$resource$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getResourceUrl"])(resource);
    const type = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$resource$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getResourceMIMEType"])(resource);
    if (type) {
        headers['content-type'] = type;
    }
    // Add a custom header with initial bytes if available
    const initialDataUrl = await getInitialDataUrl(resource);
    if (initialDataUrl) {
        headers['x-first-bytes'] = initialDataUrl;
    }
    // TODO - is this the best way of handling strings?
    // Maybe package as data URL instead?
    if (typeof resource === 'string') {
        // Convert to ArrayBuffer to avoid Response treating it as a URL
        resource = new TextEncoder().encode(resource);
    }
    // Attempt to create a Response from the resource, adding headers and setting url
    const response = new Response(resource, {
        headers
    });
    // We can't control `Response.url` via constructor, use a property override to record URL.
    Object.defineProperty(response, 'url', {
        value: url
    });
    return response;
}
async function checkResponse(response) {
    if (!response.ok) {
        const error = await getResponseError(response);
        throw error;
    }
}
function checkResponseSync(response) {
    if (!response.ok) {
        let message = `${response.status} ${response.statusText}`;
        message = message.length > 60 ? `${message.slice(0, 60)}...` : message;
        throw new Error(message);
    }
}
// HELPERS
async function getResponseError(response) {
    const shortUrl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$url$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["shortenUrlForDisplay"])(response.url);
    let message = `Failed to fetch resource (${response.status}) ${response.statusText}: ${shortUrl}`;
    message = message.length > 100 ? `${message.slice(0, 100)}...` : message;
    const info = {
        reason: response.statusText,
        url: response.url,
        response
    };
    // See if we got an error message in the body
    try {
        const contentType = response.headers.get('Content-Type');
        info.reason = !response.bodyUsed && contentType?.includes('application/json') ? await response.json() : await response.text();
    } catch (error) {
    // eslint forbids return in a finally statement, so we just catch here
    }
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$fetch$2f$fetch$2d$error$2e$js__$5b$client$5d$__$28$ecmascript$29$__["FetchError"](message, info);
}
async function getInitialDataUrl(resource) {
    const INITIAL_DATA_LENGTH = 5;
    if (typeof resource === 'string') {
        return `data:,${resource.slice(0, INITIAL_DATA_LENGTH)}`;
    }
    if (resource instanceof Blob) {
        const blobSlice = resource.slice(0, 5);
        return await new Promise((resolve)=>{
            const reader = new FileReader();
            reader.onload = (event)=>resolve(event?.target?.result);
            reader.readAsDataURL(blobSlice);
        });
    }
    if (resource instanceof ArrayBuffer) {
        const slice = resource.slice(0, INITIAL_DATA_LENGTH);
        const base64 = arrayBufferToBase64(slice);
        return `data:base64,${base64}`;
    }
    return null;
}
// https://stackoverflow.com/questions/9267899/arraybuffer-to-base64-encoded-string
function arrayBufferToBase64(buffer) {
    let binary = '';
    const bytes = new Uint8Array(buffer);
    for(let i = 0; i < bytes.byteLength; i++){
        binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
}
}}),
"[project]/node_modules/@loaders.gl/core/dist/lib/fetch/fetch-file.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "fetchFile": (()=>fetchFile),
    "isDataURL": (()=>isDataURL),
    "isNodePath": (()=>isNodePath),
    "isRequestURL": (()=>isRequestURL)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$path$2d$utils$2f$file$2d$aliases$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/file-aliases.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$response$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/utils/response-utils.js [client] (ecmascript)");
;
;
function isNodePath(url) {
    return !isRequestURL(url) && !isDataURL(url);
}
function isRequestURL(url) {
    return url.startsWith('http:') || url.startsWith('https:');
}
function isDataURL(url) {
    return url.startsWith('data:');
}
async function fetchFile(urlOrData, fetchOptions) {
    if (typeof urlOrData === 'string') {
        const url = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$path$2d$utils$2f$file$2d$aliases$2e$js__$5b$client$5d$__$28$ecmascript$29$__["resolvePath"])(urlOrData);
        // Support fetching from local file system
        if (isNodePath(url)) {
            if (globalThis.loaders?.fetchNode) {
                return globalThis.loaders?.fetchNode(url, fetchOptions);
            }
        // throw new Error(
        //   'fetchFile: globalThis.loaders.fetchNode not defined. Install @loaders.gl/polyfills'
        // );
        }
        // Call global fetch
        return await fetch(url, fetchOptions);
    }
    // TODO - should we still call fetch on non-URL inputs?
    return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$response$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["makeResponse"])(urlOrData);
}
}}),
"[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/loggers.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// probe.gl Log compatible loggers
__turbopack_context__.s({
    "ConsoleLog": (()=>ConsoleLog),
    "NullLog": (()=>NullLog),
    "probeLog": (()=>probeLog)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/log/dist/log.js [client] (ecmascript)");
;
const probeLog = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Log"]({
    id: 'loaders.gl'
});
class NullLog {
    log() {
        return ()=>{};
    }
    info() {
        return ()=>{};
    }
    warn() {
        return ()=>{};
    }
    error() {
        return ()=>{};
    }
}
class ConsoleLog {
    console;
    constructor(){
        this.console = console; // eslint-disable-line
    }
    log(...args) {
        return this.console.log.bind(this.console, ...args);
    }
    info(...args) {
        return this.console.info.bind(this.console, ...args);
    }
    warn(...args) {
        return this.console.warn.bind(this.console, ...args);
    }
    error(...args) {
        return this.console.error.bind(this.console, ...args);
    }
}
}}),
"[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/option-defaults.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "DEFAULT_LOADER_OPTIONS": (()=>DEFAULT_LOADER_OPTIONS),
    "REMOVED_LOADER_OPTIONS": (()=>REMOVED_LOADER_OPTIONS)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/globals.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$loggers$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/loggers.js [client] (ecmascript)");
;
;
const DEFAULT_LOADER_OPTIONS = {
    // baseUri
    fetch: null,
    mimeType: undefined,
    nothrow: false,
    log: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$loggers$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ConsoleLog"](),
    useLocalLibraries: false,
    CDN: 'https://unpkg.com/@loaders.gl',
    worker: true,
    maxConcurrency: 3,
    maxMobileConcurrency: 1,
    reuseWorkers: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBrowser"],
    _nodeWorkers: false,
    _workerType: '',
    limit: 0,
    _limitMB: 0,
    batchSize: 'auto',
    batchDebounceMs: 0,
    metadata: false,
    transforms: []
};
const REMOVED_LOADER_OPTIONS = {
    throws: 'nothrow',
    dataType: '(no longer used)',
    uri: 'baseUri',
    // Warn if fetch options are used on top-level
    method: 'fetch.method',
    headers: 'fetch.headers',
    body: 'fetch.body',
    mode: 'fetch.mode',
    credentials: 'fetch.credentials',
    cache: 'fetch.cache',
    redirect: 'fetch.redirect',
    referrer: 'fetch.referrer',
    referrerPolicy: 'fetch.referrerPolicy',
    integrity: 'fetch.integrity',
    keepalive: 'fetch.keepalive',
    signal: 'fetch.signal'
};
}}),
"[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/option-utils.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "getGlobalLoaderOptions": (()=>getGlobalLoaderOptions),
    "getGlobalLoaderState": (()=>getGlobalLoaderState),
    "normalizeOptions": (()=>normalizeOptions),
    "setGlobalOptions": (()=>setGlobalOptions)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$module$2d$utils$2f$js$2d$module$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/module-utils/js-module-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$loggers$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/loggers.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$option$2d$defaults$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/option-defaults.js [client] (ecmascript)");
;
;
;
;
function getGlobalLoaderState() {
    // @ts-ignore
    globalThis.loaders = globalThis.loaders || {};
    // @ts-ignore
    const { loaders } = globalThis;
    // Add _state object to keep separate from modules added to globalThis.loaders
    if (!loaders._state) {
        loaders._state = {};
    }
    return loaders._state;
}
function getGlobalLoaderOptions() {
    const state = getGlobalLoaderState();
    // Ensure all default loader options from this library are mentioned
    state.globalOptions = state.globalOptions || {
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$option$2d$defaults$2e$js__$5b$client$5d$__$28$ecmascript$29$__["DEFAULT_LOADER_OPTIONS"]
    };
    return state.globalOptions;
}
function setGlobalOptions(options) {
    const state = getGlobalLoaderState();
    const globalOptions = getGlobalLoaderOptions();
    // @ts-expect-error First param looks incorrect
    state.globalOptions = normalizeOptionsInternal(globalOptions, options);
    // Make sure any new modules are registered
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$module$2d$utils$2f$js$2d$module$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["registerJSModules"])(options.modules);
}
function normalizeOptions(options, loader, loaders, url) {
    loaders = loaders || [];
    loaders = Array.isArray(loaders) ? loaders : [
        loaders
    ];
    validateOptions(options, loaders);
    return normalizeOptionsInternal(loader, options, url);
}
// VALIDATE OPTIONS
/**
 * Warn for unsupported options
 * @param options
 * @param loaders
 */ function validateOptions(options, loaders) {
    // Check top level options
    validateOptionsObject(options, null, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$option$2d$defaults$2e$js__$5b$client$5d$__$28$ecmascript$29$__["DEFAULT_LOADER_OPTIONS"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$option$2d$defaults$2e$js__$5b$client$5d$__$28$ecmascript$29$__["REMOVED_LOADER_OPTIONS"], loaders);
    for (const loader of loaders){
        // Get the scoped, loader specific options from the user supplied options
        const idOptions = options && options[loader.id] || {};
        // Get scoped, loader specific default and deprecated options from the selected loader
        const loaderOptions = loader.options && loader.options[loader.id] || {};
        const deprecatedOptions = loader.deprecatedOptions && loader.deprecatedOptions[loader.id] || {};
        // Validate loader specific options
        // @ts-ignore
        validateOptionsObject(idOptions, loader.id, loaderOptions, deprecatedOptions, loaders);
    }
}
// eslint-disable-next-line max-params, complexity
function validateOptionsObject(options, id, defaultOptions, deprecatedOptions, loaders) {
    const loaderName = id || 'Top level';
    const prefix = id ? `${id}.` : '';
    for(const key in options){
        // If top level option value is an object it could options for a loader, so ignore
        const isSubOptions = !id && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isObject"])(options[key]);
        const isBaseUriOption = key === 'baseUri' && !id;
        const isWorkerUrlOption = key === 'workerUrl' && id;
        // <loader>.workerUrl requires special handling as it is now auto-generated and no longer specified as a default option.
        if (!(key in defaultOptions) && !isBaseUriOption && !isWorkerUrlOption) {
            // Issue deprecation warnings
            if (key in deprecatedOptions) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$loggers$2e$js__$5b$client$5d$__$28$ecmascript$29$__["probeLog"].warn(`${loaderName} loader option \'${prefix}${key}\' no longer supported, use \'${deprecatedOptions[key]}\'`)();
            } else if (!isSubOptions) {
                const suggestion = findSimilarOption(key, loaders);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$loggers$2e$js__$5b$client$5d$__$28$ecmascript$29$__["probeLog"].warn(`${loaderName} loader option \'${prefix}${key}\' not recognized. ${suggestion}`)();
            }
        }
    }
}
function findSimilarOption(optionKey, loaders) {
    const lowerCaseOptionKey = optionKey.toLowerCase();
    let bestSuggestion = '';
    for (const loader of loaders){
        for(const key in loader.options){
            if (optionKey === key) {
                return `Did you mean \'${loader.id}.${key}\'?`;
            }
            const lowerCaseKey = key.toLowerCase();
            const isPartialMatch = lowerCaseOptionKey.startsWith(lowerCaseKey) || lowerCaseKey.startsWith(lowerCaseOptionKey);
            if (isPartialMatch) {
                bestSuggestion = bestSuggestion || `Did you mean \'${loader.id}.${key}\'?`;
            }
        }
    }
    return bestSuggestion;
}
function normalizeOptionsInternal(loader, options, url) {
    const loaderDefaultOptions = loader.options || {};
    const mergedOptions = {
        ...loaderDefaultOptions
    };
    addUrlOptions(mergedOptions, url);
    // LOGGING: options.log can be set to `null` to defeat logging
    if (mergedOptions.log === null) {
        mergedOptions.log = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$loggers$2e$js__$5b$client$5d$__$28$ecmascript$29$__["NullLog"]();
    }
    mergeNestedFields(mergedOptions, getGlobalLoaderOptions());
    mergeNestedFields(mergedOptions, options);
    return mergedOptions;
}
// Merge nested options objects
function mergeNestedFields(mergedOptions, options) {
    for(const key in options){
        // Check for nested options
        // object in options => either no key in defaultOptions or object in defaultOptions
        if (key in options) {
            const value = options[key];
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isPureObject"])(value) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isPureObject"])(mergedOptions[key])) {
                mergedOptions[key] = {
                    ...mergedOptions[key],
                    ...options[key]
                };
            } else {
                mergedOptions[key] = options[key];
            }
        }
    // else: No need to merge nested opts, and the initial merge already copied over the nested options
    }
}
/**
 * Harvest information from the url
 * @deprecated This is mainly there to support a hack in the GLTFLoader
 * TODO - baseUri should be a directory, i.e. remove file component from baseUri
 * TODO - extract extension?
 * TODO - extract query parameters?
 * TODO - should these be injected on context instead of options?
 */ function addUrlOptions(options, url) {
    if (url && !('baseUri' in options)) {
        options.baseUri = url;
    }
}
}}),
"[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/get-fetch-function.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "getFetchFunction": (()=>getFetchFunction)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$fetch$2f$fetch$2d$file$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/fetch/fetch-file.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$option$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/option-utils.js [client] (ecmascript)");
;
;
;
function getFetchFunction(options, context) {
    const globalOptions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$option$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getGlobalLoaderOptions"])();
    const loaderOptions = options || globalOptions;
    // options.fetch can be a function
    if (typeof loaderOptions.fetch === 'function') {
        return loaderOptions.fetch;
    }
    // options.fetch can be an options object
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isObject"])(loaderOptions.fetch)) {
        return (url)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$fetch$2f$fetch$2d$file$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fetchFile"])(url, loaderOptions.fetch);
    }
    // else refer to context (from parent loader) if available
    if (context?.fetch) {
        return context?.fetch;
    }
    // else return the default fetch function
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$fetch$2f$fetch$2d$file$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fetchFile"];
}
}}),
"[project]/node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-string-iterator.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "makeStringIterator": (()=>makeStringIterator)
});
const DEFAULT_CHUNK_SIZE = 256 * 1024;
function* makeStringIterator(string, options) {
    const chunkSize = options?.chunkSize || DEFAULT_CHUNK_SIZE;
    let offset = 0;
    const textEncoder = new TextEncoder();
    while(offset < string.length){
        // Create a chunk of the right size
        const chunkLength = Math.min(string.length - offset, chunkSize);
        const chunk = string.slice(offset, offset + chunkLength);
        offset += chunkLength;
        // yield an ArrayBuffer chunk
        yield textEncoder.encode(chunk);
    }
}
}}),
"[project]/node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-array-buffer-iterator.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "makeArrayBufferIterator": (()=>makeArrayBufferIterator)
});
const DEFAULT_CHUNK_SIZE = 256 * 1024;
function* makeArrayBufferIterator(arrayBuffer, options = {}) {
    const { chunkSize = DEFAULT_CHUNK_SIZE } = options;
    let byteOffset = 0;
    while(byteOffset < arrayBuffer.byteLength){
        // Create a chunk of the right size
        const chunkByteLength = Math.min(arrayBuffer.byteLength - byteOffset, chunkSize);
        const chunk = new ArrayBuffer(chunkByteLength);
        // Copy data from the big chunk
        const sourceArray = new Uint8Array(arrayBuffer, byteOffset, chunkByteLength);
        const chunkArray = new Uint8Array(chunk);
        chunkArray.set(sourceArray);
        // yield the chunk
        byteOffset += chunkByteLength;
        yield chunk;
    }
}
}}),
"[project]/node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-blob-iterator.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "makeBlobIterator": (()=>makeBlobIterator)
});
const DEFAULT_CHUNK_SIZE = 1024 * 1024; // 1MB â€” biggest value that keeps UI responsive
async function* makeBlobIterator(blob, options) {
    const chunkSize = options?.chunkSize || DEFAULT_CHUNK_SIZE;
    let offset = 0;
    while(offset < blob.size){
        const end = offset + chunkSize;
        const chunk = await blob.slice(offset, end).arrayBuffer();
        offset = end;
        yield chunk;
    }
}
}}),
"[project]/node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-stream-iterator.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "makeStreamIterator": (()=>makeStreamIterator)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/globals.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$binary$2d$utils$2f$memory$2d$conversion$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/memory-conversion-utils.js [client] (ecmascript)");
;
function makeStreamIterator(stream, options) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBrowser"] ? makeBrowserStreamIterator(stream, options) : makeNodeStreamIterator(stream, options);
}
/**
 * Returns an async iterable that reads from a DOM (browser) stream
 * @param stream stream to iterate from
 * @see https://jakearchibald.com/2017/async-iterators-and-generators/#making-streams-iterate
 */ async function* makeBrowserStreamIterator(stream, options) {
    // WhatWG: stream is supposed to have a `getIterator` method
    // if (typeof stream.getIterator === 'function') {
    //   return stream.getIterator();
    // }
    // if (typeof stream[Symbol.asyncIterator] === 'function') {
    //   return makeToArrayBufferIterator(stream);
    // }
    // In the browser, we first need to get a lock on the stream
    const reader = stream.getReader();
    let nextBatchPromise;
    try {
        // eslint-disable-next-line no-constant-condition
        while(true){
            const currentBatchPromise = nextBatchPromise || reader.read();
            // Issue a read for an additional batch, while we await the next batch
            // Idea is to make fetching happen in parallel with processing / parsing
            if (options?._streamReadAhead) {
                nextBatchPromise = reader.read();
            }
            // Read from the stream
            // value is a Uint8Array
            const { done, value } = await currentBatchPromise;
            // Exit if we're done
            if (done) {
                return;
            }
            // Else yield the chunk
            yield (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$binary$2d$utils$2f$memory$2d$conversion$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toArrayBuffer"])(value);
        }
    } catch (error) {
        // TODO - examples makes it look like this should always be called,
        // but that generates exceptions so only call it if we do not reach the end
        reader.releaseLock();
    }
}
/**
 * Returns an async iterable that reads from a DOM (browser) stream
 * @param stream stream to iterate from
 * @note Requires Node.js >= 10
 */ async function* makeNodeStreamIterator(stream, options) {
    // Hacky test for node version to ensure we don't call bad polyfills
    // NODE 10+: stream is an asyncIterator
    for await (const chunk of stream){
        yield (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$binary$2d$utils$2f$memory$2d$conversion$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toArrayBuffer"])(chunk); // Coerce each chunk to ArrayBuffer
    }
} /* TODO - remove NODE < 10
 * @see https://github.com/bustle/streaming-iterables, MIT license
 *
  if (typeof stream[Symbol.asyncIterator] === 'function') {
    return;
  }

  // TODO - check if is this ever used in Node 10+?
  // eslint-disable-next-line no-constant-condition
  while (true) {
    const data = stream.read();
    if (data !== null) {
      yield toArrayBuffer(data);
      // eslint-disable-next-line no-continue
      continue;
    }
    if (stream._readableState?.ended) {
      return;
    }
    await onceReadable(stream);
  }

async function onceReadable(stream: Readable): Promise<any> {
  return new Promise((resolve) => {
    stream.once('readable', resolve);
  });
}
  */ 
}}),
"[project]/node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-iterator.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "makeIterator": (()=>makeIterator)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$iterators$2f$make$2d$iterator$2f$make$2d$string$2d$iterator$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-string-iterator.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$iterators$2f$make$2d$iterator$2f$make$2d$array$2d$buffer$2d$iterator$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-array-buffer-iterator.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$iterators$2f$make$2d$iterator$2f$make$2d$blob$2d$iterator$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-blob-iterator.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$iterators$2f$make$2d$iterator$2f$make$2d$stream$2d$iterator$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-stream-iterator.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js [client] (ecmascript)");
;
;
;
;
;
function makeIterator(data, options) {
    if (typeof data === 'string') {
        // Note: Converts string chunks to binary
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$iterators$2f$make$2d$iterator$2f$make$2d$string$2d$iterator$2e$js__$5b$client$5d$__$28$ecmascript$29$__["makeStringIterator"])(data, options);
    }
    if (data instanceof ArrayBuffer) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$iterators$2f$make$2d$iterator$2f$make$2d$array$2d$buffer$2d$iterator$2e$js__$5b$client$5d$__$28$ecmascript$29$__["makeArrayBufferIterator"])(data, options);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBlob"])(data)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$iterators$2f$make$2d$iterator$2f$make$2d$blob$2d$iterator$2e$js__$5b$client$5d$__$28$ecmascript$29$__["makeBlobIterator"])(data, options);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isReadableStream"])(data)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$iterators$2f$make$2d$iterator$2f$make$2d$stream$2d$iterator$2e$js__$5b$client$5d$__$28$ecmascript$29$__["makeStreamIterator"])(data, options);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isResponse"])(data)) {
        const response = data;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$iterators$2f$make$2d$iterator$2f$make$2d$stream$2d$iterator$2e$js__$5b$client$5d$__$28$ecmascript$29$__["makeStreamIterator"])(response.body, options);
    }
    throw new Error('makeIterator');
}
}}),
"[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/get-data.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "getArrayBufferOrStringFromData": (()=>getArrayBufferOrStringFromData),
    "getArrayBufferOrStringFromDataSync": (()=>getArrayBufferOrStringFromDataSync),
    "getAsyncIterableFromData": (()=>getAsyncIterableFromData),
    "getReadableStream": (()=>getReadableStream)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$iterators$2f$async$2d$iteration$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/iterators/async-iteration.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$iterators$2f$make$2d$iterator$2f$make$2d$iterator$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-iterator.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$response$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/utils/response-utils.js [client] (ecmascript)");
;
;
;
;
const ERR_DATA = 'Cannot convert supplied data type';
function getArrayBufferOrStringFromDataSync(data, loader, options) {
    if (loader.text && typeof data === 'string') {
        return data;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBuffer"])(data)) {
        // @ts-ignore
        data = data.buffer;
    }
    if (data instanceof ArrayBuffer) {
        const arrayBuffer = data;
        if (loader.text && !loader.binary) {
            const textDecoder = new TextDecoder('utf8');
            return textDecoder.decode(arrayBuffer);
        }
        return arrayBuffer;
    }
    // We may need to handle offsets
    if (ArrayBuffer.isView(data)) {
        // TextDecoder is invoked on typed arrays and will handle offsets
        if (loader.text && !loader.binary) {
            const textDecoder = new TextDecoder('utf8');
            return textDecoder.decode(data);
        }
        let arrayBuffer = data.buffer;
        // Since we are returning the underlying arrayBuffer, we must create a new copy
        // if this typed array / Buffer is a partial view into the ArryayBuffer
        // TODO - this is a potentially unnecessary copy
        const byteLength = data.byteLength || data.length;
        if (data.byteOffset !== 0 || byteLength !== arrayBuffer.byteLength) {
            // console.warn(`loaders.gl copying arraybuffer of length ${byteLength}`);
            arrayBuffer = arrayBuffer.slice(data.byteOffset, data.byteOffset + byteLength);
        }
        return arrayBuffer;
    }
    throw new Error(ERR_DATA);
}
async function getArrayBufferOrStringFromData(data, loader, options) {
    const isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);
    if (typeof data === 'string' || isArrayBuffer) {
        return getArrayBufferOrStringFromDataSync(data, loader, options);
    }
    // Blobs and files are FileReader compatible
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBlob"])(data)) {
        data = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$response$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["makeResponse"])(data);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isResponse"])(data)) {
        const response = data;
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$response$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["checkResponse"])(response);
        return loader.binary ? await response.arrayBuffer() : await response.text();
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isReadableStream"])(data)) {
        // @ts-expect-error TS2559 options type
        data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$iterators$2f$make$2d$iterator$2f$make$2d$iterator$2e$js__$5b$client$5d$__$28$ecmascript$29$__["makeIterator"])(data, options);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isIterable"])(data) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isAsyncIterable"])(data)) {
        // Assume arrayBuffer iterator - attempt to concatenate
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$iterators$2f$async$2d$iteration$2e$js__$5b$client$5d$__$28$ecmascript$29$__["concatenateArrayBuffersAsync"])(data);
    }
    throw new Error(ERR_DATA);
}
async function getAsyncIterableFromData(data, options) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isIterator"])(data)) {
        return data;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isResponse"])(data)) {
        const response = data;
        // Note Since this function is not async, we currently can't load error message, just status
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$response$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["checkResponse"])(response);
        // TODO - bug in polyfill, body can be a Promise under Node.js
        // eslint-disable-next-line @typescript-eslint/await-thenable
        const body = await response.body;
        // TODO - body can be null?
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$iterators$2f$make$2d$iterator$2f$make$2d$iterator$2e$js__$5b$client$5d$__$28$ecmascript$29$__["makeIterator"])(body, options);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBlob"])(data) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isReadableStream"])(data)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$iterators$2f$make$2d$iterator$2f$make$2d$iterator$2e$js__$5b$client$5d$__$28$ecmascript$29$__["makeIterator"])(data, options);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isAsyncIterable"])(data)) {
        return data;
    }
    return getIterableFromData(data);
}
async function getReadableStream(data) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isReadableStream"])(data)) {
        return data;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isResponse"])(data)) {
        // @ts-ignore
        return data.body;
    }
    const response = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$response$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["makeResponse"])(data);
    // @ts-ignore
    return response.body;
}
// HELPERS
function getIterableFromData(data) {
    // generate an iterator that emits a single chunk
    if (ArrayBuffer.isView(data)) {
        return function* oneChunk() {
            yield data.buffer;
        }();
    }
    if (data instanceof ArrayBuffer) {
        return function* oneChunk() {
            yield data;
        }();
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isIterator"])(data)) {
        return data;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isIterable"])(data)) {
        return data[Symbol.iterator]();
    }
    throw new Error(ERR_DATA);
}
}}),
"[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/loader-context.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "getLoaderContext": (()=>getLoaderContext),
    "getLoadersFromContext": (()=>getLoadersFromContext)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$get$2d$fetch$2d$function$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/get-fetch-function.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$url$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/utils/url-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$path$2d$utils$2f$path$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__path$3e$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/path.js [client] (ecmascript) <export * as path>");
;
;
;
function getLoaderContext(context, options, parentContext) {
    // For recursive calls, we already have a context
    // TODO - add any additional loaders to context?
    if (parentContext) {
        return parentContext;
    }
    const newContext = {
        fetch: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$get$2d$fetch$2d$function$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getFetchFunction"])(options, context),
        ...context
    };
    // Parse URLs so that subloaders can easily generate correct strings
    if (newContext.url) {
        const baseUrl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$url$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["stripQueryString"])(newContext.url);
        newContext.baseUrl = baseUrl;
        newContext.queryString = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$url$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["extractQueryString"])(newContext.url);
        newContext.filename = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$path$2d$utils$2f$path$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__path$3e$__["path"].filename(baseUrl);
        newContext.baseUrl = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$path$2d$utils$2f$path$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__path$3e$__["path"].dirname(baseUrl);
    }
    // Recursive loading does not use single loader
    if (!Array.isArray(newContext.loaders)) {
        newContext.loaders = null;
    }
    return newContext;
}
function getLoadersFromContext(loaders, context) {
    // A single loader (non-array) indicates no selection desired. Force select.
    if (loaders && !Array.isArray(loaders)) {
        return loaders;
    }
    // Create a merged list
    let candidateLoaders;
    if (loaders) {
        candidateLoaders = Array.isArray(loaders) ? loaders : [
            loaders
        ];
    }
    if (context && context.loaders) {
        const contextLoaders = Array.isArray(context.loaders) ? context.loaders : [
            context.loaders
        ];
        candidateLoaders = candidateLoaders ? [
            ...candidateLoaders,
            ...contextLoaders
        ] : contextLoaders;
    }
    // If no loaders, return null to look in globally registered loaders
    return candidateLoaders && candidateLoaders.length ? candidateLoaders : undefined;
}
}}),
"[project]/node_modules/@loaders.gl/core/dist/lib/api/register-loaders.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "_unregisterLoaders": (()=>_unregisterLoaders),
    "getRegisteredLoaders": (()=>getRegisteredLoaders),
    "registerLoaders": (()=>registerLoaders)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$normalize$2d$loader$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/normalize-loader.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$option$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/option-utils.js [client] (ecmascript)");
;
;
/**
 * Store global registered loaders on the global object to increase chances of cross loaders-version interoperability
 * This use case is not reliable but can help when testing new versions of loaders.gl with existing frameworks
 */ const getGlobalLoaderRegistry = ()=>{
    const state = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$option$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getGlobalLoaderState"])();
    state.loaderRegistry = state.loaderRegistry || [];
    return state.loaderRegistry;
};
function registerLoaders(loaders) {
    const loaderRegistry = getGlobalLoaderRegistry();
    loaders = Array.isArray(loaders) ? loaders : [
        loaders
    ];
    for (const loader of loaders){
        const normalizedLoader = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$normalize$2d$loader$2e$js__$5b$client$5d$__$28$ecmascript$29$__["normalizeLoader"])(loader);
        if (!loaderRegistry.find((registeredLoader)=>normalizedLoader === registeredLoader)) {
            // add to the beginning of the loaderRegistry, so the last registeredLoader get picked
            loaderRegistry.unshift(normalizedLoader);
        }
    }
}
function getRegisteredLoaders() {
    return getGlobalLoaderRegistry();
}
function _unregisterLoaders() {
    const state = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$option$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getGlobalLoaderState"])();
    state.loaderRegistry = [];
}
}}),
"[project]/node_modules/@loaders.gl/core/dist/lib/api/select-loader.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "selectLoader": (()=>selectLoader),
    "selectLoaderSync": (()=>selectLoaderSync)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$binary$2d$utils$2f$array$2d$buffer$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/array-buffer-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$path$2d$utils$2f$path$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__path$3e$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/path.js [client] (ecmascript) <export * as path>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$log$2d$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/log-utils/log.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$normalize$2d$loader$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/normalize-loader.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$resource$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/utils/resource-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$mime$2d$type$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/utils/mime-type-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$api$2f$register$2d$loaders$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/api/register-loaders.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$url$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/utils/url-utils.js [client] (ecmascript)");
;
;
;
;
;
;
;
const EXT_PATTERN = /\.([^.]+)$/;
async function selectLoader(data, loaders = [], options, context) {
    if (!validHTTPResponse(data)) {
        return null;
    }
    // First make a sync attempt, disabling exceptions
    let loader = selectLoaderSync(data, loaders, {
        ...options,
        nothrow: true
    }, context);
    if (loader) {
        return loader;
    }
    // For Blobs and Files, try to asynchronously read a small initial slice and test again with that
    // to see if we can detect by initial content
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBlob"])(data)) {
        data = await data.slice(0, 10).arrayBuffer();
        loader = selectLoaderSync(data, loaders, options, context);
    }
    // no loader available
    if (!loader && !options?.nothrow) {
        throw new Error(getNoValidLoaderMessage(data));
    }
    return loader;
}
function selectLoaderSync(data, loaders = [], options, context) {
    if (!validHTTPResponse(data)) {
        return null;
    }
    // eslint-disable-next-line complexity
    // if only a single loader was provided (not as array), force its use
    // TODO - Should this behavior be kept and documented?
    if (loaders && !Array.isArray(loaders)) {
        // TODO - remove support for legacy loaders
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$normalize$2d$loader$2e$js__$5b$client$5d$__$28$ecmascript$29$__["normalizeLoader"])(loaders);
    }
    // Build list of candidate loaders that will be searched in order for a match
    let candidateLoaders = [];
    // First search supplied loaders
    if (loaders) {
        candidateLoaders = candidateLoaders.concat(loaders);
    }
    // Then fall back to registered loaders
    if (!options?.ignoreRegisteredLoaders) {
        candidateLoaders.push(...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$api$2f$register$2d$loaders$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getRegisteredLoaders"])());
    }
    // TODO - remove support for legacy loaders
    normalizeLoaders(candidateLoaders);
    const loader = selectLoaderInternal(data, candidateLoaders, options, context);
    // no loader available
    if (!loader && !options?.nothrow) {
        throw new Error(getNoValidLoaderMessage(data));
    }
    return loader;
}
/** Implements loaders selection logic */ // eslint-disable-next-line complexity
function selectLoaderInternal(data, loaders, options, context) {
    const url = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$resource$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getResourceUrl"])(data);
    const type = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$resource$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getResourceMIMEType"])(data);
    const testUrl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$url$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["stripQueryString"])(url) || context?.url;
    let loader = null;
    let reason = '';
    // if options.mimeType is supplied, it takes precedence
    if (options?.mimeType) {
        loader = findLoaderByMIMEType(loaders, options?.mimeType);
        reason = `match forced by supplied MIME type ${options?.mimeType}`;
    }
    // Look up loader by url
    loader = loader || findLoaderByUrl(loaders, testUrl);
    reason = reason || (loader ? `matched url ${testUrl}` : '');
    // Look up loader by mime type
    loader = loader || findLoaderByMIMEType(loaders, type);
    reason = reason || (loader ? `matched MIME type ${type}` : '');
    // Look for loader via initial bytes (Note: not always accessible (e.g. Response, stream, async iterator)
    // @ts-ignore Blob | Response
    loader = loader || findLoaderByInitialBytes(loaders, data);
    // @ts-ignore Blob | Response
    reason = reason || (loader ? `matched initial data ${getFirstCharacters(data)}` : '');
    // Look up loader by fallback mime type
    if (options?.fallbackMimeType) {
        loader = loader || findLoaderByMIMEType(loaders, options?.fallbackMimeType);
        reason = reason || (loader ? `matched fallback MIME type ${type}` : '');
    }
    if (reason) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$log$2d$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].log(1, `selectLoader selected ${loader?.name}: ${reason}.`);
    }
    return loader;
}
/** Check HTTP Response */ function validHTTPResponse(data) {
    // HANDLE HTTP status
    if (data instanceof Response) {
        // 204 - NO CONTENT. This handles cases where e.g. a tile server responds with 204 for a missing tile
        if (data.status === 204) {
            return false;
        }
    }
    return true;
}
/** Generate a helpful message to help explain why loader selection failed. */ function getNoValidLoaderMessage(data) {
    const url = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$resource$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getResourceUrl"])(data);
    const type = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$resource$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getResourceMIMEType"])(data);
    let message = 'No valid loader found (';
    message += url ? `${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$path$2d$utils$2f$path$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__path$3e$__["path"].filename(url)}, ` : 'no url provided, ';
    message += `MIME type: ${type ? `"${type}"` : 'not provided'}, `;
    // First characters are only accessible when called on data (string or arrayBuffer).
    // @ts-ignore Blob | Response
    const firstCharacters = data ? getFirstCharacters(data) : '';
    message += firstCharacters ? ` first bytes: "${firstCharacters}"` : 'first bytes: not available';
    message += ')';
    return message;
}
function normalizeLoaders(loaders) {
    for (const loader of loaders){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$normalize$2d$loader$2e$js__$5b$client$5d$__$28$ecmascript$29$__["normalizeLoader"])(loader);
    }
}
// TODO - Would be nice to support http://example.com/file.glb?parameter=1
// E.g: x = new URL('http://example.com/file.glb?load=1'; x.pathname
function findLoaderByUrl(loaders, url) {
    // Get extension
    const match = url && EXT_PATTERN.exec(url);
    const extension = match && match[1];
    return extension ? findLoaderByExtension(loaders, extension) : null;
}
function findLoaderByExtension(loaders, extension) {
    extension = extension.toLowerCase();
    for (const loader of loaders){
        for (const loaderExtension of loader.extensions){
            if (loaderExtension.toLowerCase() === extension) {
                return loader;
            }
        }
    }
    return null;
}
function findLoaderByMIMEType(loaders, mimeType) {
    for (const loader of loaders){
        if (loader.mimeTypes?.some((mimeType1)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$mime$2d$type$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["compareMIMETypes"])(mimeType, mimeType1))) {
            return loader;
        }
        // Support referring to loaders using the "unregistered tree"
        // https://en.wikipedia.org/wiki/Media_type#Unregistered_tree
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$mime$2d$type$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["compareMIMETypes"])(mimeType, `application/x.${loader.id}`)) {
            return loader;
        }
    }
    return null;
}
function findLoaderByInitialBytes(loaders, data) {
    if (!data) {
        return null;
    }
    for (const loader of loaders){
        if (typeof data === 'string') {
            if (testDataAgainstText(data, loader)) {
                return loader;
            }
        } else if (ArrayBuffer.isView(data)) {
            // Typed Arrays can have offsets into underlying buffer
            if (testDataAgainstBinary(data.buffer, data.byteOffset, loader)) {
                return loader;
            }
        } else if (data instanceof ArrayBuffer) {
            const byteOffset = 0;
            if (testDataAgainstBinary(data, byteOffset, loader)) {
                return loader;
            }
        }
    // TODO Handle streaming case (requires creating a new AsyncIterator)
    }
    return null;
}
function testDataAgainstText(data, loader) {
    if (loader.testText) {
        return loader.testText(data);
    }
    const tests = Array.isArray(loader.tests) ? loader.tests : [
        loader.tests
    ];
    return tests.some((test)=>data.startsWith(test));
}
function testDataAgainstBinary(data, byteOffset, loader) {
    const tests = Array.isArray(loader.tests) ? loader.tests : [
        loader.tests
    ];
    return tests.some((test)=>testBinary(data, byteOffset, loader, test));
}
function testBinary(data, byteOffset, loader, test) {
    if (test instanceof ArrayBuffer) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$binary$2d$utils$2f$array$2d$buffer$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["compareArrayBuffers"])(test, data, test.byteLength);
    }
    switch(typeof test){
        case 'function':
            return test(data);
        case 'string':
            // Magic bytes check: If `test` is a string, check if binary data starts with that strings
            const magic = getMagicString(data, byteOffset, test.length);
            return test === magic;
        default:
            return false;
    }
}
function getFirstCharacters(data, length = 5) {
    if (typeof data === 'string') {
        return data.slice(0, length);
    } else if (ArrayBuffer.isView(data)) {
        // Typed Arrays can have offsets into underlying buffer
        return getMagicString(data.buffer, data.byteOffset, length);
    } else if (data instanceof ArrayBuffer) {
        const byteOffset = 0;
        return getMagicString(data, byteOffset, length);
    }
    return '';
}
function getMagicString(arrayBuffer, byteOffset, length) {
    if (arrayBuffer.byteLength < byteOffset + length) {
        return '';
    }
    const dataView = new DataView(arrayBuffer);
    let magic = '';
    for(let i = 0; i < length; i++){
        magic += String.fromCharCode(dataView.getUint8(byteOffset + i));
    }
    return magic;
}
}}),
"[project]/node_modules/@loaders.gl/core/dist/lib/api/parse.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "parse": (()=>parse)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$worker$2d$loader$2d$utils$2f$parse$2d$with$2d$worker$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/worker-loader-utils/parse-with-worker.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$option$2d$utils$2f$merge$2d$loader$2d$options$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/option-utils/merge-loader-options.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/assert.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$api$2f$validate$2d$worker$2d$version$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/worker-api/validate-worker-version.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$normalize$2d$loader$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/normalize-loader.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$option$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/option-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$get$2d$data$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/get-data.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$loader$2d$context$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/loader-context.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$resource$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/utils/resource-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$api$2f$select$2d$loader$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/api/select-loader.js [client] (ecmascript)");
;
;
;
;
;
;
;
;
;
async function parse(data, loaders, options, context) {
    // Signature: parse(data, options, context | url)
    // Uses registered loaders
    if (loaders && !Array.isArray(loaders) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$normalize$2d$loader$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isLoaderObject"])(loaders)) {
        context = undefined; // context not supported in short signature
        options = loaders;
        loaders = undefined;
    }
    data = await data; // Resolve any promise
    options = options || {}; // Could be invalid...
    // Extract a url for auto detection
    const url = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$resource$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getResourceUrl"])(data);
    // Chooses a loader (and normalizes it)
    // Also use any loaders in the context, new loaders take priority
    const typedLoaders = loaders;
    const candidateLoaders = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$loader$2d$context$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getLoadersFromContext"])(typedLoaders, context);
    // todo hacky type cast
    const loader = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$api$2f$select$2d$loader$2e$js__$5b$client$5d$__$28$ecmascript$29$__["selectLoader"])(data, candidateLoaders, options);
    // Note: if no loader was found, if so just return null
    if (!loader) {
        return null;
    }
    // Normalize options
    // @ts-expect-error
    options = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$option$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["normalizeOptions"])(options, loader, candidateLoaders, url); // Could be invalid...
    // Get a context (if already present, will be unchanged)
    context = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$loader$2d$context$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getLoaderContext"])(// @ts-expect-error
    {
        url,
        _parse: parse,
        loaders: candidateLoaders
    }, options, context || null);
    return await parseWithLoader(loader, data, options, context);
}
// TODO: support progress and abort
// TODO - should accept loader.parseAsyncIterator and concatenate.
async function parseWithLoader(loader, data, options, context) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$api$2f$validate$2d$worker$2d$version$2e$js__$5b$client$5d$__$28$ecmascript$29$__["validateWorkerVersion"])(loader);
    options = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$option$2d$utils$2f$merge$2d$loader$2d$options$2e$js__$5b$client$5d$__$28$ecmascript$29$__["mergeLoaderOptions"])(loader.options, options);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isResponse"])(data)) {
        // Serialize to support passing the response to web worker
        const response = data;
        const { ok, redirected, status, statusText, type, url } = response;
        const headers = Object.fromEntries(response.headers.entries());
        // @ts-expect-error TODO - fix this
        context.response = {
            headers,
            ok,
            redirected,
            status,
            statusText,
            type,
            url
        };
    }
    data = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$get$2d$data$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getArrayBufferOrStringFromData"])(data, loader, options);
    const loaderWithParser = loader;
    // First check for synchronous text parser, wrap results in promises
    if (loaderWithParser.parseTextSync && typeof data === 'string') {
        return loaderWithParser.parseTextSync(data, options, context);
    }
    // If we have a workerUrl and the loader can parse the given options efficiently in a worker
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$worker$2d$loader$2d$utils$2f$parse$2d$with$2d$worker$2e$js__$5b$client$5d$__$28$ecmascript$29$__["canParseWithWorker"])(loader, options)) {
        return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$worker$2d$loader$2d$utils$2f$parse$2d$with$2d$worker$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseWithWorker"])(loader, data, options, context, parse);
    }
    // Check for asynchronous parser
    if (loaderWithParser.parseText && typeof data === 'string') {
        return await loaderWithParser.parseText(data, options, context);
    }
    if (loaderWithParser.parse) {
        return await loaderWithParser.parse(data, options, context);
    }
    // This should not happen, all sync loaders should also offer `parse` function
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(!loaderWithParser.parseSync);
    // TBD - If asynchronous parser not available, return null
    throw new Error(`${loader.id} loader - no parser found and worker is disabled`);
}
}}),
"[project]/node_modules/@loaders.gl/core/dist/lib/api/load.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "load": (()=>load)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$normalize$2d$loader$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/normalize-loader.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$get$2d$fetch$2d$function$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/get-fetch-function.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$api$2f$parse$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/api/parse.js [client] (ecmascript)");
;
;
;
;
async function load(url, loaders, options, context) {
    let resolvedLoaders;
    let resolvedOptions;
    // Signature: load(url, options)
    if (!Array.isArray(loaders) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$normalize$2d$loader$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isLoaderObject"])(loaders)) {
        resolvedLoaders = [];
        resolvedOptions = loaders;
        context = undefined; // context not supported in short signature
    } else {
        resolvedLoaders = loaders;
        resolvedOptions = options;
    }
    // Select fetch function
    const fetch = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$get$2d$fetch$2d$function$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getFetchFunction"])(resolvedOptions);
    // at this point, `url` could be already loaded binary data
    let data = url;
    // url is a string, fetch the url
    if (typeof url === 'string') {
        data = await fetch(url);
    // URL is Blob or File, fetchFile handles it (alt: we could generate ObjectURL here)
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBlob"])(url)) {
        // The fetch response object will contain blob.name
        // @ts-expect-error TODO - This may not work for overridden fetch functions
        data = await fetch(url);
    }
    // Data is loaded (at least we have a `Response` object) so time to hand over to `parse`
    // return await parse(data, loaders as Loader[], options);
    return Array.isArray(resolvedLoaders) ? await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$api$2f$parse$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parse"])(data, resolvedLoaders, resolvedOptions) // loader array overload
     : await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$api$2f$parse$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parse"])(data, resolvedLoaders, resolvedOptions); // single loader overload
}
}}),
"[project]/node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/assert.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Throws an `Error` with the optional `message` if `condition` is falsy
 * @note Replacement for the external assert method to reduce bundle size
 */ __turbopack_context__.s({
    "assert": (()=>assert)
});
function assert(condition, message) {
    if (!condition) {
        throw new Error(message || 'loader assertion failed.');
    }
}
}}),
"[project]/node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/file-aliases.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Simple file alias mechanisms for tests.
__turbopack_context__.s({
    "addAliases": (()=>addAliases),
    "getPathPrefix": (()=>getPathPrefix),
    "resolvePath": (()=>resolvePath),
    "setPathPrefix": (()=>setPathPrefix)
});
let pathPrefix = '';
const fileAliases = {};
function setPathPrefix(prefix) {
    pathPrefix = prefix;
}
function getPathPrefix() {
    return pathPrefix;
}
function addAliases(aliases) {
    Object.assign(fileAliases, aliases);
}
function resolvePath(filename) {
    for(const alias in fileAliases){
        if (filename.startsWith(alias)) {
            const replacement = fileAliases[alias];
            filename = filename.replace(alias, replacement);
        }
    }
    if (!filename.startsWith('http://') && !filename.startsWith('https://')) {
        filename = `${pathPrefix}${filename}`;
    }
    return filename;
}
}}),
"[project]/node_modules/@loaders.gl/loader-utils/dist/lib/log-utils/log.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "VERSION": (()=>VERSION),
    "log": (()=>log)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/log/dist/log.js [client] (ecmascript)");
;
const VERSION = typeof "4.3.2" !== 'undefined' ? "4.3.2" : 'latest';
const version = VERSION[0] >= '0' && VERSION[0] <= '9' ? `v${VERSION}` : '';
// Make sure we set the global variable
function createLog() {
    const log = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Log"]({
        id: 'loaders.gl'
    });
    globalThis.loaders = globalThis.loaders || {};
    globalThis.loaders.log = log;
    globalThis.loaders.version = version;
    globalThis.probe = globalThis.probe || {};
    globalThis.probe.loaders = log;
    return log;
}
const log = createLog();
}}),
"[project]/node_modules/@loaders.gl/loader-utils/dist/lib/module-utils/js-module-utils.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "checkJSModule": (()=>checkJSModule),
    "getJSModule": (()=>getJSModule),
    "getJSModuleOrNull": (()=>getJSModuleOrNull),
    "registerJSModules": (()=>registerJSModules)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$log$2d$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/log-utils/log.js [client] (ecmascript)");
;
function registerJSModules(modules) {
    globalThis.loaders ||= {};
    globalThis.loaders.modules ||= {};
    Object.assign(globalThis.loaders.modules, modules);
}
function checkJSModule(name, caller) {
    const module = globalThis.loaders?.modules?.[name];
    if (!module) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$log$2d$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].warn(`${caller}: ${name} library not installed`)();
    }
}
function getJSModule(name, caller) {
    const module = globalThis.loaders?.modules?.[name];
    if (!module) {
        throw new Error(`${caller}: ${name} library not installed`);
    }
    return module;
}
function getJSModuleOrNull(name) {
    const module = globalThis.loaders?.modules?.[name];
    return module || null;
}
}}),
"[project]/node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/globals.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Purpose: include this in your module to avoid
// dependencies on micro modules like 'global' and 'is-browser';
/* eslint-disable no-restricted-globals */ __turbopack_context__.s({
    "document": (()=>document_),
    "global": (()=>global_),
    "isBrowser": (()=>isBrowser),
    "isWorker": (()=>isWorker),
    "nodeVersion": (()=>nodeVersion),
    "self": (()=>self_),
    "window": (()=>window_)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
const globals = {
    self: typeof self !== 'undefined' && self,
    window: typeof window !== 'undefined' && window,
    global: typeof global !== 'undefined' && global,
    document: typeof document !== 'undefined' && document
};
const self_ = globals.self || globals.window || globals.global || {};
const window_ = globals.window || globals.self || globals.global || {};
const global_ = globals.global || globals.self || globals.window || {};
const document_ = globals.document || {};
;
const isBrowser = // @ts-ignore process does not exist on browser
Boolean(typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"] !== 'object' || String(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"]) !== '[object process]' || ("TURBOPACK compile-time value", true));
const isWorker = typeof importScripts === 'function';
// Extract node major version
const matches = typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"] !== 'undefined' && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].version && /v([0-9]*)/.exec(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].version);
const nodeVersion = matches && parseFloat(matches[1]) || 0;
}}),
"[project]/node_modules/@loaders.gl/loader-utils/dist/lib/worker-loader-utils/parse-with-worker.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "canParseWithWorker": (()=>canParseWithWorker),
    "parseWithWorker": (()=>parseWithWorker)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/globals.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$farm$2f$worker$2d$farm$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__WorkerFarm$3e$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-farm.js [client] (ecmascript) <export default as WorkerFarm>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$api$2f$get$2d$worker$2d$url$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/worker-api/get-worker-url.js [client] (ecmascript)");
;
function canParseWithWorker(loader, options) {
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$farm$2f$worker$2d$farm$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__WorkerFarm$3e$__["WorkerFarm"].isSupported()) {
        return false;
    }
    // Node workers are still experimental
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBrowser"] && !options?._nodeWorkers) {
        return false;
    }
    return loader.worker && options?.worker;
}
async function parseWithWorker(loader, data, options, context, parseOnMainThread) {
    const name = loader.id; // TODO
    const url = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$api$2f$get$2d$worker$2d$url$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getWorkerURL"])(loader, options);
    const workerFarm = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$farm$2f$worker$2d$farm$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__WorkerFarm$3e$__["WorkerFarm"].getWorkerFarm(options);
    const workerPool = workerFarm.getWorkerPool({
        name,
        url
    });
    // options.log object contains functions which cannot be transferred
    // context.fetch & context.parse functions cannot be transferred
    // TODO - decide how to handle logging on workers
    options = JSON.parse(JSON.stringify(options));
    context = JSON.parse(JSON.stringify(context || {}));
    const job = await workerPool.startJob('process-on-worker', // @ts-expect-error
    onMessage.bind(null, parseOnMainThread) // eslint-disable-line @typescript-eslint/no-misused-promises
    );
    job.postMessage('process', {
        // @ts-ignore
        input: data,
        options,
        context
    });
    const result = await job.result;
    // TODO - what is going on here?
    return await result.result;
}
/**
 * Handle worker's responses to the main thread
 * @param job
 * @param type
 * @param payload
 */ async function onMessage(parseOnMainThread, job, type, payload) {
    switch(type){
        case 'done':
            job.done(payload);
            break;
        case 'error':
            job.error(new Error(payload.error));
            break;
        case 'process':
            // Worker is asking for main thread to parseO
            const { id, input, options } = payload;
            try {
                const result = await parseOnMainThread(input, options);
                job.postMessage('done', {
                    id,
                    result
                });
            } catch (error) {
                const message = error instanceof Error ? error.message : 'unknown error';
                job.postMessage('error', {
                    id,
                    error: message
                });
            }
            break;
        default:
            // eslint-disable-next-line
            console.warn(`parse-with-worker unknown message ${type}`);
    }
}
}}),
"[project]/node_modules/@loaders.gl/loader-utils/dist/lib/option-utils/merge-loader-options.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/**
 *
 * @param baseOptions Can be undefined, in which case a fresh options object will be minted
 * @param newOptions
 * @returns
 */ __turbopack_context__.s({
    "mergeLoaderOptions": (()=>mergeLoaderOptions)
});
function mergeLoaderOptions(baseOptions, newOptions) {
    return mergeOptionsRecursively(baseOptions || {}, newOptions);
}
function mergeOptionsRecursively(baseOptions, newOptions, level = 0) {
    // Sanity check (jest test runner overwrites the console object which can lead to infinite recursion)
    if (level > 3) {
        return newOptions;
    }
    const options = {
        ...baseOptions
    };
    for (const [key, newValue] of Object.entries(newOptions)){
        if (newValue && typeof newValue === 'object' && !Array.isArray(newValue)) {
            options[key] = mergeOptionsRecursively(options[key] || {}, newOptions[key], level + 1);
        // Object.assign(options[key] as object, newOptions[key]);
        } else {
            options[key] = newOptions[key];
        }
    }
    return options;
}
}}),
"[project]/node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/array-buffer-utils.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * compare two binary arrays for equality
 * @param a
 * @param b
 * @param byteLength
 */ __turbopack_context__.s({
    "compareArrayBuffers": (()=>compareArrayBuffers),
    "concatenateArrayBuffers": (()=>concatenateArrayBuffers),
    "concatenateArrayBuffersFromArray": (()=>concatenateArrayBuffersFromArray),
    "concatenateTypedArrays": (()=>concatenateTypedArrays),
    "sliceArrayBuffer": (()=>sliceArrayBuffer)
});
function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {
    byteLength = byteLength || arrayBuffer1.byteLength;
    if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {
        return false;
    }
    const array1 = new Uint8Array(arrayBuffer1);
    const array2 = new Uint8Array(arrayBuffer2);
    for(let i = 0; i < array1.length; ++i){
        if (array1[i] !== array2[i]) {
            return false;
        }
    }
    return true;
}
function concatenateArrayBuffers(...sources) {
    return concatenateArrayBuffersFromArray(sources);
}
function concatenateArrayBuffersFromArray(sources) {
    // Make sure all inputs are wrapped in typed arrays
    const sourceArrays = sources.map((source2)=>source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2);
    // Get length of all inputs
    const byteLength = sourceArrays.reduce((length, typedArray)=>length + typedArray.byteLength, 0);
    // Allocate array with space for all inputs
    const result = new Uint8Array(byteLength);
    // Copy the subarrays
    let offset = 0;
    for (const sourceArray of sourceArrays){
        result.set(sourceArray, offset);
        offset += sourceArray.byteLength;
    }
    // We work with ArrayBuffers, discard the typed array wrapper
    return result.buffer;
}
function concatenateTypedArrays(...typedArrays) {
    // @ts-ignore
    const arrays = typedArrays;
    // @ts-ignore
    const TypedArrayConstructor = arrays && arrays.length > 1 && arrays[0].constructor || null;
    if (!TypedArrayConstructor) {
        throw new Error('"concatenateTypedArrays" - incorrect quantity of arguments or arguments have incompatible data types');
    }
    const sumLength = arrays.reduce((acc, value)=>acc + value.length, 0);
    // @ts-ignore typescript does not like dynamic constructors
    const result = new TypedArrayConstructor(sumLength);
    let offset = 0;
    for (const array of arrays){
        result.set(array, offset);
        offset += array.length;
    }
    return result;
}
function sliceArrayBuffer(arrayBuffer, byteOffset, byteLength) {
    const subArray = byteLength !== undefined ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength) : new Uint8Array(arrayBuffer).subarray(byteOffset);
    const arrayCopy = new Uint8Array(subArray);
    return arrayCopy.buffer;
}
}}),
"[project]/node_modules/@loaders.gl/loader-utils/dist/lib/iterators/async-iteration.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "concatenateArrayBuffersAsync": (()=>concatenateArrayBuffersAsync),
    "concatenateStringsAsync": (()=>concatenateStringsAsync),
    "forEach": (()=>forEach)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$binary$2d$utils$2f$array$2d$buffer$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/array-buffer-utils.js [client] (ecmascript)");
;
async function forEach(iterator, visitor) {
    // eslint-disable-next-line
    while(true){
        const { done, value } = await iterator.next();
        if (done) {
            iterator.return();
            return;
        }
        const cancel = visitor(value);
        if (cancel) {
            return;
        }
    }
}
async function concatenateArrayBuffersAsync(asyncIterator) {
    const arrayBuffers = [];
    for await (const chunk of asyncIterator){
        arrayBuffers.push(chunk);
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$binary$2d$utils$2f$array$2d$buffer$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["concatenateArrayBuffers"])(...arrayBuffers);
}
async function concatenateStringsAsync(asyncIterator) {
    const strings = [];
    for await (const chunk of asyncIterator){
        strings.push(chunk);
    }
    return strings.join('');
}
}}),
"[project]/node_modules/@loaders.gl/loader-utils/dist/lib/node/buffer.browser.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// Isolates Buffer references to ensure they are only bundled under Node.js (avoids big webpack polyfill)
// this file is selected by the package.json "browser" field).
/**
 * Convert Buffer to ArrayBuffer
 * Converts Node.js `Buffer` to `ArrayBuffer` (without triggering bundler to include Buffer polyfill on browser)
 * @todo better data type
 */ __turbopack_context__.s({
    "toArrayBuffer": (()=>toArrayBuffer),
    "toBuffer": (()=>toBuffer)
});
function toArrayBuffer(buffer) {
    return buffer;
}
function toBuffer(binaryData) {
    throw new Error('Buffer not supported in browser');
}
}}),
"[project]/node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/memory-conversion-utils.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "isBuffer": (()=>isBuffer),
    "toArrayBuffer": (()=>toArrayBuffer),
    "toBuffer": (()=>toBuffer)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$node$2f$buffer$2e$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/node/buffer.browser.js [client] (ecmascript)");
;
function isBuffer(value) {
    return value && typeof value === 'object' && value.isBuffer;
}
function toBuffer(data) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$node$2f$buffer$2e$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toBuffer"] ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$node$2f$buffer$2e$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toBuffer"])(data) : data;
}
function toArrayBuffer(data) {
    // Note: Should be called first, Buffers can trigger other detections below
    if (isBuffer(data)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$node$2f$buffer$2e$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toArrayBuffer"])(data);
    }
    if (data instanceof ArrayBuffer) {
        return data;
    }
    // Careful - Node Buffers look like Uint8Arrays (keep after isBuffer)
    if (ArrayBuffer.isView(data)) {
        if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {
            return data.buffer;
        }
        return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
    }
    if (typeof data === 'string') {
        const text = data;
        const uint8Array = new TextEncoder().encode(text);
        return uint8Array.buffer;
    }
    // HACK to support Blob polyfill
    if (data && typeof data === 'object' && data._toArrayBuffer) {
        return data._toArrayBuffer();
    }
    throw new Error('toArrayBuffer');
}
}}),
"[project]/node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/get-cwd.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl MIT license
__turbopack_context__.s({
    "getCWD": (()=>getCWD)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
function getCWD() {
    if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"] !== 'undefined' && typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].cwd !== 'undefined') {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].cwd();
    }
    const pathname = window.location?.pathname;
    return pathname?.slice(0, pathname.lastIndexOf('/') + 1) || '';
}
}}),
"[project]/node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/path.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Beginning of a minimal implementation of the Node.js path API, that doesn't pull in big polyfills.
__turbopack_context__.s({
    "dirname": (()=>dirname),
    "filename": (()=>filename),
    "join": (()=>join),
    "resolve": (()=>resolve)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$path$2d$utils$2f$get$2d$cwd$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/get-cwd.js [client] (ecmascript)");
;
function filename(url) {
    const slashIndex = url ? url.lastIndexOf('/') : -1;
    return slashIndex >= 0 ? url.substr(slashIndex + 1) : '';
}
function dirname(url) {
    const slashIndex = url ? url.lastIndexOf('/') : -1;
    return slashIndex >= 0 ? url.substr(0, slashIndex) : '';
}
function join(...parts) {
    const separator = '/';
    parts = parts.map((part, index)=>{
        if (index) {
            part = part.replace(new RegExp(`^${separator}`), '');
        }
        if (index !== parts.length - 1) {
            part = part.replace(new RegExp(`${separator}$`), '');
        }
        return part;
    });
    return parts.join(separator);
}
function resolve(...components) {
    const paths = [];
    for(let _i = 0; _i < components.length; _i++){
        paths[_i] = components[_i];
    }
    let resolvedPath = '';
    let resolvedAbsolute = false;
    let cwd;
    for(let i = paths.length - 1; i >= -1 && !resolvedAbsolute; i--){
        let path;
        if (i >= 0) {
            path = paths[i];
        } else {
            if (cwd === undefined) {
                cwd = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$path$2d$utils$2f$get$2d$cwd$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getCWD"])();
            }
            path = cwd;
        }
        // Skip empty entries
        if (path.length === 0) {
            continue;
        }
        resolvedPath = `${path}/${resolvedPath}`;
        resolvedAbsolute = path.charCodeAt(0) === SLASH;
    }
    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)
    // Normalize the path (removes leading slash)
    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
    if (resolvedAbsolute) {
        return `/${resolvedPath}`;
    } else if (resolvedPath.length > 0) {
        return resolvedPath;
    }
    return '.';
}
const SLASH = 47;
const DOT = 46;
/**
 * Resolves . and .. elements in a path with directory names
 * Forked from BTOdell/path-resolve under MIT license
 * @see https://github.com/BTOdell/path-resolve/blob/master/LICENSE
 */ /* eslint-disable max-depth */ // eslint-disable-next-line complexity, max-statements
function normalizeStringPosix(path, allowAboveRoot) {
    let res = '';
    let lastSlash = -1;
    let dots = 0;
    let code;
    let isAboveRoot = false;
    for(let i = 0; i <= path.length; ++i){
        if (i < path.length) {
            code = path.charCodeAt(i);
        } else if (code === SLASH) {
            break;
        } else {
            code = SLASH;
        }
        if (code === SLASH) {
            if (lastSlash === i - 1 || dots === 1) {
            // NOOP
            } else if (lastSlash !== i - 1 && dots === 2) {
                if (res.length < 2 || !isAboveRoot || res.charCodeAt(res.length - 1) !== DOT || res.charCodeAt(res.length - 2) !== DOT) {
                    if (res.length > 2) {
                        const start = res.length - 1;
                        let j = start;
                        for(; j >= 0; --j){
                            if (res.charCodeAt(j) === SLASH) {
                                break;
                            }
                        }
                        if (j !== start) {
                            res = j === -1 ? '' : res.slice(0, j);
                            lastSlash = i;
                            dots = 0;
                            isAboveRoot = false;
                            continue;
                        }
                    } else if (res.length === 2 || res.length === 1) {
                        res = '';
                        lastSlash = i;
                        dots = 0;
                        isAboveRoot = false;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) {
                        res += '/..';
                    } else {
                        res = '..';
                    }
                    isAboveRoot = true;
                }
            } else {
                const slice = path.slice(lastSlash + 1, i);
                if (res.length > 0) {
                    res += `/${slice}`;
                } else {
                    res = slice;
                }
                isAboveRoot = false;
            }
            lastSlash = i;
            dots = 0;
        } else if (code === DOT && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
}}),
"[project]/node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/path.js [client] (ecmascript) <export * as path>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "path": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$path$2d$utils$2f$path$2e$js__$5b$client$5d$__$28$ecmascript$29$__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$path$2d$utils$2f$path$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/path.js [client] (ecmascript)");
}}),
"[project]/node_modules/@loaders.gl/loader-utils/dist/lib/request-utils/request-scheduler.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>RequestScheduler)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/stats/dist/index.js [client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$lib$2f$stats$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Stats$3e$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/stats/dist/lib/stats.js [client] (ecmascript) <export default as Stats>");
;
const STAT_QUEUED_REQUESTS = 'Queued Requests';
const STAT_ACTIVE_REQUESTS = 'Active Requests';
const STAT_CANCELLED_REQUESTS = 'Cancelled Requests';
const STAT_QUEUED_REQUESTS_EVER = 'Queued Requests Ever';
const STAT_ACTIVE_REQUESTS_EVER = 'Active Requests Ever';
const DEFAULT_PROPS = {
    id: 'request-scheduler',
    /** Specifies if the request scheduler should throttle incoming requests, mainly for comparative testing. */ throttleRequests: true,
    /** The maximum number of simultaneous active requests. Un-throttled requests do not observe this limit. */ maxRequests: 6,
    /**
     * Specifies a debounce time, in milliseconds. All requests are queued, until no new requests have
     * been added to the queue for this amount of time.
     */ debounceTime: 0
};
class RequestScheduler {
    props;
    stats;
    activeRequestCount = 0;
    /** Tracks the number of active requests and prioritizes/cancels queued requests. */ requestQueue = [];
    requestMap = new Map();
    updateTimer = null;
    constructor(props = {}){
        this.props = {
            ...DEFAULT_PROPS,
            ...props
        };
        // Returns the statistics used by the request scheduler.
        this.stats = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$lib$2f$stats$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Stats$3e$__["Stats"]({
            id: this.props.id
        });
        this.stats.get(STAT_QUEUED_REQUESTS);
        this.stats.get(STAT_ACTIVE_REQUESTS);
        this.stats.get(STAT_CANCELLED_REQUESTS);
        this.stats.get(STAT_QUEUED_REQUESTS_EVER);
        this.stats.get(STAT_ACTIVE_REQUESTS_EVER);
    }
    /**
     * Called by an application that wants to issue a request, without having it deeply queued by the browser
     *
     * When the returned promise resolved, it is OK for the application to issue a request.
     * The promise resolves to an object that contains a `done` method.
     * When the application's request has completed (or failed), the application must call the `done` function
     *
     * @param handle
     * @param getPriority will be called when request "slots" open up,
     *    allowing the caller to update priority or cancel the request
     *    Highest priority executes first, priority < 0 cancels the request
     * @returns a promise
     *   - resolves to a object (with a `done` field) when the request can be issued without queueing,
     *   - resolves to `null` if the request has been cancelled (by the callback return < 0).
     *     In this case the application should not issue the request
     */ scheduleRequest(handle, getPriority = ()=>0) {
        // Allows throttling to be disabled
        if (!this.props.throttleRequests) {
            return Promise.resolve({
                done: ()=>{}
            });
        }
        // dedupe
        if (this.requestMap.has(handle)) {
            return this.requestMap.get(handle);
        }
        const request = {
            handle,
            priority: 0,
            getPriority
        };
        const promise = new Promise((resolve)=>{
            // @ts-ignore
            request.resolve = resolve;
            return request;
        });
        this.requestQueue.push(request);
        this.requestMap.set(handle, promise);
        this._issueNewRequests();
        return promise;
    }
    // PRIVATE
    _issueRequest(request) {
        const { handle, resolve } = request;
        let isDone = false;
        const done = ()=>{
            // can only be called once
            if (!isDone) {
                isDone = true;
                // Stop tracking a request - it has completed, failed, cancelled etc
                this.requestMap.delete(handle);
                this.activeRequestCount--;
                // A slot just freed up, see if any queued requests are waiting
                this._issueNewRequests();
            }
        };
        // Track this request
        this.activeRequestCount++;
        return resolve ? resolve({
            done
        }) : Promise.resolve({
            done
        });
    }
    /** We check requests asynchronously, to prevent multiple updates */ _issueNewRequests() {
        if (this.updateTimer !== null) {
            clearTimeout(this.updateTimer);
        }
        this.updateTimer = setTimeout(()=>this._issueNewRequestsAsync(), this.props.debounceTime);
    }
    /** Refresh all requests  */ _issueNewRequestsAsync() {
        if (this.updateTimer !== null) {
            clearTimeout(this.updateTimer);
        }
        this.updateTimer = null;
        const freeSlots = Math.max(this.props.maxRequests - this.activeRequestCount, 0);
        if (freeSlots === 0) {
            return;
        }
        this._updateAllRequests();
        // Resolve pending promises for the top-priority requests
        for(let i = 0; i < freeSlots; ++i){
            const request = this.requestQueue.shift();
            if (request) {
                this._issueRequest(request); // eslint-disable-line @typescript-eslint/no-floating-promises
            }
        }
    // Uncomment to debug
    // console.log(`${freeSlots} free slots, ${this.requestQueue.length} queued requests`);
    }
    /** Ensure all requests have updated priorities, and that no longer valid requests are cancelled */ _updateAllRequests() {
        const requestQueue = this.requestQueue;
        for(let i = 0; i < requestQueue.length; ++i){
            const request = requestQueue[i];
            if (!this._updateRequest(request)) {
                // Remove the element and make sure to adjust the counter to account for shortened array
                requestQueue.splice(i, 1);
                this.requestMap.delete(request.handle);
                i--;
            }
        }
        // Sort the remaining requests based on priority
        requestQueue.sort((a, b)=>a.priority - b.priority);
    }
    /** Update a single request by calling the callback */ _updateRequest(request) {
        request.priority = request.getPriority(request.handle); // eslint-disable-line callback-return
        // by returning a negative priority, the callback cancels the request
        if (request.priority < 0) {
            request.resolve(null);
            return false;
        }
        return true;
    }
}
}}),
"[project]/node_modules/@loaders.gl/loader-utils/dist/lib/request-utils/request-scheduler.js [client] (ecmascript) <export default as RequestScheduler>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "RequestScheduler": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$request$2d$utils$2f$request$2d$scheduler$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$request$2d$utils$2f$request$2d$scheduler$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/request-utils/request-scheduler.js [client] (ecmascript)");
}}),
"[project]/node_modules/@loaders.gl/loader-utils/dist/lib/node/promisify.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// @loaders.gl, MIT license
/**
 * Typesafe promisify implementation
 * @link https://dev.to/_gdelgado/implement-a-type-safe-version-of-node-s-promisify-in-7-lines-of-code-in-typescript-2j34
 * @param fn
 * @returns
 */ __turbopack_context__.s({
    "promisify1": (()=>promisify1),
    "promisify2": (()=>promisify2),
    "promisify3": (()=>promisify3)
});
function promisify1(fn) {
    return (args)=>new Promise((resolve, reject)=>fn(args, (error, callbackArgs)=>error ? reject(error) : resolve(callbackArgs)));
}
function promisify2(fn) {
    return (arg1, arg2)=>new Promise((resolve, reject)=>fn(arg1, arg2, (error, callbackArgs)=>error ? reject(error) : resolve(callbackArgs)));
}
function promisify3(fn) {
    return (arg1, arg2, arg3)=>new Promise((resolve, reject)=>fn(arg1, arg2, arg3, (error, callbackArgs)=>error ? reject(error) : resolve(callbackArgs)));
}
}}),
"[project]/node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/globals.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// Purpose: include this in your module to avoids adding dependencies on
// micro modules like 'global' and 'is-browser';
/* eslint-disable no-restricted-globals */ __turbopack_context__.s({
    "document": (()=>document_),
    "global": (()=>global_),
    "isBrowser": (()=>isBrowser),
    "isMobile": (()=>isMobile),
    "isWorker": (()=>isWorker),
    "nodeVersion": (()=>nodeVersion),
    "self": (()=>self_),
    "window": (()=>window_)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
const globals = {
    self: typeof self !== 'undefined' && self,
    window: typeof window !== 'undefined' && window,
    global: typeof global !== 'undefined' && global,
    document: typeof document !== 'undefined' && document
};
const self_ = globals.self || globals.window || globals.global || {};
const window_ = globals.window || globals.self || globals.global || {};
const global_ = globals.global || globals.self || globals.window || {};
const document_ = globals.document || {};
;
const isBrowser = // @ts-ignore process.browser
typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"] !== 'object' || String(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"]) !== '[object process]' || ("TURBOPACK compile-time value", true);
const isWorker = typeof importScripts === 'function';
const isMobile = typeof window !== 'undefined' && typeof window.orientation !== 'undefined';
// Extract node major version
const matches = typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"] !== 'undefined' && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].version && /v([0-9]*)/.exec(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].version);
const nodeVersion = matches && parseFloat(matches[1]) || 0;
}}),
"[project]/node_modules/@loaders.gl/worker-utils/dist/lib/node/worker_threads-browser.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/** Browser polyfill for Node.js built-in `worker_threads` module.
 * These fills are non-functional, and just intended to ensure that
 * `import 'worker_threads` doesn't break browser builds.
 * The replacement is done in package.json browser field
 */ __turbopack_context__.s({
    "NodeWorker": (()=>NodeWorker),
    "parentPort": (()=>parentPort)
});
class NodeWorker {
    terminate() {}
}
const parentPort = null;
}}),
"[project]/node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/assert.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// Replacement for the external assert method to reduce bundle size
// Note: We don't use the second "message" argument in calling code,
// so no need to support it here
/** Throws an `Error` with the optional `message` if `condition` is falsy */ __turbopack_context__.s({
    "assert": (()=>assert)
});
function assert(condition, message) {
    if (!condition) {
        throw new Error(message || 'loaders.gl assertion failed.');
    }
}
}}),
"[project]/node_modules/@loaders.gl/worker-utils/dist/lib/worker-utils/get-loadable-worker-url.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "getLoadableWorkerURL": (()=>getLoadableWorkerURL)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/assert.js [client] (ecmascript)");
;
const workerURLCache = new Map();
function getLoadableWorkerURL(props) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(props.source && !props.url || !props.source && props.url); // Either source or url must be defined
    let workerURL = workerURLCache.get(props.source || props.url);
    if (!workerURL) {
        // Differentiate worker urls from worker source code
        if (props.url) {
            workerURL = getLoadableWorkerURLFromURL(props.url);
            workerURLCache.set(props.url, workerURL);
        }
        if (props.source) {
            workerURL = getLoadableWorkerURLFromSource(props.source);
            workerURLCache.set(props.source, workerURL);
        }
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(workerURL);
    return workerURL;
}
/**
 * Build a loadable worker URL from worker URL
 * @param url
 * @returns loadable URL
 */ function getLoadableWorkerURLFromURL(url) {
    // A local script url, we can use it to initialize a Worker directly
    if (!url.startsWith('http')) {
        return url;
    }
    // A remote script, we need to use `importScripts` to load from different origin
    const workerSource = buildScriptSource(url);
    return getLoadableWorkerURLFromSource(workerSource);
}
/**
 * Build a loadable worker URL from worker source
 * @param workerSource
 * @returns loadable url
 */ function getLoadableWorkerURLFromSource(workerSource) {
    const blob = new Blob([
        workerSource
    ], {
        type: 'application/javascript'
    });
    return URL.createObjectURL(blob);
}
/**
 * Per spec, worker cannot be initialized with a script from a different origin
 * However a local worker script can still import scripts from other origins,
 * so we simply build a wrapper script.
 *
 * @param workerUrl
 * @returns source
 */ function buildScriptSource(workerUrl) {
    return `\
try {
  importScripts('${workerUrl}');
} catch (error) {
  console.error(error);
  throw error;
}`;
}
}}),
"[project]/node_modules/@loaders.gl/worker-utils/dist/lib/worker-utils/get-transfer-list.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// NOTE - there is a copy of this function is both in core and loader-utils
// core does not need all the utils in loader-utils, just this one.
/**
 * Returns an array of Transferrable objects that can be used with postMessage
 * https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage
 * @param object data to be sent via postMessage
 * @param recursive - not for application use
 * @param transfers - not for application use
 * @returns a transfer list that can be passed to postMessage
 */ __turbopack_context__.s({
    "getTransferList": (()=>getTransferList),
    "getTransferListForWriter": (()=>getTransferListForWriter)
});
function getTransferList(object, recursive = true, transfers) {
    // Make sure that items in the transfer list is unique
    const transfersSet = transfers || new Set();
    if (!object) {
    // ignore
    } else if (isTransferable(object)) {
        transfersSet.add(object);
    } else if (isTransferable(object.buffer)) {
        // Typed array
        transfersSet.add(object.buffer);
    } else if (ArrayBuffer.isView(object)) {
    // object is a TypeArray viewing into a SharedArrayBuffer (not transferable)
    // Do not iterate through the content in this case
    } else if (recursive && typeof object === 'object') {
        for(const key in object){
            // Avoid perf hit - only go one level deep
            getTransferList(object[key], recursive, transfersSet);
        }
    }
    // If transfers is defined, is internal recursive call
    // Otherwise it's called by the user
    return transfers === undefined ? Array.from(transfersSet) : [];
}
// https://developer.mozilla.org/en-US/docs/Web/API/Transferable
function isTransferable(object) {
    if (!object) {
        return false;
    }
    if (object instanceof ArrayBuffer) {
        return true;
    }
    if (typeof MessagePort !== 'undefined' && object instanceof MessagePort) {
        return true;
    }
    if (typeof ImageBitmap !== 'undefined' && object instanceof ImageBitmap) {
        return true;
    }
    // @ts-ignore
    if (typeof OffscreenCanvas !== 'undefined' && object instanceof OffscreenCanvas) {
        return true;
    }
    return false;
}
function getTransferListForWriter(object) {
    if (object === null) {
        return {};
    }
    const clone = Object.assign({}, object);
    Object.keys(clone).forEach((key)=>{
        // Typed Arrays and Arrays are passed with no change
        if (typeof object[key] === 'object' && !ArrayBuffer.isView(object[key]) && !(object[key] instanceof Array)) {
            clone[key] = getTransferListForWriter(object[key]);
        } else if (typeof clone[key] === 'function' || clone[key] instanceof RegExp) {
            clone[key] = {};
        } else {
            clone[key] = object[key];
        }
    });
    return clone;
}
}}),
"[project]/node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-thread.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "default": (()=>WorkerThread)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$node$2f$worker_threads$2d$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/node/worker_threads-browser.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/globals.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/assert.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$utils$2f$get$2d$loadable$2d$worker$2d$url$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/worker-utils/get-loadable-worker-url.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$utils$2f$get$2d$transfer$2d$list$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/worker-utils/get-transfer-list.js [client] (ecmascript)");
;
;
;
;
;
const NOOP = ()=>{};
class WorkerThread {
    name;
    source;
    url;
    terminated = false;
    worker;
    onMessage;
    onError;
    _loadableURL = '';
    /** Checks if workers are supported on this platform */ static isSupported() {
        return typeof Worker !== 'undefined' && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBrowser"] || typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$node$2f$worker_threads$2d$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__["NodeWorker"] !== 'undefined' && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBrowser"];
    }
    constructor(props){
        const { name, source, url } = props;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(source || url); // Either source or url must be defined
        this.name = name;
        this.source = source;
        this.url = url;
        this.onMessage = NOOP;
        this.onError = (error)=>console.log(error); // eslint-disable-line
        this.worker = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBrowser"] ? this._createBrowserWorker() : this._createNodeWorker();
    }
    /**
     * Terminate this worker thread
     * @note Can free up significant memory
     */ destroy() {
        this.onMessage = NOOP;
        this.onError = NOOP;
        this.worker.terminate(); // eslint-disable-line @typescript-eslint/no-floating-promises
        this.terminated = true;
    }
    get isRunning() {
        return Boolean(this.onMessage);
    }
    /**
     * Send a message to this worker thread
     * @param data any data structure, ideally consisting mostly of transferrable objects
     * @param transferList If not supplied, calculated automatically by traversing data
     */ postMessage(data, transferList) {
        transferList = transferList || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$utils$2f$get$2d$transfer$2d$list$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getTransferList"])(data);
        // @ts-ignore
        this.worker.postMessage(data, transferList);
    }
    // PRIVATE
    /**
     * Generate a standard Error from an ErrorEvent
     * @param event
     */ _getErrorFromErrorEvent(event) {
        // Note Error object does not have the expected fields if loading failed completely
        // https://developer.mozilla.org/en-US/docs/Web/API/Worker#Event_handlers
        // https://developer.mozilla.org/en-US/docs/Web/API/ErrorEvent
        let message = 'Failed to load ';
        message += `worker ${this.name} from ${this.url}. `;
        if (event.message) {
            message += `${event.message} in `;
        }
        // const hasFilename = event.filename && !event.filename.startsWith('blob:');
        // message += hasFilename ? event.filename : this.source.slice(0, 100);
        if (event.lineno) {
            message += `:${event.lineno}:${event.colno}`;
        }
        return new Error(message);
    }
    /**
     * Creates a worker thread on the browser
     */ _createBrowserWorker() {
        this._loadableURL = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$utils$2f$get$2d$loadable$2d$worker$2d$url$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getLoadableWorkerURL"])({
            source: this.source,
            url: this.url
        });
        const worker = new Worker(this._loadableURL, {
            name: this.name
        });
        worker.onmessage = (event)=>{
            if (!event.data) {
                this.onError(new Error('No data received'));
            } else {
                this.onMessage(event.data);
            }
        };
        // This callback represents an uncaught exception in the worker thread
        worker.onerror = (error)=>{
            this.onError(this._getErrorFromErrorEvent(error));
            this.terminated = true;
        };
        // TODO - not clear when this would be called, for now just log in case it happens
        worker.onmessageerror = (event)=>console.error(event); // eslint-disable-line
        return worker;
    }
    /**
     * Creates a worker thread in node.js
     * @todo https://nodejs.org/api/async_hooks.html#async-resource-worker-pool
     */ _createNodeWorker() {
        let worker;
        if (this.url) {
            // Make sure relative URLs start with './'
            const absolute = this.url.includes(':/') || this.url.startsWith('/');
            const url = absolute ? this.url : `./${this.url}`;
            // console.log('Starting work from', url);
            worker = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$node$2f$worker_threads$2d$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__["NodeWorker"](url, {
                eval: false
            });
        } else if (this.source) {
            worker = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$node$2f$worker_threads$2d$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__["NodeWorker"](this.source, {
                eval: true
            });
        } else {
            throw new Error('no worker');
        }
        worker.on('message', (data)=>{
            // console.error('message', data);
            this.onMessage(data);
        });
        worker.on('error', (error)=>{
            // console.error('error', error);
            this.onError(error);
        });
        worker.on('exit', (code)=>{
        // console.error('exit', code);
        });
        return worker;
    }
}
}}),
"[project]/node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-job.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "default": (()=>WorkerJob)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/assert.js [client] (ecmascript)");
;
class WorkerJob {
    name;
    workerThread;
    isRunning = true;
    /** Promise that resolves when Job is done */ result;
    _resolve = ()=>{};
    _reject = ()=>{};
    constructor(jobName, workerThread){
        this.name = jobName;
        this.workerThread = workerThread;
        this.result = new Promise((resolve, reject)=>{
            this._resolve = resolve;
            this._reject = reject;
        });
    }
    /**
     * Send a message to the job's worker thread
     * @param data any data structure, ideally consisting mostly of transferrable objects
     */ postMessage(type, payload) {
        this.workerThread.postMessage({
            source: 'loaders.gl',
            type,
            payload
        });
    }
    /**
     * Call to resolve the `result` Promise with the supplied value
     */ done(value) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(this.isRunning);
        this.isRunning = false;
        this._resolve(value);
    }
    /**
     * Call to reject the `result` Promise with the supplied error
     */ error(error) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(this.isRunning);
        this.isRunning = false;
        this._reject(error);
    }
}
}}),
"[project]/node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-pool.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "default": (()=>WorkerPool)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/globals.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$farm$2f$worker$2d$thread$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-thread.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$farm$2f$worker$2d$job$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-job.js [client] (ecmascript)");
;
;
;
class WorkerPool {
    name = 'unnamed';
    source;
    url;
    maxConcurrency = 1;
    maxMobileConcurrency = 1;
    onDebug = ()=>{};
    reuseWorkers = true;
    props = {};
    jobQueue = [];
    idleQueue = [];
    count = 0;
    isDestroyed = false;
    /** Checks if workers are supported on this platform */ static isSupported() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$farm$2f$worker$2d$thread$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].isSupported();
    }
    /**
     * @param processor - worker function
     * @param maxConcurrency - max count of workers
     */ constructor(props){
        this.source = props.source;
        this.url = props.url;
        this.setProps(props);
    }
    /**
     * Terminates all workers in the pool
     * @note Can free up significant memory
     */ destroy() {
        // Destroy idle workers, active Workers will be destroyed on completion
        this.idleQueue.forEach((worker)=>worker.destroy());
        this.isDestroyed = true;
    }
    setProps(props) {
        this.props = {
            ...this.props,
            ...props
        };
        if (props.name !== undefined) {
            this.name = props.name;
        }
        if (props.maxConcurrency !== undefined) {
            this.maxConcurrency = props.maxConcurrency;
        }
        if (props.maxMobileConcurrency !== undefined) {
            this.maxMobileConcurrency = props.maxMobileConcurrency;
        }
        if (props.reuseWorkers !== undefined) {
            this.reuseWorkers = props.reuseWorkers;
        }
        if (props.onDebug !== undefined) {
            this.onDebug = props.onDebug;
        }
    }
    async startJob(name, onMessage = (job, type, data)=>job.done(data), onError = (job, error)=>job.error(error)) {
        // Promise resolves when thread starts working on this job
        const startPromise = new Promise((onStart)=>{
            // Promise resolves when thread completes or fails working on this job
            this.jobQueue.push({
                name,
                onMessage,
                onError,
                onStart
            });
            return this;
        });
        this._startQueuedJob(); // eslint-disable-line @typescript-eslint/no-floating-promises
        return await startPromise;
    }
    // PRIVATE
    /**
     * Starts first queued job if worker is available or can be created
     * Called when job is started and whenever a worker returns to the idleQueue
     */ async _startQueuedJob() {
        if (!this.jobQueue.length) {
            return;
        }
        const workerThread = this._getAvailableWorker();
        if (!workerThread) {
            return;
        }
        // We have a worker, dequeue and start the job
        const queuedJob = this.jobQueue.shift();
        if (queuedJob) {
            // Emit a debug event
            // @ts-ignore
            this.onDebug({
                message: 'Starting job',
                name: queuedJob.name,
                workerThread,
                backlog: this.jobQueue.length
            });
            // Create a worker job to let the app access thread and manage job completion
            const job = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$farm$2f$worker$2d$job$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"](queuedJob.name, workerThread);
            // Set the worker thread's message handlers
            workerThread.onMessage = (data)=>queuedJob.onMessage(job, data.type, data.payload);
            workerThread.onError = (error)=>queuedJob.onError(job, error);
            // Resolve the start promise so that the app can start sending messages to worker
            queuedJob.onStart(job);
            // Wait for the app to signal that the job is complete, then return worker to queue
            try {
                await job.result;
            } catch (error) {
                // eslint-disable-next-line no-console
                console.error(`Worker exception: ${error}`);
            } finally{
                this.returnWorkerToQueue(workerThread);
            }
        }
    }
    /**
     * Returns a worker to the idle queue
     * Destroys the worker if
     *  - pool is destroyed
     *  - if this pool doesn't reuse workers
     *  - if maxConcurrency has been lowered
     * @param worker
     */ returnWorkerToQueue(worker) {
        const shouldDestroyWorker = // Workers on Node.js prevent the process from exiting.
        // Until we figure out how to close them before exit, we always destroy them
        !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBrowser"] || // If the pool is destroyed, there is no reason to keep the worker around
        this.isDestroyed || // If the app has disabled worker reuse, any completed workers should be destroyed
        !this.reuseWorkers || // If concurrency has been lowered, this worker might be surplus to requirements
        this.count > this._getMaxConcurrency();
        if (shouldDestroyWorker) {
            worker.destroy();
            this.count--;
        } else {
            this.idleQueue.push(worker);
        }
        if (!this.isDestroyed) {
            this._startQueuedJob(); // eslint-disable-line @typescript-eslint/no-floating-promises
        }
    }
    /**
     * Returns idle worker or creates new worker if maxConcurrency has not been reached
     */ _getAvailableWorker() {
        // If a worker has completed and returned to the queue, it can be used
        if (this.idleQueue.length > 0) {
            return this.idleQueue.shift() || null;
        }
        // Create fresh worker if we haven't yet created the max amount of worker threads for this worker source
        if (this.count < this._getMaxConcurrency()) {
            this.count++;
            const name = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$farm$2f$worker$2d$thread$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"]({
                name,
                source: this.source,
                url: this.url
            });
        }
        // No worker available, have to wait
        return null;
    }
    _getMaxConcurrency() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isMobile"] ? this.maxMobileConcurrency : this.maxConcurrency;
    }
}
}}),
"[project]/node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-farm.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "default": (()=>WorkerFarm)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$farm$2f$worker$2d$pool$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-pool.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$farm$2f$worker$2d$thread$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-thread.js [client] (ecmascript)");
;
;
const DEFAULT_PROPS = {
    maxConcurrency: 3,
    maxMobileConcurrency: 1,
    reuseWorkers: true,
    onDebug: ()=>{}
};
class WorkerFarm {
    props;
    workerPools = new Map();
    // singleton
    static _workerFarm;
    /** Checks if workers are supported on this platform */ static isSupported() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$farm$2f$worker$2d$thread$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].isSupported();
    }
    /** Get the singleton instance of the global worker farm */ static getWorkerFarm(props = {}) {
        WorkerFarm._workerFarm = WorkerFarm._workerFarm || new WorkerFarm({});
        WorkerFarm._workerFarm.setProps(props);
        return WorkerFarm._workerFarm;
    }
    /** get global instance with WorkerFarm.getWorkerFarm() */ constructor(props){
        this.props = {
            ...DEFAULT_PROPS
        };
        this.setProps(props);
        /** @type Map<string, WorkerPool>} */ this.workerPools = new Map();
    }
    /**
     * Terminate all workers in the farm
     * @note Can free up significant memory
     */ destroy() {
        for (const workerPool of this.workerPools.values()){
            workerPool.destroy();
        }
        this.workerPools = new Map();
    }
    /**
     * Set props used when initializing worker pools
     * @param props
     */ setProps(props) {
        this.props = {
            ...this.props,
            ...props
        };
        // Update worker pool props
        for (const workerPool of this.workerPools.values()){
            workerPool.setProps(this._getWorkerPoolProps());
        }
    }
    /**
     * Returns a worker pool for the specified worker
     * @param options - only used first time for a specific worker name
     * @param options.name - the name of the worker - used to identify worker pool
     * @param options.url -
     * @param options.source -
     * @example
     *   const job = WorkerFarm.getWorkerFarm().getWorkerPool({name, url}).startJob(...);
     */ getWorkerPool(options) {
        const { name, source, url } = options;
        let workerPool = this.workerPools.get(name);
        if (!workerPool) {
            workerPool = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$farm$2f$worker$2d$pool$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"]({
                name,
                source,
                url
            });
            workerPool.setProps(this._getWorkerPoolProps());
            this.workerPools.set(name, workerPool);
        }
        return workerPool;
    }
    _getWorkerPoolProps() {
        return {
            maxConcurrency: this.props.maxConcurrency,
            maxMobileConcurrency: this.props.maxMobileConcurrency,
            reuseWorkers: this.props.reuseWorkers,
            onDebug: this.props.onDebug
        };
    }
}
}}),
"[project]/node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-farm.js [client] (ecmascript) <export default as WorkerFarm>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "WorkerFarm": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$farm$2f$worker$2d$farm$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$farm$2f$worker$2d$farm$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-farm.js [client] (ecmascript)");
}}),
"[project]/node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/version.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// Version constant cannot be imported, it needs to correspond to the build version of **this** module.
/**
 * TODO - unpkg.com doesn't seem to have a `latest` specifier for alpha releases...
 * 'beta' on beta branch, 'latest' on prod branch
 */ __turbopack_context__.s({
    "NPM_TAG": (()=>NPM_TAG),
    "VERSION": (()=>VERSION)
});
const NPM_TAG = 'latest';
function getVersion() {
    if (!globalThis._loadersgl_?.version) {
        globalThis._loadersgl_ = globalThis._loadersgl_ || {};
        // __VERSION__ is injected by babel-plugin-version-inline
        if (typeof "4.3.2" === 'undefined') {
            // eslint-disable-next-line
            console.warn('loaders.gl: The __VERSION__ variable is not injected using babel plugin. Latest unstable workers would be fetched from the CDN.');
            globalThis._loadersgl_.version = NPM_TAG;
        } else {
            globalThis._loadersgl_.version = "4.3.2";
        }
    }
    return globalThis._loadersgl_.version;
}
const VERSION = getVersion();
}}),
"[project]/node_modules/@loaders.gl/worker-utils/dist/lib/worker-api/get-worker-url.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "getWorkerName": (()=>getWorkerName),
    "getWorkerURL": (()=>getWorkerURL)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/assert.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/globals.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$version$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/version.js [client] (ecmascript)");
;
;
;
function getWorkerName(worker) {
    const warning = worker.version !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$version$2e$js__$5b$client$5d$__$28$ecmascript$29$__["VERSION"] ? ` (worker-utils@${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$version$2e$js__$5b$client$5d$__$28$ecmascript$29$__["VERSION"]})` : '';
    return `${worker.name}@${worker.version}${warning}`;
}
function getWorkerURL(worker, options = {}) {
    const workerOptions = options[worker.id] || {};
    const workerFile = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBrowser"] ? `${worker.id}-worker.js` : `${worker.id}-worker-node.js`;
    let url = workerOptions.workerUrl;
    // HACK: Allow for non-nested workerUrl for the CompressionWorker.
    // For the compression worker, workerOptions is currently not nested correctly. For most loaders,
    // you'd have options within an object, i.e. `{mvt: {coordinates: ...}}` but the CompressionWorker
    // puts options at the top level, not within a `compression` key (its `id`). For this reason, the
    // above `workerOptions` will always be a string (i.e. `'gzip'`) for the CompressionWorker. To not
    // break backwards compatibility, we allow the CompressionWorker to have options at the top level.
    if (!url && worker.id === 'compression') {
        url = options.workerUrl;
    }
    // If URL is test, generate local loaders.gl url
    // @ts-ignore _workerType
    if (options._workerType === 'test') {
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBrowser"]) {
            url = `modules/${worker.module}/dist/${workerFile}`;
        } else {
            // In the test environment the ts-node loader requires TypeScript code
            url = `modules/${worker.module}/src/workers/${worker.id}-worker-node.ts`;
        }
    }
    // If url override is not provided, generate a URL to published version on npm CDN unpkg.com
    if (!url) {
        // GENERATE
        let version = worker.version;
        // On master we need to load npm alpha releases published with the `beta` tag
        if (version === 'latest') {
            // throw new Error('latest worker version specified');
            version = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$version$2e$js__$5b$client$5d$__$28$ecmascript$29$__["NPM_TAG"];
        }
        const versionTag = version ? `@${version}` : '';
        url = `https://unpkg.com/@loaders.gl/${worker.module}${versionTag}/dist/${workerFile}`;
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(url);
    // Allow user to override location
    return url;
}
}}),
"[project]/node_modules/@loaders.gl/worker-utils/dist/lib/worker-api/validate-worker-version.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "validateWorkerVersion": (()=>validateWorkerVersion)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/assert.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$version$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/version.js [client] (ecmascript)");
;
;
function validateWorkerVersion(worker, coreVersion = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$version$2e$js__$5b$client$5d$__$28$ecmascript$29$__["VERSION"]) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(worker, 'no worker provided');
    const workerVersion = worker.version;
    if (!coreVersion || !workerVersion) {
        return false;
    }
    // TODO enable when fix the __version__ injection
    // const coreVersions = parseVersion(coreVersion);
    // const workerVersions = parseVersion(workerVersion);
    // assert(
    //   coreVersion.major === workerVersion.major && coreVersion.minor <= workerVersion.minor,
    //   `worker: ${worker.name} is not compatible. ${coreVersion.major}.${
    //     coreVersion.minor
    //   }+ is required.`
    // );
    return true;
}
// @ts-ignore
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function parseVersion(version) {
    const parts = version.split('.').map(Number);
    return {
        major: parts[0],
        minor: parts[1]
    };
}
}}),
"[project]/node_modules/@loaders.gl/images/dist/lib/utils/version.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Version constant cannot be imported, it needs to correspond to the build version of **this** module.
// __VERSION__ is injected by babel-plugin-version-inline
// @ts-ignore TS2304: Cannot find name '__VERSION__'.
__turbopack_context__.s({
    "VERSION": (()=>VERSION)
});
const VERSION = typeof "4.3.2" !== 'undefined' ? "4.3.2" : 'latest';
}}),
"[project]/node_modules/@loaders.gl/images/dist/lib/category-api/image-type.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "getDefaultImageType": (()=>getDefaultImageType),
    "isImageTypeSupported": (()=>isImageTypeSupported)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/globals.js [client] (ecmascript)");
;
// @ts-ignore TS2339: Property does not exist on type
const parseImageNode = globalThis.loaders?.parseImageNode;
const IMAGE_SUPPORTED = typeof Image !== 'undefined'; // NOTE: "false" positives if jsdom is installed
const IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== 'undefined';
const NODE_IMAGE_SUPPORTED = Boolean(parseImageNode);
const DATA_SUPPORTED = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBrowser"] ? true : NODE_IMAGE_SUPPORTED;
function isImageTypeSupported(type) {
    switch(type){
        case 'auto':
            // Should only ever be false in Node.js, if polyfills have not been installed...
            return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED;
        case 'imagebitmap':
            return IMAGE_BITMAP_SUPPORTED;
        case 'image':
            return IMAGE_SUPPORTED;
        case 'data':
            return DATA_SUPPORTED;
        default:
            throw new Error(`@loaders.gl/images: image ${type} not supported in this environment`);
    }
}
function getDefaultImageType() {
    if (IMAGE_BITMAP_SUPPORTED) {
        return 'imagebitmap';
    }
    if (IMAGE_SUPPORTED) {
        return 'image';
    }
    if (DATA_SUPPORTED) {
        return 'data';
    }
    // This should only happen in Node.js
    throw new Error('Install \'@loaders.gl/polyfills\' to parse images under Node.js');
}
}}),
"[project]/node_modules/@loaders.gl/images/dist/lib/category-api/parsed-image-api.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "deleteImage": (()=>deleteImage),
    "getImageData": (()=>getImageData),
    "getImageSize": (()=>getImageSize),
    "getImageType": (()=>getImageType),
    "isImage": (()=>isImage)
});
function isImage(image) {
    return Boolean(getImageTypeOrNull(image));
}
function deleteImage(image) {
    switch(getImageType(image)){
        case 'imagebitmap':
            image.close();
            break;
        default:
    }
}
function getImageType(image) {
    const format = getImageTypeOrNull(image);
    if (!format) {
        throw new Error('Not an image');
    }
    return format;
}
function getImageSize(image) {
    return getImageData(image);
}
function getImageData(image) {
    switch(getImageType(image)){
        case 'data':
            return image;
        case 'image':
        case 'imagebitmap':
            // Extract the image data from the image via a canvas
            const canvas = document.createElement('canvas');
            // TODO - reuse the canvas?
            const context = canvas.getContext('2d');
            if (!context) {
                throw new Error('getImageData');
            }
            // @ts-ignore
            canvas.width = image.width;
            // @ts-ignore
            canvas.height = image.height;
            // @ts-ignore
            context.drawImage(image, 0, 0);
            // @ts-ignore
            return context.getImageData(0, 0, image.width, image.height);
        default:
            throw new Error('getImageData');
    }
}
// PRIVATE
// eslint-disable-next-line complexity
function getImageTypeOrNull(image) {
    if (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
        return 'imagebitmap';
    }
    if (typeof Image !== 'undefined' && image instanceof Image) {
        return 'image';
    }
    if (image && typeof image === 'object' && image.data && image.width && image.height) {
        return 'data';
    }
    return null;
}
}}),
"[project]/node_modules/@loaders.gl/images/dist/lib/parsers/svg-utils.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// SVG parsing has limitations, e.g:
// https://bugs.chromium.org/p/chromium/issues/detail?id=606319
__turbopack_context__.s({
    "getBlob": (()=>getBlob),
    "getBlobOrSVGDataUrl": (()=>getBlobOrSVGDataUrl),
    "isSVG": (()=>isSVG)
});
const SVG_DATA_URL_PATTERN = /^data:image\/svg\+xml/;
const SVG_URL_PATTERN = /\.svg((\?|#).*)?$/;
function isSVG(url) {
    return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));
}
function getBlobOrSVGDataUrl(arrayBuffer, url) {
    if (isSVG(url)) {
        // Prepare a properly tagged data URL, and load using normal mechanism
        const textDecoder = new TextDecoder();
        let xmlText = textDecoder.decode(arrayBuffer);
        // TODO Escape in browser to support e.g. Chinese characters
        try {
            if (typeof unescape === 'function' && typeof encodeURIComponent === 'function') {
                xmlText = unescape(encodeURIComponent(xmlText));
            }
        } catch (error) {
            throw new Error(error.message);
        }
        // base64 encoding is safer. utf-8 fails in some browsers
        const src = `data:image/svg+xml;base64,${btoa(xmlText)}`;
        return src;
    }
    return getBlob(arrayBuffer, url);
}
function getBlob(arrayBuffer, url) {
    if (isSVG(url)) {
        // https://bugs.chromium.org/p/chromium/issues/detail?id=606319
        // return new Blob([new Uint8Array(arrayBuffer)], {type: 'image/svg+xml'});
        throw new Error('SVG cannot be parsed directly to imagebitmap');
    }
    // TODO - how to determine mime type? Param? Sniff here?
    return new Blob([
        new Uint8Array(arrayBuffer)
    ]); // MIME type not needed?
}
}}),
"[project]/node_modules/@loaders.gl/images/dist/lib/parsers/parse-to-image.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "loadToImage": (()=>loadToImage),
    "parseToImage": (()=>parseToImage)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$parsers$2f$svg$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/images/dist/lib/parsers/svg-utils.js [client] (ecmascript)");
;
async function parseToImage(arrayBuffer, options, url) {
    // Note: image parsing requires conversion to Blob (for createObjectURL).
    // Potentially inefficient for not using `response.blob()` (and for File / Blob inputs)...
    // But presumably not worth adding 'blob' flag to loader objects?
    const blobOrDataUrl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$parsers$2f$svg$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getBlobOrSVGDataUrl"])(arrayBuffer, url);
    const URL = self.URL || self.webkitURL;
    const objectUrl = typeof blobOrDataUrl !== 'string' && URL.createObjectURL(blobOrDataUrl);
    try {
        return await loadToImage(objectUrl || blobOrDataUrl, options);
    } finally{
        if (objectUrl) {
            URL.revokeObjectURL(objectUrl);
        }
    }
}
async function loadToImage(url, options) {
    const image = new Image();
    image.src = url;
    // The `image.onload()` callback does not guarantee that the image has been decoded
    // so a main thread "freeze" can be incurred when using the image for the first time.
    // `Image.decode()` returns a promise that completes when image is decoded.
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/decode
    // Note: When calling `img.decode()`, we do not need to wait for `img.onload()`
    // Note: `HTMLImageElement.decode()` is not available in Edge and IE11
    if (options.image && options.image.decode && image.decode) {
        await image.decode();
        return image;
    }
    // Create a promise that tracks onload/onerror callbacks
    return await new Promise((resolve, reject)=>{
        try {
            image.onload = ()=>resolve(image);
            image.onerror = (error)=>{
                const message = error instanceof Error ? error.message : 'error';
                reject(new Error(message));
            };
        } catch (error) {
            reject(error);
        }
    });
}
}}),
"[project]/node_modules/@loaders.gl/images/dist/lib/parsers/parse-to-image-bitmap.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "parseToImageBitmap": (()=>parseToImageBitmap)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$parsers$2f$svg$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/images/dist/lib/parsers/svg-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$parsers$2f$parse$2d$to$2d$image$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/images/dist/lib/parsers/parse-to-image.js [client] (ecmascript)");
;
;
const EMPTY_OBJECT = {};
let imagebitmapOptionsSupported = true;
async function parseToImageBitmap(arrayBuffer, options, url) {
    let blob;
    // Cannot parse SVG directly to ImageBitmap, parse to Image first
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$parsers$2f$svg$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isSVG"])(url)) {
        // Note: this only works on main thread
        const image = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$parsers$2f$parse$2d$to$2d$image$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseToImage"])(arrayBuffer, options, url);
        blob = image;
    } else {
        // Create blob from the array buffer
        blob = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$parsers$2f$svg$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getBlob"])(arrayBuffer, url);
    }
    const imagebitmapOptions = options && options.imagebitmap;
    return await safeCreateImageBitmap(blob, imagebitmapOptions);
}
/**
 * Safely creates an imageBitmap with options
 * *
 * Firefox crashes if imagebitmapOptions is supplied
 * Avoid supplying if not provided or supported, remember if not supported
 */ async function safeCreateImageBitmap(blob, imagebitmapOptions = null) {
    if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) {
        imagebitmapOptions = null;
    }
    if (imagebitmapOptions) {
        try {
            // @ts-ignore Options
            return await createImageBitmap(blob, imagebitmapOptions);
        } catch (error) {
            console.warn(error); // eslint-disable-line
            imagebitmapOptionsSupported = false;
        }
    }
    return await createImageBitmap(blob);
}
function isEmptyObject(object) {
    // @ts-ignore
    for(const key in object || EMPTY_OBJECT){
        return false;
    }
    return true;
}
}}),
"[project]/node_modules/@loaders.gl/images/dist/lib/category-api/parse-isobmff-binary.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// code adapted from https://github.com/sindresorhus/file-type under MIT license
/**
 * Tests if a buffer is in ISO base media file format (ISOBMFF) @see https://en.wikipedia.org/wiki/ISO_base_media_file_format
 * (ISOBMFF is a media container standard based on the Apple QuickTime container format)
 */ __turbopack_context__.s({
    "decodeMajorBrand": (()=>decodeMajorBrand),
    "getISOBMFFMediaType": (()=>getISOBMFFMediaType)
});
function getISOBMFFMediaType(buffer) {
    // Almost all ISO base media files start with `ftyp` box. (It's not required to be first, but it's recommended to be.)
    if (!checkString(buffer, 'ftyp', 4)) {
        return null;
    }
    // Extra check: test for 8859-1 printable characters (for simplicity, it's a mask which also catches one non-printable character).
    if ((buffer[8] & 0x60) === 0x00) {
        return null;
    }
    // `ftyp` box must contain a brand major identifier, which must consist of ISO 8859-1 printable characters.
    return decodeMajorBrand(buffer);
}
function decodeMajorBrand(buffer) {
    const brandMajor = getUTF8String(buffer, 8, 12).replace('\0', ' ').trim();
    switch(brandMajor){
        case 'avif':
        case 'avis':
            return {
                extension: 'avif',
                mimeType: 'image/avif'
            };
        default:
            return null;
    }
// We don't need these now, but they are easy to add
// case 'mif1':
//   return {extension: 'heic', mimeType: 'image/heif'};
// case 'msf1':
//   return {extension: 'heic', mimeType: 'image/heif-sequence'};
// case 'heic':
// case 'heix':
//   return {extension: 'heic', mimeType: 'image/heic'};
// case 'hevc':
// case 'hevx':
//   return {extension: 'heic', mimeType: 'image/heic-sequence'};
// case 'qt':
//   return {ext: 'mov', mime: 'video/quicktime'};
// case 'M4V':
// case 'M4VH':
// case 'M4VP':
//   return {ext: 'm4v', mime: 'video/x-m4v'};
// case 'M4P':
//   return {ext: 'm4p', mime: 'video/mp4'};
// case 'M4B':
//   return {ext: 'm4b', mime: 'audio/mp4'};
// case 'M4A':
//   return {ext: 'm4a', mime: 'audio/x-m4a'};
// case 'F4V':
//   return {ext: 'f4v', mime: 'video/mp4'};
// case 'F4P':
//   return {ext: 'f4p', mime: 'video/mp4'};
// case 'F4A':
//   return {ext: 'f4a', mime: 'audio/mp4'};
// case 'F4B':
//   return {ext: 'f4b', mime: 'audio/mp4'};
// case 'crx':
//   return {ext: 'cr3', mime: 'image/x-canon-cr3'};
// default:
// if (brandMajor.startsWith('3g')) {
//   if (brandMajor.startsWith('3g2')) {
//     return {ext: '3g2', mime: 'video/3gpp2'};
//   }
//   return {ext: '3gp', mime: 'video/3gpp'};
// }
// return {ext: 'mp4', mime: 'video/mp4'};
}
/** Interpret a chunk of bytes as a UTF8 string */ function getUTF8String(array, start, end) {
    return String.fromCharCode(...array.slice(start, end));
}
function stringToBytes(string) {
    return [
        ...string
    ].map((character)=>character.charCodeAt(0));
}
function checkString(buffer, header, offset = 0) {
    const headerBytes = stringToBytes(header);
    for(let i = 0; i < headerBytes.length; ++i){
        if (headerBytes[i] !== buffer[i + offset]) {
            return false;
        }
    }
    return true;
}
}}),
"[project]/node_modules/@loaders.gl/images/dist/lib/category-api/binary-image-api.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Attributions
// * Based on binary-gltf-utils under MIT license: Copyright (c) 2016-17 Karl Cheng
__turbopack_context__.s({
    "getBinaryImageMetadata": (()=>getBinaryImageMetadata),
    "getBmpMetadata": (()=>getBmpMetadata)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$category$2d$api$2f$parse$2d$isobmff$2d$binary$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/images/dist/lib/category-api/parse-isobmff-binary.js [client] (ecmascript)");
;
const BIG_ENDIAN = false;
const LITTLE_ENDIAN = true;
function getBinaryImageMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    return getPngMetadata(dataView) || getJpegMetadata(dataView) || getGifMetadata(dataView) || getBmpMetadata(dataView) || getISOBMFFMetadata(dataView);
}
// ISOBMFF
function getISOBMFFMetadata(binaryData) {
    const buffer = new Uint8Array(binaryData instanceof DataView ? binaryData.buffer : binaryData);
    const mediaType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$category$2d$api$2f$parse$2d$isobmff$2d$binary$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getISOBMFFMediaType"])(buffer);
    if (!mediaType) {
        return null;
    }
    return {
        mimeType: mediaType.mimeType,
        // TODO - decode width and height
        width: 0,
        height: 0
    };
}
// PNG
function getPngMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    // Check file contains the first 4 bytes of the PNG signature.
    const isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 0x89504e47;
    if (!isPng) {
        return null;
    }
    // Extract size from a binary PNG file
    return {
        mimeType: 'image/png',
        width: dataView.getUint32(16, BIG_ENDIAN),
        height: dataView.getUint32(20, BIG_ENDIAN)
    };
}
// GIF
// Extract size from a binary GIF file
// TODO: GIF is not this simple
function getGifMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    // Check first 4 bytes of the GIF signature ("GIF8").
    const isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 0x47494638;
    if (!isGif) {
        return null;
    }
    // GIF is little endian.
    return {
        mimeType: 'image/gif',
        width: dataView.getUint16(6, LITTLE_ENDIAN),
        height: dataView.getUint16(8, LITTLE_ENDIAN)
    };
}
function getBmpMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    // Check magic number is valid (first 2 characters should be "BM").
    // The mandatory bitmap file header is 14 bytes long.
    const isBmp = dataView.byteLength >= 14 && dataView.getUint16(0, BIG_ENDIAN) === 0x424d && dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;
    if (!isBmp) {
        return null;
    }
    // BMP is little endian.
    return {
        mimeType: 'image/bmp',
        width: dataView.getUint32(18, LITTLE_ENDIAN),
        height: dataView.getUint32(22, LITTLE_ENDIAN)
    };
}
// JPEG
// Extract width and height from a binary JPEG file
function getJpegMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    // Check file contains the JPEG "start of image" (SOI) marker
    // followed by another marker.
    const isJpeg = dataView.byteLength >= 3 && dataView.getUint16(0, BIG_ENDIAN) === 0xffd8 && dataView.getUint8(2) === 0xff;
    if (!isJpeg) {
        return null;
    }
    const { tableMarkers, sofMarkers } = getJpegMarkers();
    // Exclude the two byte SOI marker.
    let i = 2;
    while(i + 9 < dataView.byteLength){
        const marker = dataView.getUint16(i, BIG_ENDIAN);
        // The frame that contains the width and height of the JPEG image.
        if (sofMarkers.has(marker)) {
            return {
                mimeType: 'image/jpeg',
                height: dataView.getUint16(i + 5, BIG_ENDIAN),
                width: dataView.getUint16(i + 7, BIG_ENDIAN) // Number of pixels per line
            };
        }
        // Miscellaneous tables/data preceding the frame header.
        if (!tableMarkers.has(marker)) {
            return null;
        }
        // Length includes size of length parameter but not the two byte header.
        i += 2;
        i += dataView.getUint16(i, BIG_ENDIAN);
    }
    return null;
}
function getJpegMarkers() {
    // Tables/misc header markers.
    // DQT, DHT, DAC, DRI, COM, APP_n
    const tableMarkers = new Set([
        0xffdb,
        0xffc4,
        0xffcc,
        0xffdd,
        0xfffe
    ]);
    for(let i = 0xffe0; i < 0xfff0; ++i){
        tableMarkers.add(i);
    }
    // SOF markers and DHP marker.
    // These markers are after tables/misc data.
    const sofMarkers = new Set([
        0xffc0,
        0xffc1,
        0xffc2,
        0xffc3,
        0xffc5,
        0xffc6,
        0xffc7,
        0xffc9,
        0xffca,
        0xffcb,
        0xffcd,
        0xffce,
        0xffcf,
        0xffde
    ]);
    return {
        tableMarkers,
        sofMarkers
    };
}
// TODO - move into image module?
function toDataView(data) {
    if (data instanceof DataView) {
        return data;
    }
    if (ArrayBuffer.isView(data)) {
        return new DataView(data.buffer);
    }
    // TODO: make these functions work for Node.js buffers?
    // if (bufferToArrayBuffer) {
    //   data = bufferToArrayBuffer(data);
    // }
    // Careful - Node Buffers will look like ArrayBuffers (keep after isBuffer)
    if (data instanceof ArrayBuffer) {
        return new DataView(data);
    }
    throw new Error('toDataView');
}
}}),
"[project]/node_modules/@loaders.gl/images/dist/lib/parsers/parse-to-node-image.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "parseToNodeImage": (()=>parseToNodeImage)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/assert.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$category$2d$api$2f$binary$2d$image$2d$api$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/images/dist/lib/category-api/binary-image-api.js [client] (ecmascript)");
;
;
async function parseToNodeImage(arrayBuffer, options) {
    const { mimeType } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$category$2d$api$2f$binary$2d$image$2d$api$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getBinaryImageMetadata"])(arrayBuffer) || {};
    // @ts-ignore
    const parseImageNode = globalThis.loaders?.parseImageNode;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(parseImageNode); // '@loaders.gl/polyfills not installed'
    // @ts-expect-error TODO should we throw error in this case?
    return await parseImageNode(arrayBuffer, mimeType);
}
}}),
"[project]/node_modules/@loaders.gl/images/dist/lib/parsers/parse-image.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "parseImage": (()=>parseImage)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/assert.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$category$2d$api$2f$image$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/images/dist/lib/category-api/image-type.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$category$2d$api$2f$parsed$2d$image$2d$api$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/images/dist/lib/category-api/parsed-image-api.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$parsers$2f$parse$2d$to$2d$image$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/images/dist/lib/parsers/parse-to-image.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$parsers$2f$parse$2d$to$2d$image$2d$bitmap$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/images/dist/lib/parsers/parse-to-image-bitmap.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$parsers$2f$parse$2d$to$2d$node$2d$image$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/images/dist/lib/parsers/parse-to-node-image.js [client] (ecmascript)");
;
;
;
;
;
;
async function parseImage(arrayBuffer, options, context) {
    options = options || {};
    const imageOptions = options.image || {};
    // The user can request a specific output format via `options.image.type`
    const imageType = imageOptions.type || 'auto';
    const { url } = context || {};
    // Note: For options.image.type === `data`, we may still need to load as `image` or `imagebitmap`
    const loadType = getLoadableImageType(imageType);
    let image;
    switch(loadType){
        case 'imagebitmap':
            image = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$parsers$2f$parse$2d$to$2d$image$2d$bitmap$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseToImageBitmap"])(arrayBuffer, options, url);
            break;
        case 'image':
            image = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$parsers$2f$parse$2d$to$2d$image$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseToImage"])(arrayBuffer, options, url);
            break;
        case 'data':
            // Node.js loads imagedata directly
            image = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$parsers$2f$parse$2d$to$2d$node$2d$image$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseToNodeImage"])(arrayBuffer, options);
            break;
        default:
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(false);
    }
    // Browser: if options.image.type === 'data', we can now extract data from the loaded image
    if (imageType === 'data') {
        image = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$category$2d$api$2f$parsed$2d$image$2d$api$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getImageData"])(image);
    }
    return image;
}
// Get a loadable image type from image type
function getLoadableImageType(type) {
    switch(type){
        case 'auto':
        case 'data':
            // Browser: For image data we need still need to load using an image format
            // Node: the default image type is `data`.
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$category$2d$api$2f$image$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getDefaultImageType"])();
        default:
            // Throw an error if not supported
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$category$2d$api$2f$image$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isImageTypeSupported"])(type);
            return type;
    }
}
}}),
"[project]/node_modules/@loaders.gl/images/dist/image-loader.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// import type { ImageType } from '@loaders.gl/schema';
__turbopack_context__.s({
    "ImageLoader": (()=>ImageLoader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$utils$2f$version$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/images/dist/lib/utils/version.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$parsers$2f$parse$2d$image$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/images/dist/lib/parsers/parse-image.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$category$2d$api$2f$binary$2d$image$2d$api$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/images/dist/lib/category-api/binary-image-api.js [client] (ecmascript)");
;
;
;
const EXTENSIONS = [
    'png',
    'jpg',
    'jpeg',
    'gif',
    'webp',
    'bmp',
    'ico',
    'svg',
    'avif'
];
const MIME_TYPES = [
    'image/png',
    'image/jpeg',
    'image/gif',
    'image/webp',
    'image/avif',
    'image/bmp',
    'image/vnd.microsoft.icon',
    'image/svg+xml'
];
const DEFAULT_IMAGE_LOADER_OPTIONS = {
    image: {
        type: 'auto',
        decode: true // if format is HTML
    }
};
const ImageLoader = {
    dataType: null,
    batchType: null,
    id: 'image',
    module: 'images',
    name: 'Images',
    version: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$utils$2f$version$2e$js__$5b$client$5d$__$28$ecmascript$29$__["VERSION"],
    mimeTypes: MIME_TYPES,
    extensions: EXTENSIONS,
    parse: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$parsers$2f$parse$2d$image$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseImage"],
    // TODO: byteOffset, byteLength;
    tests: [
        (arrayBuffer)=>Boolean((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$category$2d$api$2f$binary$2d$image$2d$api$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getBinaryImageMetadata"])(new DataView(arrayBuffer)))
    ],
    options: DEFAULT_IMAGE_LOADER_OPTIONS
};
}}),
"[project]/node_modules/@loaders.gl/gis/dist/lib/binary-features/binary-to-geojson.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/**
 * Convert binary geometry representation to GeoJSON
 * @param data   geometry data in binary representation
 * @param options
 * @param options.type  Input data type: Point, LineString, or Polygon
 * @param options.featureId  Global feature id. If specified, only a single feature is extracted
 * @return GeoJSON objects
 */ __turbopack_context__.s({
    "binaryToGeojson": (()=>binaryToGeojson),
    "binaryToGeometry": (()=>binaryToGeometry)
});
function binaryToGeojson(data, options) {
    const globalFeatureId = options?.globalFeatureId;
    if (globalFeatureId !== undefined) {
        return getSingleFeature(data, globalFeatureId);
    }
    return parseFeatures(data, options?.type);
}
/**
 * Return a single feature from a binary geometry representation as GeoJSON
 * @param data   geometry data in binary representation
 * @return GeoJSON feature
 */ function getSingleFeature(data, globalFeatureId) {
    const dataArray = normalizeInput(data);
    for (const data of dataArray){
        let lastIndex = 0;
        let lastValue = data.featureIds.value[0];
        // Scan through data until we find matching feature
        for(let i = 0; i < data.featureIds.value.length; i++){
            const currValue = data.featureIds.value[i];
            if (currValue === lastValue) {
                continue;
            }
            if (globalFeatureId === data.globalFeatureIds.value[lastIndex]) {
                return parseFeature(data, lastIndex, i);
            }
            lastIndex = i;
            lastValue = currValue;
        }
        if (globalFeatureId === data.globalFeatureIds.value[lastIndex]) {
            return parseFeature(data, lastIndex, data.featureIds.value.length);
        }
    }
    throw new Error(`featureId:${globalFeatureId} not found`);
}
function parseFeatures(data, type) {
    const dataArray = normalizeInput(data, type);
    return parseFeatureCollection(dataArray);
}
function binaryToGeometry(data, startIndex, endIndex) {
    switch(data.type){
        case 'Point':
            return pointToGeoJson(data, startIndex, endIndex);
        case 'LineString':
            return lineStringToGeoJson(data, startIndex, endIndex);
        case 'Polygon':
            return polygonToGeoJson(data, startIndex, endIndex);
        default:
            const unexpectedInput = data;
            throw new Error(`Unsupported geometry type: ${unexpectedInput?.type}`);
    }
}
// Normalize features
// Return an array of data objects, each of which have a type key
function normalizeInput(data, type) {
    const features = [];
    if (data.points) {
        data.points.type = 'Point';
        features.push(data.points);
    }
    if (data.lines) {
        data.lines.type = 'LineString';
        features.push(data.lines);
    }
    if (data.polygons) {
        data.polygons.type = 'Polygon';
        features.push(data.polygons);
    }
    return features;
}
/** Parse input binary data and return an array of GeoJSON Features */ function parseFeatureCollection(dataArray) {
    const features = [];
    for (const data of dataArray){
        if (data.featureIds.value.length === 0) {
            continue;
        }
        let lastIndex = 0;
        let lastValue = data.featureIds.value[0];
        // Need to deduce start, end indices of each feature
        for(let i = 0; i < data.featureIds.value.length; i++){
            const currValue = data.featureIds.value[i];
            if (currValue === lastValue) {
                continue;
            }
            features.push(parseFeature(data, lastIndex, i));
            lastIndex = i;
            lastValue = currValue;
        }
        // Last feature
        features.push(parseFeature(data, lastIndex, data.featureIds.value.length));
    }
    return features;
}
/** Parse input binary data and return a single GeoJSON Feature */ function parseFeature(data, startIndex, endIndex) {
    const geometry = binaryToGeometry(data, startIndex, endIndex);
    const properties = parseProperties(data, startIndex, endIndex);
    const fields = parseFields(data, startIndex, endIndex);
    return {
        type: 'Feature',
        geometry,
        properties,
        ...fields
    };
}
/** Parse input binary data and return an object of fields */ function parseFields(data, startIndex = 0, endIndex) {
    return data.fields && data.fields[data.featureIds.value[startIndex]];
}
/** Parse input binary data and return an object of properties */ function parseProperties(data, startIndex = 0, endIndex) {
    const properties = Object.assign({}, data.properties[data.featureIds.value[startIndex]]);
    for(const key in data.numericProps){
        properties[key] = data.numericProps[key].value[startIndex];
    }
    return properties;
}
/** Parse binary data of type Polygon */ function polygonToGeoJson(data, startIndex = -Infinity, endIndex = Infinity) {
    const { positions } = data;
    const polygonIndices = data.polygonIndices.value.filter((x)=>x >= startIndex && x <= endIndex);
    const primitivePolygonIndices = data.primitivePolygonIndices.value.filter((x)=>x >= startIndex && x <= endIndex);
    const multi = polygonIndices.length > 2;
    // Polygon
    if (!multi) {
        const coordinates = [];
        for(let i = 0; i < primitivePolygonIndices.length - 1; i++){
            const startRingIndex = primitivePolygonIndices[i];
            const endRingIndex = primitivePolygonIndices[i + 1];
            const ringCoordinates = ringToGeoJson(positions, startRingIndex, endRingIndex);
            coordinates.push(ringCoordinates);
        }
        return {
            type: 'Polygon',
            coordinates
        };
    }
    // MultiPolygon
    const coordinates = [];
    for(let i = 0; i < polygonIndices.length - 1; i++){
        const startPolygonIndex = polygonIndices[i];
        const endPolygonIndex = polygonIndices[i + 1];
        const polygonCoordinates = polygonToGeoJson(data, startPolygonIndex, endPolygonIndex).coordinates;
        coordinates.push(polygonCoordinates);
    }
    return {
        type: 'MultiPolygon',
        coordinates
    };
}
/** Parse binary data of type LineString */ function lineStringToGeoJson(data, startIndex = -Infinity, endIndex = Infinity) {
    const { positions } = data;
    const pathIndices = data.pathIndices.value.filter((x)=>x >= startIndex && x <= endIndex);
    const multi = pathIndices.length > 2;
    if (!multi) {
        const coordinates = ringToGeoJson(positions, pathIndices[0], pathIndices[1]);
        return {
            type: 'LineString',
            coordinates
        };
    }
    const coordinates = [];
    for(let i = 0; i < pathIndices.length - 1; i++){
        const ringCoordinates = ringToGeoJson(positions, pathIndices[i], pathIndices[i + 1]);
        coordinates.push(ringCoordinates);
    }
    return {
        type: 'MultiLineString',
        coordinates
    };
}
/** Parse binary data of type Point */ function pointToGeoJson(data, startIndex, endIndex) {
    const { positions } = data;
    const coordinates = ringToGeoJson(positions, startIndex, endIndex);
    const multi = coordinates.length > 1;
    if (multi) {
        return {
            type: 'MultiPoint',
            coordinates
        };
    }
    return {
        type: 'Point',
        coordinates: coordinates[0]
    };
}
/**
 * Parse a linear ring of positions to a GeoJSON linear ring
 *
 * @param positions Positions TypedArray
 * @param startIndex Start index to include in ring
 * @param endIndex End index to include in ring
 * @returns GeoJSON ring
 */ function ringToGeoJson(positions, startIndex, endIndex) {
    startIndex = startIndex || 0;
    endIndex = endIndex || positions.value.length / positions.size;
    const ringCoordinates = [];
    for(let j = startIndex; j < endIndex; j++){
        const coord = Array();
        for(let k = j * positions.size; k < (j + 1) * positions.size; k++){
            coord.push(Number(positions.value[k]));
        }
        ringCoordinates.push(coord);
    }
    return ringCoordinates;
}
}}),
"[project]/node_modules/@loaders.gl/gis/dist/lib/binary-features/flat-geojson-to-binary.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* eslint-disable indent */ __turbopack_context__.s({
    "TEST_EXPORTS": (()=>TEST_EXPORTS),
    "flatGeojsonToBinary": (()=>flatGeojsonToBinary)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/polygon/dist/index.js [client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$earcut$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/polygon/dist/earcut.js [client] (ecmascript)");
;
function flatGeojsonToBinary(features, geometryInfo, options) {
    const propArrayTypes = extractNumericPropTypes(features);
    const numericPropKeys = Object.keys(propArrayTypes).filter((k)=>propArrayTypes[k] !== Array);
    return fillArrays(features, {
        propArrayTypes,
        ...geometryInfo
    }, {
        numericPropKeys: options && options.numericPropKeys || numericPropKeys,
        PositionDataType: options ? options.PositionDataType : Float32Array,
        triangulate: options ? options.triangulate : true
    });
}
const TEST_EXPORTS = {
    extractNumericPropTypes
};
/**
 * Extracts properties that are always numeric
 *
 * @param features
 * @returns object with numeric types
 */ function extractNumericPropTypes(features) {
    const propArrayTypes = {};
    for (const feature of features){
        if (feature.properties) {
            for(const key in feature.properties){
                // If property has not been seen before, or if property has been numeric
                // in all previous features, check if numeric in this feature
                // If not numeric, Array is stored to prevent rechecking in the future
                // Additionally, detects if 64 bit precision is required
                const val = feature.properties[key];
                propArrayTypes[key] = deduceArrayType(val, propArrayTypes[key]);
            }
        }
    }
    return propArrayTypes;
}
/**
 * Fills coordinates into pre-allocated typed arrays
 *
 * @param features
 * @param geometryInfo
 * @param options
 * @returns an accessor object with value and size keys
 */ // eslint-disable-next-line complexity, max-statements
function fillArrays(features, geometryInfo, options) {
    const { pointPositionsCount, pointFeaturesCount, linePositionsCount, linePathsCount, lineFeaturesCount, polygonPositionsCount, polygonObjectsCount, polygonRingsCount, polygonFeaturesCount, propArrayTypes, coordLength } = geometryInfo;
    const { numericPropKeys = [], PositionDataType = Float32Array, triangulate = true } = options;
    const hasGlobalId = features[0] && 'id' in features[0];
    const GlobalFeatureIdsDataType = features.length > 65535 ? Uint32Array : Uint16Array;
    const points = {
        type: 'Point',
        positions: new PositionDataType(pointPositionsCount * coordLength),
        globalFeatureIds: new GlobalFeatureIdsDataType(pointPositionsCount),
        featureIds: pointFeaturesCount > 65535 ? new Uint32Array(pointPositionsCount) : new Uint16Array(pointPositionsCount),
        numericProps: {},
        properties: [],
        fields: []
    };
    const lines = {
        type: 'LineString',
        pathIndices: linePositionsCount > 65535 ? new Uint32Array(linePathsCount + 1) : new Uint16Array(linePathsCount + 1),
        positions: new PositionDataType(linePositionsCount * coordLength),
        globalFeatureIds: new GlobalFeatureIdsDataType(linePositionsCount),
        featureIds: lineFeaturesCount > 65535 ? new Uint32Array(linePositionsCount) : new Uint16Array(linePositionsCount),
        numericProps: {},
        properties: [],
        fields: []
    };
    const polygons = {
        type: 'Polygon',
        polygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonObjectsCount + 1) : new Uint16Array(polygonObjectsCount + 1),
        primitivePolygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonRingsCount + 1) : new Uint16Array(polygonRingsCount + 1),
        positions: new PositionDataType(polygonPositionsCount * coordLength),
        globalFeatureIds: new GlobalFeatureIdsDataType(polygonPositionsCount),
        featureIds: polygonFeaturesCount > 65535 ? new Uint32Array(polygonPositionsCount) : new Uint16Array(polygonPositionsCount),
        numericProps: {},
        properties: [],
        fields: []
    };
    if (triangulate) {
        polygons.triangles = [];
    }
    // Instantiate numeric properties arrays; one value per vertex
    for (const object of [
        points,
        lines,
        polygons
    ]){
        for (const propName of numericPropKeys){
            // If property has been numeric in all previous features in which the property existed, check
            // if numeric in this feature
            const T = propArrayTypes[propName];
            object.numericProps[propName] = new T(object.positions.length / coordLength);
        }
    }
    // Set last element of path/polygon indices as positions length
    lines.pathIndices[linePathsCount] = linePositionsCount;
    polygons.polygonIndices[polygonObjectsCount] = polygonPositionsCount;
    polygons.primitivePolygonIndices[polygonRingsCount] = polygonPositionsCount;
    const indexMap = {
        pointPosition: 0,
        pointFeature: 0,
        linePosition: 0,
        linePath: 0,
        lineFeature: 0,
        polygonPosition: 0,
        polygonObject: 0,
        polygonRing: 0,
        polygonFeature: 0,
        feature: 0
    };
    for (const feature of features){
        const geometry = feature.geometry;
        const properties = feature.properties || {};
        switch(geometry.type){
            case 'Point':
                handlePoint(geometry, points, indexMap, coordLength, properties);
                points.properties.push(keepStringProperties(properties, numericPropKeys));
                if (hasGlobalId) {
                    points.fields.push({
                        id: feature.id
                    });
                }
                indexMap.pointFeature++;
                break;
            case 'LineString':
                handleLineString(geometry, lines, indexMap, coordLength, properties);
                lines.properties.push(keepStringProperties(properties, numericPropKeys));
                if (hasGlobalId) {
                    lines.fields.push({
                        id: feature.id
                    });
                }
                indexMap.lineFeature++;
                break;
            case 'Polygon':
                handlePolygon(geometry, polygons, indexMap, coordLength, properties);
                polygons.properties.push(keepStringProperties(properties, numericPropKeys));
                if (hasGlobalId) {
                    polygons.fields.push({
                        id: feature.id
                    });
                }
                indexMap.polygonFeature++;
                break;
            default:
                throw new Error('Invalid geometry type');
        }
        indexMap.feature++;
    }
    // Wrap each array in an accessor object with value and size keys
    return makeAccessorObjects(points, lines, polygons, coordLength);
}
/**
 * Fills (Multi)Point coordinates into points object of arrays
 *
 * @param geometry
 * @param points
 * @param indexMap
 * @param coordLength
 * @param properties
 */ function handlePoint(geometry, points, indexMap, coordLength, properties) {
    points.positions.set(geometry.data, indexMap.pointPosition * coordLength);
    const nPositions = geometry.data.length / coordLength;
    fillNumericProperties(points, properties, indexMap.pointPosition, nPositions);
    points.globalFeatureIds.fill(indexMap.feature, indexMap.pointPosition, indexMap.pointPosition + nPositions);
    points.featureIds.fill(indexMap.pointFeature, indexMap.pointPosition, indexMap.pointPosition + nPositions);
    indexMap.pointPosition += nPositions;
}
/**
 * Fills (Multi)LineString coordinates into lines object of arrays
 *
 * @param geometry
 * @param lines
 * @param indexMap
 * @param coordLength
 * @param properties
 */ function handleLineString(geometry, lines, indexMap, coordLength, properties) {
    lines.positions.set(geometry.data, indexMap.linePosition * coordLength);
    const nPositions = geometry.data.length / coordLength;
    fillNumericProperties(lines, properties, indexMap.linePosition, nPositions);
    lines.globalFeatureIds.fill(indexMap.feature, indexMap.linePosition, indexMap.linePosition + nPositions);
    lines.featureIds.fill(indexMap.lineFeature, indexMap.linePosition, indexMap.linePosition + nPositions);
    for(let i = 0, il = geometry.indices.length; i < il; ++i){
        // Extract range of data we are working with, defined by start
        // and end indices (these index into the geometry.data array)
        const start = geometry.indices[i];
        const end = i === il - 1 ? geometry.data.length // last line, so read to end of data
         : geometry.indices[i + 1]; // start index for next line
        lines.pathIndices[indexMap.linePath++] = indexMap.linePosition;
        indexMap.linePosition += (end - start) / coordLength;
    }
}
/**
 * Fills (Multi)Polygon coordinates into polygons object of arrays
 *
 * @param geometry
 * @param polygons
 * @param indexMap
 * @param coordLength
 * @param properties
 */ function handlePolygon(geometry, polygons, indexMap, coordLength, properties) {
    polygons.positions.set(geometry.data, indexMap.polygonPosition * coordLength);
    const nPositions = geometry.data.length / coordLength;
    fillNumericProperties(polygons, properties, indexMap.polygonPosition, nPositions);
    polygons.globalFeatureIds.fill(indexMap.feature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);
    polygons.featureIds.fill(indexMap.polygonFeature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);
    // Unlike Point & LineString geometry.indices is a 2D array
    for(let l = 0, ll = geometry.indices.length; l < ll; ++l){
        const startPosition = indexMap.polygonPosition;
        polygons.polygonIndices[indexMap.polygonObject++] = startPosition;
        const areas = geometry.areas[l];
        const indices = geometry.indices[l];
        const nextIndices = geometry.indices[l + 1];
        for(let i = 0, il = indices.length; i < il; ++i){
            const start = indices[i];
            const end = i === il - 1 ? nextIndices === undefined ? geometry.data.length // end of data (no next indices)
             : nextIndices[0] // start of first line in nextIndices
             : indices[i + 1]; // start index for next line
            polygons.primitivePolygonIndices[indexMap.polygonRing++] = indexMap.polygonPosition;
            indexMap.polygonPosition += (end - start) / coordLength;
        }
        const endPosition = indexMap.polygonPosition;
        triangulatePolygon(polygons, areas, indices, {
            startPosition,
            endPosition,
            coordLength
        });
    }
}
/**
 * Triangulate polygon using earcut
 *
 * @param polygons
 * @param areas
 * @param indices
 * @param param3
 */ function triangulatePolygon(polygons, areas, indices, { startPosition, endPosition, coordLength }) {
    if (!polygons.triangles) {
        return;
    }
    const start = startPosition * coordLength;
    const end = endPosition * coordLength;
    // Extract positions and holes for just this polygon
    const polygonPositions = polygons.positions.subarray(start, end);
    // Holes are referenced relative to outer polygon
    const offset = indices[0];
    const holes = indices.slice(1).map((n)=>(n - offset) / coordLength);
    // Compute triangulation
    const triangles = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$earcut$2e$js__$5b$client$5d$__$28$ecmascript$29$__["earcut"])(polygonPositions, holes, coordLength, areas);
    // Indices returned by triangulation are relative to start
    // of polygon, so we need to offset
    for(let t = 0, tl = triangles.length; t < tl; ++t){
        polygons.triangles.push(startPosition + triangles[t]);
    }
}
/**
 * Wraps an object containing array into accessors
 *
 * @param obj
 * @param size
 */ function wrapProps(obj, size) {
    const returnObj = {};
    for(const key in obj){
        returnObj[key] = {
            value: obj[key],
            size
        };
    }
    return returnObj;
}
/**
 * Wrap each array in an accessor object with value and size keys
 *
 * @param points
 * @param lines
 * @param polygons
 * @param coordLength
 * @returns object
 */ function makeAccessorObjects(points, lines, polygons, coordLength) {
    const binaryFeatures = {
        shape: 'binary-feature-collection',
        points: {
            ...points,
            positions: {
                value: points.positions,
                size: coordLength
            },
            globalFeatureIds: {
                value: points.globalFeatureIds,
                size: 1
            },
            featureIds: {
                value: points.featureIds,
                size: 1
            },
            numericProps: wrapProps(points.numericProps, 1)
        },
        lines: {
            ...lines,
            positions: {
                value: lines.positions,
                size: coordLength
            },
            pathIndices: {
                value: lines.pathIndices,
                size: 1
            },
            globalFeatureIds: {
                value: lines.globalFeatureIds,
                size: 1
            },
            featureIds: {
                value: lines.featureIds,
                size: 1
            },
            numericProps: wrapProps(lines.numericProps, 1)
        },
        polygons: {
            ...polygons,
            positions: {
                value: polygons.positions,
                size: coordLength
            },
            polygonIndices: {
                value: polygons.polygonIndices,
                size: 1
            },
            primitivePolygonIndices: {
                value: polygons.primitivePolygonIndices,
                size: 1
            },
            globalFeatureIds: {
                value: polygons.globalFeatureIds,
                size: 1
            },
            featureIds: {
                value: polygons.featureIds,
                size: 1
            },
            numericProps: wrapProps(polygons.numericProps, 1)
        } // triangles not expected
    };
    if (binaryFeatures.polygons && polygons.triangles) {
        binaryFeatures.polygons.triangles = {
            value: new Uint32Array(polygons.triangles),
            size: 1
        };
    }
    return binaryFeatures;
}
/**
 * Add numeric properties to object
 *
 * @param object
 * @param properties
 * @param index
 * @param length
 */ function fillNumericProperties(object, properties, index, length) {
    for(const numericPropName in object.numericProps){
        if (numericPropName in properties) {
            const value = properties[numericPropName];
            object.numericProps[numericPropName].fill(value, index, index + length);
        }
    }
}
/**
 * Keep string properties in object
 *
 * @param properties
 * @param numericKeys
 * @returns object
 */ function keepStringProperties(properties, numericKeys) {
    const props = {};
    for(const key in properties){
        if (!numericKeys.includes(key)) {
            props[key] = properties[key];
        }
    }
    return props;
}
/**
 *
 * Deduce correct array constructor to use for a given value
 *
 * @param x value to test
 * @param constructor previous constructor deduced
 * @returns PropArrayConstructor
 */ function deduceArrayType(x, constructor) {
    if (constructor === Array || !Number.isFinite(x)) {
        return Array;
    }
    // If this or previous value required 64bits use Float64Array
    return constructor === Float64Array || Math.fround(x) !== x ? Float64Array : Float32Array;
}
}}),
"[project]/node_modules/@loaders.gl/compression/dist/lib/compression.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// Compression interface
__turbopack_context__.s({
    "Compression": (()=>Compression)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$iterators$2f$async$2d$iteration$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/iterators/async-iteration.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$module$2d$utils$2f$js$2d$module$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/module-utils/js-module-utils.js [client] (ecmascript)");
;
class Compression {
    constructor(options){
        this.compressBatches = this.compressBatches.bind(this);
        this.decompressBatches = this.decompressBatches.bind(this);
    }
    /** Preloads any dynamic libraries. May enable sync functions */ async preload(modules = {}) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$module$2d$utils$2f$js$2d$module$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["registerJSModules"])(modules);
        return;
    }
    /** Asynchronously compress data */ async compress(input) {
        await this.preload();
        return this.compressSync(input);
    }
    /** Asynchronously decompress data */ async decompress(input, size) {
        await this.preload();
        return this.decompressSync(input, size);
    }
    /** Synchronously compress data */ compressSync(input) {
        throw new Error(`${this.name}: sync compression not supported`);
    }
    /** Synchronously compress data */ decompressSync(input, size) {
        throw new Error(`${this.name}: sync decompression not supported`);
    }
    /** Compress batches */ async *compressBatches(asyncIterator) {
        // TODO - implement incremental compression
        const input = await this.concatenate(asyncIterator);
        yield this.compress(input);
    }
    /** Decompress batches */ async *decompressBatches(asyncIterator) {
        // TODO - implement incremental compression
        const input = await this.concatenate(asyncIterator);
        yield this.decompress(input);
    }
    // HELPERS
    concatenate(asyncIterator) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$iterators$2f$async$2d$iteration$2e$js__$5b$client$5d$__$28$ecmascript$29$__["concatenateArrayBuffersAsync"])(asyncIterator);
    }
    improveError(error) {
        if (!error.message.includes(this.name)) {
            error.message = `${this.name} ${error.message}`;
        }
        return error;
    }
}
}}),
"[project]/node_modules/@loaders.gl/compression/dist/lib/deflate-compression.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "DeflateCompression": (()=>DeflateCompression)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$compression$2f$dist$2f$lib$2f$compression$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/compression/dist/lib/compression.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/globals.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$binary$2d$utils$2f$memory$2d$conversion$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/memory-conversion-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$node$2f$promisify$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/node/promisify.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pako$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pako/index.js [client] (ecmascript)"); // https://bundlephobia.com/package/pako
;
;
;
;
class DeflateCompression extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$compression$2f$dist$2f$lib$2f$compression$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Compression"] {
    name = 'deflate';
    extensions = [];
    contentEncodings = [
        'deflate'
    ];
    isSupported = true;
    options;
    _chunks = [];
    constructor(options = {}){
        super(options);
        this.options = options;
    }
    async compress(input) {
        // On Node.js we can use built-in zlib
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBrowser"] && this.options.deflate?.useZlib) {
            const buffer = this.options.deflate?.gzip ? await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$node$2f$promisify$2e$js__$5b$client$5d$__$28$ecmascript$29$__["promisify1"])(zlib.gzip)(input) : await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$node$2f$promisify$2e$js__$5b$client$5d$__$28$ecmascript$29$__["promisify1"])(zlib.deflate)(input);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$binary$2d$utils$2f$memory$2d$conversion$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toArrayBuffer"])(buffer);
        }
        return this.compressSync(input);
    }
    async decompress(input) {
        // On Node.js we can use built-in zlib
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBrowser"] && this.options.deflate?.useZlib) {
            const buffer = this.options.deflate?.gzip ? await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$node$2f$promisify$2e$js__$5b$client$5d$__$28$ecmascript$29$__["promisify1"])(zlib.gunzip)(input) : await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$node$2f$promisify$2e$js__$5b$client$5d$__$28$ecmascript$29$__["promisify1"])(zlib.inflate)(input);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$binary$2d$utils$2f$memory$2d$conversion$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toArrayBuffer"])(buffer);
        }
        return this.decompressSync(input);
    }
    compressSync(input) {
        // On Node.js we can use built-in zlib
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBrowser"] && this.options.deflate?.useZlib) {
            const buffer = this.options.deflate?.gzip ? zlib.gzipSync(input) : zlib.deflateSync(input);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$binary$2d$utils$2f$memory$2d$conversion$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toArrayBuffer"])(buffer);
        }
        const pakoOptions = this.options?.deflate || {};
        const inputArray = new Uint8Array(input);
        const deflate = this.options?.raw ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pako$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].deflateRaw : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pako$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].deflate;
        return deflate(inputArray, pakoOptions).buffer;
    }
    decompressSync(input) {
        // On Node.js we can use built-in zlib
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBrowser"] && this.options.deflate?.useZlib) {
            const buffer = this.options.deflate?.gzip ? zlib.gunzipSync(input) : zlib.inflateSync(input);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$binary$2d$utils$2f$memory$2d$conversion$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toArrayBuffer"])(buffer);
        }
        const pakoOptions = this.options?.deflate || {};
        const inputArray = new Uint8Array(input);
        const inflate = this.options?.raw ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pako$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].inflateRaw : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pako$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].inflate;
        return inflate(inputArray, pakoOptions).buffer;
    }
    async *compressBatches(asyncIterator) {
        const pakoOptions = this.options?.deflate || {};
        const pakoProcessor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pako$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].Deflate(pakoOptions);
        yield* this.transformBatches(pakoProcessor, asyncIterator);
    }
    async *decompressBatches(asyncIterator) {
        const pakoOptions = this.options?.deflate || {};
        const pakoProcessor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pako$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].Inflate(pakoOptions);
        yield* this.transformBatches(pakoProcessor, asyncIterator);
    }
    async *transformBatches(pakoProcessor, asyncIterator) {
        pakoProcessor.onData = this._onData.bind(this);
        pakoProcessor.onEnd = this._onEnd.bind(this);
        for await (const chunk of asyncIterator){
            const uint8Array = new Uint8Array(chunk);
            const ok = pakoProcessor.push(uint8Array, false); // false -> not last chunk
            if (!ok) {
                throw new Error(`${this._getError()}write`);
            }
            const chunks = this._getChunks();
            yield* chunks;
        }
        // End
        const emptyChunk = new Uint8Array(0);
        const ok = pakoProcessor.push(emptyChunk, true); // true -> last chunk
        if (!ok) {
        // For some reason we get error but it still works???
        // throw new Error(this._getError() + 'end');
        }
        const chunks = this._getChunks();
        yield* chunks;
    }
    _onData(chunk) {
        this._chunks.push(chunk);
    }
    _onEnd(status) {
        if (status !== 0) {
            throw new Error(this._getError(status) + this._chunks.length);
        }
    }
    _getChunks() {
        const chunks = this._chunks;
        this._chunks = [];
        return chunks;
    }
    // TODO - For some reason we don't get the error message from pako in _onEnd?
    _getError(code = 0) {
        const MESSAGES = {
            /* Z_NEED_DICT       2  */ 2: 'need dictionary',
            /* Z_STREAM_END      1  */ 1: 'stream end',
            /* Z_OK              0  */ 0: '',
            /* Z_ERRNO         (-1) */ '-1': 'file error',
            /* Z_STREAM_ERROR  (-2) */ '-2': 'stream error',
            /* Z_DATA_ERROR    (-3) */ '-3': 'data error',
            /* Z_MEM_ERROR     (-4) */ '-4': 'insufficient memory',
            /* Z_BUF_ERROR     (-5) */ '-5': 'buffer error',
            /* Z_VERSION_ERROR (-6) */ '-6': 'incompatible version'
        };
        return `${this.name}: ${MESSAGES[code]}`;
    }
}
}}),
"[project]/node_modules/@loaders.gl/compression/dist/lib/gzip-compression.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "GZipCompression": (()=>GZipCompression)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$compression$2f$dist$2f$lib$2f$deflate$2d$compression$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/compression/dist/lib/deflate-compression.js [client] (ecmascript)");
;
class GZipCompression extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$compression$2f$dist$2f$lib$2f$deflate$2d$compression$2e$js__$5b$client$5d$__$28$ecmascript$29$__["DeflateCompression"] {
    name = 'gzip';
    extensions = [
        'gz',
        'gzip'
    ];
    contentEncodings = [
        'gzip',
        'x-gzip'
    ];
    isSupported = true;
    constructor(options){
        super({
            ...options,
            deflate: {
                ...options?.gzip,
                gzip: true
            }
        });
    }
}
}}),
"[project]/node_modules/@loaders.gl/mvt/dist/lib/utils/geometry-utils.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright vis.gl contributors
__turbopack_context__.s({
    "classifyRings": (()=>classifyRings),
    "classifyRingsFlat": (()=>classifyRingsFlat),
    "convertToLocalCoordinates": (()=>convertToLocalCoordinates),
    "convertToLocalCoordinatesFlat": (()=>convertToLocalCoordinatesFlat),
    "projectToLngLat": (()=>projectToLngLat),
    "projectToLngLatFlat": (()=>projectToLngLatFlat),
    "signedArea": (()=>signedArea)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/polygon/dist/index.js [client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$polygon$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/polygon/dist/polygon-utils.js [client] (ecmascript)");
;
function signedArea(ring) {
    let sum = 0;
    for(let i = 0, j = ring.length - 1, p1, p2; i < ring.length; j = i++){
        p1 = ring[i];
        p2 = ring[j];
        sum += (p2[0] - p1[0]) * (p1[1] + p2[1]);
    }
    return sum;
}
function convertToLocalCoordinates(coordinates, extent) {
    if (Array.isArray(coordinates[0])) {
        for (const subcoords of coordinates){
            convertToLocalCoordinates(subcoords, extent);
        }
        return;
    }
    // Just a point
    const p = coordinates;
    p[0] /= extent;
    p[1] /= extent;
}
function convertToLocalCoordinatesFlat(data, extent) {
    for(let i = 0; i < data.length; ++i){
        data[i] /= extent;
    }
}
function projectToLngLat(line, tileIndex, extent) {
    if (typeof line[0][0] !== 'number') {
        for (const point of line){
            // @ts-expect-error
            projectToLngLat(point, tileIndex, extent);
        }
        return;
    }
    const size = extent * Math.pow(2, tileIndex.z);
    const x0 = extent * tileIndex.x;
    const y0 = extent * tileIndex.y;
    for(let j = 0; j < line.length; j++){
        const p = line[j];
        p[0] = (p[0] + x0) * 360 / size - 180;
        const y2 = 180 - (p[1] + y0) * 360 / size;
        p[1] = 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;
    }
}
function projectToLngLatFlat(data, tileIndex, extent) {
    const { x, y, z } = tileIndex;
    const size = extent * Math.pow(2, z);
    const x0 = extent * x;
    const y0 = extent * y;
    for(let j = 0, jl = data.length; j < jl; j += 2){
        data[j] = (data[j] + x0) * 360 / size - 180;
        const y2 = 180 - (data[j + 1] + y0) * 360 / size;
        data[j + 1] = 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;
    }
}
function classifyRings(rings) {
    const len = rings.length;
    if (len <= 1) return [
        rings
    ];
    const polygons = [];
    let polygon;
    let ccw;
    for(let i = 0; i < len; i++){
        const area = signedArea(rings[i]);
        if (area === 0) continue; // eslint-disable-line no-continue
        if (ccw === undefined) ccw = area < 0;
        if (ccw === area < 0) {
            if (polygon) polygons.push(polygon);
            polygon = [
                rings[i]
            ];
        } else if (polygon) polygon.push(rings[i]);
    }
    if (polygon) polygons.push(polygon);
    return polygons;
}
function classifyRingsFlat(geom) {
    const len = geom.indices.length;
    const type = 'Polygon';
    if (len <= 1) {
        return {
            type,
            data: geom.data,
            areas: [
                [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$polygon$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getPolygonSignedArea"])(geom.data)
                ]
            ],
            indices: [
                geom.indices
            ]
        };
    }
    const areas = [];
    const polygons = [];
    let ringAreas = [];
    let polygon = [];
    let ccw;
    let offset = 0;
    for(let endIndex, i = 0, startIndex; i < len; i++){
        startIndex = geom.indices[i] - offset;
        endIndex = geom.indices[i + 1] - offset || geom.data.length;
        const shape = geom.data.slice(startIndex, endIndex);
        const area = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$polygon$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getPolygonSignedArea"])(shape);
        if (area === 0) {
            // This polygon has no area, so remove it from the shape
            // Remove the section from the data array
            const before = geom.data.slice(0, startIndex);
            const after = geom.data.slice(endIndex);
            geom.data = before.concat(after);
            // Need to offset any remaining indices as we have
            // modified the data buffer
            offset += endIndex - startIndex;
            continue; // eslint-disable-line no-continue
        }
        if (ccw === undefined) ccw = area < 0;
        if (ccw === area < 0) {
            if (polygon.length) {
                areas.push(ringAreas);
                polygons.push(polygon);
            }
            polygon = [
                startIndex
            ];
            ringAreas = [
                area
            ];
        } else {
            ringAreas.push(area);
            polygon.push(startIndex);
        }
    }
    if ("TURBOPACK compile-time truthy", 1) areas.push(ringAreas);
    if (polygon.length) polygons.push(polygon);
    return {
        type,
        areas,
        indices: polygons,
        data: geom.data
    };
}
}}),
"[project]/node_modules/@loaders.gl/mvt/dist/lib/vector-tile/vector-tile-feature.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright vis.gl contributors
__turbopack_context__.s({
    "VectorTileFeature": (()=>VectorTileFeature)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$mvt$2f$dist$2f$lib$2f$utils$2f$geometry$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/mvt/dist/lib/utils/geometry-utils.js [client] (ecmascript)");
;
class VectorTileFeature {
    properties;
    extent;
    type;
    id;
    _pbf;
    _geometry;
    _keys;
    _values;
    _geometryInfo;
    static types = [
        'Unknown',
        'Point',
        'LineString',
        'Polygon'
    ];
    // eslint-disable-next-line max-params
    constructor(pbf, end, extent, keys, values, geometryInfo){
        // Public
        this.properties = {};
        this.extent = extent;
        this.type = 0;
        this.id = null;
        // Private
        this._pbf = pbf;
        this._geometry = -1;
        this._keys = keys;
        this._values = values;
        // Only used by binary tiles
        this._geometryInfo = geometryInfo;
        pbf.readFields(readFeature, this, end);
    }
    toGeoJSONFeature(coordinates, tileIndex) {
        const coords = this.loadGeometry();
        switch(coordinates){
            case 'wgs84':
                return _toGeoJSONFeature(this, coords, (line)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$mvt$2f$dist$2f$lib$2f$utils$2f$geometry$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["projectToLngLat"])(line, tileIndex, this.extent));
            default:
                return _toGeoJSONFeature(this, coords, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$mvt$2f$dist$2f$lib$2f$utils$2f$geometry$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["convertToLocalCoordinates"]);
        }
    }
    /**
     *
     * @param options
     * @returns
     */ toBinaryFeature(coordinates, tileIndex) {
        const geom = this.loadFlatGeometry();
        switch(coordinates){
            case 'wgs84':
                return this._toBinaryCoordinates(geom, (coords)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$mvt$2f$dist$2f$lib$2f$utils$2f$geometry$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["projectToLngLatFlat"])(coords, tileIndex, this.extent));
            default:
                return this._toBinaryCoordinates(geom, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$mvt$2f$dist$2f$lib$2f$utils$2f$geometry$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["convertToLocalCoordinatesFlat"]);
        }
    }
    /** Read a bounding box from the feature */ // eslint-disable-next-line max-statements
    bbox() {
        const pbf = this._pbf;
        pbf.pos = this._geometry;
        const end = pbf.readVarint() + pbf.pos;
        let cmd = 1;
        let length = 0;
        let x = 0;
        let y = 0;
        let x1 = Infinity;
        let x2 = -Infinity;
        let y1 = Infinity;
        let y2 = -Infinity;
        while(pbf.pos < end){
            if (length <= 0) {
                const cmdLen = pbf.readVarint();
                cmd = cmdLen & 0x7;
                length = cmdLen >> 3;
            }
            length--;
            if (cmd === 1 || cmd === 2) {
                x += pbf.readSVarint();
                y += pbf.readSVarint();
                if (x < x1) x1 = x;
                if (x > x2) x2 = x;
                if (y < y1) y1 = y;
                if (y > y2) y2 = y;
            } else if (cmd !== 7) {
                throw new Error(`unknown command ${cmd}`);
            }
        }
        return [
            x1,
            y1,
            x2,
            y2
        ];
    }
    // BINARY HELPERS
    /**
     *
     * @param transform
     * @returns result
     */ _toBinaryCoordinates(geom, transform) {
        let geometry;
        // Apply the supplied transformation to data
        transform(geom.data, this.extent);
        const coordLength = 2;
        // eslint-disable-next-line default-case
        switch(this.type){
            case 1:
                this._geometryInfo.pointFeaturesCount++;
                this._geometryInfo.pointPositionsCount += geom.indices.length;
                geometry = {
                    type: 'Point',
                    ...geom
                };
                break;
            case 2:
                this._geometryInfo.lineFeaturesCount++;
                this._geometryInfo.linePathsCount += geom.indices.length;
                this._geometryInfo.linePositionsCount += geom.data.length / coordLength;
                geometry = {
                    type: 'LineString',
                    ...geom
                };
                break;
            case 3:
                geometry = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$mvt$2f$dist$2f$lib$2f$utils$2f$geometry$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["classifyRingsFlat"])(geom);
                // Unlike Point & LineString geom.indices is a 2D array, thanks
                // to the classifyRings method
                this._geometryInfo.polygonFeaturesCount++;
                this._geometryInfo.polygonObjectsCount += geometry.indices.length;
                for (const indices of geometry.indices){
                    this._geometryInfo.polygonRingsCount += indices.length;
                }
                this._geometryInfo.polygonPositionsCount += geometry.data.length / coordLength;
                break;
            default:
                throw new Error(`Invalid geometry type: ${this.type}`);
        }
        const result = {
            type: 'Feature',
            geometry,
            properties: this.properties
        };
        if (this.id !== null) {
            result.id = this.id;
        }
        return result;
    }
    // GEOJSON HELPER
    // eslint-disable-next-line complexity, max-statements
    loadGeometry() {
        const pbf = this._pbf;
        pbf.pos = this._geometry;
        const end = pbf.readVarint() + pbf.pos;
        let cmd = 1;
        let length = 0;
        let x = 0;
        let y = 0;
        const lines = [];
        let line;
        while(pbf.pos < end){
            if (length <= 0) {
                const cmdLen = pbf.readVarint();
                cmd = cmdLen & 0x7;
                length = cmdLen >> 3;
            }
            length--;
            switch(cmd){
                case 1:
                case 2:
                    x += pbf.readSVarint();
                    y += pbf.readSVarint();
                    if (cmd === 1) {
                        // moveTo
                        if (line) lines.push(line);
                        line = [];
                    }
                    if (line) line.push([
                        x,
                        y
                    ]);
                    break;
                case 7:
                    // Workaround for https://github.com/mapbox/mapnik-vector-tile/issues/90
                    if (line) {
                        line.push(line[0].slice()); // closePolygon
                    }
                    break;
                default:
                    throw new Error(`unknown command ${cmd}`);
            }
        }
        if (line) lines.push(line);
        return lines;
    }
    /**
     * Expands the protobuf data to an intermediate Flat GeoJSON
     * data format, which maps closely to the binary data buffers.
     * It is similar to GeoJSON, but rather than storing the coordinates
     * in multidimensional arrays, we have a 1D `data` with all the
     * coordinates, and then index into this using the `indices`
     * parameter, e.g.
     *
     * geometry: {
     *   type: 'Point', data: [1,2], indices: [0]
     * }
     * geometry: {
     *   type: 'LineString', data: [1,2,3,4,...], indices: [0]
     * }
     * geometry: {
     *   type: 'Polygon', data: [1,2,3,4,...], indices: [[0, 2]]
     * }
     * Thus the indices member lets us look up the relevant range
     * from the data array.
     * The Multi* versions of the above types share the same data
     * structure, just with multiple elements in the indices array
     */ // eslint-disable-next-line complexity, max-statements
    loadFlatGeometry() {
        const pbf = this._pbf;
        pbf.pos = this._geometry;
        const endPos = pbf.readVarint() + pbf.pos;
        let cmd = 1;
        let cmdLen;
        let length = 0;
        let x = 0;
        let y = 0;
        let i = 0;
        // Note: I attempted to replace the `data` array with a
        // Float32Array, but performance was worse, both using
        // `set()` and direct index access. Also, we cannot
        // know how large the buffer should be, so it would
        // increase memory usage
        const indices = []; // Indices where geometries start
        const data = []; // Flat array of coordinate data
        while(pbf.pos < endPos){
            if (length <= 0) {
                cmdLen = pbf.readVarint();
                cmd = cmdLen & 0x7;
                length = cmdLen >> 3;
            }
            length--;
            if (cmd === 1 || cmd === 2) {
                x += pbf.readSVarint();
                y += pbf.readSVarint();
                if (cmd === 1) {
                    // New line
                    indices.push(i);
                }
                data.push(x, y);
                i += 2;
            } else if (cmd === 7) {
                // Workaround for https://github.com/mapbox/mapnik-vector-tile/issues/90
                if (i > 0) {
                    const start = indices[indices.length - 1]; // start index of polygon
                    data.push(data[start], data[start + 1]); // closePolygon
                    i += 2;
                }
            } else {
                throw new Error(`unknown command ${cmd}`);
            }
        }
        return {
            data,
            indices
        };
    }
}
function _toGeoJSONFeature(vtFeature, coords, transform) {
    let type = VectorTileFeature.types[vtFeature.type];
    let i;
    let j;
    let coordinates;
    switch(vtFeature.type){
        case 1:
            const points = [];
            for(i = 0; i < coords.length; i++){
                points[i] = coords[i][0];
            }
            coordinates = points;
            transform(coordinates, vtFeature.extent);
            break;
        case 2:
            coordinates = coords;
            for(i = 0; i < coordinates.length; i++){
                transform(coordinates[i], vtFeature.extent);
            }
            break;
        case 3:
            coordinates = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$mvt$2f$dist$2f$lib$2f$utils$2f$geometry$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["classifyRings"])(coords);
            for(i = 0; i < coordinates.length; i++){
                for(j = 0; j < coordinates[i].length; j++){
                    transform(coordinates[i][j], vtFeature.extent);
                }
            }
            break;
        default:
            throw new Error('illegal vector tile type');
    }
    if (coordinates.length === 1) {
        // @ts-expect-error
        coordinates = coordinates[0];
    } else {
        type = `Multi${type}`;
    }
    const result = {
        type: 'Feature',
        geometry: {
            type: type,
            coordinates: coordinates
        },
        properties: vtFeature.properties
    };
    if (vtFeature.id !== null) {
        result.properties ||= {};
        result.properties.id = vtFeature.id;
    }
    return result;
}
// PBF READER UTILS
/**
 *
 * @param tag
 * @param feature
 * @param pbf
 */ function readFeature(tag, feature, pbf) {
    if (feature && pbf) {
        if (tag === 1) feature.id = pbf.readVarint();
        else if (tag === 2) readTag(pbf, feature);
        else if (tag === 3) feature.type = pbf.readVarint();
        else if (tag === 4) feature._geometry = pbf.pos;
    }
}
/**
 *
 * @param pbf
 * @param feature
 */ function readTag(pbf, feature) {
    const end = pbf.readVarint() + pbf.pos;
    while(pbf.pos < end){
        const key = feature._keys[pbf.readVarint()];
        const value = feature._values[pbf.readVarint()];
        feature.properties[key] = value;
    }
}
}}),
"[project]/node_modules/@loaders.gl/mvt/dist/lib/vector-tile/vector-tile-layer.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright vis.gl contributors
__turbopack_context__.s({
    "VectorTileLayer": (()=>VectorTileLayer)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$mvt$2f$dist$2f$lib$2f$vector$2d$tile$2f$vector$2d$tile$2d$feature$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/mvt/dist/lib/vector-tile/vector-tile-feature.js [client] (ecmascript)");
;
class VectorTileLayer {
    version;
    name;
    extent;
    length;
    _pbf;
    _keys;
    _values;
    _features;
    constructor(pbf, end){
        // Public
        this.version = 1;
        this.name = '';
        this.extent = 4096;
        this.length = 0;
        // Private
        this._pbf = pbf;
        this._keys = [];
        this._values = [];
        this._features = [];
        pbf.readFields(readLayer, this, end);
        this.length = this._features.length;
    }
    /**
     * return feature `i` from this layer as a `VectorTileFeature`
     * @param index
     * @returns feature
     */ getGeoJSONFeature(i) {
        if (i < 0 || i >= this._features.length) {
            throw new Error('feature index out of bounds');
        }
        this._pbf.pos = this._features[i];
        const end = this._pbf.readVarint() + this._pbf.pos;
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$mvt$2f$dist$2f$lib$2f$vector$2d$tile$2f$vector$2d$tile$2d$feature$2e$js__$5b$client$5d$__$28$ecmascript$29$__["VectorTileFeature"](this._pbf, end, this.extent, this._keys, this._values);
    }
    /**
     * return binary feature `i` from this layer as a `VectorTileFeature`
     *
     * @param index
     * @param geometryInfo
     * @returns binary feature
     */ getBinaryFeature(i, geometryInfo) {
        if (i < 0 || i >= this._features.length) {
            throw new Error('feature index out of bounds');
        }
        this._pbf.pos = this._features[i];
        const end = this._pbf.readVarint() + this._pbf.pos;
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$mvt$2f$dist$2f$lib$2f$vector$2d$tile$2f$vector$2d$tile$2d$feature$2e$js__$5b$client$5d$__$28$ecmascript$29$__["VectorTileFeature"](this._pbf, end, this.extent, this._keys, this._values, geometryInfo);
    }
}
/**
 *
 * @param tag
 * @param layer
 * @param pbf
 */ function readLayer(tag, layer, pbf) {
    if (layer && pbf) {
        if (tag === 15) layer.version = pbf.readVarint();
        else if (tag === 1) layer.name = pbf.readString();
        else if (tag === 5) layer.extent = pbf.readVarint();
        else if (tag === 2) layer._features.push(pbf.pos);
        else if (tag === 3) layer._keys.push(pbf.readString());
        else if (tag === 4) layer._values.push(readValueMessage(pbf));
    }
}
/**
 *
 * @param pbf
 * @returns value
 */ function readValueMessage(pbf) {
    let value = null;
    const end = pbf.readVarint() + pbf.pos;
    while(pbf.pos < end){
        const tag = pbf.readVarint() >> 3;
        value = tag === 1 ? pbf.readString() : tag === 2 ? pbf.readFloat() : tag === 3 ? pbf.readDouble() : tag === 4 ? pbf.readVarint64() : tag === 5 ? pbf.readVarint() : tag === 6 ? pbf.readSVarint() : tag === 7 ? pbf.readBoolean() : null;
    }
    return value;
}
}}),
"[project]/node_modules/@loaders.gl/mvt/dist/lib/vector-tile/vector-tile.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright vis.gl contributors
// This code is forked from https://github.com/mapbox/vector-tile-js under BSD 3-clause license.
__turbopack_context__.s({
    "VectorTile": (()=>VectorTile)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$mvt$2f$dist$2f$lib$2f$vector$2d$tile$2f$vector$2d$tile$2d$layer$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/mvt/dist/lib/vector-tile/vector-tile-layer.js [client] (ecmascript)");
;
class VectorTile {
    layers;
    constructor(pbf, end){
        this.layers = pbf.readFields(readTile, {}, end);
    }
}
/**
 *
 * @param tag
 * @param layers
 * @param pbf
 */ function readTile(tag, layers, pbf) {
    if (tag === 3) {
        if (pbf) {
            const layer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$mvt$2f$dist$2f$lib$2f$vector$2d$tile$2f$vector$2d$tile$2d$layer$2e$js__$5b$client$5d$__$28$ecmascript$29$__["VectorTileLayer"](pbf, pbf.readVarint() + pbf.pos);
            if (layer.length && layers) {
                layers[layer.name] = layer;
            }
        }
    }
}
}}),
"[project]/node_modules/@loaders.gl/mvt/dist/lib/parse-mvt.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright vis.gl contributors
__turbopack_context__.s({
    "parseMVT": (()=>parseMVT)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$gis$2f$dist$2f$lib$2f$binary$2d$features$2f$flat$2d$geojson$2d$to$2d$binary$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/gis/dist/lib/binary-features/flat-geojson-to-binary.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$log$2d$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/log-utils/log.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pbf$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pbf/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$mvt$2f$dist$2f$lib$2f$vector$2d$tile$2f$vector$2d$tile$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/mvt/dist/lib/vector-tile/vector-tile.js [client] (ecmascript)");
;
;
;
;
function parseMVT(arrayBuffer, options) {
    const mvtOptions = checkOptions(options);
    const shape = options?.gis?.format || options?.mvt?.shape || options?.shape;
    switch(shape){
        case 'columnar-table':
            return {
                shape: 'columnar-table',
                data: parseToBinary(arrayBuffer, mvtOptions)
            };
        case 'geojson-table':
            {
                const table = {
                    shape: 'geojson-table',
                    type: 'FeatureCollection',
                    features: parseToGeojsonFeatures(arrayBuffer, mvtOptions)
                };
                return table;
            }
        case 'geojson':
            return parseToGeojsonFeatures(arrayBuffer, mvtOptions);
        case 'binary-geometry':
            return parseToBinary(arrayBuffer, mvtOptions);
        case 'binary':
            return parseToBinary(arrayBuffer, mvtOptions);
        default:
            throw new Error(shape || 'undefined shape');
    }
}
function parseToBinary(arrayBuffer, options) {
    const [flatGeoJsonFeatures, geometryInfo] = parseToFlatGeoJson(arrayBuffer, options);
    const binaryData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$gis$2f$dist$2f$lib$2f$binary$2d$features$2f$flat$2d$geojson$2d$to$2d$binary$2e$js__$5b$client$5d$__$28$ecmascript$29$__["flatGeojsonToBinary"])(flatGeoJsonFeatures, geometryInfo);
    // Add the original byteLength (as a reasonable approximation of the size of the binary data)
    // TODO decide where to store extra fields like byteLength (header etc) and document
    // @ts-ignore
    binaryData.byteLength = arrayBuffer.byteLength;
    return binaryData;
}
function parseToFlatGeoJson(arrayBuffer, options) {
    const features = [];
    const geometryInfo = {
        coordLength: 2,
        pointPositionsCount: 0,
        pointFeaturesCount: 0,
        linePositionsCount: 0,
        linePathsCount: 0,
        lineFeaturesCount: 0,
        polygonPositionsCount: 0,
        polygonObjectsCount: 0,
        polygonRingsCount: 0,
        polygonFeaturesCount: 0
    };
    if (arrayBuffer.byteLength <= 0) {
        return [
            features,
            geometryInfo
        ];
    }
    const tile = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$mvt$2f$dist$2f$lib$2f$vector$2d$tile$2f$vector$2d$tile$2e$js__$5b$client$5d$__$28$ecmascript$29$__["VectorTile"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pbf$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"](arrayBuffer));
    const selectedLayers = options && Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);
    selectedLayers.forEach((layerName)=>{
        const vectorTileLayer = tile.layers[layerName];
        if (!vectorTileLayer) {
            return;
        }
        for(let i = 0; i < vectorTileLayer.length; i++){
            const vectorTileFeature = vectorTileLayer.getBinaryFeature(i, geometryInfo);
            const decodedFeature = getDecodedFeatureBinary(vectorTileFeature, options, layerName);
            features.push(decodedFeature);
        }
    });
    return [
        features,
        geometryInfo
    ];
}
function parseToGeojsonFeatures(arrayBuffer, options) {
    if (arrayBuffer.byteLength <= 0) {
        return [];
    }
    const features = [];
    const tile = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$mvt$2f$dist$2f$lib$2f$vector$2d$tile$2f$vector$2d$tile$2e$js__$5b$client$5d$__$28$ecmascript$29$__["VectorTile"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pbf$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"](arrayBuffer));
    const selectedLayers = Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);
    selectedLayers.forEach((layerName)=>{
        const vectorTileLayer = tile.layers[layerName];
        if (!vectorTileLayer) {
            return;
        }
        for(let i = 0; i < vectorTileLayer.length; i++){
            const vectorTileFeature = vectorTileLayer.getGeoJSONFeature(i);
            const decodedFeature = getDecodedFeature(vectorTileFeature, options, layerName);
            features.push(decodedFeature);
        }
    });
    return features;
}
/** Check that options are good */ function checkOptions(options) {
    if (!options?.mvt) {
        throw new Error('mvt options required');
    }
    if (options.mvt?.coordinates === 'wgs84' && !options.mvt.tileIndex) {
        throw new Error('MVT Loader: WGS84 coordinates need tileIndex property');
    }
    if (options.gis) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$log$2d$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].warn('MVTLoader: "options.gis" is deprecated, use "options.mvt.shape" instead')();
    }
    return options.mvt;
}
/**
 * @param feature
 * @param options
 * @returns decoded feature
 */ function getDecodedFeature(feature, options, layerName) {
    const decodedFeature = feature.toGeoJSONFeature(options.coordinates || 'local', options.tileIndex);
    // Add layer name to GeoJSON properties
    if (options.layerProperty) {
        decodedFeature.properties ||= {};
        decodedFeature.properties[options.layerProperty] = layerName;
    }
    return decodedFeature;
}
/**
 * @param feature
 * @param options
 * @returns decoded binary feature
 */ function getDecodedFeatureBinary(feature, options, layerName) {
    const decodedFeature = feature.toBinaryFeature(options.coordinates || 'local', options.tileIndex);
    // Add layer name to GeoJSON properties
    if (options.layerProperty && decodedFeature.properties) {
        decodedFeature.properties[options.layerProperty] = layerName;
    }
    return decodedFeature;
}
}}),
"[project]/node_modules/@loaders.gl/mvt/dist/mvt-loader.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright vis.gl contributors
// import type {MVTOptions} from './lib/types';
__turbopack_context__.s({
    "MVTLoader": (()=>MVTLoader),
    "MVTWorkerLoader": (()=>MVTWorkerLoader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$mvt$2f$dist$2f$lib$2f$parse$2d$mvt$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/mvt/dist/lib/parse-mvt.js [client] (ecmascript)");
;
// __VERSION__ is injected by babel-plugin-version-inline
// @ts-ignore TS2304: Cannot find name '__VERSION__'.
const VERSION = typeof "4.3.2" !== 'undefined' ? "4.3.2" : 'latest';
const MVTWorkerLoader = {
    dataType: null,
    batchType: null,
    name: 'Mapbox Vector Tile',
    id: 'mvt',
    module: 'mvt',
    version: VERSION,
    // Note: ArcGIS uses '.pbf' extension and 'application/octet-stream'
    extensions: [
        'mvt',
        'pbf'
    ],
    mimeTypes: [
        // https://www.iana.org/assignments/media-types/application/vnd.mapbox-vector-tile
        'application/vnd.mapbox-vector-tile',
        'application/x-protobuf'
    ],
    worker: true,
    category: 'geometry',
    options: {
        mvt: {
            shape: 'geojson',
            coordinates: 'local',
            layerProperty: 'layerName',
            layers: undefined,
            tileIndex: undefined
        }
    }
};
const MVTLoader = {
    ...MVTWorkerLoader,
    parse: async (arrayBuffer, options)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$mvt$2f$dist$2f$lib$2f$parse$2d$mvt$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseMVT"])(arrayBuffer, options),
    parseSync: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$mvt$2f$dist$2f$lib$2f$parse$2d$mvt$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseMVT"],
    binary: true
};
}}),
}]);

//# sourceMappingURL=node_modules_%40loaders_gl_97411756._.js.map