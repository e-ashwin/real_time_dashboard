(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_@math_gl_de08079b._.js", {

"[project]/node_modules/@math.gl/web-mercator/dist/math-utils.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "clamp": (()=>clamp),
    "createMat4": (()=>createMat4),
    "lerp": (()=>lerp),
    "log2": (()=>log2),
    "mod": (()=>mod),
    "transformVector": (()=>transformVector)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec4$3e$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/gl-matrix/vec4.js [client] (ecmascript) <export * as vec4>");
;
function createMat4() {
    return [
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
    ];
}
function transformVector(matrix, vector) {
    const result = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec4$3e$__["vec4"].transformMat4([], vector, matrix);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec4$3e$__["vec4"].scale(result, result, 1 / result[3]);
    return result;
}
function mod(value, divisor) {
    const modulus = value % divisor;
    return modulus < 0 ? divisor + modulus : modulus;
}
function lerp(start, end, step) {
    return step * end + (1 - step) * start;
}
function clamp(x, min, max) {
    return x < min ? min : x > max ? max : x;
}
function ieLog2(x) {
    return Math.log(x) * Math.LOG2E;
}
const log2 = Math.log2 || ieLog2; //# sourceMappingURL=math-utils.js.map
}}),
"[project]/node_modules/@math.gl/web-mercator/dist/assert.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Replacement for the external assert method to reduce bundle size
// Note: We don't use the second "message" argument in calling code,
// so no need to support it here
__turbopack_context__.s({
    "assert": (()=>assert)
});
function assert(condition, message) {
    if (!condition) {
        throw new Error(message || '@math.gl/web-mercator: assertion failed.');
    }
} //# sourceMappingURL=assert.js.map
}}),
"[project]/node_modules/@math.gl/web-mercator/dist/web-mercator-utils.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// TODO - THE UTILITIES IN THIS FILE SHOULD BE IMPORTED FROM WEB-MERCATOR-VIEWPORT MODULE
__turbopack_context__.s({
    "DEFAULT_ALTITUDE": (()=>DEFAULT_ALTITUDE),
    "MAX_LATITUDE": (()=>MAX_LATITUDE),
    "addMetersToLngLat": (()=>addMetersToLngLat),
    "altitudeToFovy": (()=>altitudeToFovy),
    "fovyToAltitude": (()=>fovyToAltitude),
    "getDistanceScales": (()=>getDistanceScales),
    "getMeterZoom": (()=>getMeterZoom),
    "getProjectionMatrix": (()=>getProjectionMatrix),
    "getProjectionParameters": (()=>getProjectionParameters),
    "getViewMatrix": (()=>getViewMatrix),
    "lngLatToWorld": (()=>lngLatToWorld),
    "pixelsToWorld": (()=>pixelsToWorld),
    "scaleToZoom": (()=>scaleToZoom),
    "unitsPerMeter": (()=>unitsPerMeter),
    "worldToLngLat": (()=>worldToLngLat),
    "worldToPixels": (()=>worldToPixels),
    "zoomToScale": (()=>zoomToScale)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/math-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$mat4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__mat4$3e$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/gl-matrix/mat4.js [client] (ecmascript) <export * as mat4>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec2$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec2$3e$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/gl-matrix/vec2.js [client] (ecmascript) <export * as vec2>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec3$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec3$3e$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/gl-matrix/vec3.js [client] (ecmascript) <export * as vec3>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/assert.js [client] (ecmascript)");
;
;
;
// CONSTANTS
const PI = Math.PI;
const PI_4 = PI / 4;
const DEGREES_TO_RADIANS = PI / 180;
const RADIANS_TO_DEGREES = 180 / PI;
const TILE_SIZE = 512;
// Average circumference (40075 km equatorial, 40007 km meridional)
const EARTH_CIRCUMFERENCE = 40.03e6;
const MAX_LATITUDE = 85.051129;
const DEFAULT_ALTITUDE = 1.5;
function zoomToScale(zoom) {
    return Math.pow(2, zoom);
}
function scaleToZoom(scale) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log2"])(scale);
}
function lngLatToWorld(lngLat) {
    const [lng, lat] = lngLat;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(Number.isFinite(lng));
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(Number.isFinite(lat) && lat >= -90 && lat <= 90, 'invalid latitude');
    const lambda2 = lng * DEGREES_TO_RADIANS;
    const phi2 = lat * DEGREES_TO_RADIANS;
    const x = TILE_SIZE * (lambda2 + PI) / (2 * PI);
    const y = TILE_SIZE * (PI + Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);
    return [
        x,
        y
    ];
}
function worldToLngLat(xy) {
    const [x, y] = xy;
    const lambda2 = x / TILE_SIZE * (2 * PI) - PI;
    const phi2 = 2 * (Math.atan(Math.exp(y / TILE_SIZE * (2 * PI) - PI)) - PI_4);
    return [
        lambda2 * RADIANS_TO_DEGREES,
        phi2 * RADIANS_TO_DEGREES
    ];
}
function getMeterZoom(options) {
    const { latitude } = options;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(Number.isFinite(latitude));
    const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);
    return scaleToZoom(EARTH_CIRCUMFERENCE * latCosine) - 9;
}
function unitsPerMeter(latitude) {
    const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);
    return TILE_SIZE / EARTH_CIRCUMFERENCE / latCosine;
}
function getDistanceScales(options) {
    const { latitude, longitude, highPrecision = false } = options;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(Number.isFinite(latitude) && Number.isFinite(longitude));
    const worldSize = TILE_SIZE;
    const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);
    /**
     * Number of pixels occupied by one degree longitude around current lat/lon:
       unitsPerDegreeX = d(lngLatToWorld([lng, lat])[0])/d(lng)
         = scale * TILE_SIZE * DEGREES_TO_RADIANS / (2 * PI)
       unitsPerDegreeY = d(lngLatToWorld([lng, lat])[1])/d(lat)
         = -scale * TILE_SIZE * DEGREES_TO_RADIANS / cos(lat * DEGREES_TO_RADIANS)  / (2 * PI)
     */ const unitsPerDegreeX = worldSize / 360;
    const unitsPerDegreeY = unitsPerDegreeX / latCosine;
    /**
     * Number of pixels occupied by one meter around current lat/lon:
     */ const altUnitsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;
    /**
     * LngLat: longitude -> east and latitude -> north (bottom left)
     * UTM meter offset: x -> east and y -> north (bottom left)
     * World space: x -> east and y -> south (top left)
     *
     * Y needs to be flipped when converting delta degree/meter to delta pixels
     */ const result = {
        unitsPerMeter: [
            altUnitsPerMeter,
            altUnitsPerMeter,
            altUnitsPerMeter
        ],
        metersPerUnit: [
            1 / altUnitsPerMeter,
            1 / altUnitsPerMeter,
            1 / altUnitsPerMeter
        ],
        unitsPerDegree: [
            unitsPerDegreeX,
            unitsPerDegreeY,
            altUnitsPerMeter
        ],
        degreesPerUnit: [
            1 / unitsPerDegreeX,
            1 / unitsPerDegreeY,
            1 / altUnitsPerMeter
        ]
    };
    /**
     * Taylor series 2nd order for 1/latCosine
       f'(a) * (x - a)
         = d(1/cos(lat * DEGREES_TO_RADIANS))/d(lat) * dLat
         = DEGREES_TO_RADIANS * tan(lat * DEGREES_TO_RADIANS) / cos(lat * DEGREES_TO_RADIANS) * dLat
     */ if (highPrecision) {
        const latCosine2 = DEGREES_TO_RADIANS * Math.tan(latitude * DEGREES_TO_RADIANS) / latCosine;
        const unitsPerDegreeY2 = unitsPerDegreeX * latCosine2 / 2;
        const altUnitsPerDegree2 = worldSize / EARTH_CIRCUMFERENCE * latCosine2;
        const altUnitsPerMeter2 = altUnitsPerDegree2 / unitsPerDegreeY * altUnitsPerMeter;
        result.unitsPerDegree2 = [
            0,
            unitsPerDegreeY2,
            altUnitsPerDegree2
        ];
        result.unitsPerMeter2 = [
            altUnitsPerMeter2,
            0,
            altUnitsPerMeter2
        ];
    }
    // Main results, used for converting meters to latlng deltas and scaling offsets
    return result;
}
function addMetersToLngLat(lngLatZ, xyz) {
    const [longitude, latitude, z0] = lngLatZ;
    const [x, y, z] = xyz;
    // eslint-disable-next-line no-shadow
    const { unitsPerMeter, unitsPerMeter2 } = getDistanceScales({
        longitude,
        latitude,
        highPrecision: true
    });
    const worldspace = lngLatToWorld(lngLatZ);
    worldspace[0] += x * (unitsPerMeter[0] + unitsPerMeter2[0] * y);
    worldspace[1] += y * (unitsPerMeter[1] + unitsPerMeter2[1] * y);
    const newLngLat = worldToLngLat(worldspace);
    const newZ = (z0 || 0) + (z || 0);
    return Number.isFinite(z0) || Number.isFinite(z) ? [
        newLngLat[0],
        newLngLat[1],
        newZ
    ] : newLngLat;
}
function getViewMatrix(options) {
    const { // Viewport props
    height, pitch, bearing, altitude, // Pre-calculated parameters
    scale, center } = options;
    // VIEW MATRIX: PROJECTS MERCATOR WORLD COORDINATES
    // Note that mercator world coordinates typically need to be flipped
    //
    // Note: As usual, matrix operation orders should be read in reverse
    // since vectors will be multiplied from the right during transformation
    const vm = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["createMat4"])();
    // Move camera to altitude (along the pitch & bearing direction)
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$mat4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__mat4$3e$__["mat4"].translate(vm, vm, [
        0,
        0,
        -altitude
    ]);
    // Rotate by bearing, and then by pitch (which tilts the view)
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$mat4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__mat4$3e$__["mat4"].rotateX(vm, vm, -pitch * DEGREES_TO_RADIANS);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$mat4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__mat4$3e$__["mat4"].rotateZ(vm, vm, bearing * DEGREES_TO_RADIANS);
    const relativeScale = scale / height;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$mat4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__mat4$3e$__["mat4"].scale(vm, vm, [
        relativeScale,
        relativeScale,
        relativeScale
    ]);
    if (center) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$mat4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__mat4$3e$__["mat4"].translate(vm, vm, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec3$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec3$3e$__["vec3"].negate([], center));
    }
    return vm;
}
function getProjectionParameters(options) {
    const { width, height, altitude, pitch = 0, offset, center, scale, nearZMultiplier = 1, farZMultiplier = 1 } = options;
    let { fovy = altitudeToFovy(DEFAULT_ALTITUDE) } = options;
    // For back-compatibility allow field of view to be
    // derived from altitude
    if (altitude !== undefined) {
        fovy = altitudeToFovy(altitude);
    }
    const fovRadians = fovy * DEGREES_TO_RADIANS;
    const pitchRadians = pitch * DEGREES_TO_RADIANS;
    // Distance from camera to the target
    const focalDistance = fovyToAltitude(fovy);
    let cameraToSeaLevelDistance = focalDistance;
    if (center) {
        cameraToSeaLevelDistance += center[2] * scale / Math.cos(pitchRadians) / height;
    }
    const fovAboveCenter = fovRadians * (0.5 + (offset ? offset[1] : 0) / height);
    // Find the distance from the center point to the center top
    // in focal distance units using law of sines.
    const topHalfSurfaceDistance = Math.sin(fovAboveCenter) * cameraToSeaLevelDistance / Math.sin((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["clamp"])(Math.PI / 2 - pitchRadians - fovAboveCenter, 0.01, Math.PI - 0.01));
    // Calculate z distance of the farthest fragment that should be rendered.
    const furthestDistance = Math.sin(pitchRadians) * topHalfSurfaceDistance + cameraToSeaLevelDistance;
    // Matches mapbox limit
    const horizonDistance = cameraToSeaLevelDistance * 10;
    // Calculate z value of the farthest fragment that should be rendered.
    const farZ = Math.min(furthestDistance * farZMultiplier, horizonDistance);
    return {
        fov: fovRadians,
        aspect: width / height,
        focalDistance,
        near: nearZMultiplier,
        far: farZ
    };
}
function getProjectionMatrix(options) {
    const { fov, aspect, near, far } = getProjectionParameters(options);
    const projectionMatrix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$mat4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__mat4$3e$__["mat4"].perspective([], fov, aspect, near, far // far plane
    );
    return projectionMatrix;
}
function altitudeToFovy(altitude) {
    return 2 * Math.atan(0.5 / altitude) * RADIANS_TO_DEGREES;
}
function fovyToAltitude(fovy) {
    return 0.5 / Math.tan(0.5 * fovy * DEGREES_TO_RADIANS);
}
function worldToPixels(xyz, pixelProjectionMatrix) {
    const [x, y, z = 0] = xyz;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z));
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["transformVector"])(pixelProjectionMatrix, [
        x,
        y,
        z,
        1
    ]);
}
function pixelsToWorld(xyz, pixelUnprojectionMatrix, targetZ = 0) {
    const [x, y, z] = xyz;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(Number.isFinite(x) && Number.isFinite(y), 'invalid pixel coordinate');
    if (Number.isFinite(z)) {
        // Has depth component
        const coord = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["transformVector"])(pixelUnprojectionMatrix, [
            x,
            y,
            z,
            1
        ]);
        return coord;
    }
    // since we don't know the correct projected z value for the point,
    // unproject two points to get a line and then find the point on that line with z=0
    const coord0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["transformVector"])(pixelUnprojectionMatrix, [
        x,
        y,
        0,
        1
    ]);
    const coord1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["transformVector"])(pixelUnprojectionMatrix, [
        x,
        y,
        1,
        1
    ]);
    const z0 = coord0[2];
    const z1 = coord1[2];
    const t = z0 === z1 ? 0 : ((targetZ || 0) - z0) / (z1 - z0);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec2$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec2$3e$__["vec2"].lerp([], coord0, coord1, t);
} //# sourceMappingURL=web-mercator-utils.js.map
}}),
"[project]/node_modules/@math.gl/web-mercator/dist/fit-bounds.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "fitBounds": (()=>fitBounds)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/assert.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/math-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/web-mercator-utils.js [client] (ecmascript)");
;
;
;
function fitBounds(options) {
    const { width, height, bounds, minExtent = 0, maxZoom = 24, offset = [
        0,
        0
    ] } = options;
    const [[west, south], [east, north]] = bounds;
    const padding = getPaddingObject(options.padding);
    const nw = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["lngLatToWorld"])([
        west,
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["clamp"])(north, -__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["MAX_LATITUDE"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["MAX_LATITUDE"])
    ]);
    const se = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["lngLatToWorld"])([
        east,
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["clamp"])(south, -__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["MAX_LATITUDE"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["MAX_LATITUDE"])
    ]);
    // width/height on the Web Mercator plane
    const size = [
        Math.max(Math.abs(se[0] - nw[0]), minExtent),
        Math.max(Math.abs(se[1] - nw[1]), minExtent)
    ];
    const targetSize = [
        width - padding.left - padding.right - Math.abs(offset[0]) * 2,
        height - padding.top - padding.bottom - Math.abs(offset[1]) * 2
    ];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(targetSize[0] > 0 && targetSize[1] > 0);
    // scale = screen pixels per unit on the Web Mercator plane
    const scaleX = targetSize[0] / size[0];
    const scaleY = targetSize[1] / size[1];
    // Find how much we need to shift the center
    const offsetX = (padding.right - padding.left) / 2 / scaleX;
    const offsetY = (padding.top - padding.bottom) / 2 / scaleY;
    const center = [
        (se[0] + nw[0]) / 2 + offsetX,
        (se[1] + nw[1]) / 2 + offsetY
    ];
    const centerLngLat = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["worldToLngLat"])(center);
    const zoom = Math.min(maxZoom, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log2"])(Math.abs(Math.min(scaleX, scaleY))));
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(Number.isFinite(zoom));
    return {
        longitude: centerLngLat[0],
        latitude: centerLngLat[1],
        zoom
    };
}
// Helpers
function getPaddingObject(padding = 0) {
    if (typeof padding === 'number') {
        return {
            top: padding,
            bottom: padding,
            left: padding,
            right: padding
        };
    }
    // Make sure all the required properties are set
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(Number.isFinite(padding.top) && Number.isFinite(padding.bottom) && Number.isFinite(padding.left) && Number.isFinite(padding.right));
    return padding;
} //# sourceMappingURL=fit-bounds.js.map
}}),
"[project]/node_modules/@math.gl/web-mercator/dist/get-bounds.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* eslint-disable camelcase */ __turbopack_context__.s({
    "getBounds": (()=>getBounds)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec2$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec2$3e$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/gl-matrix/vec2.js [client] (ecmascript) <export * as vec2>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/web-mercator-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/math-utils.js [client] (ecmascript)");
;
;
;
const DEGREES_TO_RADIANS = Math.PI / 180;
function getBounds(viewport, z = 0) {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    const { width, height, unproject } = viewport;
    const unprojectOps = {
        targetZ: z
    };
    const bottomLeft = unproject([
        0,
        height
    ], unprojectOps);
    const bottomRight = unproject([
        width,
        height
    ], unprojectOps);
    let topLeft;
    let topRight;
    const halfFov = viewport.fovy ? 0.5 * viewport.fovy * DEGREES_TO_RADIANS : Math.atan(0.5 / viewport.altitude);
    const angleToGround = (90 - viewport.pitch) * DEGREES_TO_RADIANS;
    // The top plane is parallel to the ground if halfFov == angleToGround
    if (halfFov > angleToGround - 0.01) {
        // intersect with the far plane
        topLeft = unprojectOnFarPlane(viewport, 0, z);
        topRight = unprojectOnFarPlane(viewport, width, z);
    } else {
        // intersect with the top plane
        topLeft = unproject([
            0,
            0
        ], unprojectOps);
        topRight = unproject([
            width,
            0
        ], unprojectOps);
    }
    return [
        bottomLeft,
        bottomRight,
        topRight,
        topLeft
    ];
}
/*
 * Find a point on the far clipping plane of the viewport
 * @param {WebMercatorViewport} viewport
 * @param {Number} x - projected x in screen space
 * @param {Number} targetZ - the elevation of the point in meters
 */ function unprojectOnFarPlane(viewport, x, targetZ) {
    const { pixelUnprojectionMatrix } = viewport;
    const coord0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["transformVector"])(pixelUnprojectionMatrix, [
        x,
        0,
        1,
        1
    ]);
    const coord1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["transformVector"])(pixelUnprojectionMatrix, [
        x,
        viewport.height,
        1,
        1
    ]);
    const z = targetZ * viewport.distanceScales.unitsPerMeter[2];
    const t = (z - coord0[2]) / (coord1[2] - coord0[2]);
    const coord = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec2$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec2$3e$__["vec2"].lerp([], coord0, coord1, t);
    const result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["worldToLngLat"])(coord);
    result.push(targetZ);
    return result;
} //# sourceMappingURL=get-bounds.js.map
}}),
"[project]/node_modules/@math.gl/web-mercator/dist/web-mercator-viewport.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// View and Projection Matrix calculations for mapbox-js style map view properties
__turbopack_context__.s({
    "WebMercatorViewport": (()=>WebMercatorViewport)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/math-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/web-mercator-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$fit$2d$bounds$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/fit-bounds.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$get$2d$bounds$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/get-bounds.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$mat4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__mat4$3e$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/gl-matrix/mat4.js [client] (ecmascript) <export * as mat4>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec2$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec2$3e$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/gl-matrix/vec2.js [client] (ecmascript) <export * as vec2>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec3$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec3$3e$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/gl-matrix/vec3.js [client] (ecmascript) <export * as vec3>");
;
;
;
;
;
class WebMercatorViewport {
    /**
     * @classdesc
     * Creates view/projection matrices from mercator params
     * Note: The Viewport is immutable in the sense that it only has accessors.
     * A new viewport instance should be created if any parameters have changed.
     */ // eslint-disable-next-line max-statements
    constructor(props = {
        width: 1,
        height: 1
    }){
        /** Two viewports are equal if width and height are identical, and if
         * their view and projection matrices are (approximately) equal.
         */ this.equals = (viewport)=>{
            if (!(viewport instanceof WebMercatorViewport)) {
                return false;
            }
            return viewport.width === this.width && viewport.height === this.height && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$mat4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__mat4$3e$__["mat4"].equals(viewport.projectionMatrix, this.projectionMatrix) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$mat4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__mat4$3e$__["mat4"].equals(viewport.viewMatrix, this.viewMatrix);
        };
        /**
         * Projects xyz (possibly latitude and longitude) to pixel coordinates in window
         * using viewport projection parameters
         * - [longitude, latitude] to [x, y]
         * - [longitude, latitude, Z] => [x, y, z]
         * Note: By default, returns top-left coordinates for canvas/SVG type render
         *
         * @param lngLatZ - [lng, lat] or [lng, lat, Z]
         * @param options - options
         * @param options.topLeft=true - Whether projected coords are top left
         * @return - screen coordinates [x, y] or [x, y, z], z as pixel depth
         */ this.project = (lngLatZ, options = {})=>{
            const { topLeft = true } = options;
            const worldPosition = this.projectPosition(lngLatZ);
            const coord = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["worldToPixels"])(worldPosition, this.pixelProjectionMatrix);
            const [x, y] = coord;
            const y2 = topLeft ? y : this.height - y;
            return lngLatZ.length === 2 ? [
                x,
                y2
            ] : [
                x,
                y2,
                coord[2]
            ];
        };
        /**
         * Unproject pixel coordinates on screen onto world coordinates, possibly `[lon, lat]` on map.
         *
         * - [x, y] => [lng, lat]
         * - [x, y, z] => [lng, lat, Z]
         *
         * @param xyz - screen coordinates, z as pixel depth
         * @param options - options
         * @param options.topLeft=true - Whether projected coords are top left
         * @param options.targetZ=0 - If pixel depth is unknown, targetZ is used as
         *   the elevation plane to unproject onto
         * @return - [lng, lat, Z] or [X, Y, Z]
         */ this.unproject = (xyz, options = {})=>{
            const { topLeft = true, targetZ = undefined } = options;
            const [x, y, z] = xyz;
            const y2 = topLeft ? y : this.height - y;
            const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];
            const coord = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["pixelsToWorld"])([
                x,
                y2,
                z
            ], this.pixelUnprojectionMatrix, targetZWorld);
            const [X, Y, Z] = this.unprojectPosition(coord);
            if (Number.isFinite(z)) {
                return [
                    X,
                    Y,
                    Z
                ];
            }
            return Number.isFinite(targetZ) ? [
                X,
                Y,
                targetZ
            ] : [
                X,
                Y
            ];
        };
        // NON_LINEAR PROJECTION HOOKS
        // Used for web meractor projection
        this.projectPosition = (xyz)=>{
            const [X, Y] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["lngLatToWorld"])(xyz);
            const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];
            return [
                X,
                Y,
                Z
            ];
        };
        this.unprojectPosition = (xyz)=>{
            const [X, Y] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["worldToLngLat"])(xyz);
            const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];
            return [
                X,
                Y,
                Z
            ];
        };
        let { // Map state
        width, height, altitude = null, fovy = null } = props;
        const { latitude = 0, longitude = 0, zoom = 0, pitch = 0, bearing = 0, position = null, nearZMultiplier = 0.02, farZMultiplier = 1.01 } = props;
        // Silently allow apps to send in 0,0 to facilitate isomorphic render etc
        width = width || 1;
        height = height || 1;
        // `fovy` & `altitude` are independent parameters, one for the
        // projection and the latter for the view matrix. In the past,
        // the `fovy` was always derived from the `altitude`
        if (fovy === null && altitude === null) {
            altitude = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["DEFAULT_ALTITUDE"];
            fovy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["altitudeToFovy"])(altitude);
        } else if (fovy === null) {
            fovy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["altitudeToFovy"])(altitude);
        } else if (altitude === null) {
            altitude = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fovyToAltitude"])(fovy);
        }
        const scale = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["zoomToScale"])(zoom);
        // Altitude - prevent division by 0
        // TODO - just throw an Error instead?
        altitude = Math.max(0.75, altitude);
        const distanceScales = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getDistanceScales"])({
            longitude,
            latitude
        });
        const center = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["lngLatToWorld"])([
            longitude,
            latitude
        ]);
        center.push(0);
        if (position) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec3$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec3$3e$__["vec3"].add(center, center, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec3$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec3$3e$__["vec3"].mul([], position, distanceScales.unitsPerMeter));
        }
        this.projectionMatrix = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProjectionMatrix"])({
            width,
            height,
            scale,
            center,
            pitch,
            fovy,
            nearZMultiplier,
            farZMultiplier
        });
        this.viewMatrix = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getViewMatrix"])({
            height,
            scale,
            center,
            pitch,
            bearing,
            altitude
        });
        // Save parameters
        this.width = width;
        this.height = height;
        this.scale = scale;
        this.latitude = latitude;
        this.longitude = longitude;
        this.zoom = zoom;
        this.pitch = pitch;
        this.bearing = bearing;
        this.altitude = altitude;
        this.fovy = fovy;
        this.center = center;
        this.meterOffset = position || [
            0,
            0,
            0
        ];
        this.distanceScales = distanceScales;
        this._initMatrices();
        Object.freeze(this);
    }
    _initMatrices() {
        const { width, height, projectionMatrix, viewMatrix } = this;
        // Note: As usual, matrix operations should be applied in "reverse" order
        // since vectors will be multiplied in from the right during transformation
        const vpm = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["createMat4"])();
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$mat4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__mat4$3e$__["mat4"].multiply(vpm, vpm, projectionMatrix);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$mat4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__mat4$3e$__["mat4"].multiply(vpm, vpm, viewMatrix);
        this.viewProjectionMatrix = vpm;
        // Calculate matrices and scales needed for projection
        /**
         * Builds matrices that converts preprojected lngLats to screen pixels
         * and vice versa.
         * Note: Currently returns bottom-left coordinates!
         * Note: Starts with the GL projection matrix and adds steps to the
         *       scale and translate that matrix onto the window.
         * Note: WebGL controls clip space to screen projection with gl.viewport
         *       and does not need this step.
         */ const m = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["createMat4"])();
        // matrix for conversion from location to screen coordinates
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$mat4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__mat4$3e$__["mat4"].scale(m, m, [
            width / 2,
            -height / 2,
            1
        ]);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$mat4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__mat4$3e$__["mat4"].translate(m, m, [
            1,
            -1,
            0
        ]);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$mat4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__mat4$3e$__["mat4"].multiply(m, m, vpm);
        const mInverse = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$mat4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__mat4$3e$__["mat4"].invert((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["createMat4"])(), m);
        if (!mInverse) {
            throw new Error('Pixel project matrix not invertible');
        }
        this.pixelProjectionMatrix = m;
        this.pixelUnprojectionMatrix = mInverse;
    }
    /**
     * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
     * Performs the nonlinear part of the web mercator projection.
     * Remaining projection is done with 4x4 matrices which also handles
     * perspective.
     *
     * @param lngLat - [lng, lat] coordinates
     *   Specifies a point on the sphere to project onto the map.
     * @return [x,y] coordinates.
     */ projectFlat(lngLat) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["lngLatToWorld"])(lngLat);
    }
    /**
     * Unproject world point [x,y] on map onto {lat, lon} on sphere
     *
     * @param xy - array with [x,y] members
     *  representing point on projected map plane
     * @return - array with [lat,lon] of point on sphere.
     *   Has toArray method if you need a GeoJSON Array.
     *   Per cartographic tradition, lat and lon are specified as degrees.
     */ unprojectFlat(xy) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["worldToLngLat"])(xy);
    }
    /**
     * Get the map center that place a given [lng, lat] coordinate at screen point [x, y]
     * @param opt
     * @param opt.lngLat - [lng,lat] coordinates
     *   Specifies a point on the sphere.
     * @param opt.pos - [x,y] coordinates
     *   Specifies a point on the screen.
     * @return [lng,lat] new map center.
     */ getMapCenterByLngLatPosition({ lngLat, pos }) {
        const fromLocation = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["pixelsToWorld"])(pos, this.pixelUnprojectionMatrix);
        const toLocation = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["lngLatToWorld"])(lngLat);
        const translate = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec2$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec2$3e$__["vec2"].add([], toLocation, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec2$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec2$3e$__["vec2"].negate([], fromLocation));
        const newCenter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec2$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec2$3e$__["vec2"].add([], this.center, translate);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["worldToLngLat"])(newCenter);
    }
    /**
     * Returns a new viewport that fit around the given rectangle.
     * Only supports non-perspective mode.
     * @param bounds - [[lon, lat], [lon, lat]]
     * @param [options]
     * @param [options.padding] - The amount of padding in pixels to add to the given bounds.
     * @param [options.offset] - The center of the given bounds relative to the map's center,
     *    [x, y] measured in pixels.
     * @returns {WebMercatorViewport}
     */ fitBounds(bounds, options = {}) {
        const { width, height } = this;
        const { longitude, latitude, zoom } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$fit$2d$bounds$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fitBounds"])(Object.assign({
            width,
            height,
            bounds
        }, options));
        return new WebMercatorViewport({
            width,
            height,
            longitude,
            latitude,
            zoom
        });
    }
    /**
     * Returns the bounding box of the viewport.
     * @param [options]
     * @param [options.z] - The altitude at which the bounds should be calculated.
     * @returns {Array} bounds - [[lon, lat], [lon, lat]]
     */ getBounds(options) {
        const corners = this.getBoundingRegion(options);
        const west = Math.min(...corners.map((p)=>p[0]));
        const east = Math.max(...corners.map((p)=>p[0]));
        const south = Math.min(...corners.map((p)=>p[1]));
        const north = Math.max(...corners.map((p)=>p[1]));
        return [
            [
                west,
                south
            ],
            [
                east,
                north
            ]
        ];
    }
    /**
     * Returns the bounding box of the viewport.
     * @param [options]
     * @param [options.z] - The altitude at which the bounds should be calculated.
     * @returns {Array} an array of 4 points that define the visible region
     */ getBoundingRegion(options = {}) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$get$2d$bounds$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getBounds"])(this, options.z || 0);
    }
    // DEPRECATED
    /** @deprecated Legacy method name */ getLocationAtPoint({ lngLat, pos }) {
        return this.getMapCenterByLngLatPosition({
            lngLat,
            pos
        });
    }
} //# sourceMappingURL=web-mercator-viewport.js.map
}}),
"[project]/node_modules/@math.gl/web-mercator/dist/normalize-viewport-props.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "normalizeViewportProps": (()=>normalizeViewportProps)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/web-mercator-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/math-utils.js [client] (ecmascript)");
;
;
// defined by mapbox-gl
const TILE_SIZE = 512;
function normalizeViewportProps(props) {
    const { width, height, pitch = 0 } = props;
    let { longitude, latitude, zoom, bearing = 0 } = props;
    // Normalize degrees
    if (longitude < -180 || longitude > 180) {
        longitude = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["mod"])(longitude + 180, 360) - 180;
    }
    if (bearing < -180 || bearing > 180) {
        bearing = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["mod"])(bearing + 180, 360) - 180;
    }
    // Constrain zoom and shift center at low zoom levels
    const minZoom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log2"])(height / TILE_SIZE);
    if (zoom <= minZoom) {
        zoom = minZoom;
        latitude = 0;
    } else {
        // Eliminate white space above and below the map
        const halfHeightPixels = height / 2 / Math.pow(2, zoom);
        const minLatitude = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["worldToLngLat"])([
            0,
            halfHeightPixels
        ])[1];
        if (latitude < minLatitude) {
            latitude = minLatitude;
        } else {
            const maxLatitude = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["worldToLngLat"])([
                0,
                TILE_SIZE - halfHeightPixels
            ])[1];
            if (latitude > maxLatitude) {
                latitude = maxLatitude;
            }
        }
    }
    return {
        width,
        height,
        longitude,
        latitude,
        zoom,
        pitch,
        bearing
    };
} //# sourceMappingURL=normalize-viewport-props.js.map
}}),
"[project]/node_modules/@math.gl/web-mercator/dist/fly-to-viewport.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "flyToViewport": (()=>flyToViewport),
    "getFlyToDuration": (()=>getFlyToDuration)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/math-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/web-mercator-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec2$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec2$3e$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/gl-matrix/vec2.js [client] (ecmascript) <export * as vec2>");
;
;
;
const EPSILON = 0.01;
const VIEWPORT_TRANSITION_PROPS = [
    'longitude',
    'latitude',
    'zoom'
];
const DEFAULT_OPTS = {
    curve: 1.414,
    speed: 1.2
};
function flyToViewport(startProps, endProps, t, options) {
    // Equations from above paper are referred where needed.
    const { startZoom, startCenterXY, uDelta, w0, u1, S, rho, rho2, r0 } = getFlyToTransitionParams(startProps, endProps, options);
    // If change in center is too small, do linear interpolaiton.
    if (u1 < EPSILON) {
        const viewport = {};
        for (const key of VIEWPORT_TRANSITION_PROPS){
            const startValue = startProps[key];
            const endValue = endProps[key];
            // @ts-ignore-error properties are populated dynamically
            viewport[key] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["lerp"])(startValue, endValue, t);
        }
        // @ts-expect-error properties are populated dynamically
        return viewport;
    }
    const s = t * S;
    const w = Math.cosh(r0) / Math.cosh(r0 + rho * s);
    const u = w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s) - Math.sinh(r0)) / rho2) / u1;
    const scaleIncrement = 1 / w; // Using w method for scaling.
    const newZoom = startZoom + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["scaleToZoom"])(scaleIncrement);
    const newCenterWorld = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec2$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec2$3e$__["vec2"].scale([], uDelta, u);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec2$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec2$3e$__["vec2"].add(newCenterWorld, newCenterWorld, startCenterXY);
    const newCenter = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["worldToLngLat"])(newCenterWorld);
    return {
        longitude: newCenter[0],
        latitude: newCenter[1],
        zoom: newZoom
    };
}
function getFlyToDuration(startProps, endProps, options) {
    const opts = {
        ...DEFAULT_OPTS,
        ...options
    };
    const { screenSpeed, speed, maxDuration } = opts;
    const { S, rho } = getFlyToTransitionParams(startProps, endProps, opts);
    const length = 1000 * S;
    let duration;
    if (Number.isFinite(screenSpeed)) {
        duration = length / (screenSpeed / rho);
    } else {
        duration = length / speed;
    }
    return Number.isFinite(maxDuration) && duration > maxDuration ? 0 : duration;
}
// Private Methods
// Calculate all parameters that are static for given startProps and endProps
function getFlyToTransitionParams(startProps, endProps, opts) {
    opts = Object.assign({}, DEFAULT_OPTS, opts);
    const rho = opts.curve;
    const startZoom = startProps.zoom;
    const startCenter = [
        startProps.longitude,
        startProps.latitude
    ];
    const startScale = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["zoomToScale"])(startZoom);
    const endZoom = endProps.zoom;
    const endCenter = [
        endProps.longitude,
        endProps.latitude
    ];
    const scale = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["zoomToScale"])(endZoom - startZoom);
    const startCenterXY = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["lngLatToWorld"])(startCenter);
    const endCenterXY = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["lngLatToWorld"])(endCenter);
    const uDelta = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec2$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec2$3e$__["vec2"].sub([], endCenterXY, startCenterXY);
    const w0 = Math.max(startProps.width, startProps.height);
    const w1 = w0 / scale;
    const u1 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec2$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec2$3e$__["vec2"].length(uDelta) * startScale;
    // u0 is treated as '0' in Eq (9).
    // If u1 is too small, will generate invalid number
    const _u1 = Math.max(u1, EPSILON);
    // Implement Equation (9) from above algorithm.
    const rho2 = rho * rho;
    const b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * _u1 * _u1) / (2 * w0 * rho2 * _u1);
    const b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * _u1 * _u1) / (2 * w1 * rho2 * _u1);
    const r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);
    const r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
    const S = (r1 - r0) / rho;
    return {
        startZoom,
        startCenterXY,
        uDelta,
        w0,
        u1,
        S,
        rho,
        rho2,
        r0,
        r1
    };
} //# sourceMappingURL=fly-to-viewport.js.map
}}),
"[project]/node_modules/@math.gl/web-mercator/dist/index.js [client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Classic web-mercator-project
__turbopack_context__.s({});
;
;
;
;
;
;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@math.gl/web-mercator/dist/index.js [client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$viewport$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/web-mercator-viewport.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$get$2d$bounds$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/get-bounds.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$fit$2d$bounds$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/fit-bounds.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$normalize$2d$viewport$2d$props$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/normalize-viewport-props.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$fly$2d$to$2d$viewport$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/fly-to-viewport.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/web-mercator-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/index.js [client] (ecmascript) <locals>");
}}),
"[project]/node_modules/@math.gl/types/dist/is-array.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/**
 * Check is an array is a typed array
 * @param value value to be tested
 * @returns input with type narrowed to TypedArray, or null
 */ __turbopack_context__.s({
    "isNumberArray": (()=>isNumberArray),
    "isNumericArray": (()=>isNumericArray),
    "isTypedArray": (()=>isTypedArray)
});
function isTypedArray(value) {
    return ArrayBuffer.isView(value) && !(value instanceof DataView);
}
function isNumberArray(value) {
    if (Array.isArray(value)) {
        return value.length === 0 || typeof value[0] === 'number';
    }
    return false;
}
function isNumericArray(value) {
    return isTypedArray(value) || isNumberArray(value);
} //# sourceMappingURL=is-array.js.map
}}),
"[project]/node_modules/@math.gl/polygon/dist/polygon-utils.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT and ISC
// Copyright (c) vis.gl contributors
/* eslint-disable max-statements, max-depth, complexity, no-unused-expressions */ __turbopack_context__.s({
    "DimIndex": (()=>DimIndex),
    "WINDING": (()=>WINDING),
    "forEachSegmentInPolygon": (()=>forEachSegmentInPolygon),
    "forEachSegmentInPolygonPoints": (()=>forEachSegmentInPolygonPoints),
    "getPolygonSignedArea": (()=>getPolygonSignedArea),
    "getPolygonSignedAreaPoints": (()=>getPolygonSignedAreaPoints),
    "getPolygonWindingDirection": (()=>getPolygonWindingDirection),
    "getPolygonWindingDirectionPoints": (()=>getPolygonWindingDirectionPoints),
    "modifyPolygonWindingDirection": (()=>modifyPolygonWindingDirection),
    "modifyPolygonWindingDirectionPoints": (()=>modifyPolygonWindingDirectionPoints)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$common$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/lib/common.js [client] (ecmascript)");
;
const WINDING = {
    CLOCKWISE: 1,
    COUNTER_CLOCKWISE: -1
};
function modifyPolygonWindingDirection(points, direction, options = {}) {
    const windingDirection = getPolygonWindingDirection(points, options);
    if (windingDirection !== direction) {
        reversePolygon(points, options);
        return true;
    }
    return false;
}
function getPolygonWindingDirection(points, options = {}) {
    return Math.sign(getPolygonSignedArea(points, options));
}
const DimIndex = {
    x: 0,
    y: 1,
    z: 2
};
function getPolygonSignedArea(points, options = {}) {
    const { start = 0, end = points.length, plane = 'xy' } = options;
    const dim = options.size || 2;
    let area = 0;
    const i0 = DimIndex[plane[0]];
    const i1 = DimIndex[plane[1]];
    for(let i = start, j = end - dim; i < end; i += dim){
        area += (points[i + i0] - points[j + i0]) * (points[i + i1] + points[j + i1]);
        j = i;
    }
    return area / 2;
}
function forEachSegmentInPolygon(points, visitor, options = {}) {
    const { start = 0, end = points.length, size = 2, isClosed } = options;
    const numPoints = (end - start) / size;
    for(let i = 0; i < numPoints - 1; ++i){
        visitor(points[start + i * size], points[start + i * size + 1], points[start + (i + 1) * size], points[start + (i + 1) * size + 1], i, i + 1);
    }
    const endPointIndex = start + (numPoints - 1) * size;
    const isClosedEx = isClosed || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$common$2e$js__$5b$client$5d$__$28$ecmascript$29$__["equals"])(points[start], points[endPointIndex]) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$common$2e$js__$5b$client$5d$__$28$ecmascript$29$__["equals"])(points[start + 1], points[endPointIndex + 1]);
    if (!isClosedEx) {
        visitor(points[endPointIndex], points[endPointIndex + 1], points[start], points[start + 1], numPoints - 1, 0);
    }
}
function reversePolygon(points, options) {
    const { start = 0, end = points.length, size = 2 } = options;
    const numPoints = (end - start) / size;
    const numSwaps = Math.floor(numPoints / 2);
    for(let i = 0; i < numSwaps; ++i){
        const b1 = start + i * size;
        const b2 = start + (numPoints - 1 - i) * size;
        for(let j = 0; j < size; ++j){
            const tmp = points[b1 + j];
            points[b1 + j] = points[b2 + j];
            points[b2 + j] = tmp;
        }
    }
}
function modifyPolygonWindingDirectionPoints(points, direction, options = {}) {
    const currentDirection = getPolygonWindingDirectionPoints(points, options);
    if (currentDirection !== direction) {
        points.reverse();
        return true;
    }
    return false;
}
function getPolygonWindingDirectionPoints(points, options = {}) {
    return Math.sign(getPolygonSignedAreaPoints(points, options));
}
function getPolygonSignedAreaPoints(points, options = {}) {
    // https://en.wikipedia.org/wiki/Shoelace_formula
    const { start = 0, end = points.length, plane = 'xy' } = options;
    let area = 0;
    const i0 = DimIndex[plane[0]];
    const i1 = DimIndex[plane[1]];
    for(let i = start, j = end - 1; i < end; ++i){
        area += (points[i][i0] - points[j][i0]) * (points[i][i1] + points[j][i1]);
        j = i;
    }
    return area / 2;
}
function forEachSegmentInPolygonPoints(points, visitor, options = {}) {
    const { start = 0, end = points.length, isClosed } = options;
    for(let i = start; i < end - 1; ++i){
        visitor(points[i], points[i + 1], i, i + 1);
    }
    const isClosedEx = isClosed || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$common$2e$js__$5b$client$5d$__$28$ecmascript$29$__["equals"])(points[end - 1], points[0]);
    if (!isClosedEx) {
        visitor(points[end - 1], points[0], end - 1, 0);
    }
} //# sourceMappingURL=polygon-utils.js.map
}}),
"[project]/node_modules/@math.gl/polygon/dist/polygon.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/* eslint-disable no-undef, no-console */ __turbopack_context__.s({
    "Polygon": (()=>Polygon)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$common$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/lib/common.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$polygon$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/polygon/dist/polygon-utils.js [client] (ecmascript)");
;
;
class Polygon {
    constructor(points, options = {}){
        this.points = points;
        this.isFlatArray = !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$common$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isArray"])(points[0]);
        this.options = {
            start: options.start || 0,
            end: options.end || points.length,
            size: options.size || 2,
            isClosed: options.isClosed
        };
        Object.freeze(this);
    }
    /**
     * Returns signed area of the polygon.
     * @returns Signed area of the polygon.
     */ getSignedArea() {
        if (this.isFlatArray) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$polygon$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getPolygonSignedArea"])(this.points, this.options);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$polygon$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getPolygonSignedAreaPoints"])(this.points, this.options);
    }
    /**
     * Returns absolute area of the polygon.
     * @returns Absolute area of the polygon.
     */ getArea() {
        return Math.abs(this.getSignedArea());
    }
    /**
     * Returns winding direction of the polygon.
     * @returns Winding direction of the polygon. 1 is for clockwise, -1 for counterclockwise winding direction.
     */ getWindingDirection() {
        return Math.sign(this.getSignedArea());
    }
    /**
     * Calls the visitor callback for each segment in the polygon.
     * @param visitor A callback to call for each segment.
     */ forEachSegment(visitor) {
        if (this.isFlatArray) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$polygon$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["forEachSegmentInPolygon"])(this.points, // eslint-disable-next-line max-params
            (x1, y1, x2, y2, i1, i2)=>{
                // TODO @igorDykhta original visitor uses arrays for each point, but with flat arrays performance degrades if we allocate points for each segment
                visitor([
                    x1,
                    y1
                ], [
                    x2,
                    y2
                ], i1, i2);
            }, this.options);
        } else {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$polygon$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["forEachSegmentInPolygonPoints"])(this.points, visitor, this.options);
        }
    }
    /**
     * Checks winding direction of the polygon and reverses the polygon in case of opposite winding direction.
     * @param direction Requested winding direction. 1 is for clockwise, -1 for counterclockwise winding direction.
     * @return Returns true if the winding direction was changed.
     */ modifyWindingDirection(direction) {
        if (this.isFlatArray) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$polygon$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["modifyPolygonWindingDirection"])(this.points, direction, this.options);
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$polygon$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["modifyPolygonWindingDirectionPoints"])(this.points, direction, this.options);
    }
} //# sourceMappingURL=polygon.js.map
}}),
"[project]/node_modules/@math.gl/polygon/dist/earcut.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT and ISC
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "earcut": (()=>earcut)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$polygon$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/polygon/dist/polygon-utils.js [client] (ecmascript)");
;
function earcut(positions, holeIndices, dim = 2, areas, plane = 'xy') {
    const hasHoles = holeIndices && holeIndices.length;
    const outerLen = hasHoles ? holeIndices[0] * dim : positions.length;
    let outerNode = linkedList(positions, 0, outerLen, dim, true, areas && areas[0], plane);
    const triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev) return triangles;
    let invSize;
    let maxX;
    let maxY;
    let minX;
    let minY;
    let x;
    let y;
    if (hasHoles) outerNode = eliminateHoles(positions, holeIndices, outerNode, dim, areas, plane);
    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (positions.length > 80 * dim) {
        minX = maxX = positions[0];
        minY = maxY = positions[1];
        for(let i = dim; i < outerLen; i += dim){
            x = positions[i];
            y = positions[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }
        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
    return triangles;
}
// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise, area, plane) {
    let i;
    let last;
    if (area === undefined) {
        area = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$polygon$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getPolygonSignedArea"])(data, {
            start,
            end,
            size: dim,
            plane
        });
    }
    let i0 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$polygon$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["DimIndex"][plane[0]];
    let i1 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$polygon$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["DimIndex"][plane[1]];
    // Note that the signed area calculation in math.gl
    // has the opposite sign to that which was originally
    // present in earcut, thus the `< 0` is reversed
    if (clockwise === area < 0) {
        for(i = start; i < end; i += dim)last = insertNode(i, data[i + i0], data[i + i1], last);
    } else {
        for(i = end - dim; i >= start; i -= dim)last = insertNode(i, data[i + i0], data[i + i1], last);
    }
    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }
    return last;
}
// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;
    let p = start;
    let again;
    do {
        again = false;
        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;
        } else {
            p = p.next;
        }
    }while (again || p !== end)
    return end;
}
// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;
    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
    let stop = ear;
    let prev;
    let next;
    // iterate through ears, slicing them one by one
    while(ear.prev !== ear.next){
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim | 0);
            triangles.push(ear.i / dim | 0);
            triangles.push(next.i / dim | 0);
            removeNode(ear);
            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;
            continue;
        }
        ear = next;
        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }
            break;
        }
    }
}
// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    const a = ear.prev;
    const b = ear;
    const c = ear.next;
    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
    // now make sure we don't have other points inside the potential ear
    const ax = a.x;
    const bx = b.x;
    const cx = c.x;
    const ay = a.y;
    const by = b.y;
    const cy = c.y;
    // triangle bbox; min & max are calculated like this for speed
    const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx;
    const y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy;
    const x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx;
    const y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
    let p = c.next;
    while(p !== a){
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }
    return true;
}
function isEarHashed(ear, minX, minY, invSize) {
    const a = ear.prev;
    const b = ear;
    const c = ear.next;
    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
    const ax = a.x;
    const bx = b.x;
    const cx = c.x;
    const ay = a.y;
    const by = b.y;
    const cy = c.y;
    // triangle bbox; min & max are calculated like this for speed
    const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx;
    const y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy;
    const x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx;
    const y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
    // z-order range for the current triangle bbox;
    const minZ = zOrder(x0, y0, minX, minY, invSize);
    const maxZ = zOrder(x1, y1, minX, minY, invSize);
    let p = ear.prevZ;
    let n = ear.nextZ;
    // look for points inside the triangle in both directions
    while(p && p.z >= minZ && n && n.z <= maxZ){
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }
    // look for remaining points in decreasing z-order
    while(p && p.z >= minZ){
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }
    // look for remaining points in increasing z-order
    while(n && n.z <= maxZ){
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }
    return true;
}
// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    let p = start;
    do {
        const a = p.prev;
        const b = p.next.next;
        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
            triangles.push(a.i / dim | 0);
            triangles.push(p.i / dim | 0);
            triangles.push(b.i / dim | 0);
            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);
            p = start = b;
        }
        p = p.next;
    }while (p !== start)
    return filterPoints(p);
}
// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    let a = start;
    do {
        let b = a.next.next;
        while(b !== a.prev){
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                let c = splitPolygon(a, b);
                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);
                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
                return;
            }
            b = b.next;
        }
        a = a.next;
    }while (a !== start)
}
// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim, areas, plane) {
    const queue = [];
    let i;
    let len;
    let start;
    let end;
    let list;
    for(i = 0, len = holeIndices.length; i < len; i++){
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false, areas && areas[i + 1], plane);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }
    queue.sort(compareX);
    // process holes from left to right
    for(i = 0; i < queue.length; i++){
        outerNode = eliminateHole(queue[i], outerNode);
    }
    return outerNode;
}
function compareX(a, b) {
    return a.x - b.x;
}
// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    const bridge = findHoleBridge(hole, outerNode);
    if (!bridge) {
        return outerNode;
    }
    const bridgeReverse = splitPolygon(bridge, hole);
    // filter collinear points around the cuts
    filterPoints(bridgeReverse, bridgeReverse.next);
    return filterPoints(bridge, bridge.next);
}
// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    let p = outerNode;
    const hx = hole.x;
    const hy = hole.y;
    let qx = -Infinity;
    let m;
    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                m = p.x < p.next.x ? p : p.next;
                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint
            }
        }
        p = p.next;
    }while (p !== outerNode)
    if (!m) return null;
    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point
    const stop = m;
    const mx = m.x;
    const my = m.y;
    let tanMin = Infinity;
    let tan;
    p = m;
    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential
            if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
                m = p;
                tanMin = tan;
            }
        }
        p = p.next;
    }while (p !== stop)
    return m;
}
// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}
// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    let p = start;
    do {
        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    }while (p !== start)
    p.prevZ.nextZ = null;
    p.prevZ = null;
    sortLinked(p);
}
// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    let e;
    let i;
    let inSize = 1;
    let numMerges;
    let p;
    let pSize;
    let q;
    let qSize;
    let tail;
    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;
        while(p){
            numMerges++;
            q = p;
            pSize = 0;
            for(i = 0; i < inSize; i++){
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;
            while(pSize > 0 || qSize > 0 && q){
                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }
                if (tail) tail.nextZ = e;
                else list = e;
                e.prevZ = tail;
                tail = e;
            }
            p = q;
        }
        tail.nextZ = null;
        inSize *= 2;
    }while (numMerges > 1)
    return list;
}
// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = (x - minX) * invSize | 0;
    y = (y - minY) * invSize | 0;
    x = (x | x << 8) & 0x00ff00ff;
    x = (x | x << 4) & 0x0f0f0f0f;
    x = (x | x << 2) & 0x33333333;
    x = (x | x << 1) & 0x55555555;
    y = (y | y << 8) & 0x00ff00ff;
    y = (y | y << 4) & 0x0f0f0f0f;
    y = (y | y << 2) & 0x33333333;
    y = (y | y << 1) & 0x55555555;
    return x | y << 1;
}
// find the leftmost node of a polygon ring
function getLeftmost(start) {
    let p = start;
    let leftmost = start;
    do {
        if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
        p = p.next;
    }while (p !== start)
    return leftmost;
}
// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
}
// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
    (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
    (area(a.prev, a, b.prev) || area(a, b.prev, b)) || equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}
// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}
// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}
// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    const o1 = sign(area(p1, q1, p2));
    const o2 = sign(area(p1, q1, q2));
    const o3 = sign(area(p2, q2, p1));
    const o4 = sign(area(p2, q2, q1));
    if (o1 !== o2 && o3 !== o4) return true; // general case
    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2
    return false;
}
// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}
function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}
// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    let p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
        p = p.next;
    }while (p !== a)
    return false;
}
// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}
// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    let p = a;
    let inside = false;
    const px = (a.x + b.x) / 2;
    const py = (a.y + b.y) / 2;
    do {
        if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
        p = p.next;
    }while (p !== a)
    return inside;
}
// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    const a2 = new Vertex(a.i, a.x, a.y);
    const b2 = new Vertex(b.i, b.x, b.y);
    const an = a.next;
    const bp = b.prev;
    a.next = b;
    b.prev = a;
    a2.next = an;
    an.prev = a2;
    b2.next = a2;
    a2.prev = b2;
    bp.next = b2;
    b2.prev = bp;
    return b2;
}
// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    const p = new Vertex(i, x, y);
    if (!last) {
        p.prev = p;
        p.next = p;
    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}
function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;
    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}
class Vertex {
    constructor(i, x, y){
        // previous and next vertex nodes in a polygon ring
        this.prev = null;
        this.next = null;
        // z-order curve value
        this.z = 0;
        // previous and next nodes in z-order
        this.prevZ = null;
        this.nextZ = null;
        // indicates whether this is a steiner point
        this.steiner = false;
        this.i = i;
        this.x = x;
        this.y = y;
    }
} //# sourceMappingURL=earcut.js.map
}}),
"[project]/node_modules/@math.gl/polygon/dist/utils.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "copy": (()=>copy),
    "getPointAtIndex": (()=>getPointAtIndex),
    "push": (()=>push)
});
function push(target, source) {
    const size = source.length;
    const startIndex = target.length;
    // dedupe, if source is the same point as the last vertex
    if (startIndex > 0) {
        let isDuplicate = true;
        for(let i = 0; i < size; i++){
            if (target[startIndex - size + i] !== source[i]) {
                isDuplicate = false;
                break;
            }
        }
        if (isDuplicate) {
            return false;
        }
    }
    for(let i = 0; i < size; i++){
        target[startIndex + i] = source[i];
    }
    return true;
}
function copy(target, source) {
    const size = source.length;
    for(let i = 0; i < size; i++){
        target[i] = source[i];
    }
}
function getPointAtIndex(positions, index, size, offset, out = []) {
    const startI = offset + index * size;
    for(let i = 0; i < size; i++){
        out[i] = positions[startI + i];
    }
    return out;
} //# sourceMappingURL=utils.js.map
}}),
"[project]/node_modules/@math.gl/polygon/dist/lineclip.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT and ISC
// Copyright (c) vis.gl contributors
/*
  Adapted from https://github.com/mapbox/lineclip to work with flat arrays
  and 3d positions

  ISC License

  Copyright (c) 2015, Mapbox

  Permission to use, copy, modify, and/or distribute this software for any purpose
  with or without fee is hereby granted, provided that the above copyright notice
  and this permission notice appear in all copies.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
  FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
  OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
  THIS SOFTWARE.

 */ /* eslint-disable max-statements, max-depth, complexity */ __turbopack_context__.s({
    "bitCode": (()=>bitCode),
    "clipPolygon": (()=>clipPolygon),
    "clipPolyline": (()=>clipPolyline),
    "intersect": (()=>intersect)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/polygon/dist/utils.js [client] (ecmascript)");
;
function clipPolyline(positions, bbox, options) {
    const { size = 2, startIndex = 0, endIndex = positions.length } = options || {};
    const numPoints = (endIndex - startIndex) / size;
    const result = [];
    let part = [];
    let a;
    let b;
    let codeA = -1;
    let codeB;
    let lastCode;
    for(let i = 1; i < numPoints; i++){
        a = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getPointAtIndex"])(positions, i - 1, size, startIndex, a);
        b = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getPointAtIndex"])(positions, i, size, startIndex, b);
        if (codeA < 0) {
            codeA = bitCode(a, bbox);
        }
        codeB = lastCode = bitCode(b, bbox);
        // eslint-disable-next-line no-constant-condition
        while(true){
            if (!(codeA | codeB)) {
                // accept
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["push"])(part, a);
                if (codeB !== lastCode) {
                    // segment went outside
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["push"])(part, b);
                    if (i < numPoints - 1) {
                        // start a new line
                        result.push(part);
                        part = [];
                    }
                } else if (i === numPoints - 1) {
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["push"])(part, b);
                }
                break;
            } else if (codeA & codeB) {
                break;
            } else if (codeA) {
                // a outside, intersect with clip edge
                intersect(a, b, codeA, bbox, a);
                codeA = bitCode(a, bbox);
            } else {
                // b outside
                intersect(a, b, codeB, bbox, b);
                codeB = bitCode(b, bbox);
            }
        }
        codeA = lastCode;
    }
    if (part.length) result.push(part);
    return result;
}
function clipPolygon(positions, bbox, options) {
    const { size = 2, endIndex = positions.length } = options || {};
    let { startIndex = 0 } = options || {};
    let numPoints = (endIndex - startIndex) / size;
    let result;
    let p;
    let prev;
    let inside;
    let prevInside;
    // clip against each side of the clip rectangle
    for(let edge = 1; edge <= 8; edge *= 2){
        result = [];
        prev = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getPointAtIndex"])(positions, numPoints - 1, size, startIndex, prev);
        prevInside = !(bitCode(prev, bbox) & edge);
        for(let i = 0; i < numPoints; i++){
            p = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getPointAtIndex"])(positions, i, size, startIndex, p);
            inside = !(bitCode(p, bbox) & edge);
            // if segment goes through the clip window, add an intersection
            if (inside !== prevInside) (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["push"])(result, intersect(prev, p, edge, bbox));
            if (inside) (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["push"])(result, p); // add a point if it's inside
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["copy"])(prev, p);
            prevInside = inside;
        }
        // close loop
        positions = result;
        startIndex = 0;
        numPoints = result.length / size;
        if (!numPoints) break;
    }
    return result;
}
function intersect(a, b, edge, bbox, out = []) {
    let t;
    // Forces out[snapI] to be on the bbox edge
    // Interpolation introduces precision issue which may cause lineclip to be
    // stuck in an infinite loop
    let snap;
    if (edge & 8) {
        // top
        t = (bbox[3] - a[1]) / (b[1] - a[1]);
        snap = 3;
    } else if (edge & 4) {
        // bottom
        t = (bbox[1] - a[1]) / (b[1] - a[1]);
        snap = 1;
    } else if (edge & 2) {
        // right
        t = (bbox[2] - a[0]) / (b[0] - a[0]);
        snap = 2;
    } else if (edge & 1) {
        // left
        t = (bbox[0] - a[0]) / (b[0] - a[0]);
        snap = 0;
    } else {
        return null;
    }
    for(let i = 0; i < a.length; i++){
        out[i] = (snap & 1) === i ? bbox[snap] : t * (b[i] - a[i]) + a[i];
    }
    return out;
}
function bitCode(p, bbox) {
    let code = 0;
    if (p[0] < bbox[0]) code |= 1;
    else if (p[0] > bbox[2]) code |= 2; // right
    if (p[1] < bbox[1]) code |= 4;
    else if (p[1] > bbox[3]) code |= 8; // top
    return code;
} //# sourceMappingURL=lineclip.js.map
}}),
"[project]/node_modules/@math.gl/polygon/dist/cut-by-grid.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/* eslint-disable max-statements, max-depth, complexity, no-unused-expressions */ __turbopack_context__.s({
    "cutPolygonByGrid": (()=>cutPolygonByGrid),
    "cutPolylineByGrid": (()=>cutPolylineByGrid)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$lineclip$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/polygon/dist/lineclip.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/polygon/dist/utils.js [client] (ecmascript)");
;
;
function cutPolylineByGrid(positions, options) {
    const { size = 2, broken = false, gridResolution = 10, gridOffset = [
        0,
        0
    ], startIndex = 0, endIndex = positions.length } = options || {};
    const numPoints = (endIndex - startIndex) / size;
    let part = [];
    const result = [
        part
    ];
    const a = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getPointAtIndex"])(positions, 0, size, startIndex);
    let b;
    let codeB;
    const cell = getGridCell(a, gridResolution, gridOffset, []);
    const scratchPoint = [];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["push"])(part, a);
    for(let i = 1; i < numPoints; i++){
        b = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getPointAtIndex"])(positions, i, size, startIndex, b);
        codeB = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$lineclip$2e$js__$5b$client$5d$__$28$ecmascript$29$__["bitCode"])(b, cell);
        while(codeB){
            // find the intersection with the current cell
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$lineclip$2e$js__$5b$client$5d$__$28$ecmascript$29$__["intersect"])(a, b, codeB, cell, scratchPoint);
            const codeAlt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$lineclip$2e$js__$5b$client$5d$__$28$ecmascript$29$__["bitCode"])(scratchPoint, cell);
            if (codeAlt) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$lineclip$2e$js__$5b$client$5d$__$28$ecmascript$29$__["intersect"])(a, scratchPoint, codeAlt, cell, scratchPoint);
                codeB = codeAlt;
            }
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["push"])(part, scratchPoint);
            // move to the next cell
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["copy"])(a, scratchPoint);
            moveToNeighborCell(cell, gridResolution, codeB);
            if (broken && part.length > size) {
                part = [];
                result.push(part);
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["push"])(part, a);
            }
            codeB = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$lineclip$2e$js__$5b$client$5d$__$28$ecmascript$29$__["bitCode"])(b, cell);
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["push"])(part, b);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["copy"])(a, b);
    }
    return broken ? result : result[0];
}
const TYPE_INSIDE = 0;
const TYPE_BORDER = 1;
function cutPolygonByGrid(positions, holeIndices = null, options) {
    if (!positions.length) {
        // input is empty
        return [];
    }
    const { size = 2, gridResolution = 10, gridOffset = [
        0,
        0
    ], edgeTypes = false } = options || {};
    const result = [];
    const queue = [
        {
            pos: positions,
            types: edgeTypes ? new Array(positions.length / size).fill(TYPE_BORDER) : null,
            holes: holeIndices || []
        }
    ];
    const bbox = [
        [],
        []
    ];
    // @ts-ignore
    let cell = [];
    // Recursively bisect polygon until every part fit in a single grid cell
    while(queue.length){
        const { pos, types, holes } = queue.shift();
        // Get the bounding box of the outer polygon
        getBoundingBox(pos, size, holes[0] || pos.length, bbox);
        cell = getGridCell(bbox[0], gridResolution, gridOffset, cell);
        const code = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$lineclip$2e$js__$5b$client$5d$__$28$ecmascript$29$__["bitCode"])(bbox[1], cell);
        if (code) {
            // Split the outer ring at the boundary
            let parts = bisectPolygon(pos, types, size, 0, holes[0] || pos.length, cell, code);
            const polygonLow = {
                pos: parts[0].pos,
                types: parts[0].types,
                holes: []
            };
            const polygonHigh = {
                pos: parts[1].pos,
                types: parts[1].types,
                holes: []
            };
            queue.push(polygonLow, polygonHigh);
            // Split each hole at the boundary
            for(let i = 0; i < holes.length; i++){
                parts = bisectPolygon(pos, types, size, holes[i], holes[i + 1] || pos.length, cell, code);
                if (parts[0]) {
                    polygonLow.holes.push(polygonLow.pos.length);
                    polygonLow.pos = concatInPlace(polygonLow.pos, parts[0].pos);
                    if (edgeTypes) {
                        polygonLow.types = concatInPlace(polygonLow.types, parts[0].types);
                    }
                }
                if (parts[1]) {
                    polygonHigh.holes.push(polygonHigh.pos.length);
                    polygonHigh.pos = concatInPlace(polygonHigh.pos, parts[1].pos);
                    if (edgeTypes) {
                        polygonHigh.types = concatInPlace(polygonHigh.types, parts[1].types);
                    }
                }
            }
        } else {
            // Polygon fits in a single cell, no more processing required
            const polygon = {
                positions: pos
            };
            if (edgeTypes) {
                polygon.edgeTypes = types;
            }
            if (holes.length) {
                polygon.holeIndices = holes;
            }
            result.push(polygon);
        }
    }
    return result;
}
// edgeTypes:
// TYPE_BORDER - edge from the original polygon
// TYPE_INSIDE - inside the original polygon
// eslint-disable-next-line max-params
function bisectPolygon(positions, edgeTypes, size, startIndex, endIndex, bbox, edge) {
    const numPoints = (endIndex - startIndex) / size;
    const resultLow = [];
    const resultHigh = [];
    const typesLow = [];
    const typesHigh = [];
    const scratchPoint = [];
    let p;
    let side;
    let type;
    const prev = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getPointAtIndex"])(positions, numPoints - 1, size, startIndex);
    let prevSide = Math.sign(edge & 8 ? prev[1] - bbox[3] : prev[0] - bbox[2]);
    let prevType = edgeTypes && edgeTypes[numPoints - 1];
    let lowPointCount = 0;
    let highPointCount = 0;
    for(let i = 0; i < numPoints; i++){
        p = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getPointAtIndex"])(positions, i, size, startIndex, p);
        side = Math.sign(edge & 8 ? p[1] - bbox[3] : p[0] - bbox[2]);
        type = edgeTypes && edgeTypes[startIndex / size + i];
        // if segment goes through the boundary, add an intersection
        if (side && prevSide && prevSide !== side) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$lineclip$2e$js__$5b$client$5d$__$28$ecmascript$29$__["intersect"])(prev, p, edge, bbox, scratchPoint);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["push"])(resultLow, scratchPoint) && typesLow.push(prevType);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["push"])(resultHigh, scratchPoint) && typesHigh.push(prevType);
        }
        if (side <= 0) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["push"])(resultLow, p) && typesLow.push(type);
            lowPointCount -= side;
        } else if (typesLow.length) {
            typesLow[typesLow.length - 1] = TYPE_INSIDE;
        }
        if (side >= 0) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["push"])(resultHigh, p) && typesHigh.push(type);
            highPointCount += side;
        } else if (typesHigh.length) {
            typesHigh[typesHigh.length - 1] = TYPE_INSIDE;
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["copy"])(prev, p);
        prevSide = side;
        prevType = type;
    }
    return [
        lowPointCount ? {
            pos: resultLow,
            types: edgeTypes && typesLow
        } : null,
        highPointCount ? {
            pos: resultHigh,
            types: edgeTypes && typesHigh
        } : null
    ];
}
function getGridCell(p, gridResolution, gridOffset, out) {
    const left = Math.floor((p[0] - gridOffset[0]) / gridResolution) * gridResolution + gridOffset[0];
    const bottom = Math.floor((p[1] - gridOffset[1]) / gridResolution) * gridResolution + gridOffset[1];
    out[0] = left;
    out[1] = bottom;
    out[2] = left + gridResolution;
    out[3] = bottom + gridResolution;
    return out;
}
function moveToNeighborCell(cell, gridResolution, edge) {
    if (edge & 8) {
        // top
        cell[1] += gridResolution;
        cell[3] += gridResolution;
    } else if (edge & 4) {
        // bottom
        cell[1] -= gridResolution;
        cell[3] -= gridResolution;
    } else if (edge & 2) {
        // right
        cell[0] += gridResolution;
        cell[2] += gridResolution;
    } else if (edge & 1) {
        // left
        cell[0] -= gridResolution;
        cell[2] -= gridResolution;
    }
}
function getBoundingBox(positions, size, endIndex, out) {
    let minX = Infinity;
    let maxX = -Infinity;
    let minY = Infinity;
    let maxY = -Infinity;
    for(let i = 0; i < endIndex; i += size){
        const x = positions[i];
        const y = positions[i + 1];
        minX = x < minX ? x : minX;
        maxX = x > maxX ? x : maxX;
        minY = y < minY ? y : minY;
        maxY = y > maxY ? y : maxY;
    }
    out[0][0] = minX;
    out[0][1] = minY;
    out[1][0] = maxX;
    out[1][1] = maxY;
    return out;
}
function concatInPlace(arr1, arr2) {
    for(let i = 0; i < arr2.length; i++){
        arr1.push(arr2[i]);
    }
    return arr1;
} //# sourceMappingURL=cut-by-grid.js.map
}}),
"[project]/node_modules/@math.gl/polygon/dist/cut-by-mercator-bounds.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "cutPolygonByMercatorBounds": (()=>cutPolygonByMercatorBounds),
    "cutPolylineByMercatorBounds": (()=>cutPolylineByMercatorBounds)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$cut$2d$by$2d$grid$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/polygon/dist/cut-by-grid.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/polygon/dist/utils.js [client] (ecmascript)");
;
;
// https://en.wikipedia.org/wiki/Web_Mercator_projection
const DEFAULT_MAX_LATITUDE = 85.051129;
function cutPolylineByMercatorBounds(positions, options) {
    const { size = 2, startIndex = 0, endIndex = positions.length, normalize = true } = options || {};
    // Remap longitudes so that each segment takes the shorter path
    const newPositions = positions.slice(startIndex, endIndex);
    wrapLongitudesForShortestPath(newPositions, size, 0, endIndex - startIndex);
    const parts = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$cut$2d$by$2d$grid$2e$js__$5b$client$5d$__$28$ecmascript$29$__["cutPolylineByGrid"])(newPositions, {
        size,
        broken: true,
        gridResolution: 360,
        gridOffset: [
            -180,
            -180
        ]
    });
    if (normalize) {
        // Each part is guaranteed to be in a single copy of the world
        // Map longitudes back to [-180, 180]
        for (const part of parts){
            shiftLongitudesIntoRange(part, size);
        }
    }
    return parts;
}
function cutPolygonByMercatorBounds(positions, holeIndices = null, options) {
    const { size = 2, normalize = true, edgeTypes = false } = options || {};
    holeIndices = holeIndices || [];
    const newPositions = [];
    const newHoleIndices = [];
    let srcStartIndex = 0;
    let targetIndex = 0;
    for(let ringIndex = 0; ringIndex <= holeIndices.length; ringIndex++){
        // srcStartIndex/srcEndIndex define the ring in the original positions
        const srcEndIndex = holeIndices[ringIndex] || positions.length;
        // targetStartIndex/targetIndex define the ring in newPositions
        const targetStartIndex = targetIndex;
        // In case the ring contains a pole (e.g. Antarctica), we'll have to insert vertices
        // The insertion point is defined by the vertex closest to the pole
        // Split the the ring by the insertion point when copying to newPositions
        const splitIndex = findSplitIndex(positions, size, srcStartIndex, srcEndIndex);
        for(let i = splitIndex; i < srcEndIndex; i++){
            newPositions[targetIndex++] = positions[i];
        }
        for(let i = srcStartIndex; i < splitIndex; i++){
            newPositions[targetIndex++] = positions[i];
        }
        // Remap longitudes so that each segment takes the shorter path
        wrapLongitudesForShortestPath(newPositions, size, targetStartIndex, targetIndex);
        // Handle the case when the ring contains a pole
        insertPoleVertices(newPositions, size, targetStartIndex, targetIndex, options?.maxLatitude);
        srcStartIndex = srcEndIndex;
        newHoleIndices[ringIndex] = targetIndex;
    }
    newHoleIndices.pop();
    const parts = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$cut$2d$by$2d$grid$2e$js__$5b$client$5d$__$28$ecmascript$29$__["cutPolygonByGrid"])(newPositions, newHoleIndices, {
        size,
        gridResolution: 360,
        gridOffset: [
            -180,
            -180
        ],
        edgeTypes
    });
    if (normalize) {
        // Each part is guaranteed to be in a single copy of the world
        // Map longitudes back to [-180, 180]
        for (const part of parts){
            // @ts-expect-error (mutates readonly array) May mutate newPositions, which is created by us
            shiftLongitudesIntoRange(part.positions, size);
        }
    }
    return parts;
}
/* Helpers */ // See comments for insertPoleVertices
function findSplitIndex(positions, size, startIndex, endIndex) {
    let maxLat = -1;
    let pointIndex = -1;
    for(let i = startIndex + 1; i < endIndex; i += size){
        const lat = Math.abs(positions[i]);
        if (lat > maxLat) {
            maxLat = lat;
            pointIndex = i - 1;
        }
    }
    return pointIndex;
}
// https://user-images.githubusercontent.com/2059298/78857483-5987e400-79de-11ea-98fc-0631287a8431.png
//
// If the polygon contains a pole, to tesselate it correctly, we need to insert the edge
// of map into the polygon. This requires adding two vertices that represent the pole, by
// drawing a perpendicular line to the Mercator map edge from a selected vertex on the ring.
//
// We select the insertion position carefully so that the inserted line segments do not
// intersect with the ring itself. This is ensured by findSplitIndex, which returns the
// vertex closest to the pole.
function insertPoleVertices(positions, size, startIndex, endIndex, maxLatitude = DEFAULT_MAX_LATITUDE) {
    // Check if the ring contains a pole
    const firstLng = positions[startIndex];
    const lastLng = positions[endIndex - size];
    if (Math.abs(firstLng - lastLng) > 180) {
        // The ring does not make a round trip
        // Add the nearest pole to the vertices so that the polygon tesselates correctly
        const p = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getPointAtIndex"])(positions, 0, size, startIndex);
        // Copy the first vertex to the world of the last vertex
        p[0] += Math.round((lastLng - firstLng) / 360) * 360;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["push"])(positions, p);
        // Project the copied vertex to the edge of the map
        p[1] = Math.sign(p[1]) * maxLatitude;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["push"])(positions, p);
        // Project the first vertex to the edge of the map
        p[0] = firstLng;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["push"])(positions, p);
    }
}
function wrapLongitudesForShortestPath(positions, size, startIndex, endIndex) {
    let prevLng = positions[0];
    let lng;
    for(let i = startIndex; i < endIndex; i += size){
        lng = positions[i];
        const delta = lng - prevLng;
        if (delta > 180 || delta < -180) {
            lng -= Math.round(delta / 360) * 360;
        }
        positions[i] = prevLng = lng;
    }
}
function shiftLongitudesIntoRange(positions, size) {
    let refLng;
    const pointCount = positions.length / size;
    // Find a longitude that is not on the edge of a world
    // Which we will use to determine which world copy it is
    for(let i = 0; i < pointCount; i++){
        refLng = positions[i * size];
        if ((refLng + 180) % 360 !== 0) {
            break;
        }
    }
    const delta = -Math.round(refLng / 360) * 360;
    if (delta === 0) {
        return;
    }
    for(let i = 0; i < pointCount; i++){
        positions[i * size] += delta;
    }
} //# sourceMappingURL=cut-by-mercator-bounds.js.map
}}),
"[project]/node_modules/@math.gl/polygon/dist/index.js [client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({});
;
;
;
;
;
;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@math.gl/polygon/dist/index.js [client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$polygon$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/polygon/dist/polygon.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$polygon$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/polygon/dist/polygon-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$earcut$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/polygon/dist/earcut.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$lineclip$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/polygon/dist/lineclip.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$cut$2d$by$2d$grid$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/polygon/dist/cut-by-grid.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$cut$2d$by$2d$mercator$2d$bounds$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/polygon/dist/cut-by-mercator-bounds.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/polygon/dist/index.js [client] (ecmascript) <locals>");
}}),
"[project]/node_modules/@math.gl/culling/dist/constants.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "INTERSECTION": (()=>INTERSECTION)
});
const INTERSECTION = {
    OUTSIDE: -1,
    INTERSECTING: 0,
    INSIDE: 1 // Represents that an object is fully within the frustum.
}; //# sourceMappingURL=constants.js.map
}}),
"[project]/node_modules/@math.gl/culling/dist/lib/bounding-volumes/axis-aligned-bounding-box.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT and Apache-2.0
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "AxisAlignedBoundingBox": (()=>AxisAlignedBoundingBox)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/classes/vector3.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/constants.js [client] (ecmascript)");
;
;
const scratchVector = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const scratchNormal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
class AxisAlignedBoundingBox {
    /**
     * Creates an instance of an AxisAlignedBoundingBox from the minimum and maximum points along the x, y, and z axes.
     * @param minimum=[0, 0, 0] The minimum point along the x, y, and z axes.
     * @param maximum=[0, 0, 0] The maximum point along the x, y, and z axes.
     * @param center The center of the box; automatically computed if not supplied.
     */ constructor(minimum = [
        0,
        0,
        0
    ], maximum = [
        0,
        0,
        0
    ], center){
        // If center was not defined, compute it.
        center = center || scratchVector.copy(minimum).add(maximum).scale(0.5);
        this.center = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"](center);
        this.halfDiagonal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"](maximum).subtract(this.center);
        /**
         * The minimum point defining the bounding box.
         * @type {Vector3}
         * @default {@link 0, 0, 0}
         */ this.minimum = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"](minimum);
        /**
         * The maximum point defining the bounding box.
         * @type {Vector3}
         * @default {@link 0, 0, 0}
         */ this.maximum = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"](maximum);
    }
    /**
     * Duplicates a AxisAlignedBoundingBox instance.
     *
     * @returns {AxisAlignedBoundingBox} A new AxisAlignedBoundingBox instance.
     */ clone() {
        return new AxisAlignedBoundingBox(this.minimum, this.maximum, this.center);
    }
    /**
     * Compares the provided AxisAlignedBoundingBox componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     *
     * @param {AxisAlignedBoundingBox} [right] The second AxisAlignedBoundingBox to compare with.
     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */ equals(right) {
        return this === right || Boolean(right) && this.minimum.equals(right.minimum) && this.maximum.equals(right.maximum);
    }
    /**
     * Applies a 4x4 affine transformation matrix to a bounding sphere.
     * @param transform The transformation matrix to apply to the bounding sphere.
     * @returns itself, i.e. the modified BoundingVolume.
     */ transform(transform) {
        this.center.transformAsPoint(transform);
        // TODO - this.halfDiagonal.transformAsVector(transform);
        this.halfDiagonal.transform(transform);
        this.minimum.transform(transform);
        this.maximum.transform(transform);
        return this;
    }
    /**
     * Determines which side of a plane a box is located.
     */ intersectPlane(plane) {
        const { halfDiagonal } = this;
        const normal = scratchNormal.from(plane.normal);
        const e = halfDiagonal.x * Math.abs(normal.x) + halfDiagonal.y * Math.abs(normal.y) + halfDiagonal.z * Math.abs(normal.z);
        const s = this.center.dot(normal) + plane.distance; // signed distance from center
        if (s - e > 0) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["INTERSECTION"].INSIDE;
        }
        if (s + e < 0) {
            // Not in front because normals point inward
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["INTERSECTION"].OUTSIDE;
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["INTERSECTION"].INTERSECTING;
    }
    /** Computes the estimated distance from the closest point on a bounding box to a point. */ distanceTo(point) {
        return Math.sqrt(this.distanceSquaredTo(point));
    }
    /** Computes the estimated distance squared from the closest point on a bounding box to a point. */ distanceSquaredTo(point) {
        const offset = scratchVector.from(point).subtract(this.center);
        const { halfDiagonal } = this;
        let distanceSquared = 0.0;
        let d;
        d = Math.abs(offset.x) - halfDiagonal.x;
        if (d > 0) {
            distanceSquared += d * d;
        }
        d = Math.abs(offset.y) - halfDiagonal.y;
        if (d > 0) {
            distanceSquared += d * d;
        }
        d = Math.abs(offset.z) - halfDiagonal.z;
        if (d > 0) {
            distanceSquared += d * d;
        }
        return distanceSquared;
    }
} //# sourceMappingURL=axis-aligned-bounding-box.js.map
}}),
"[project]/node_modules/@math.gl/culling/dist/lib/bounding-volumes/bounding-sphere.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT and Apache-2.0
// Copyright (c) vis.gl contributors
// This file is derived from the Cesium math library under Apache 2 license
// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md
__turbopack_context__.s({
    "BoundingSphere": (()=>BoundingSphere)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/classes/vector3.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$mat4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__mat4$3e$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/gl-matrix/mat4.js [client] (ecmascript) <export * as mat4>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/constants.js [client] (ecmascript)");
;
;
const scratchVector = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const scratchVector2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
class BoundingSphere {
    /** Creates a bounding sphere */ constructor(center = [
        0,
        0,
        0
    ], radius = 0.0){
        this.radius = -0;
        this.center = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
        this.fromCenterRadius(center, radius);
    }
    /** Sets the bounding sphere from `center` and `radius`. */ fromCenterRadius(center, radius) {
        this.center.from(center);
        this.radius = radius;
        return this;
    }
    /**
     * Computes a bounding sphere from the corner points of an axis-aligned bounding box.  The sphere
     * tightly and fully encompasses the box.
     */ fromCornerPoints(corner, oppositeCorner) {
        oppositeCorner = scratchVector.from(oppositeCorner);
        this.center = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]().from(corner).add(oppositeCorner).scale(0.5);
        this.radius = this.center.distance(oppositeCorner);
        return this;
    }
    /** Compares the provided BoundingSphere component wise */ equals(right) {
        return this === right || Boolean(right) && this.center.equals(right.center) && this.radius === right.radius;
    }
    /** Duplicates a BoundingSphere instance. */ clone() {
        return new BoundingSphere(this.center, this.radius);
    }
    /** Computes a bounding sphere that contains both the left and right bounding spheres. */ union(boundingSphere) {
        const leftCenter = this.center;
        const leftRadius = this.radius;
        const rightCenter = boundingSphere.center;
        const rightRadius = boundingSphere.radius;
        const toRightCenter = scratchVector.copy(rightCenter).subtract(leftCenter);
        const centerSeparation = toRightCenter.magnitude();
        if (leftRadius >= centerSeparation + rightRadius) {
            // Left sphere wins.
            return this.clone();
        }
        if (rightRadius >= centerSeparation + leftRadius) {
            // Right sphere wins.
            return boundingSphere.clone();
        }
        // There are two tangent points, one on far side of each sphere.
        const halfDistanceBetweenTangentPoints = (leftRadius + centerSeparation + rightRadius) * 0.5;
        // Compute the center point halfway between the two tangent points.
        scratchVector2.copy(toRightCenter).scale((-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation).add(leftCenter);
        this.center.copy(scratchVector2);
        this.radius = halfDistanceBetweenTangentPoints;
        return this;
    }
    /** Computes a bounding sphere by enlarging the provided sphere to contain the provided point. */ expand(point) {
        const scratchPoint = scratchVector.from(point);
        const radius = scratchPoint.subtract(this.center).magnitude();
        if (radius > this.radius) {
            this.radius = radius;
        }
        return this;
    }
    // BoundingVolume interface
    /**
     * Applies a 4x4 affine transformation matrix to a bounding sphere.
     * @param sphere The bounding sphere to apply the transformation to.
     * @param transform The transformation matrix to apply to the bounding sphere.
     * @returns self.
     */ transform(transform) {
        this.center.transform(transform);
        const scale = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$mat4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__mat4$3e$__["mat4"].getScaling(scratchVector, transform);
        this.radius = Math.max(scale[0], Math.max(scale[1], scale[2])) * this.radius;
        return this;
    }
    /** Computes the estimated distance squared from the closest point on a bounding sphere to a point. */ distanceSquaredTo(point) {
        const d = this.distanceTo(point);
        return d * d;
    }
    /** Computes the estimated distance from the closest point on a bounding sphere to a point. */ distanceTo(point) {
        const scratchPoint = scratchVector.from(point);
        const delta = scratchPoint.subtract(this.center);
        return Math.max(0, delta.len() - this.radius);
    }
    /** Determines which side of a plane a sphere is located. */ intersectPlane(plane) {
        const center = this.center;
        const radius = this.radius;
        const normal = plane.normal;
        const distanceToPlane = normal.dot(center) + plane.distance;
        // The center point is negative side of the plane normal
        if (distanceToPlane < -radius) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["INTERSECTION"].OUTSIDE;
        }
        // The center point is positive side of the plane, but radius extends beyond it; partial overlap
        if (distanceToPlane < radius) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["INTERSECTION"].INTERSECTING;
        }
        // The center point and radius is positive side of the plane
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["INTERSECTION"].INSIDE;
    }
} //# sourceMappingURL=bounding-sphere.js.map
}}),
"[project]/node_modules/@math.gl/culling/dist/lib/bounding-volumes/oriented-bounding-box.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT and Apache-2.0
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "OrientedBoundingBox": (()=>OrientedBoundingBox)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/classes/vector3.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix3$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/classes/matrix3.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$quaternion$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/classes/quaternion.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$bounding$2d$volumes$2f$bounding$2d$sphere$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/bounding-volumes/bounding-sphere.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/constants.js [client] (ecmascript)");
;
;
;
const scratchVector3 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const scratchOffset = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const scratchVectorU = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const scratchVectorV = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const scratchVectorW = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const scratchCorner = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const scratchToCenter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const MATRIX3 = {
    COLUMN0ROW0: 0,
    COLUMN0ROW1: 1,
    COLUMN0ROW2: 2,
    COLUMN1ROW0: 3,
    COLUMN1ROW1: 4,
    COLUMN1ROW2: 5,
    COLUMN2ROW0: 6,
    COLUMN2ROW1: 7,
    COLUMN2ROW2: 8
};
class OrientedBoundingBox {
    constructor(center = [
        0,
        0,
        0
    ], halfAxes = [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
    ]){
        this.center = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]().from(center);
        this.halfAxes = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix3"](halfAxes);
    }
    /** Returns an array with three halfSizes for the bounding box */ get halfSize() {
        const xAxis = this.halfAxes.getColumn(0);
        const yAxis = this.halfAxes.getColumn(1);
        const zAxis = this.halfAxes.getColumn(2);
        return [
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"](xAxis).len(),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"](yAxis).len(),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"](zAxis).len()
        ];
    }
    /** Returns a quaternion describing the orientation of the bounding box */ get quaternion() {
        const xAxis = this.halfAxes.getColumn(0);
        const yAxis = this.halfAxes.getColumn(1);
        const zAxis = this.halfAxes.getColumn(2);
        const normXAxis = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"](xAxis).normalize();
        const normYAxis = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"](yAxis).normalize();
        const normZAxis = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"](zAxis).normalize();
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$quaternion$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Quaternion"]().fromMatrix3(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix3"]([
            ...normXAxis,
            ...normYAxis,
            ...normZAxis
        ]));
    }
    /**
     * Create OrientedBoundingBox from quaternion based OBB,
     */ fromCenterHalfSizeQuaternion(center, halfSize, quaternion) {
        const quaternionObject = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$quaternion$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Quaternion"](quaternion);
        const directionsMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix3"]().fromQuaternion(quaternionObject);
        directionsMatrix[0] = directionsMatrix[0] * halfSize[0];
        directionsMatrix[1] = directionsMatrix[1] * halfSize[0];
        directionsMatrix[2] = directionsMatrix[2] * halfSize[0];
        directionsMatrix[3] = directionsMatrix[3] * halfSize[1];
        directionsMatrix[4] = directionsMatrix[4] * halfSize[1];
        directionsMatrix[5] = directionsMatrix[5] * halfSize[1];
        directionsMatrix[6] = directionsMatrix[6] * halfSize[2];
        directionsMatrix[7] = directionsMatrix[7] * halfSize[2];
        directionsMatrix[8] = directionsMatrix[8] * halfSize[2];
        this.center = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]().from(center);
        this.halfAxes = directionsMatrix;
        return this;
    }
    /** Duplicates a OrientedBoundingBox instance. */ clone() {
        return new OrientedBoundingBox(this.center, this.halfAxes);
    }
    /** Compares the provided OrientedBoundingBox component wise and returns */ equals(right) {
        return this === right || Boolean(right) && this.center.equals(right.center) && this.halfAxes.equals(right.halfAxes);
    }
    /** Computes a tight-fitting bounding sphere enclosing the provided oriented bounding box. */ getBoundingSphere(result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$bounding$2d$volumes$2f$bounding$2d$sphere$2e$js__$5b$client$5d$__$28$ecmascript$29$__["BoundingSphere"]()) {
        const halfAxes = this.halfAxes;
        const u = halfAxes.getColumn(0, scratchVectorU);
        const v = halfAxes.getColumn(1, scratchVectorV);
        const w = halfAxes.getColumn(2, scratchVectorW);
        // Calculate "corner" vector
        const cornerVector = scratchVector3.copy(u).add(v).add(w);
        result.center.copy(this.center);
        result.radius = cornerVector.magnitude();
        return result;
    }
    /** Determines which side of a plane the oriented bounding box is located. */ intersectPlane(plane) {
        const center = this.center;
        const normal = plane.normal;
        const halfAxes = this.halfAxes;
        const normalX = normal.x;
        const normalY = normal.y;
        const normalZ = normal.z;
        // Plane is used as if it is its normal; the first three components are assumed to be normalized
        const radEffective = Math.abs(normalX * halfAxes[MATRIX3.COLUMN0ROW0] + normalY * halfAxes[MATRIX3.COLUMN0ROW1] + normalZ * halfAxes[MATRIX3.COLUMN0ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN1ROW0] + normalY * halfAxes[MATRIX3.COLUMN1ROW1] + normalZ * halfAxes[MATRIX3.COLUMN1ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN2ROW0] + normalY * halfAxes[MATRIX3.COLUMN2ROW1] + normalZ * halfAxes[MATRIX3.COLUMN2ROW2]);
        const distanceToPlane = normal.dot(center) + plane.distance;
        if (distanceToPlane <= -radEffective) {
            // The entire box is on the negative side of the plane normal
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["INTERSECTION"].OUTSIDE;
        } else if (distanceToPlane >= radEffective) {
            // The entire box is on the positive side of the plane normal
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["INTERSECTION"].INSIDE;
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["INTERSECTION"].INTERSECTING;
    }
    /** Computes the estimated distance from the closest point on a bounding box to a point. */ distanceTo(point) {
        return Math.sqrt(this.distanceSquaredTo(point));
    }
    /**
     * Computes the estimated distance squared from the closest point
     * on a bounding box to a point.
     * See Geometric Tools for Computer Graphics 10.4.2
     */ distanceSquaredTo(point) {
        // Computes the estimated distance squared from the
        // closest point on a bounding box to a point.
        // See Geometric Tools for Computer Graphics 10.4.2
        const offset = scratchOffset.from(point).subtract(this.center);
        const halfAxes = this.halfAxes;
        const u = halfAxes.getColumn(0, scratchVectorU);
        const v = halfAxes.getColumn(1, scratchVectorV);
        const w = halfAxes.getColumn(2, scratchVectorW);
        const uHalf = u.magnitude();
        const vHalf = v.magnitude();
        const wHalf = w.magnitude();
        u.normalize();
        v.normalize();
        w.normalize();
        let distanceSquared = 0.0;
        let d;
        d = Math.abs(offset.dot(u)) - uHalf;
        if (d > 0) {
            distanceSquared += d * d;
        }
        d = Math.abs(offset.dot(v)) - vHalf;
        if (d > 0) {
            distanceSquared += d * d;
        }
        d = Math.abs(offset.dot(w)) - wHalf;
        if (d > 0) {
            distanceSquared += d * d;
        }
        return distanceSquared;
    }
    /**
     * The distances calculated by the vector from the center of the bounding box
     * to position projected onto direction.
     *
     * - If you imagine the infinite number of planes with normal direction,
     *   this computes the smallest distance to the closest and farthest planes
     *   from `position` that intersect the bounding box.
     *
     * @param position The position to calculate the distance from.
     * @param direction The direction from position.
     * @param result An Interval (array of length 2) to store the nearest and farthest distances.
     * @returns Interval (array of length 2) with nearest and farthest distances
     *   on the bounding box from position in direction.
     */ // eslint-disable-next-line max-statements
    computePlaneDistances(position, direction, result = [
        -0,
        -0
    ]) {
        let minDist = Number.POSITIVE_INFINITY;
        let maxDist = Number.NEGATIVE_INFINITY;
        const center = this.center;
        const halfAxes = this.halfAxes;
        const u = halfAxes.getColumn(0, scratchVectorU);
        const v = halfAxes.getColumn(1, scratchVectorV);
        const w = halfAxes.getColumn(2, scratchVectorW);
        // project first corner
        const corner = scratchCorner.copy(u).add(v).add(w).add(center);
        const toCenter = scratchToCenter.copy(corner).subtract(position);
        let mag = direction.dot(toCenter);
        minDist = Math.min(mag, minDist);
        maxDist = Math.max(mag, maxDist);
        // project second corner
        corner.copy(center).add(u).add(v).subtract(w);
        toCenter.copy(corner).subtract(position);
        mag = direction.dot(toCenter);
        minDist = Math.min(mag, minDist);
        maxDist = Math.max(mag, maxDist);
        // project third corner
        corner.copy(center).add(u).subtract(v).add(w);
        toCenter.copy(corner).subtract(position);
        mag = direction.dot(toCenter);
        minDist = Math.min(mag, minDist);
        maxDist = Math.max(mag, maxDist);
        // project fourth corner
        corner.copy(center).add(u).subtract(v).subtract(w);
        toCenter.copy(corner).subtract(position);
        mag = direction.dot(toCenter);
        minDist = Math.min(mag, minDist);
        maxDist = Math.max(mag, maxDist);
        // project fifth corner
        center.copy(corner).subtract(u).add(v).add(w);
        toCenter.copy(corner).subtract(position);
        mag = direction.dot(toCenter);
        minDist = Math.min(mag, minDist);
        maxDist = Math.max(mag, maxDist);
        // project sixth corner
        center.copy(corner).subtract(u).add(v).subtract(w);
        toCenter.copy(corner).subtract(position);
        mag = direction.dot(toCenter);
        minDist = Math.min(mag, minDist);
        maxDist = Math.max(mag, maxDist);
        // project seventh corner
        center.copy(corner).subtract(u).subtract(v).add(w);
        toCenter.copy(corner).subtract(position);
        mag = direction.dot(toCenter);
        minDist = Math.min(mag, minDist);
        maxDist = Math.max(mag, maxDist);
        // project eighth corner
        center.copy(corner).subtract(u).subtract(v).subtract(w);
        toCenter.copy(corner).subtract(position);
        mag = direction.dot(toCenter);
        minDist = Math.min(mag, minDist);
        maxDist = Math.max(mag, maxDist);
        result[0] = minDist;
        result[1] = maxDist;
        return result;
    }
    /**
     * Applies a 4x4 affine transformation matrix to a bounding sphere.
     * @param transform The transformation matrix to apply to the bounding sphere.
     * @returns itself, i.e. the modified BoundingVolume.
     */ transform(transformation) {
        this.center.transformAsPoint(transformation);
        const xAxis = this.halfAxes.getColumn(0, scratchVectorU);
        xAxis.transformAsPoint(transformation);
        const yAxis = this.halfAxes.getColumn(1, scratchVectorV);
        yAxis.transformAsPoint(transformation);
        const zAxis = this.halfAxes.getColumn(2, scratchVectorW);
        zAxis.transformAsPoint(transformation);
        this.halfAxes = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix3"]([
            ...xAxis,
            ...yAxis,
            ...zAxis
        ]);
        return this;
    }
    getTransform() {
        // const modelMatrix = Matrix4.fromRotationTranslation(this.boundingVolume.halfAxes, this.boundingVolume.center);
        // return modelMatrix;
        throw new Error('not implemented');
    }
} //# sourceMappingURL=oriented-bounding-box.js.map
}}),
"[project]/node_modules/@math.gl/culling/dist/lib/plane.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT and Apache-2.0
// Copyright (c) vis.gl contributors
// This file is derived from the Cesium math library under Apache 2 license
// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md
/* eslint-disable */ __turbopack_context__.s({
    "Plane": (()=>Plane)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/classes/vector3.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$common$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/lib/common.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/lib/assert.js [client] (ecmascript)");
;
const scratchPosition = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const scratchNormal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
class Plane {
    constructor(normal = [
        0,
        0,
        1
    ], distance = 0){
        this.normal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
        this.distance = -0;
        this.fromNormalDistance(normal, distance);
    }
    /** Creates a plane from a normal and a distance from the origin. */ fromNormalDistance(normal, distance) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(Number.isFinite(distance));
        this.normal.from(normal).normalize();
        this.distance = distance;
        return this;
    }
    /** Creates a plane from a normal and a point on the plane. */ fromPointNormal(point, normal) {
        point = scratchPosition.from(point);
        this.normal.from(normal).normalize();
        const distance = -this.normal.dot(point);
        this.distance = distance;
        return this;
    }
    /** Creates a plane from the general equation */ fromCoefficients(a, b, c, d) {
        this.normal.set(a, b, c);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$common$2e$js__$5b$client$5d$__$28$ecmascript$29$__["equals"])(this.normal.len(), 1));
        this.distance = d;
        return this;
    }
    /** Duplicates a Plane instance. */ clone() {
        return new Plane(this.normal, this.distance);
    }
    /** Compares the provided Planes by normal and distance */ equals(right) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$common$2e$js__$5b$client$5d$__$28$ecmascript$29$__["equals"])(this.distance, right.distance) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$common$2e$js__$5b$client$5d$__$28$ecmascript$29$__["equals"])(this.normal, right.normal);
    }
    /** Computes the signed shortest distance of a point to a plane.
     * The sign of the distance determines which side of the plane the point is on.
     */ getPointDistance(point) {
        return this.normal.dot(point) + this.distance;
    }
    /** Transforms the plane by the given transformation matrix. */ transform(matrix4) {
        const normal = scratchNormal.copy(this.normal).transformAsVector(matrix4).normalize();
        const point = this.normal.scale(-this.distance).transform(matrix4);
        return this.fromPointNormal(point, normal);
    }
    projectPointOntoPlane(point, result = [
        0,
        0,
        0
    ]) {
        const scratchPoint = scratchPosition.from(point);
        // projectedPoint = point - (normal.point + scale) * normal
        const pointDistance = this.getPointDistance(scratchPoint);
        const scaledNormal = scratchNormal.copy(this.normal).scale(pointDistance);
        return scratchPoint.subtract(scaledNormal).to(result);
    }
} //# sourceMappingURL=plane.js.map
}}),
"[project]/node_modules/@math.gl/culling/dist/lib/culling-volume.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT and Apache-2.0
// Copyright (c) vis.gl contributors
// This file is derived from the Cesium math library under Apache 2 license
// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md
/* eslint-disable */ __turbopack_context__.s({
    "CullingVolume": (()=>CullingVolume)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/classes/vector3.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/lib/assert.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/constants.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$plane$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/plane.js [client] (ecmascript)");
;
;
;
// X, Y, Z Unit vectors
const faces = [
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]([
        1,
        0,
        0
    ]),
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]([
        0,
        1,
        0
    ]),
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]([
        0,
        0,
        1
    ])
];
const scratchPlaneCenter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const scratchPlaneNormal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
class CullingVolume {
    /**
     * Create a new `CullingVolume` bounded by an array of clipping planed
     * @param planes Array of clipping planes.
     * */ constructor(planes = []){
        this.planes = planes;
    }
    /**
     * Constructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere.
     * The planes are aligned to the x, y, and z axes in world coordinates.
     */ fromBoundingSphere(boundingSphere) {
        this.planes.length = 2 * faces.length;
        const center = boundingSphere.center;
        const radius = boundingSphere.radius;
        let planeIndex = 0;
        for (const faceNormal of faces){
            let plane0 = this.planes[planeIndex];
            let plane1 = this.planes[planeIndex + 1];
            if (!plane0) {
                plane0 = this.planes[planeIndex] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$plane$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Plane"]();
            }
            if (!plane1) {
                plane1 = this.planes[planeIndex + 1] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$plane$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Plane"]();
            }
            const plane0Center = scratchPlaneCenter.copy(faceNormal).scale(-radius).add(center);
            // const plane0Distance = -faceNormal.dot(plane0Center);
            plane0.fromPointNormal(plane0Center, faceNormal);
            const plane1Center = scratchPlaneCenter.copy(faceNormal).scale(radius).add(center);
            const negatedFaceNormal = scratchPlaneNormal.copy(faceNormal).negate();
            // const plane1Distance = -negatedFaceNormal.dot(plane1Center);
            plane1.fromPointNormal(plane1Center, negatedFaceNormal);
            planeIndex += 2;
        }
        return this;
    }
    /** Determines whether a bounding volume intersects the culling volume. */ computeVisibility(boundingVolume) {
        // const planes = this.planes;
        let intersect = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["INTERSECTION"].INSIDE;
        for (const plane of this.planes){
            const result = boundingVolume.intersectPlane(plane);
            switch(result){
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["INTERSECTION"].OUTSIDE:
                    // We are done
                    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["INTERSECTION"].OUTSIDE;
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["INTERSECTION"].INTERSECTING:
                    // If no other intersection is outside, return INTERSECTING
                    intersect = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["INTERSECTION"].INTERSECTING;
                    break;
                default:
            }
        }
        return intersect;
    }
    /**
     * Determines whether a bounding volume intersects the culling volume.
     *
     * @param parentPlaneMask A bit mask from the boundingVolume's parent's check against the same culling
     *   volume, such that if (planeMask & (1 << planeIndex) === 0), for k < 31, then
     *   the parent (and therefore this) volume is completely inside plane[planeIndex]
     *   and that plane check can be skipped.
     */ computeVisibilityWithPlaneMask(boundingVolume, parentPlaneMask) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(Number.isFinite(parentPlaneMask), 'parentPlaneMask is required.');
        if (parentPlaneMask === CullingVolume.MASK_OUTSIDE || parentPlaneMask === CullingVolume.MASK_INSIDE) {
            // parent is completely outside or completely inside, so this child is as well.
            return parentPlaneMask;
        }
        // Start with MASK_INSIDE (all zeros) so that after the loop, the return value can be compared with MASK_INSIDE.
        // (Because if there are fewer than 31 planes, the upper bits wont be changed.)
        let mask = CullingVolume.MASK_INSIDE;
        const planes = this.planes;
        for(let k = 0; k < this.planes.length; ++k){
            // For k greater than 31 (since 31 is the maximum number of INSIDE/INTERSECTING bits we can store), skip the optimization.
            const flag = k < 31 ? 1 << k : 0;
            if (k < 31 && (parentPlaneMask & flag) === 0) {
                continue;
            }
            const plane = planes[k];
            const result = boundingVolume.intersectPlane(plane);
            if (result === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["INTERSECTION"].OUTSIDE) {
                return CullingVolume.MASK_OUTSIDE;
            } else if (result === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["INTERSECTION"].INTERSECTING) {
                mask |= flag;
            }
        }
        return mask;
    }
}
/**
 * For plane masks (as used in {@link CullingVolume#computeVisibilityWithPlaneMask}), this special value
 * represents the case where the object bounding volume is entirely outside the culling volume.
 */ CullingVolume.MASK_OUTSIDE = 0xffffffff;
/**
 * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value
 * represents the case where the object bounding volume is entirely inside the culling volume.
 */ CullingVolume.MASK_INSIDE = 0x00000000;
/**
 * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value
 * represents the case where the object bounding volume (may) intersect all planes of the culling volume.
 */ CullingVolume.MASK_INDETERMINATE = 0x7fffffff; //# sourceMappingURL=culling-volume.js.map
}}),
"[project]/node_modules/@math.gl/culling/dist/lib/perspective-off-center-frustum.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT and Apache-2.0
// Copyright (c) vis.gl contributors
// This file is derived from the Cesium math library under Apache 2 license
// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md
// Note: This class is still an experimental export, mainly used by other test cases
// - It has not been fully adapted to math.gl conventions
// - Documentation has not been ported
__turbopack_context__.s({
    "PerspectiveOffCenterFrustum": (()=>PerspectiveOffCenterFrustum)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/classes/vector3.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix4$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/classes/matrix4.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/lib/assert.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$culling$2d$volume$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/culling-volume.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$plane$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/plane.js [client] (ecmascript)");
;
;
;
const scratchPlaneUpVector = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const scratchPlaneRightVector = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const scratchPlaneNearCenter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const scratchPlaneFarCenter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const scratchPlaneNormal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
class PerspectiveOffCenterFrustum {
    /**
     * The viewing frustum is defined by 6 planes.
     * Each plane is represented by a {@link Vector4} object, where the x, y, and z components
     * define the unit vector normal to the plane, and the w component is the distance of the
     * plane from the origin/camera position.
     *
     * @alias PerspectiveOffCenterFrustum
     *
     * @example
     * const frustum = new PerspectiveOffCenterFrustum({
     *     left : -1.0,
     *     right : 1.0,
     *     top : 1.0,
     *     bottom : -1.0,
     *     near : 1.0,
     *     far : 100.0
     * });
     *
     * @see PerspectiveFrustum
     */ constructor(options = {}){
        this._cullingVolume = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$culling$2d$volume$2e$js__$5b$client$5d$__$28$ecmascript$29$__["CullingVolume"]([
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$plane$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Plane"](),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$plane$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Plane"](),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$plane$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Plane"](),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$plane$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Plane"](),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$plane$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Plane"](),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$plane$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Plane"]()
        ]);
        this._perspectiveMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix4$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix4"]();
        this._infinitePerspective = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix4$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix4"]();
        const { near = 1.0, far = 500000000.0 } = options;
        this.left = options.left;
        this._left = undefined;
        this.right = options.right;
        this._right = undefined;
        this.top = options.top;
        this._top = undefined;
        this.bottom = options.bottom;
        this._bottom = undefined;
        this.near = near;
        this._near = near;
        this.far = far;
        this._far = far;
    }
    /**
     * Returns a duplicate of a PerspectiveOffCenterFrustum instance.
     * @returns {PerspectiveOffCenterFrustum} A new PerspectiveFrustum instance.
     * */ clone() {
        return new PerspectiveOffCenterFrustum({
            right: this.right,
            left: this.left,
            top: this.top,
            bottom: this.bottom,
            near: this.near,
            far: this.far
        });
    }
    /**
     * Compares the provided PerspectiveOffCenterFrustum componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     *
     * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
     */ equals(other) {
        return other && other instanceof PerspectiveOffCenterFrustum && this.right === other.right && this.left === other.left && this.top === other.top && this.bottom === other.bottom && this.near === other.near && this.far === other.far;
    }
    /**
     * Gets the perspective projection matrix computed from the view frustum.
     * @memberof PerspectiveOffCenterFrustum.prototype
     * @type {Matrix4}
     *
     * @see PerspectiveOffCenterFrustum#infiniteProjectionMatrix
     */ get projectionMatrix() {
        this._update();
        return this._perspectiveMatrix;
    }
    /**
     * Gets the perspective projection matrix computed from the view frustum with an infinite far plane.
     * @memberof PerspectiveOffCenterFrustum.prototype
     * @type {Matrix4}
     *
     * @see PerspectiveOffCenterFrustum#projectionMatrix
     */ get infiniteProjectionMatrix() {
        this._update();
        return this._infinitePerspective;
    }
    /**
     * Creates a culling volume for this frustum.
     * @returns {CullingVolume} A culling volume at the given position and orientation.
     *
     * @example
     * // Check if a bounding volume intersects the frustum.
     * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);
     * const intersect = cullingVolume.computeVisibility(boundingVolume);
     */ // eslint-disable-next-line complexity, max-statements
    computeCullingVolume(/** A Vector3 defines the eye position. */ position, /** A Vector3 defines the view direction. */ direction, /** A Vector3 defines the up direction. */ up) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(position, 'position is required.');
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(direction, 'direction is required.');
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(up, 'up is required.');
        const planes = this._cullingVolume.planes;
        up = scratchPlaneUpVector.copy(up).normalize();
        const right = scratchPlaneRightVector.copy(direction).cross(up).normalize();
        const nearCenter = scratchPlaneNearCenter.copy(direction).multiplyByScalar(this.near).add(position);
        const farCenter = scratchPlaneFarCenter.copy(direction).multiplyByScalar(this.far).add(position);
        let normal = scratchPlaneNormal;
        // Left plane computation
        normal.copy(right).multiplyByScalar(this.left).add(nearCenter).subtract(position).cross(up);
        planes[0].fromPointNormal(position, normal);
        // Right plane computation
        normal.copy(right).multiplyByScalar(this.right).add(nearCenter).subtract(position).cross(up).negate();
        planes[1].fromPointNormal(position, normal);
        // Bottom plane computation
        normal.copy(up).multiplyByScalar(this.bottom).add(nearCenter).subtract(position).cross(right).negate();
        planes[2].fromPointNormal(position, normal);
        // Top plane computation
        normal.copy(up).multiplyByScalar(this.top).add(nearCenter).subtract(position).cross(right);
        planes[3].fromPointNormal(position, normal);
        normal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]().copy(direction);
        // Near plane computation
        planes[4].fromPointNormal(nearCenter, normal);
        // Far plane computation
        normal.negate();
        planes[5].fromPointNormal(farCenter, normal);
        return this._cullingVolume;
    }
    /**
     * Returns the pixel's width and height in meters.
     *
     * @returns {Vector2} The modified result parameter or a new instance of {@link Vector2} with the pixel's width and height in the x and y properties, respectively.
     *
     * @exception {DeveloperError} drawingBufferWidth must be greater than zero.
     * @exception {DeveloperError} drawingBufferHeight must be greater than zero.
     *
     * @example
     * // Example 1
     * // Get the width and height of a pixel.
     * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, new Vector2());
     *
     * @example
     * // Example 2
     * // Get the width and height of a pixel if the near plane was set to 'distance'.
     * // For example, get the size of a pixel of an image on a billboard.
     * const position = camera.position;
     * const direction = camera.direction;
     * const toCenter = Vector3.subtract(primitive.boundingVolume.center, position, new Vector3());      // vector from camera to a primitive
     * const toCenterProj = Vector3.multiplyByScalar(direction, Vector3.dot(direction, toCenter), new Vector3()); // project vector onto camera direction vector
     * const distance = Vector3.magnitude(toCenterProj);
     * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distance, new Vector2());
     */ getPixelDimensions(/** The width of the drawing buffer. */ drawingBufferWidth, /** The height of the drawing buffer. */ drawingBufferHeight, /** The distance to the near plane in meters. */ distance, /** The object onto which to store the result. */ result) {
        this._update();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(Number.isFinite(drawingBufferWidth) && Number.isFinite(drawingBufferHeight));
        // 'Both drawingBufferWidth and drawingBufferHeight are required.'
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(drawingBufferWidth > 0);
        // 'drawingBufferWidth must be greater than zero.'
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(drawingBufferHeight > 0);
        // 'drawingBufferHeight must be greater than zero.'
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(distance > 0);
        // 'distance is required.');
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(result);
        // 'A result object is required.');
        const inverseNear = 1.0 / this.near;
        let tanTheta = this.top * inverseNear;
        const pixelHeight = 2.0 * distance * tanTheta / drawingBufferHeight;
        tanTheta = this.right * inverseNear;
        const pixelWidth = 2.0 * distance * tanTheta / drawingBufferWidth;
        result.x = pixelWidth;
        result.y = pixelHeight;
        return result;
    }
    // eslint-disable-next-line complexity, max-statements
    _update() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(Number.isFinite(this.right) && Number.isFinite(this.left) && Number.isFinite(this.top) && Number.isFinite(this.bottom) && Number.isFinite(this.near) && Number.isFinite(this.far));
        // throw new DeveloperError('right, left, top, bottom, near, or far parameters are not set.');
        const { top, bottom, right, left, near, far } = this;
        if (top !== this._top || bottom !== this._bottom || left !== this._left || right !== this._right || near !== this._near || far !== this._far) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(this.near > 0 && this.near < this.far, 'near must be greater than zero and less than far.');
            this._left = left;
            this._right = right;
            this._top = top;
            this._bottom = bottom;
            this._near = near;
            this._far = far;
            this._perspectiveMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix4$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix4"]().frustum({
                left,
                right,
                bottom,
                top,
                near,
                far
            });
            this._infinitePerspective = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix4$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix4"]().frustum({
                left,
                right,
                bottom,
                top,
                near,
                far: Infinity
            });
        }
    }
} //# sourceMappingURL=perspective-off-center-frustum.js.map
}}),
"[project]/node_modules/@math.gl/culling/dist/lib/perspective-frustum.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT and Apache-2.0
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "PerspectiveFrustum": (()=>PerspectiveFrustum)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/lib/assert.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector2$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/classes/vector2.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$perspective$2d$off$2d$center$2d$frustum$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/perspective-off-center-frustum.js [client] (ecmascript)");
;
;
const defined = (val)=>val !== null && typeof val !== 'undefined';
class PerspectiveFrustum {
    constructor(options = {}){
        this._offCenterFrustum = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$perspective$2d$off$2d$center$2d$frustum$2e$js__$5b$client$5d$__$28$ecmascript$29$__["PerspectiveOffCenterFrustum"]();
        const { fov, aspectRatio, near = 1.0, far = 500000000.0, xOffset = 0.0, yOffset = 0.0 } = options;
        this.fov = fov;
        this.aspectRatio = aspectRatio;
        this.near = near;
        this.far = far;
        this.xOffset = xOffset;
        this.yOffset = yOffset;
    }
    /**
     * Returns a duplicate of a PerspectiveFrustum instance.
     */ clone() {
        return new PerspectiveFrustum({
            aspectRatio: this.aspectRatio,
            fov: this.fov,
            near: this.near,
            far: this.far
        });
    }
    /**
     * Compares the provided PerspectiveFrustum componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     */ equals(other) {
        if (!defined(other) || !(other instanceof PerspectiveFrustum)) {
            return false;
        }
        this._update();
        other._update();
        return this.fov === other.fov && this.aspectRatio === other.aspectRatio && this.near === other.near && this.far === other.far && this._offCenterFrustum.equals(other._offCenterFrustum);
    }
    /**
     * Gets the perspective projection matrix computed from the view this.
     */ get projectionMatrix() {
        this._update();
        return this._offCenterFrustum.projectionMatrix;
    }
    /**
     * The perspective projection matrix computed from the view frustum with an infinite far plane.
     */ get infiniteProjectionMatrix() {
        this._update();
        return this._offCenterFrustum.infiniteProjectionMatrix;
    }
    /**
     * Gets the angle of the vertical field of view, in radians.
     */ get fovy() {
        this._update();
        return this._fovy;
    }
    /**
     * @private
     */ get sseDenominator() {
        this._update();
        return this._sseDenominator;
    }
    /**
     * Creates a culling volume for this this.ion.
     * @returns {CullingVolume} A culling volume at the given position and orientation.
     *
     * @example
     * // Check if a bounding volume intersects the this.
     * var cullingVolume = this.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);
     * var intersect = cullingVolume.computeVisibility(boundingVolume);
     */ computeCullingVolume(/** A Vector3 defines the eye position. */ position, /** A Vector3 defines the view direction. */ direction, /** A Vector3 defines the up direction. */ up) {
        this._update();
        return this._offCenterFrustum.computeCullingVolume(position, direction, up);
    }
    /**
     * Returns the pixel's width and height in meters.
     * @returns {Vector2} The modified result parameter or a new instance of {@link Vector2} with the pixel's width and height in the x and y properties, respectively.
     *
     * @exception {DeveloperError} drawingBufferWidth must be greater than zero.
     * @exception {DeveloperError} drawingBufferHeight must be greater than zero.
     *
     * @example
     * // Example 1
     * // Get the width and height of a pixel.
     * var pixelSize = camera.this.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, new Vector2());
     *
     * @example
     * // Example 2
     * // Get the width and height of a pixel if the near plane was set to 'distance'.
     * // For example, get the size of a pixel of an image on a billboard.
     * var position = camera.position;
     * var direction = camera.direction;
     * var toCenter = Vector3.subtract(primitive.boundingVolume.center, position, new Vector3());      // vector from camera to a primitive
     * var toCenterProj = Vector3.multiplyByScalar(direction, Vector3.dot(direction, toCenter), new Vector3()); // project vector onto camera direction vector
     * var distance = Vector3.magnitude(toCenterProj);
     * var pixelSize = camera.this.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distance, new Vector2());
     */ getPixelDimensions(/** The width of the drawing buffer. */ drawingBufferWidth, /** The height of the drawing buffer. */ drawingBufferHeight, /** The distance to the near plane in meters. */ distance, /** The object onto which to store the result. */ result) {
        this._update();
        return this._offCenterFrustum.getPixelDimensions(drawingBufferWidth, drawingBufferHeight, distance, result || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector2$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector2"]());
    }
    // eslint-disable-next-line complexity, max-statements
    _update() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(Number.isFinite(this.fov) && Number.isFinite(this.aspectRatio) && Number.isFinite(this.near) && Number.isFinite(this.far));
        // 'fov, aspectRatio, near, or far parameters are not set.'
        const f = this._offCenterFrustum;
        if (this.fov !== this._fov || this.aspectRatio !== this._aspectRatio || this.near !== this._near || this.far !== this._far || this.xOffset !== this._xOffset || this.yOffset !== this._yOffset) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(this.fov >= 0 && this.fov < Math.PI);
            // throw new DeveloperError('fov must be in the range [0, PI).');
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(this.aspectRatio > 0);
            // throw new DeveloperError('aspectRatio must be positive.');
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(this.near >= 0 && this.near < this.far);
            // throw new DeveloperError('near must be greater than zero and less than far.');
            this._aspectRatio = this.aspectRatio;
            this._fov = this.fov;
            this._fovy = this.aspectRatio <= 1 ? this.fov : Math.atan(Math.tan(this.fov * 0.5) / this.aspectRatio) * 2.0;
            this._near = this.near;
            this._far = this.far;
            this._sseDenominator = 2.0 * Math.tan(0.5 * this._fovy);
            this._xOffset = this.xOffset;
            this._yOffset = this.yOffset;
            f.top = this.near * Math.tan(0.5 * this._fovy);
            f.bottom = -f.top;
            f.right = this.aspectRatio * f.top;
            f.left = -f.right;
            f.near = this.near;
            f.far = this.far;
            f.right += this.xOffset;
            f.left += this.xOffset;
            f.top += this.yOffset;
            f.bottom += this.yOffset;
        }
    }
} //# sourceMappingURL=perspective-frustum.js.map
}}),
"[project]/node_modules/@math.gl/culling/dist/lib/algorithms/bounding-sphere-from-points.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT and Apache-2.0
// Copyright (c) vis.gl contributors
// This file is derived from the Cesium math library under Apache 2 license
// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md
__turbopack_context__.s({
    "makeBoundingSphereFromPoints": (()=>makeBoundingSphereFromPoints)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/classes/vector3.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$bounding$2d$volumes$2f$bounding$2d$sphere$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/bounding-volumes/bounding-sphere.js [client] (ecmascript)");
;
;
/* eslint-disable */ const fromPointsXMin = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const fromPointsYMin = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const fromPointsZMin = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const fromPointsXMax = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const fromPointsYMax = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const fromPointsZMax = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const fromPointsCurrentPos = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const fromPointsScratch = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const fromPointsRitterCenter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const fromPointsMinBoxPt = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const fromPointsMaxBoxPt = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const fromPointsNaiveCenterScratch = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
function makeBoundingSphereFromPoints(positions, result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$bounding$2d$volumes$2f$bounding$2d$sphere$2e$js__$5b$client$5d$__$28$ecmascript$29$__["BoundingSphere"]()) {
    if (!positions || positions.length === 0) {
        return result.fromCenterRadius([
            0,
            0,
            0
        ], 0);
    }
    const currentPos = fromPointsCurrentPos.copy(positions[0]);
    const xMin = fromPointsXMin.copy(currentPos);
    const yMin = fromPointsYMin.copy(currentPos);
    const zMin = fromPointsZMin.copy(currentPos);
    const xMax = fromPointsXMax.copy(currentPos);
    const yMax = fromPointsYMax.copy(currentPos);
    const zMax = fromPointsZMax.copy(currentPos);
    for (const position of positions){
        currentPos.copy(position);
        const x = currentPos.x;
        const y = currentPos.y;
        const z = currentPos.z;
        // Store points containing the the smallest and largest components
        if (x < xMin.x) {
            xMin.copy(currentPos);
        }
        if (x > xMax.x) {
            xMax.copy(currentPos);
        }
        if (y < yMin.y) {
            yMin.copy(currentPos);
        }
        if (y > yMax.y) {
            yMax.copy(currentPos);
        }
        if (z < zMin.z) {
            zMin.copy(currentPos);
        }
        if (z > zMax.z) {
            zMax.copy(currentPos);
        }
    }
    // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).
    const xSpan = fromPointsScratch.copy(xMax).subtract(xMin).magnitudeSquared();
    const ySpan = fromPointsScratch.copy(yMax).subtract(yMin).magnitudeSquared();
    const zSpan = fromPointsScratch.copy(zMax).subtract(zMin).magnitudeSquared();
    // Set the diameter endpoints to the largest span.
    let diameter1 = xMin;
    let diameter2 = xMax;
    let maxSpan = xSpan;
    if (ySpan > maxSpan) {
        maxSpan = ySpan;
        diameter1 = yMin;
        diameter2 = yMax;
    }
    if (zSpan > maxSpan) {
        maxSpan = zSpan;
        diameter1 = zMin;
        diameter2 = zMax;
    }
    // Calculate the center of the initial sphere found by Ritter's algorithm
    const ritterCenter = fromPointsRitterCenter;
    ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;
    ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;
    ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;
    // Calculate the radius of the initial sphere found by Ritter's algorithm
    let radiusSquared = fromPointsScratch.copy(diameter2).subtract(ritterCenter).magnitudeSquared();
    let ritterRadius = Math.sqrt(radiusSquared);
    // Find the center of the sphere found using the Naive method.
    const minBoxPt = fromPointsMinBoxPt;
    minBoxPt.x = xMin.x;
    minBoxPt.y = yMin.y;
    minBoxPt.z = zMin.z;
    const maxBoxPt = fromPointsMaxBoxPt;
    maxBoxPt.x = xMax.x;
    maxBoxPt.y = yMax.y;
    maxBoxPt.z = zMax.z;
    const naiveCenter = fromPointsNaiveCenterScratch.copy(minBoxPt).add(maxBoxPt).multiplyByScalar(0.5);
    // Begin 2nd pass to find naive radius and modify the ritter sphere.
    let naiveRadius = 0;
    for (const position of positions){
        currentPos.copy(position);
        // Find the furthest point from the naive center to calculate the naive radius.
        const r = fromPointsScratch.copy(currentPos).subtract(naiveCenter).magnitude();
        if (r > naiveRadius) {
            naiveRadius = r;
        }
        // Make adjustments to the Ritter Sphere to include all points.
        const oldCenterToPointSquared = fromPointsScratch.copy(currentPos).subtract(ritterCenter).magnitudeSquared();
        if (oldCenterToPointSquared > radiusSquared) {
            const oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);
            // Calculate new radius to include the point that lies outside
            ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;
            radiusSquared = ritterRadius * ritterRadius;
            // Calculate center of new Ritter sphere
            const oldToNew = oldCenterToPoint - ritterRadius;
            ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;
            ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;
            ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;
        }
    }
    if (ritterRadius < naiveRadius) {
        ritterCenter.to(result.center);
        result.radius = ritterRadius;
    } else {
        naiveCenter.to(result.center);
        result.radius = naiveRadius;
    }
    return result;
} //# sourceMappingURL=bounding-sphere-from-points.js.map
}}),
"[project]/node_modules/@math.gl/culling/dist/lib/algorithms/compute-eigen-decomposition.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT and Apache-2.0
// Copyright (c) vis.gl contributors
// This file is derived from the Cesium math library under Apache 2 license
// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md
__turbopack_context__.s({
    "computeEigenDecomposition": (()=>computeEigenDecomposition)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix3$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/classes/matrix3.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__$5f$MathUtils$3e$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/lib/math-utils.js [client] (ecmascript) <export * as _MathUtils>");
;
const scratchMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix3"]();
const scratchUnitary = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix3"]();
const scratchDiagonal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix3"]();
const jMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix3"]();
const jMatrixTranspose = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix3"]();
function computeEigenDecomposition(matrix, // @ts-expect-error accept empty object type
result = {}) {
    const EIGEN_TOLERANCE = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__$5f$MathUtils$3e$__["_MathUtils"].EPSILON20;
    const EIGEN_MAX_SWEEPS = 10;
    let count = 0;
    let sweep = 0;
    const unitaryMatrix = scratchUnitary;
    const diagonalMatrix = scratchDiagonal;
    unitaryMatrix.identity();
    diagonalMatrix.copy(matrix);
    const epsilon = EIGEN_TOLERANCE * computeFrobeniusNorm(diagonalMatrix);
    while(sweep < EIGEN_MAX_SWEEPS && offDiagonalFrobeniusNorm(diagonalMatrix) > epsilon){
        shurDecomposition(diagonalMatrix, jMatrix);
        jMatrixTranspose.copy(jMatrix).transpose();
        diagonalMatrix.multiplyRight(jMatrix);
        diagonalMatrix.multiplyLeft(jMatrixTranspose);
        unitaryMatrix.multiplyRight(jMatrix);
        if (++count > 2) {
            ++sweep;
            count = 0;
        }
    }
    result.unitary = unitaryMatrix.toTarget(result.unitary);
    result.diagonal = diagonalMatrix.toTarget(result.diagonal);
    return result;
}
function computeFrobeniusNorm(matrix) {
    let norm = 0.0;
    for(let i = 0; i < 9; ++i){
        const temp = matrix[i];
        norm += temp * temp;
    }
    return Math.sqrt(norm);
}
const rowVal = [
    1,
    0,
    0
];
const colVal = [
    2,
    2,
    1
];
// Computes the "off-diagonal" Frobenius norm.
// Assumes matrix is symmetric.
function offDiagonalFrobeniusNorm(matrix) {
    let norm = 0.0;
    for(let i = 0; i < 3; ++i){
        const temp = matrix[scratchMatrix.getElementIndex(colVal[i], rowVal[i])];
        norm += 2.0 * temp * temp;
    }
    return Math.sqrt(norm);
}
// The routine takes a matrix, which is assumed to be symmetric, and
// finds the largest off-diagonal term, and then creates
// a matrix (result) which can be used to help reduce it
//
// This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,
// section 8.4.2 The 2by2 Symmetric Schur Decomposition.
//
// eslint-disable-next-line max-statements
function shurDecomposition(matrix, result) {
    const tolerance = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__$5f$MathUtils$3e$__["_MathUtils"].EPSILON15;
    let maxDiagonal = 0.0;
    let rotAxis = 1;
    // find pivot (rotAxis) based on max diagonal of matrix
    for(let i = 0; i < 3; ++i){
        const temp = Math.abs(matrix[scratchMatrix.getElementIndex(colVal[i], rowVal[i])]);
        if (temp > maxDiagonal) {
            rotAxis = i;
            maxDiagonal = temp;
        }
    }
    const p = rowVal[rotAxis];
    const q = colVal[rotAxis];
    let c = 1.0;
    let s = 0.0;
    if (Math.abs(matrix[scratchMatrix.getElementIndex(q, p)]) > tolerance) {
        const qq = matrix[scratchMatrix.getElementIndex(q, q)];
        const pp = matrix[scratchMatrix.getElementIndex(p, p)];
        const qp = matrix[scratchMatrix.getElementIndex(q, p)];
        const tau = (qq - pp) / 2.0 / qp;
        let t;
        if (tau < 0.0) {
            t = -1.0 / (-tau + Math.sqrt(1.0 + tau * tau));
        } else {
            t = 1.0 / (tau + Math.sqrt(1.0 + tau * tau));
        }
        c = 1.0 / Math.sqrt(1.0 + t * t);
        s = t * c;
    }
    // Copy into result
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix3"].IDENTITY.to(result);
    result[scratchMatrix.getElementIndex(p, p)] = result[scratchMatrix.getElementIndex(q, q)] = c;
    result[scratchMatrix.getElementIndex(q, p)] = s;
    result[scratchMatrix.getElementIndex(p, q)] = -s;
    return result;
} //# sourceMappingURL=compute-eigen-decomposition.js.map
}}),
"[project]/node_modules/@math.gl/culling/dist/lib/algorithms/bounding-box-from-points.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT and Apache-2.0
// Copyright (c) vis.gl contributors
// This file is derived from the Cesium math library under Apache 2 license
// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md
__turbopack_context__.s({
    "makeAxisAlignedBoundingBoxFromPoints": (()=>makeAxisAlignedBoundingBoxFromPoints),
    "makeOrientedBoundingBoxFromPoints": (()=>makeOrientedBoundingBoxFromPoints)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/classes/vector3.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix3$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/classes/matrix3.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$algorithms$2f$compute$2d$eigen$2d$decomposition$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/algorithms/compute-eigen-decomposition.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$bounding$2d$volumes$2f$oriented$2d$bounding$2d$box$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/bounding-volumes/oriented-bounding-box.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$bounding$2d$volumes$2f$axis$2d$aligned$2d$bounding$2d$box$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/bounding-volumes/axis-aligned-bounding-box.js [client] (ecmascript)");
;
;
;
;
const scratchVector2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const scratchVector3 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const scratchVector4 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const scratchVector5 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const scratchVector6 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const scratchCovarianceResult = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix3"]();
const scratchEigenResult = {
    diagonal: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix3"](),
    unitary: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix3"]()
};
function makeOrientedBoundingBoxFromPoints(positions, result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$bounding$2d$volumes$2f$oriented$2d$bounding$2d$box$2e$js__$5b$client$5d$__$28$ecmascript$29$__["OrientedBoundingBox"]()) {
    if (!positions || positions.length === 0) {
        result.halfAxes = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix3"]([
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]);
        result.center = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
        return result;
    }
    const length = positions.length;
    const meanPoint = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"](0, 0, 0);
    for (const position of positions){
        meanPoint.add(position);
    }
    const invLength = 1.0 / length;
    meanPoint.multiplyByScalar(invLength);
    let exx = 0.0;
    let exy = 0.0;
    let exz = 0.0;
    let eyy = 0.0;
    let eyz = 0.0;
    let ezz = 0.0;
    for (const position of positions){
        const p = scratchVector2.copy(position).subtract(meanPoint);
        exx += p.x * p.x;
        exy += p.x * p.y;
        exz += p.x * p.z;
        eyy += p.y * p.y;
        eyz += p.y * p.z;
        ezz += p.z * p.z;
    }
    exx *= invLength;
    exy *= invLength;
    exz *= invLength;
    eyy *= invLength;
    eyz *= invLength;
    ezz *= invLength;
    const covarianceMatrix = scratchCovarianceResult;
    covarianceMatrix[0] = exx;
    covarianceMatrix[1] = exy;
    covarianceMatrix[2] = exz;
    covarianceMatrix[3] = exy;
    covarianceMatrix[4] = eyy;
    covarianceMatrix[5] = eyz;
    covarianceMatrix[6] = exz;
    covarianceMatrix[7] = eyz;
    covarianceMatrix[8] = ezz;
    const { unitary } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$algorithms$2f$compute$2d$eigen$2d$decomposition$2e$js__$5b$client$5d$__$28$ecmascript$29$__["computeEigenDecomposition"])(covarianceMatrix, scratchEigenResult);
    const rotation = result.halfAxes.copy(unitary);
    let v1 = rotation.getColumn(0, scratchVector4);
    let v2 = rotation.getColumn(1, scratchVector5);
    let v3 = rotation.getColumn(2, scratchVector6);
    let u1 = -Number.MAX_VALUE;
    let u2 = -Number.MAX_VALUE;
    let u3 = -Number.MAX_VALUE;
    let l1 = Number.MAX_VALUE;
    let l2 = Number.MAX_VALUE;
    let l3 = Number.MAX_VALUE;
    for (const position of positions){
        scratchVector2.copy(position);
        u1 = Math.max(scratchVector2.dot(v1), u1);
        u2 = Math.max(scratchVector2.dot(v2), u2);
        u3 = Math.max(scratchVector2.dot(v3), u3);
        l1 = Math.min(scratchVector2.dot(v1), l1);
        l2 = Math.min(scratchVector2.dot(v2), l2);
        l3 = Math.min(scratchVector2.dot(v3), l3);
    }
    v1 = v1.multiplyByScalar(0.5 * (l1 + u1));
    v2 = v2.multiplyByScalar(0.5 * (l2 + u2));
    v3 = v3.multiplyByScalar(0.5 * (l3 + u3));
    result.center.copy(v1).add(v2).add(v3);
    const scale = scratchVector3.set(u1 - l1, u2 - l2, u3 - l3).multiplyByScalar(0.5);
    const scaleMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix3"]([
        scale[0],
        0,
        0,
        0,
        scale[1],
        0,
        0,
        0,
        scale[2]
    ]);
    result.halfAxes.multiplyRight(scaleMatrix);
    return result;
}
function makeAxisAlignedBoundingBoxFromPoints(positions, result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$bounding$2d$volumes$2f$axis$2d$aligned$2d$bounding$2d$box$2e$js__$5b$client$5d$__$28$ecmascript$29$__["AxisAlignedBoundingBox"]()) {
    if (!positions || positions.length === 0) {
        result.minimum.set(0, 0, 0);
        result.maximum.set(0, 0, 0);
        result.center.set(0, 0, 0);
        result.halfDiagonal.set(0, 0, 0);
        return result;
    }
    let minimumX = positions[0][0];
    let minimumY = positions[0][1];
    let minimumZ = positions[0][2];
    let maximumX = positions[0][0];
    let maximumY = positions[0][1];
    let maximumZ = positions[0][2];
    for (const p of positions){
        const x = p[0];
        const y = p[1];
        const z = p[2];
        minimumX = Math.min(x, minimumX);
        maximumX = Math.max(x, maximumX);
        minimumY = Math.min(y, minimumY);
        maximumY = Math.max(y, maximumY);
        minimumZ = Math.min(z, minimumZ);
        maximumZ = Math.max(z, maximumZ);
    }
    result.minimum.set(minimumX, minimumY, minimumZ);
    result.maximum.set(maximumX, maximumY, maximumZ);
    result.center.copy(result.minimum).add(result.maximum).scale(0.5);
    result.halfDiagonal.copy(result.maximum).subtract(result.center);
    return result;
} //# sourceMappingURL=bounding-box-from-points.js.map
}}),
"[project]/node_modules/@math.gl/culling/dist/index.js [client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({});
;
;
;
;
;
;
;
;
;
;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@math.gl/culling/dist/index.js [client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/constants.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$bounding$2d$volumes$2f$axis$2d$aligned$2d$bounding$2d$box$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/bounding-volumes/axis-aligned-bounding-box.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$bounding$2d$volumes$2f$bounding$2d$sphere$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/bounding-volumes/bounding-sphere.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$bounding$2d$volumes$2f$oriented$2d$bounding$2d$box$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/bounding-volumes/oriented-bounding-box.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$culling$2d$volume$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/culling-volume.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$plane$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/plane.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$perspective$2d$off$2d$center$2d$frustum$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/perspective-off-center-frustum.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$perspective$2d$frustum$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/perspective-frustum.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$algorithms$2f$bounding$2d$sphere$2d$from$2d$points$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/algorithms/bounding-sphere-from-points.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$algorithms$2f$bounding$2d$box$2d$from$2d$points$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/algorithms/bounding-box-from-points.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$algorithms$2f$compute$2d$eigen$2d$decomposition$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/algorithms/compute-eigen-decomposition.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/index.js [client] (ecmascript) <locals>");
}}),
}]);

//# sourceMappingURL=node_modules_%40math_gl_de08079b._.js.map