(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_@deck_gl_623e23e0._.js", {

"[project]/node_modules/@deck.gl/react/dist/utils/use-isomorphic-layout-effect.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// From https://github.com/streamich/react-use/blob/master/src/useIsomorphicLayoutEffect.ts
// useLayoutEffect but does not trigger warning in server-side rendering
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react/index.js [client] (ecmascript)");
;
const useIsomorphicLayoutEffect = typeof window !== 'undefined' ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useLayoutEffect"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useEffect"];
const __TURBOPACK__default__export__ = useIsomorphicLayoutEffect;
 //# sourceMappingURL=use-isomorphic-layout-effect.js.map
}}),
"[project]/node_modules/@deck.gl/react/dist/utils/inherits-from.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// Check if one JavaScript class inherits from another
__turbopack_context__.s({
    "inheritsFrom": (()=>inheritsFrom)
});
function inheritsFrom(Type, ParentType) {
    while(Type){
        if (Type === ParentType) {
            return true;
        }
        Type = Object.getPrototypeOf(Type);
    }
    return false;
} //# sourceMappingURL=inherits-from.js.map
}}),
"[project]/node_modules/@deck.gl/react/dist/utils/evaluate-children.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "default": (()=>evaluateChildren),
    "isComponent": (()=>isComponent)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react/index.js [client] (ecmascript)");
;
const MAP_STYLE = {
    position: 'absolute',
    zIndex: -1
};
function evaluateChildren(children, childProps) {
    if (typeof children === 'function') {
        return children(childProps);
    }
    if (Array.isArray(children)) {
        return children.map((child)=>evaluateChildren(child, childProps));
    }
    if (isComponent(children)) {
        // Special treatment for react-map-gl's Map component
        // to support shorthand use case <DeckGL><StaticMap /></DeckGL>
        if (isReactMap(children)) {
            // Place map under the canvas
            childProps.style = MAP_STYLE;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["cloneElement"])(children, childProps);
        }
        if (needsDeckGLViewProps(children)) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["cloneElement"])(children, childProps);
        }
    }
    return children;
}
function isComponent(child) {
    return child && typeof child === 'object' && 'type' in child || false;
}
function isReactMap(child) {
    return child.props?.mapStyle;
}
function needsDeckGLViewProps(child) {
    const componentClass = child.type;
    // @ts-expect-error deckGLViewProps is a custom hack defined on the constructor (nebula.gl)
    return componentClass && componentClass.deckGLViewProps;
} //# sourceMappingURL=evaluate-children.js.map
}}),
"[project]/node_modules/@deck.gl/react/dist/utils/extract-jsx-layers.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "default": (()=>extractJSXLayers)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$inherits$2d$from$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/react/dist/utils/inherits-from.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$layer$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Layer$3e$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/core/dist/lib/layer.js [client] (ecmascript) <export default as Layer>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$views$2f$view$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__View$3e$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/core/dist/views/view.js [client] (ecmascript) <export default as View>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$evaluate$2d$children$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/react/dist/utils/evaluate-children.js [client] (ecmascript)");
;
;
;
;
;
// recursively wrap render callbacks in `View`
function wrapInView(node) {
    if (typeof node === 'function') {
        // React.Children does not traverse functions.
        // All render callbacks must be protected under a <View>
        // @ts-expect-error View is not a ReactJSXElement constructor. Only used as a temporary wrapper and will be removed in extractJSXLayers
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["createElement"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$views$2f$view$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__View$3e$__["View"], {}, node);
    }
    if (Array.isArray(node)) {
        return node.map(wrapInView);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$evaluate$2d$children$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isComponent"])(node)) {
        if (node.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Fragment"]) {
            return wrapInView(node.props.children);
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$inherits$2d$from$2e$js__$5b$client$5d$__$28$ecmascript$29$__["inheritsFrom"])(node.type, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$views$2f$view$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__View$3e$__["View"])) {
            return node;
        }
    }
    return node;
}
function extractJSXLayers({ children, layers = [], views = null }) {
    const reactChildren = []; // extract real react elements (i.e. not deck.gl layers)
    const jsxLayers = []; // extracted layer from react children, will add to deck.gl layer array
    const jsxViews = {};
    // React.children
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Children"].forEach(wrapInView(children), (reactElement)=>{
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$evaluate$2d$children$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isComponent"])(reactElement)) {
            // For some reason Children.forEach doesn't filter out `null`s
            const ElementType = reactElement.type;
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$inherits$2d$from$2e$js__$5b$client$5d$__$28$ecmascript$29$__["inheritsFrom"])(ElementType, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$layer$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Layer$3e$__["Layer"])) {
                const layer = createLayer(ElementType, reactElement.props);
                jsxLayers.push(layer);
            } else {
                reactChildren.push(reactElement);
            }
            // empty id => default view
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$inherits$2d$from$2e$js__$5b$client$5d$__$28$ecmascript$29$__["inheritsFrom"])(ElementType, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$views$2f$view$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__View$3e$__["View"]) && ElementType !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$views$2f$view$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__View$3e$__["View"] && reactElement.props.id) {
                // @ts-ignore Cannot instantiate an abstract class (View)
                const view = new ElementType(reactElement.props);
                jsxViews[view.id] = view;
            }
        } else if (reactElement) {
            reactChildren.push(reactElement);
        }
    });
    // Avoid modifying views if no JSX views were found
    if (Object.keys(jsxViews).length > 0) {
        // If a view is specified in both views prop and JSX, use the one in views
        if (Array.isArray(views)) {
            views.forEach((view)=>{
                jsxViews[view.id] = view;
            });
        } else if (views) {
            jsxViews[views.id] = views;
        }
        views = Object.values(jsxViews);
    }
    // Avoid modifying layers array if no JSX layers were found
    layers = jsxLayers.length > 0 ? [
        ...jsxLayers,
        ...layers
    ] : layers;
    return {
        layers,
        children: reactChildren,
        views
    };
}
function createLayer(LayerType, reactProps) {
    const props = {};
    // Layer.defaultProps is treated as ReactElement.defaultProps and merged into react props
    // Remove them
    const defaultProps = LayerType.defaultProps || {};
    for(const key in reactProps){
        if (defaultProps[key] !== reactProps[key]) {
            props[key] = reactProps[key];
        }
    }
    // @ts-ignore Cannot instantiate an abstract class (Layer)
    return new LayerType(props);
} //# sourceMappingURL=extract-jsx-layers.js.map
}}),
"[project]/node_modules/@deck.gl/react/dist/utils/deckgl-context.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "DeckGlContext": (()=>DeckGlContext)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react/index.js [client] (ecmascript)");
;
const DeckGlContext = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["createContext"])(); //# sourceMappingURL=deckgl-context.js.map
}}),
"[project]/node_modules/@deck.gl/react/dist/utils/position-children-under-views.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "default": (()=>positionChildrenUnderViews)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$views$2f$view$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__View$3e$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/core/dist/views/view.js [client] (ecmascript) <export default as View>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$inherits$2d$from$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/react/dist/utils/inherits-from.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$evaluate$2d$children$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/react/dist/utils/evaluate-children.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$deckgl$2d$context$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/react/dist/utils/deckgl-context.js [client] (ecmascript)");
;
;
;
;
;
function positionChildrenUnderViews({ children, deck, ContextProvider = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$deckgl$2d$context$2e$js__$5b$client$5d$__$28$ecmascript$29$__["DeckGlContext"].Provider }) {
    // @ts-expect-error accessing protected property
    const { viewManager } = deck || {};
    if (!viewManager || !viewManager.views.length) {
        return [];
    }
    const views = {};
    const defaultViewId = viewManager.views[0].id;
    // Sort children by view id
    for (const child of children){
        // Unless child is a View, position / render as part of the default view
        let viewId = defaultViewId;
        let viewChildren = child;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$evaluate$2d$children$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isComponent"])(child) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$inherits$2d$from$2e$js__$5b$client$5d$__$28$ecmascript$29$__["inheritsFrom"])(child.type, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$views$2f$view$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__View$3e$__["View"])) {
            viewId = child.props.id || defaultViewId;
            viewChildren = child.props.children;
        }
        const viewport = viewManager.getViewport(viewId);
        const viewState = viewManager.getViewState(viewId);
        // Drop (auto-hide) elements with viewId that are not matched by any current view
        if (viewport) {
            viewState.padding = viewport.padding;
            const { x, y, width, height } = viewport;
            // Resolve potentially relative dimensions using the deck.gl container size
            viewChildren = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$evaluate$2d$children$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(viewChildren, {
                x,
                y,
                width,
                height,
                viewport,
                viewState
            });
            if (!views[viewId]) {
                views[viewId] = {
                    viewport,
                    children: []
                };
            }
            views[viewId].children.push(viewChildren);
        }
    }
    // Render views
    return Object.keys(views).map((viewId)=>{
        const { viewport, children: viewChildren } = views[viewId];
        const { x, y, width, height } = viewport;
        const style = {
            position: 'absolute',
            left: x,
            top: y,
            width,
            height
        };
        const key = `view-${viewId}`;
        // If children is passed as an array, React will throw the "each element in a list needs
        // a key" warning. Sending each child as separate arguments removes this requirement.
        const viewElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["createElement"])('div', {
            key,
            id: key,
            style
        }, ...viewChildren);
        const contextValue = {
            deck,
            viewport,
            // @ts-expect-error accessing protected property
            container: deck.canvas.offsetParent,
            // @ts-expect-error accessing protected property
            eventManager: deck.eventManager,
            onViewStateChange: (params)=>{
                params.viewId = viewId;
                // @ts-expect-error accessing protected method
                deck._onViewStateChange(params);
            },
            widgets: []
        };
        const providerKey = `view-${viewId}-context`;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["createElement"])(ContextProvider, {
            key: providerKey,
            value: contextValue
        }, viewElement);
    });
} //# sourceMappingURL=position-children-under-views.js.map
}}),
"[project]/node_modules/@deck.gl/react/dist/utils/extract-styles.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "default": (()=>extractStyles)
});
const CANVAS_ONLY_STYLES = {
    mixBlendMode: null
};
function extractStyles({ width, height, style }) {
    // This styling is enforced for correct positioning with children
    const containerStyle = {
        position: 'absolute',
        zIndex: 0,
        left: 0,
        top: 0,
        width,
        height
    };
    // Fill the container
    const canvasStyle = {
        left: 0,
        top: 0
    };
    if (style) {
        for(const key in style){
            if (key in CANVAS_ONLY_STYLES) {
                // apply style to the canvas, but not deck's children, e.g. mix-blend-mode
                canvasStyle[key] = style[key];
            } else {
                // apply style to the container, e.g. position/flow settings
                containerStyle[key] = style[key];
            }
        }
    }
    return {
        containerStyle,
        canvasStyle
    };
} //# sourceMappingURL=extract-styles.js.map
}}),
"[project]/node_modules/@deck.gl/react/dist/deckgl.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$deck$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Deck$3e$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/core/dist/lib/deck.js [client] (ecmascript) <export default as Deck>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$use$2d$isomorphic$2d$layout$2d$effect$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/react/dist/utils/use-isomorphic-layout-effect.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$extract$2d$jsx$2d$layers$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/react/dist/utils/extract-jsx-layers.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$position$2d$children$2d$under$2d$views$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/react/dist/utils/position-children-under-views.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$extract$2d$styles$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/react/dist/utils/extract-styles.js [client] (ecmascript)");
;
;
;
;
;
;
;
function getRefHandles(thisRef) {
    return {
        get deck () {
            return thisRef.deck;
        },
        // The following method can only be called after ref is available, by which point deck is defined in useEffect
        pickObject: (opts)=>thisRef.deck.pickObject(opts),
        pickMultipleObjects: (opts)=>thisRef.deck.pickMultipleObjects(opts),
        pickObjects: (opts)=>thisRef.deck.pickObjects(opts)
    };
}
function redrawDeck(thisRef) {
    if (thisRef.redrawReason) {
        // Only redraw if we have received a dirty flag
        // @ts-expect-error accessing protected method
        thisRef.deck._drawLayers(thisRef.redrawReason);
        thisRef.redrawReason = null;
    }
}
function createDeckInstance(thisRef, DeckClass, props) {
    const deck = new DeckClass({
        ...props,
        // The Deck's animation loop is independent from React's render cycle, causing potential
        // synchronization issues. We provide this custom render function to make sure that React
        // and Deck update on the same schedule.
        // TODO(ibgreen) - Hack to enable WebGPU as it needs to render quickly to avoid CanvasContext texture from going stale
        _customRender: props.deviceProps?.adapters?.[0]?.type === 'webgpu' ? undefined : (redrawReason)=>{
            // Save the dirty flag for later
            thisRef.redrawReason = redrawReason;
            // Viewport/view state is passed to child components as props.
            // If they have changed, we need to trigger a React rerender to update children props.
            const viewports = deck.getViewports();
            if (thisRef.lastRenderedViewports !== viewports) {
                // Viewports have changed, update children props first.
                // This will delay the Deck canvas redraw till after React update (in useLayoutEffect)
                // so that the canvas does not get rendered before the child components update.
                thisRef.forceUpdate();
            } else {
                redrawDeck(thisRef);
            }
        }
    });
    return deck;
}
function DeckGLWithRef(props, ref) {
    // A mechanism to force redraw
    const [version, setVersion] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useState"])(0);
    // A reference to persistent states
    const _thisRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useRef"])({
        control: null,
        version,
        forceUpdate: {
            "DeckGLWithRef.useRef[_thisRef]": ()=>setVersion({
                    "DeckGLWithRef.useRef[_thisRef]": (v)=>v + 1
                }["DeckGLWithRef.useRef[_thisRef]"])
        }["DeckGLWithRef.useRef[_thisRef]"]
    });
    const thisRef = _thisRef.current;
    // DOM refs
    const containerRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useRef"])(null);
    const canvasRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useRef"])(null);
    // extract any deck.gl layers masquerading as react elements from props.children
    const jsxProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "DeckGLWithRef.useMemo[jsxProps]": ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$extract$2d$jsx$2d$layers$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(props)
    }["DeckGLWithRef.useMemo[jsxProps]"], [
        props.layers,
        props.views,
        props.children
    ]);
    // Callbacks
    let inRender = true;
    const handleViewStateChange = (params)=>{
        if (inRender && props.viewState) {
            // Callback may invoke a state update. Defer callback to after render() to avoid React error
            // In React StrictMode, render is executed twice and useEffect/useLayoutEffect is executed once
            // Store deferred parameters in ref so that we can access it in another render
            thisRef.viewStateUpdateRequested = params;
            return null;
        }
        thisRef.viewStateUpdateRequested = null;
        return props.onViewStateChange?.(params);
    };
    const handleInteractionStateChange = (params)=>{
        if (inRender) {
            // Callback may invoke a state update. Defer callback to after render() to avoid React error
            // In React StrictMode, render is executed twice and useEffect/useLayoutEffect is executed once
            // Store deferred parameters in ref so that we can access it in another render
            thisRef.interactionStateUpdateRequested = params;
        } else {
            thisRef.interactionStateUpdateRequested = null;
            props.onInteractionStateChange?.(params);
        }
    };
    // Update Deck's props. If Deck needs redraw, this will trigger a call to `_customRender` in
    // the next animation frame.
    // Needs to be called both from initial mount, and when new props are received
    const deckProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "DeckGLWithRef.useMemo[deckProps]": ()=>{
            const forwardProps = {
                widgets: [],
                ...props,
                // Override user styling props. We will set the canvas style in render()
                style: null,
                width: '100%',
                height: '100%',
                parent: containerRef.current,
                canvas: canvasRef.current,
                layers: jsxProps.layers,
                views: jsxProps.views,
                onViewStateChange: handleViewStateChange,
                onInteractionStateChange: handleInteractionStateChange
            };
            // The defaultValue for _customRender is null, which would overwrite the definition
            // of _customRender. Remove to avoid frequently redeclaring the method here.
            delete forwardProps._customRender;
            if (thisRef.deck) {
                thisRef.deck.setProps(forwardProps);
            }
            return forwardProps;
        }
    }["DeckGLWithRef.useMemo[deckProps]"], [
        props
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "DeckGLWithRef.useEffect": ()=>{
            const DeckClass = props.Deck || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$deck$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Deck$3e$__["Deck"];
            thisRef.deck = createDeckInstance(thisRef, DeckClass, {
                ...deckProps,
                parent: containerRef.current,
                canvas: canvasRef.current
            });
            return ({
                "DeckGLWithRef.useEffect": ()=>thisRef.deck?.finalize()
            })["DeckGLWithRef.useEffect"];
        }
    }["DeckGLWithRef.useEffect"], []);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$use$2d$isomorphic$2d$layout$2d$effect$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])({
        "DeckGLWithRef.useIsomorphicLayoutEffect": ()=>{
            // render has just been called. The children are positioned based on the current view state.
            // Redraw Deck canvas immediately, if necessary, using the current view state, so that it
            // matches the child components.
            redrawDeck(thisRef);
            // Execute deferred callbacks
            const { viewStateUpdateRequested, interactionStateUpdateRequested } = thisRef;
            if (viewStateUpdateRequested) {
                handleViewStateChange(viewStateUpdateRequested);
            }
            if (interactionStateUpdateRequested) {
                handleInteractionStateChange(interactionStateUpdateRequested);
            }
        }
    }["DeckGLWithRef.useIsomorphicLayoutEffect"]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useImperativeHandle"])(ref, {
        "DeckGLWithRef.useImperativeHandle": ()=>getRefHandles(thisRef)
    }["DeckGLWithRef.useImperativeHandle"], []);
    const currentViewports = thisRef.deck && thisRef.deck.isInitialized ? thisRef.deck.getViewports() : undefined;
    const { ContextProvider, width = '100%', height = '100%', id, style } = props;
    const { containerStyle, canvasStyle } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "DeckGLWithRef.useMemo": ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$extract$2d$styles$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])({
                width,
                height,
                style
            })
    }["DeckGLWithRef.useMemo"], [
        width,
        height,
        style
    ]);
    // Props changes may lead to 3 types of updates:
    // 1. Only the WebGL canvas - updated in Deck's render cycle (next animation frame)
    // 2. Only the DOM - updated in React's lifecycle (now)
    // 3. Both the WebGL canvas and the DOM - defer React rerender to next animation frame just
    //    before Deck redraw to ensure perfect synchronization & avoid excessive redraw
    //    This is because multiple changes may happen to Deck between two frames e.g. transition
    if (!thisRef.viewStateUpdateRequested && thisRef.lastRenderedViewports === currentViewports || // case 2
    thisRef.version !== version // case 3 just before deck redraws
    ) {
        thisRef.lastRenderedViewports = currentViewports;
        thisRef.version = version;
        // Render the background elements (typically react-map-gl instances)
        // using the view descriptors
        const childrenUnderViews = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$position$2d$children$2d$under$2d$views$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])({
            children: jsxProps.children,
            deck: thisRef.deck,
            ContextProvider
        });
        const canvas = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["createElement"])('canvas', {
            key: 'canvas',
            id: id || 'deckgl-overlay',
            ref: canvasRef,
            style: canvasStyle
        });
        // Render deck.gl as the last child
        thisRef.control = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["createElement"])('div', {
            id: `${id || 'deckgl'}-wrapper`,
            ref: containerRef,
            style: containerStyle
        }, [
            canvas,
            childrenUnderViews
        ]);
    }
    inRender = false;
    return thisRef.control;
}
const DeckGL = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["forwardRef"])(DeckGLWithRef);
const __TURBOPACK__default__export__ = DeckGL;
 //# sourceMappingURL=deckgl.js.map
}}),
"[project]/node_modules/@deck.gl/geo-layers/dist/tileset-2d/tile-2d-header.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "Tile2DHeader": (()=>Tile2DHeader)
});
class Tile2DHeader {
    constructor(index){
        this.index = index;
        this.isVisible = false;
        this.isSelected = false;
        this.parent = null;
        this.children = [];
        this.content = null;
        this._loader = undefined;
        this._abortController = null;
        this._loaderId = 0;
        this._isLoaded = false;
        this._isCancelled = false;
        this._needsReload = false;
    }
    /** @deprecated use `boundingBox` instead */ get bbox() {
        return this._bbox;
    }
    // TODO - remove in v9
    set bbox(value) {
        // Only set once from `Tileset2D.getTileMetadata`
        if (this._bbox) return;
        this._bbox = value;
        if ('west' in value) {
            this.boundingBox = [
                [
                    value.west,
                    value.south
                ],
                [
                    value.east,
                    value.north
                ]
            ];
        } else {
            this.boundingBox = [
                [
                    value.left,
                    value.top
                ],
                [
                    value.right,
                    value.bottom
                ]
            ];
        }
    }
    get data() {
        return this.isLoading && this._loader ? this._loader.then(()=>this.data) : this.content;
    }
    get isLoaded() {
        return this._isLoaded && !this._needsReload;
    }
    get isLoading() {
        return Boolean(this._loader) && !this._isCancelled;
    }
    get needsReload() {
        return this._needsReload || this._isCancelled;
    }
    get byteLength() {
        const result = this.content ? this.content.byteLength : 0;
        if (!Number.isFinite(result)) {
            // eslint-disable-next-line no-console
            console.error('byteLength not defined in tile data');
        }
        return result;
    }
    /* eslint-disable max-statements */ async _loadData({ getData, requestScheduler, onLoad, onError }) {
        const { index, id, bbox, userData, zoom } = this;
        const loaderId = this._loaderId;
        this._abortController = new AbortController();
        const { signal } = this._abortController;
        // @ts-expect-error (2345) Argument of type '(tile: any) => 1 | -1' is not assignable ...
        const requestToken = await requestScheduler.scheduleRequest(this, (tile)=>{
            return tile.isSelected ? 1 : -1;
        });
        if (!requestToken) {
            this._isCancelled = true;
            return;
        }
        // A tile can be cancelled while being scheduled
        if (this._isCancelled) {
            requestToken.done();
            return;
        }
        let tileData = null;
        let error;
        try {
            tileData = await getData({
                index,
                id,
                bbox,
                userData,
                zoom,
                signal
            });
        } catch (err) {
            error = err || true;
        } finally{
            requestToken.done();
        }
        // If loadData has been called with a newer version, discard the result from this operation
        if (loaderId !== this._loaderId) {
            return;
        }
        // Clear the `isLoading` flag
        this._loader = undefined;
        // Rewrite tile content with the result of getTileData if successful, or `null` in case of
        // error or cancellation
        this.content = tileData;
        // If cancelled, do not invoke the callbacks
        // Consider it loaded if we tried to cancel but `getTileData` still returned data
        if (this._isCancelled && !tileData) {
            this._isLoaded = false;
            return;
        }
        this._isLoaded = true;
        this._isCancelled = false;
        if (error) {
            onError(error, this);
        } else {
            onLoad(this);
        }
    }
    loadData(opts) {
        this._isLoaded = false;
        this._isCancelled = false;
        this._needsReload = false;
        this._loaderId++;
        this._loader = this._loadData(opts);
        return this._loader;
    }
    setNeedsReload() {
        if (this.isLoading) {
            this.abort();
            this._loader = undefined;
        }
        this._needsReload = true;
    }
    abort() {
        if (this.isLoaded) {
            return;
        }
        this._isCancelled = true;
        this._abortController?.abort();
    }
} //# sourceMappingURL=tile-2d-header.js.map
}}),
"[project]/node_modules/@deck.gl/geo-layers/dist/tileset-2d/tile-2d-traversal.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "getOSMTileIndices": (()=>getOSMTileIndices)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$viewports$2f$web$2d$mercator$2d$viewport$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__WebMercatorViewport$3e$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/core/dist/viewports/web-mercator-viewport.js [client] (ecmascript) <export default as WebMercatorViewport>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$viewports$2f$globe$2d$viewport$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__$5f$GlobeViewport$3e$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/core/dist/viewports/globe-viewport.js [client] (ecmascript) <export default as _GlobeViewport>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/index.js [client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$culling$2d$volume$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/culling-volume.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$plane$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/plane.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$bounding$2d$volumes$2f$axis$2d$aligned$2d$bounding$2d$box$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/bounding-volumes/axis-aligned-bounding-box.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$algorithms$2f$bounding$2d$box$2d$from$2d$points$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/algorithms/bounding-box-from-points.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/index.js [client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/web-mercator-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/geo-layers/dist/tileset-2d/utils.js [client] (ecmascript)");
;
;
;
;
const TILE_SIZE = 512;
// number of world copies to check
const MAX_MAPS = 3;
// for calculating bounding volume of a tile in a non-web-mercator viewport
const REF_POINTS_5 = [
    [
        0.5,
        0.5
    ],
    [
        0,
        0
    ],
    [
        0,
        1
    ],
    [
        1,
        0
    ],
    [
        1,
        1
    ]
]; // 4 corners and center
const REF_POINTS_9 = REF_POINTS_5.concat([
    [
        0,
        0.5
    ],
    [
        0.5,
        0
    ],
    [
        1,
        0.5
    ],
    [
        0.5,
        1
    ]
]); // 4 corners, center and 4 mid points
const REF_POINTS_11 = REF_POINTS_9.concat([
    [
        0.25,
        0.5
    ],
    [
        0.75,
        0.5
    ]
]); // 2 additional points on equator for top tile
class OSMNode {
    constructor(x, y, z){
        this.x = x;
        this.y = y;
        this.z = z;
    }
    get children() {
        if (!this._children) {
            const x = this.x * 2;
            const y = this.y * 2;
            const z = this.z + 1;
            this._children = [
                new OSMNode(x, y, z),
                new OSMNode(x, y + 1, z),
                new OSMNode(x + 1, y, z),
                new OSMNode(x + 1, y + 1, z)
            ];
        }
        return this._children;
    }
    // eslint-disable-next-line complexity
    update(params) {
        const { viewport, cullingVolume, elevationBounds, minZ, maxZ, bounds, offset, project } = params;
        const boundingVolume = this.getBoundingVolume(elevationBounds, offset, project);
        // First, check if this tile is visible
        if (bounds && !this.insideBounds(bounds)) {
            return false;
        }
        const isInside = cullingVolume.computeVisibility(boundingVolume);
        if (isInside < 0) {
            return false;
        }
        // Avoid loading overlapping tiles - if a descendant is requested, do not request the ancester
        if (!this.childVisible) {
            let { z } = this;
            if (z < maxZ && z >= minZ) {
                // Adjust LOD
                // If the tile is far enough from the camera, accept a lower zoom level
                const distance = boundingVolume.distanceTo(viewport.cameraPosition) * viewport.scale / viewport.height;
                z += Math.floor(Math.log2(distance));
            }
            if (z >= maxZ) {
                // LOD is acceptable
                this.selected = true;
                return true;
            }
        }
        // LOD is not enough, recursively test child tiles
        this.selected = false;
        this.childVisible = true;
        for (const child of this.children){
            child.update(params);
        }
        return true;
    }
    getSelected(result = []) {
        if (this.selected) {
            result.push(this);
        }
        if (this._children) {
            for (const node of this._children){
                node.getSelected(result);
            }
        }
        return result;
    }
    insideBounds([minX, minY, maxX, maxY]) {
        const scale = Math.pow(2, this.z);
        const extent = TILE_SIZE / scale;
        return this.x * extent < maxX && this.y * extent < maxY && (this.x + 1) * extent > minX && (this.y + 1) * extent > minY;
    }
    getBoundingVolume(zRange, worldOffset, project) {
        if (project) {
            // Custom projection
            // Estimate bounding box from sample points
            // At low zoom level we need more samples to calculate the bounding volume correctly
            const refPoints = this.z < 1 ? REF_POINTS_11 : this.z < 2 ? REF_POINTS_9 : REF_POINTS_5;
            // Convert from tile-relative coordinates to common space
            const refPointPositions = [];
            for (const p of refPoints){
                const lngLat = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["osmTile2lngLat"])(this.x + p[0], this.y + p[1], this.z);
                lngLat[2] = zRange[0];
                refPointPositions.push(project(lngLat));
                if (zRange[0] !== zRange[1]) {
                    // Account for the elevation volume
                    lngLat[2] = zRange[1];
                    refPointPositions.push(project(lngLat));
                }
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$algorithms$2f$bounding$2d$box$2d$from$2d$points$2e$js__$5b$client$5d$__$28$ecmascript$29$__["makeOrientedBoundingBoxFromPoints"])(refPointPositions);
        }
        // Use WebMercator projection
        const scale = Math.pow(2, this.z);
        const extent = TILE_SIZE / scale;
        const originX = this.x * extent + worldOffset * TILE_SIZE;
        // deck's common space is y-flipped
        const originY = TILE_SIZE - (this.y + 1) * extent;
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$bounding$2d$volumes$2f$axis$2d$aligned$2d$bounding$2d$box$2e$js__$5b$client$5d$__$28$ecmascript$29$__["AxisAlignedBoundingBox"]([
            originX,
            originY,
            zRange[0]
        ], [
            originX + extent,
            originY + extent,
            zRange[1]
        ]);
    }
}
function getOSMTileIndices(viewport, maxZ, zRange, bounds) {
    const project = viewport instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$viewports$2f$globe$2d$viewport$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__$5f$GlobeViewport$3e$__["_GlobeViewport"] && viewport.resolution ? viewport.projectPosition : null;
    // Get the culling volume of the current camera
    const planes = Object.values(viewport.getFrustumPlanes()).map(({ normal, distance })=>new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$plane$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Plane"](normal.clone().negate(), distance));
    const cullingVolume = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$culling$2d$volume$2e$js__$5b$client$5d$__$28$ecmascript$29$__["CullingVolume"](planes);
    // Project zRange from meters to common space
    const unitsPerMeter = viewport.distanceScales.unitsPerMeter[2];
    const elevationMin = zRange && zRange[0] * unitsPerMeter || 0;
    const elevationMax = zRange && zRange[1] * unitsPerMeter || 0;
    // Always load at the current zoom level if pitch is small
    const minZ = viewport instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$viewports$2f$web$2d$mercator$2d$viewport$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__WebMercatorViewport$3e$__["WebMercatorViewport"] && viewport.pitch <= 60 ? maxZ : 0;
    // Map extent to OSM position
    if (bounds) {
        const [minLng, minLat, maxLng, maxLat] = bounds;
        const topLeft = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["lngLatToWorld"])([
            minLng,
            maxLat
        ]);
        const bottomRight = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["lngLatToWorld"])([
            maxLng,
            minLat
        ]);
        bounds = [
            topLeft[0],
            TILE_SIZE - topLeft[1],
            bottomRight[0],
            TILE_SIZE - bottomRight[1]
        ];
    }
    const root = new OSMNode(0, 0, 0);
    const traversalParams = {
        viewport,
        project,
        cullingVolume,
        elevationBounds: [
            elevationMin,
            elevationMax
        ],
        minZ,
        maxZ,
        bounds,
        // num. of worlds from the center. For repeated maps
        offset: 0
    };
    root.update(traversalParams);
    if (viewport instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$viewports$2f$web$2d$mercator$2d$viewport$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__WebMercatorViewport$3e$__["WebMercatorViewport"] && viewport.subViewports && viewport.subViewports.length > 1) {
        // Check worlds in repeated maps
        traversalParams.offset = -1;
        while(root.update(traversalParams)){
            if (--traversalParams.offset < -MAX_MAPS) {
                break;
            }
        }
        traversalParams.offset = 1;
        while(root.update(traversalParams)){
            if (++traversalParams.offset > MAX_MAPS) {
                break;
            }
        }
    }
    return root.getSelected();
} //# sourceMappingURL=tile-2d-traversal.js.map
}}),
"[project]/node_modules/@deck.gl/geo-layers/dist/tileset-2d/utils.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "getCullBounds": (()=>getCullBounds),
    "getTileIndices": (()=>getTileIndices),
    "getURLFromTemplate": (()=>getURLFromTemplate),
    "isGeoBoundingBox": (()=>isGeoBoundingBox),
    "isURLTemplate": (()=>isURLTemplate),
    "osmTile2lngLat": (()=>osmTile2lngLat),
    "tileToBoundingBox": (()=>tileToBoundingBox),
    "urlType": (()=>urlType)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$tile$2d$2d$2d$traversal$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/geo-layers/dist/tileset-2d/tile-2d-traversal.js [client] (ecmascript)");
;
const TILE_SIZE = 512;
const DEFAULT_EXTENT = [
    -Infinity,
    -Infinity,
    Infinity,
    Infinity
];
const urlType = {
    type: 'object',
    value: null,
    validate: (value, propType)=>propType.optional && value === null || typeof value === 'string' || Array.isArray(value) && value.every((url)=>typeof url === 'string'),
    equal: (value1, value2)=>{
        if (value1 === value2) {
            return true;
        }
        if (!Array.isArray(value1) || !Array.isArray(value2)) {
            return false;
        }
        const len = value1.length;
        if (len !== value2.length) {
            return false;
        }
        for(let i = 0; i < len; i++){
            if (value1[i] !== value2[i]) {
                return false;
            }
        }
        return true;
    }
};
function transformBox(bbox, modelMatrix) {
    const transformedCoords = [
        // top-left
        modelMatrix.transformAsPoint([
            bbox[0],
            bbox[1]
        ]),
        // top-right
        modelMatrix.transformAsPoint([
            bbox[2],
            bbox[1]
        ]),
        // bottom-left
        modelMatrix.transformAsPoint([
            bbox[0],
            bbox[3]
        ]),
        // bottom-right
        modelMatrix.transformAsPoint([
            bbox[2],
            bbox[3]
        ])
    ];
    const transformedBox = [
        // Minimum x coord
        Math.min(...transformedCoords.map((i)=>i[0])),
        // Minimum y coord
        Math.min(...transformedCoords.map((i)=>i[1])),
        // Max x coord
        Math.max(...transformedCoords.map((i)=>i[0])),
        // Max y coord
        Math.max(...transformedCoords.map((i)=>i[1]))
    ];
    return transformedBox;
}
function stringHash(s) {
    return Math.abs(s.split('').reduce((a, b)=>(a << 5) - a + b.charCodeAt(0) | 0, 0));
}
function getURLFromTemplate(template, tile) {
    if (!template || !template.length) {
        return null;
    }
    const { index, id } = tile;
    if (Array.isArray(template)) {
        const i = stringHash(id) % template.length;
        template = template[i];
    }
    let url = template;
    for (const key of Object.keys(index)){
        const regex = new RegExp(`{${key}}`, 'g');
        url = url.replace(regex, String(index[key]));
    }
    // Back-compatible support for {-y}
    if (Number.isInteger(index.y) && Number.isInteger(index.z)) {
        url = url.replace(/\{-y\}/g, String(Math.pow(2, index.z) - index.y - 1));
    }
    return url;
}
/**
 * gets the bounding box of a viewport
 */ function getBoundingBox(viewport, zRange, extent) {
    let bounds;
    if (zRange && zRange.length === 2) {
        const [minZ, maxZ] = zRange;
        const bounds0 = viewport.getBounds({
            z: minZ
        });
        const bounds1 = viewport.getBounds({
            z: maxZ
        });
        bounds = [
            Math.min(bounds0[0], bounds1[0]),
            Math.min(bounds0[1], bounds1[1]),
            Math.max(bounds0[2], bounds1[2]),
            Math.max(bounds0[3], bounds1[3])
        ];
    } else {
        bounds = viewport.getBounds();
    }
    if (!viewport.isGeospatial) {
        return [
            // Top corner should not be more then bottom corner in either direction
            Math.max(Math.min(bounds[0], extent[2]), extent[0]),
            Math.max(Math.min(bounds[1], extent[3]), extent[1]),
            // Bottom corner should not be less then top corner in either direction
            Math.min(Math.max(bounds[2], extent[0]), extent[2]),
            Math.min(Math.max(bounds[3], extent[1]), extent[3])
        ];
    }
    return [
        Math.max(bounds[0], extent[0]),
        Math.max(bounds[1], extent[1]),
        Math.min(bounds[2], extent[2]),
        Math.min(bounds[3], extent[3])
    ];
}
function getCullBounds({ viewport, z, cullRect }) {
    const subViewports = viewport.subViewports || [
        viewport
    ];
    return subViewports.map((v)=>getCullBoundsInViewport(v, z || 0, cullRect));
}
function getCullBoundsInViewport(/** Current viewport */ viewport, /** At altitude */ z, /** Culling rectangle in screen space */ cullRect) {
    if (!Array.isArray(z)) {
        const x = cullRect.x - viewport.x;
        const y = cullRect.y - viewport.y;
        const { width, height } = cullRect;
        const unprojectOption = {
            targetZ: z
        };
        const topLeft = viewport.unproject([
            x,
            y
        ], unprojectOption);
        const topRight = viewport.unproject([
            x + width,
            y
        ], unprojectOption);
        const bottomLeft = viewport.unproject([
            x,
            y + height
        ], unprojectOption);
        const bottomRight = viewport.unproject([
            x + width,
            y + height
        ], unprojectOption);
        return [
            Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),
            Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]),
            Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),
            Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])
        ];
    }
    const bounds0 = getCullBoundsInViewport(viewport, z[0], cullRect);
    const bounds1 = getCullBoundsInViewport(viewport, z[1], cullRect);
    return [
        Math.min(bounds0[0], bounds1[0]),
        Math.min(bounds0[1], bounds1[1]),
        Math.max(bounds0[2], bounds1[2]),
        Math.max(bounds0[3], bounds1[3])
    ];
}
function getIndexingCoords(bbox, scale, modelMatrixInverse) {
    if (modelMatrixInverse) {
        const transformedTileIndex = transformBox(bbox, modelMatrixInverse).map((i)=>i * scale / TILE_SIZE);
        return transformedTileIndex;
    }
    return bbox.map((i)=>i * scale / TILE_SIZE);
}
function getScale(z, tileSize) {
    return Math.pow(2, z) * TILE_SIZE / tileSize;
}
function osmTile2lngLat(x, y, z) {
    const scale = getScale(z, TILE_SIZE);
    const lng = x / scale * 360 - 180;
    const n = Math.PI - 2 * Math.PI * y / scale;
    const lat = 180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
    return [
        lng,
        lat
    ];
}
function tile2XY(x, y, z, tileSize) {
    const scale = getScale(z, tileSize);
    return [
        x / scale * TILE_SIZE,
        y / scale * TILE_SIZE
    ];
}
function tileToBoundingBox(viewport, x, y, z, tileSize = TILE_SIZE) {
    if (viewport.isGeospatial) {
        const [west, north] = osmTile2lngLat(x, y, z);
        const [east, south] = osmTile2lngLat(x + 1, y + 1, z);
        return {
            west,
            north,
            east,
            south
        };
    }
    const [left, top] = tile2XY(x, y, z, tileSize);
    const [right, bottom] = tile2XY(x + 1, y + 1, z, tileSize);
    return {
        left,
        top,
        right,
        bottom
    };
}
function getIdentityTileIndices(viewport, z, tileSize, extent, modelMatrixInverse) {
    const bbox = getBoundingBox(viewport, null, extent);
    const scale = getScale(z, tileSize);
    const [minX, minY, maxX, maxY] = getIndexingCoords(bbox, scale, modelMatrixInverse);
    const indices = [];
    /*
        |  TILE  |  TILE  |  TILE  |
          |(minX)            |(maxX)
     */ for(let x = Math.floor(minX); x < maxX; x++){
        for(let y = Math.floor(minY); y < maxY; y++){
            indices.push({
                x,
                y,
                z
            });
        }
    }
    return indices;
}
function getTileIndices({ viewport, maxZoom, minZoom, zRange, extent, tileSize = TILE_SIZE, modelMatrix, modelMatrixInverse, zoomOffset = 0 }) {
    let z = viewport.isGeospatial ? Math.round(viewport.zoom + Math.log2(TILE_SIZE / tileSize)) + zoomOffset : Math.ceil(viewport.zoom) + zoomOffset;
    if (typeof minZoom === 'number' && Number.isFinite(minZoom) && z < minZoom) {
        if (!extent) {
            return [];
        }
        z = minZoom;
    }
    if (typeof maxZoom === 'number' && Number.isFinite(maxZoom) && z > maxZoom) {
        z = maxZoom;
    }
    let transformedExtent = extent;
    if (modelMatrix && modelMatrixInverse && extent && !viewport.isGeospatial) {
        transformedExtent = transformBox(extent, modelMatrix);
    }
    return viewport.isGeospatial ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$tile$2d$2d$2d$traversal$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getOSMTileIndices"])(viewport, z, zRange, extent) : getIdentityTileIndices(viewport, z, tileSize, transformedExtent || DEFAULT_EXTENT, modelMatrixInverse);
}
function isURLTemplate(s) {
    return /(?=.*{z})(?=.*{x})(?=.*({y}|{-y}))/.test(s);
}
function isGeoBoundingBox(v) {
    return Number.isFinite(v.west) && Number.isFinite(v.north) && Number.isFinite(v.east) && Number.isFinite(v.south);
} //# sourceMappingURL=utils.js.map
}}),
"[project]/node_modules/@deck.gl/geo-layers/dist/tileset-2d/memoize.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// deck.gl, MIT license
// @note - this is a duplicate of the deck.gl core export (because Tileset2D should be deck.gl independent)
/**
 * Speed up consecutive function calls by caching the result of calls with identical input
 * https://en.wikipedia.org/wiki/Memoization
 * @param compute - the function to be memoized
 */ __turbopack_context__.s({
    "memoize": (()=>memoize)
});
function memoize(compute) {
    let cachedArgs = {};
    let cachedResult;
    return (args)=>{
        for(const key in args){
            if (!isEqual(args[key], cachedArgs[key])) {
                cachedResult = compute(args);
                cachedArgs = args;
                break;
            }
        }
        return cachedResult;
    };
}
function isEqual(a, b) {
    if (a === b) {
        return true;
    }
    if (Array.isArray(a)) {
        // Special treatment for arrays: compare 1-level deep
        // This is to support equality of matrix/coordinate props
        const len = a.length;
        if (!b || b.length !== len) {
            return false;
        }
        for(let i = 0; i < len; i++){
            if (a[i] !== b[i]) {
                return false;
            }
        }
        return true;
    }
    return false;
} //# sourceMappingURL=memoize.js.map
}}),
"[project]/node_modules/@deck.gl/geo-layers/dist/tileset-2d/tileset-2d.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "DEFAULT_TILESET2D_PROPS": (()=>DEFAULT_TILESET2D_PROPS),
    "STRATEGY_DEFAULT": (()=>STRATEGY_DEFAULT),
    "STRATEGY_NEVER": (()=>STRATEGY_NEVER),
    "STRATEGY_REPLACE": (()=>STRATEGY_REPLACE),
    "Tileset2D": (()=>Tileset2D)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$request$2d$utils$2f$request$2d$scheduler$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__RequestScheduler$3e$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/request-utils/request-scheduler.js [client] (ecmascript) <export default as RequestScheduler>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix4$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/classes/matrix4.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$common$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/lib/common.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$tile$2d$2d$2d$header$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/geo-layers/dist/tileset-2d/tile-2d-header.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/geo-layers/dist/tileset-2d/utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$memoize$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/geo-layers/dist/tileset-2d/memoize.js [client] (ecmascript)");
;
;
;
;
;
// bit masks
const TILE_STATE_VISITED = 1;
const TILE_STATE_VISIBLE = 2;
const STRATEGY_NEVER = 'never';
const STRATEGY_REPLACE = 'no-overlap';
const STRATEGY_DEFAULT = 'best-available';
const DEFAULT_CACHE_SCALE = 5;
const STRATEGIES = {
    [STRATEGY_DEFAULT]: updateTileStateDefault,
    [STRATEGY_REPLACE]: updateTileStateReplace,
    [STRATEGY_NEVER]: ()=>{}
};
const DEFAULT_TILESET2D_PROPS = {
    extent: null,
    tileSize: 512,
    maxZoom: null,
    minZoom: null,
    maxCacheSize: null,
    maxCacheByteSize: null,
    refinementStrategy: 'best-available',
    zRange: null,
    maxRequests: 6,
    debounceTime: 0,
    zoomOffset: 0,
    // onTileLoad: (tile: Tile2DHeader) => void,  // onTileUnload: (tile: Tile2DHeader) => void,  // onTileError: (error: any, tile: Tile2DHeader) => void,  /** Called when all tiles in the current viewport are loaded. */
    // onViewportLoad: ((tiles: Tile2DHeader<DataT>[]) => void) | null,
    onTileLoad: ()=>{},
    onTileUnload: ()=>{},
    onTileError: ()=>{}
};
class Tileset2D {
    /**
     * Takes in a function that returns tile data, a cache size, and a max and a min zoom level.
     * Cache size defaults to 5 * number of tiles in the current viewport
     */ constructor(opts){
        /* Private methods */ this._getCullBounds = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$memoize$2e$js__$5b$client$5d$__$28$ecmascript$29$__["memoize"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getCullBounds"]);
        this.opts = {
            ...DEFAULT_TILESET2D_PROPS,
            ...opts
        };
        this.setOptions(this.opts);
        this.onTileLoad = (tile)=>{
            this.opts.onTileLoad?.(tile);
            if (this.opts.maxCacheByteSize !== null) {
                this._cacheByteSize += tile.byteLength;
                this._resizeCache();
            }
        };
        this._requestScheduler = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$request$2d$utils$2f$request$2d$scheduler$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__RequestScheduler$3e$__["RequestScheduler"]({
            throttleRequests: this.opts.maxRequests > 0 || this.opts.debounceTime > 0,
            maxRequests: this.opts.maxRequests,
            debounceTime: this.opts.debounceTime
        });
        // Maps tile id in string {z}-{x}-{y} to a Tile object
        this._cache = new Map();
        this._tiles = [];
        this._dirty = false;
        this._cacheByteSize = 0;
        // Cache the last processed viewport
        this._viewport = null;
        this._zRange = null;
        this._selectedTiles = null;
        this._frameNumber = 0;
        this._modelMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix4$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix4"]();
        this._modelMatrixInverse = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix4$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix4"]();
    }
    /* Public API */ get tiles() {
        return this._tiles;
    }
    get selectedTiles() {
        return this._selectedTiles;
    }
    get isLoaded() {
        return this._selectedTiles !== null && this._selectedTiles.every((tile)=>tile.isLoaded);
    }
    get needsReload() {
        return this._selectedTiles !== null && this._selectedTiles.some((tile)=>tile.needsReload);
    }
    setOptions(opts) {
        Object.assign(this.opts, opts);
        if (Number.isFinite(opts.maxZoom)) {
            this._maxZoom = Math.floor(opts.maxZoom);
        }
        if (Number.isFinite(opts.minZoom)) {
            this._minZoom = Math.ceil(opts.minZoom);
        }
    }
    // Clean up any outstanding tile requests.
    finalize() {
        for (const tile of this._cache.values()){
            if (tile.isLoading) {
                tile.abort();
            }
        }
        this._cache.clear();
        this._tiles = [];
        this._selectedTiles = null;
    }
    reloadAll() {
        for (const id of this._cache.keys()){
            const tile = this._cache.get(id);
            if (!this._selectedTiles || !this._selectedTiles.includes(tile)) {
                this._cache.delete(id);
            } else {
                tile.setNeedsReload();
            }
        }
    }
    /**
     * Update the cache with the given viewport and model matrix and triggers callback onUpdate.
     */ update(viewport, { zRange, modelMatrix } = {
        zRange: null,
        modelMatrix: null
    }) {
        const modelMatrixAsMatrix4 = modelMatrix ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix4$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix4"](modelMatrix) : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix4$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix4"]();
        const isModelMatrixNew = !modelMatrixAsMatrix4.equals(this._modelMatrix);
        if (!this._viewport || !viewport.equals(this._viewport) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$common$2e$js__$5b$client$5d$__$28$ecmascript$29$__["equals"])(this._zRange, zRange) || isModelMatrixNew) {
            if (isModelMatrixNew) {
                this._modelMatrixInverse = modelMatrixAsMatrix4.clone().invert();
                this._modelMatrix = modelMatrixAsMatrix4;
            }
            this._viewport = viewport;
            this._zRange = zRange;
            const tileIndices = this.getTileIndices({
                viewport,
                maxZoom: this._maxZoom,
                minZoom: this._minZoom,
                zRange,
                modelMatrix: this._modelMatrix,
                modelMatrixInverse: this._modelMatrixInverse
            });
            this._selectedTiles = tileIndices.map((index)=>this._getTile(index, true));
            if (this._dirty) {
                // Some new tiles are added
                this._rebuildTree();
            }
        // Check for needed reloads explicitly even if the view/matrix has not changed.
        } else if (this.needsReload) {
            this._selectedTiles = this._selectedTiles.map((tile)=>this._getTile(tile.index, true));
        }
        // Update tile states
        const changed = this.updateTileStates();
        this._pruneRequests();
        if (this._dirty) {
            // cache size is either the user defined maxSize or 5 * number of current tiles in the viewport.
            this._resizeCache();
        }
        if (changed) {
            this._frameNumber++;
        }
        return this._frameNumber;
    }
    // eslint-disable-next-line complexity
    isTileVisible(tile, cullRect) {
        if (!tile.isVisible) {
            return false;
        }
        if (cullRect && this._viewport) {
            const boundsArr = this._getCullBounds({
                viewport: this._viewport,
                z: this._zRange,
                cullRect
            });
            const { bbox } = tile;
            for (const [minX, minY, maxX, maxY] of boundsArr){
                let overlaps;
                if ('west' in bbox) {
                    overlaps = bbox.west < maxX && bbox.east > minX && bbox.south < maxY && bbox.north > minY;
                } else {
                    // top/bottom could be swapped depending on the indexing system
                    const y0 = Math.min(bbox.top, bbox.bottom);
                    const y1 = Math.max(bbox.top, bbox.bottom);
                    overlaps = bbox.left < maxX && bbox.right > minX && y0 < maxY && y1 > minY;
                }
                if (overlaps) {
                    return true;
                }
            }
            return false;
        }
        return true;
    }
    /* Public interface for subclassing */ /** Returns array of tile indices in the current viewport */ getTileIndices({ viewport, maxZoom, minZoom, zRange, modelMatrix, modelMatrixInverse }) {
        const { tileSize, extent, zoomOffset } = this.opts;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getTileIndices"])({
            viewport,
            maxZoom,
            minZoom,
            zRange,
            tileSize,
            extent: extent,
            modelMatrix,
            modelMatrixInverse,
            zoomOffset
        });
    }
    /** Returns unique string key for a tile index */ getTileId(index) {
        return `${index.x}-${index.y}-${index.z}`;
    }
    /** Returns a zoom level for a tile index */ getTileZoom(index) {
        return index.z;
    }
    /** Returns additional metadata to add to tile, bbox by default */ getTileMetadata(index) {
        const { tileSize } = this.opts;
        return {
            bbox: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["tileToBoundingBox"])(this._viewport, index.x, index.y, index.z, tileSize)
        };
    }
    /** Returns index of the parent tile */ getParentIndex(index) {
        const x = Math.floor(index.x / 2);
        const y = Math.floor(index.y / 2);
        const z = index.z - 1;
        return {
            x,
            y,
            z
        };
    }
    // Returns true if any tile's visibility changed
    updateTileStates() {
        const refinementStrategy = this.opts.refinementStrategy || STRATEGY_DEFAULT;
        const visibilities = new Array(this._cache.size);
        let i = 0;
        // Reset state
        for (const tile of this._cache.values()){
            // save previous state
            visibilities[i++] = tile.isVisible;
            tile.isSelected = false;
            tile.isVisible = false;
        }
        // @ts-expect-error called only when _selectedTiles is already defined
        for (const tile of this._selectedTiles){
            tile.isSelected = true;
            tile.isVisible = true;
        }
        // Strategy-specific state logic
        (typeof refinementStrategy === 'function' ? refinementStrategy : STRATEGIES[refinementStrategy])(Array.from(this._cache.values()));
        i = 0;
        // Check if any visibility has changed
        for (const tile of this._cache.values()){
            if (visibilities[i++] !== tile.isVisible) {
                return true;
            }
        }
        return false;
    }
    _pruneRequests() {
        const { maxRequests = 0 } = this.opts;
        const abortCandidates = [];
        let ongoingRequestCount = 0;
        for (const tile of this._cache.values()){
            // Keep track of all the ongoing requests
            if (tile.isLoading) {
                ongoingRequestCount++;
                if (!tile.isSelected && !tile.isVisible) {
                    abortCandidates.push(tile);
                }
            }
        }
        while(maxRequests > 0 && ongoingRequestCount > maxRequests && abortCandidates.length > 0){
            // There are too many ongoing requests, so abort some that are unselected
            const tile = abortCandidates.shift();
            tile.abort();
            ongoingRequestCount--;
        }
    }
    // This needs to be called every time some tiles have been added/removed from cache
    _rebuildTree() {
        const { _cache } = this;
        // Reset states
        for (const tile of _cache.values()){
            tile.parent = null;
            if (tile.children) {
                tile.children.length = 0;
            }
        }
        // Rebuild tree
        for (const tile of _cache.values()){
            const parent = this._getNearestAncestor(tile);
            tile.parent = parent;
            if (parent?.children) {
                parent.children.push(tile);
            }
        }
    }
    /**
     * Clear tiles that are not visible when the cache is full
     */ /* eslint-disable complexity */ _resizeCache() {
        const { _cache, opts } = this;
        const maxCacheSize = opts.maxCacheSize ?? // @ts-expect-error called only when selectedTiles is initialized
        (opts.maxCacheByteSize !== null ? Infinity : DEFAULT_CACHE_SCALE * this.selectedTiles.length);
        const maxCacheByteSize = opts.maxCacheByteSize ?? Infinity;
        const overflown = _cache.size > maxCacheSize || this._cacheByteSize > maxCacheByteSize;
        if (overflown) {
            for (const [id, tile] of _cache){
                if (!tile.isVisible && !tile.isSelected) {
                    // delete tile
                    this._cacheByteSize -= opts.maxCacheByteSize !== null ? tile.byteLength : 0;
                    _cache.delete(id);
                    this.opts.onTileUnload?.(tile);
                }
                if (_cache.size <= maxCacheSize && this._cacheByteSize <= maxCacheByteSize) {
                    break;
                }
            }
            this._rebuildTree();
            this._dirty = true;
        }
        if (this._dirty) {
            // sort by zoom level so that smaller tiles are displayed on top
            this._tiles = Array.from(this._cache.values()).sort((t1, t2)=>t1.zoom - t2.zoom);
            this._dirty = false;
        }
    }
    _getTile(index, create) {
        const id = this.getTileId(index);
        let tile = this._cache.get(id);
        let needsReload = false;
        if (!tile && create) {
            tile = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$tile$2d$2d$2d$header$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Tile2DHeader"](index);
            Object.assign(tile, this.getTileMetadata(tile.index));
            Object.assign(tile, {
                id,
                zoom: this.getTileZoom(tile.index)
            });
            needsReload = true;
            this._cache.set(id, tile);
            this._dirty = true;
        } else if (tile && tile.needsReload) {
            needsReload = true;
        }
        if (tile && needsReload) {
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            tile.loadData({
                getData: this.opts.getTileData,
                requestScheduler: this._requestScheduler,
                onLoad: this.onTileLoad,
                onError: this.opts.onTileError
            });
        }
        return tile;
    }
    _getNearestAncestor(tile) {
        const { _minZoom = 0 } = this;
        let index = tile.index;
        while(this.getTileZoom(index) > _minZoom){
            index = this.getParentIndex(index);
            const parent = this._getTile(index);
            if (parent) {
                return parent;
            }
        }
        return null;
    }
}
/* -- Refinement strategies --*/ /* eslint-disable max-depth */ // For all the selected && pending tiles:
// - pick the closest ancestor as placeholder
// - if no ancestor is visible, pick the closest children as placeholder
function updateTileStateDefault(allTiles) {
    for (const tile of allTiles){
        tile.state = 0;
    }
    for (const tile of allTiles){
        if (tile.isSelected && !getPlaceholderInAncestors(tile)) {
            getPlaceholderInChildren(tile);
        }
    }
    for (const tile of allTiles){
        tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);
    }
}
// Until a selected tile and all its selected siblings are loaded, use the closest ancestor as placeholder
function updateTileStateReplace(allTiles) {
    for (const tile of allTiles){
        tile.state = 0;
    }
    for (const tile of allTiles){
        if (tile.isSelected) {
            getPlaceholderInAncestors(tile);
        }
    }
    // Always process parents first
    const sortedTiles = Array.from(allTiles).sort((t1, t2)=>t1.zoom - t2.zoom);
    for (const tile of sortedTiles){
        tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);
        if (tile.children && (tile.isVisible || tile.state & TILE_STATE_VISITED)) {
            // If the tile is rendered, or if the tile has been explicitly hidden, hide all of its children
            for (const child of tile.children){
                child.state = TILE_STATE_VISITED;
            }
        } else if (tile.isSelected) {
            getPlaceholderInChildren(tile);
        }
    }
}
// Walk up the tree until we find one ancestor that is loaded. Returns true if successful.
function getPlaceholderInAncestors(startTile) {
    let tile = startTile;
    while(tile){
        if (tile.isLoaded || tile.content) {
            tile.state |= TILE_STATE_VISIBLE;
            return true;
        }
        tile = tile.parent;
    }
    return false;
}
// Recursively set children as placeholder
function getPlaceholderInChildren(tile) {
    for (const child of tile.children){
        if (child.isLoaded || child.content) {
            child.state |= TILE_STATE_VISIBLE;
        } else {
            getPlaceholderInChildren(child);
        }
    }
} //# sourceMappingURL=tileset-2d.js.map
}}),
"[project]/node_modules/@deck.gl/geo-layers/dist/tile-layer/tile-layer.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$composite$2d$layer$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__CompositeLayer$3e$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/core/dist/lib/composite-layer.js [client] (ecmascript) <export default as CompositeLayer>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$utils$2f$flatten$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__flatten__as__$5f$flatten$3e$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/core/dist/utils/flatten.js [client] (ecmascript) <export flatten as _flatten>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$layers$2f$dist$2f$geojson$2d$layer$2f$geojson$2d$layer$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__GeoJsonLayer$3e$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/layers/dist/geojson-layer/geojson-layer.js [client] (ecmascript) <export default as GeoJsonLayer>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$tileset$2d$2d$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/geo-layers/dist/tileset-2d/tileset-2d.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/geo-layers/dist/tileset-2d/utils.js [client] (ecmascript)");
;
;
;
;
const defaultProps = {
    TilesetClass: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$tileset$2d$2d$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Tileset2D"],
    data: {
        type: 'data',
        value: []
    },
    dataComparator: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["urlType"].equal,
    renderSubLayers: {
        type: 'function',
        value: (props)=>new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$layers$2f$dist$2f$geojson$2d$layer$2f$geojson$2d$layer$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__GeoJsonLayer$3e$__["GeoJsonLayer"](props)
    },
    getTileData: {
        type: 'function',
        optional: true,
        value: null
    },
    // TODO - change to onViewportLoad to align with Tile3DLayer
    onViewportLoad: {
        type: 'function',
        optional: true,
        value: null
    },
    onTileLoad: {
        type: 'function',
        value: (tile)=>{}
    },
    onTileUnload: {
        type: 'function',
        value: (tile)=>{}
    },
    // eslint-disable-next-line
    onTileError: {
        type: 'function',
        value: (err)=>console.error(err)
    },
    extent: {
        type: 'array',
        optional: true,
        value: null,
        compare: true
    },
    tileSize: 512,
    maxZoom: null,
    minZoom: 0,
    maxCacheSize: null,
    maxCacheByteSize: null,
    refinementStrategy: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$tileset$2d$2d$2e$js__$5b$client$5d$__$28$ecmascript$29$__["STRATEGY_DEFAULT"],
    zRange: null,
    maxRequests: 6,
    debounceTime: 0,
    zoomOffset: 0
};
/**
 * The TileLayer is a composite layer that makes it possible to visualize very large datasets.
 *
 * Instead of fetching the entire dataset, it only loads and renders what's visible in the current viewport.
 */ class TileLayer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$composite$2d$layer$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__CompositeLayer$3e$__["CompositeLayer"] {
    initializeState() {
        this.state = {
            tileset: null,
            isLoaded: false
        };
    }
    finalizeState() {
        this.state?.tileset?.finalize();
    }
    get isLoaded() {
        return Boolean(this.state?.tileset?.selectedTiles?.every((tile)=>tile.isLoaded && tile.layers && tile.layers.every((layer)=>layer.isLoaded)));
    }
    shouldUpdateState({ changeFlags }) {
        return changeFlags.somethingChanged;
    }
    updateState({ changeFlags }) {
        let { tileset } = this.state;
        const propsChanged = changeFlags.propsOrDataChanged || changeFlags.updateTriggersChanged;
        const dataChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getTileData);
        if (!tileset) {
            tileset = new this.props.TilesetClass(this._getTilesetOptions());
            this.setState({
                tileset
            });
        } else if (propsChanged) {
            tileset.setOptions(this._getTilesetOptions());
            if (dataChanged) {
                // reload all tiles
                // use cached layers until new content is loaded
                tileset.reloadAll();
            } else {
                // some render options changed, regenerate sub layers now
                tileset.tiles.forEach((tile)=>{
                    tile.layers = null;
                });
            }
        }
        this._updateTileset();
    }
    _getTilesetOptions() {
        const { tileSize, maxCacheSize, maxCacheByteSize, refinementStrategy, extent, maxZoom, minZoom, maxRequests, debounceTime, zoomOffset } = this.props;
        return {
            maxCacheSize,
            maxCacheByteSize,
            maxZoom,
            minZoom,
            tileSize,
            refinementStrategy,
            extent,
            maxRequests,
            debounceTime,
            zoomOffset,
            getTileData: this.getTileData.bind(this),
            onTileLoad: this._onTileLoad.bind(this),
            onTileError: this._onTileError.bind(this),
            onTileUnload: this._onTileUnload.bind(this)
        };
    }
    _updateTileset() {
        const tileset = this.state.tileset;
        const { zRange, modelMatrix } = this.props;
        const frameNumber = tileset.update(this.context.viewport, {
            zRange,
            modelMatrix
        });
        const { isLoaded } = tileset;
        const loadingStateChanged = this.state.isLoaded !== isLoaded;
        const tilesetChanged = this.state.frameNumber !== frameNumber;
        if (isLoaded && (loadingStateChanged || tilesetChanged)) {
            this._onViewportLoad();
        }
        if (tilesetChanged) {
            // Save the tileset frame number - trigger a rerender
            this.setState({
                frameNumber
            });
        }
        // Save the loaded state - should not trigger a rerender
        this.state.isLoaded = isLoaded;
    }
    _onViewportLoad() {
        const { tileset } = this.state;
        const { onViewportLoad } = this.props;
        if (onViewportLoad) {
            // This method can only be called when tileset is defined and updated
            onViewportLoad(tileset.selectedTiles);
        }
    }
    _onTileLoad(tile) {
        this.props.onTileLoad(tile);
        tile.layers = null;
        this.setNeedsUpdate();
    }
    _onTileError(error, tile) {
        this.props.onTileError(error);
        tile.layers = null;
        this.setNeedsUpdate();
    }
    _onTileUnload(tile) {
        this.props.onTileUnload(tile);
    }
    // Methods for subclass to override
    getTileData(tile) {
        const { data, getTileData, fetch } = this.props;
        const { signal } = tile;
        tile.url = typeof data === 'string' || Array.isArray(data) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getURLFromTemplate"])(data, tile) : null;
        if (getTileData) {
            return getTileData(tile);
        }
        if (fetch && tile.url) {
            return fetch(tile.url, {
                propName: 'data',
                layer: this,
                signal
            });
        }
        return null;
    }
    renderSubLayers(props) {
        return this.props.renderSubLayers(props);
    }
    getSubLayerPropsByTile(tile) {
        return null;
    }
    getPickingInfo(params) {
        // TileLayer does not directly render anything, sourceLayer cannot be null
        const sourceLayer = params.sourceLayer;
        const sourceTile = sourceLayer.props.tile;
        const info = params.info;
        if (info.picked) {
            info.tile = sourceTile;
        }
        info.sourceTile = sourceTile;
        info.sourceTileSubLayer = sourceLayer;
        return info;
    }
    _updateAutoHighlight(info) {
        info.sourceTileSubLayer.updateAutoHighlight(info);
    }
    renderLayers() {
        return this.state.tileset.tiles.map((tile)=>{
            const subLayerProps = this.getSubLayerPropsByTile(tile);
            // cache the rendered layer in the tile
            if (!tile.isLoaded && !tile.content) {
            // nothing to show
            } else if (!tile.layers) {
                const layers = this.renderSubLayers({
                    ...this.props,
                    ...this.getSubLayerProps({
                        id: tile.id,
                        updateTriggers: this.props.updateTriggers
                    }),
                    data: tile.content,
                    _offset: 0,
                    tile
                });
                tile.layers = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$utils$2f$flatten$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__flatten__as__$5f$flatten$3e$__["_flatten"])(layers, Boolean).map((layer)=>layer.clone({
                        tile,
                        ...subLayerProps
                    }));
            } else if (subLayerProps && tile.layers[0] && Object.keys(subLayerProps).some((propName)=>tile.layers[0].props[propName] !== subLayerProps[propName])) {
                tile.layers = tile.layers.map((layer)=>layer.clone(subLayerProps));
            }
            return tile.layers;
        });
    }
    filterSubLayer({ layer, cullRect }) {
        const { tile } = layer.props;
        return this.state.tileset.isTileVisible(tile, cullRect);
    }
}
TileLayer.defaultProps = defaultProps;
TileLayer.layerName = 'TileLayer';
const __TURBOPACK__default__export__ = TileLayer;
 //# sourceMappingURL=tile-layer.js.map
}}),
"[project]/node_modules/@deck.gl/geo-layers/dist/tile-layer/tile-layer.js [client] (ecmascript) <export default as TileLayer>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "TileLayer": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tile$2d$layer$2f$tile$2d$layer$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tile$2d$layer$2f$tile$2d$layer$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/geo-layers/dist/tile-layer/tile-layer.js [client] (ecmascript)");
}}),
"[project]/node_modules/@deck.gl/geo-layers/dist/tileset-2d/tileset-2d.js [client] (ecmascript) <export Tileset2D as _Tileset2D>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "_Tileset2D": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$tileset$2d$2d$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Tileset2D"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$tileset$2d$2d$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/geo-layers/dist/tileset-2d/tileset-2d.js [client] (ecmascript)");
}}),
"[project]/node_modules/@deck.gl/geo-layers/dist/h3-layers/h3-utils.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "flattenPolygon": (()=>flattenPolygon),
    "getHexagonCentroid": (()=>getHexagonCentroid),
    "h3ToPolygon": (()=>h3ToPolygon),
    "normalizeLongitudes": (()=>normalizeLongitudes),
    "scalePolygon": (()=>scalePolygon)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$h3$2d$js$2f$dist$2f$browser$2f$h3$2d$js$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/h3-js/dist/browser/h3-js.es.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$common$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/lib/common.js [client] (ecmascript)");
;
;
function normalizeLongitudes(vertices, refLng) {
    refLng = refLng === undefined ? vertices[0][0] : refLng;
    for (const pt of vertices){
        const deltaLng = pt[0] - refLng;
        if (deltaLng > 180) {
            pt[0] -= 360;
        } else if (deltaLng < -180) {
            pt[0] += 360;
        }
    }
}
function scalePolygon(hexId, vertices, factor) {
    const [lat, lng] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$h3$2d$js$2f$dist$2f$browser$2f$h3$2d$js$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["cellToLatLng"])(hexId);
    const actualCount = vertices.length;
    // normalize with respect to center
    normalizeLongitudes(vertices, lng);
    // `cellToBoundary` returns same array object for first and last vertex (closed polygon),
    // if so skip scaling the last vertex
    const vertexCount = vertices[0] === vertices[actualCount - 1] ? actualCount - 1 : actualCount;
    for(let i = 0; i < vertexCount; i++){
        vertices[i][0] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$common$2e$js__$5b$client$5d$__$28$ecmascript$29$__["lerp"])(lng, vertices[i][0], factor);
        vertices[i][1] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$common$2e$js__$5b$client$5d$__$28$ecmascript$29$__["lerp"])(lat, vertices[i][1], factor);
    }
}
function getHexagonCentroid(getHexagon, object, objectInfo) {
    const hexagonId = getHexagon(object, objectInfo);
    const [lat, lng] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$h3$2d$js$2f$dist$2f$browser$2f$h3$2d$js$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["cellToLatLng"])(hexagonId);
    return [
        lng,
        lat
    ];
}
function h3ToPolygon(hexId, coverage = 1) {
    const vertices = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$h3$2d$js$2f$dist$2f$browser$2f$h3$2d$js$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["cellToBoundary"])(hexId, true);
    if (coverage !== 1) {
        // scale and normalize vertices w.r.t to center
        scalePolygon(hexId, vertices, coverage);
    } else {
        // normalize w.r.t to start vertex
        normalizeLongitudes(vertices);
    }
    return vertices;
}
function flattenPolygon(vertices) {
    const positions = new Float64Array(vertices.length * 2);
    let i = 0;
    for (const pt of vertices){
        positions[i++] = pt[0];
        positions[i++] = pt[1];
    }
    return positions;
} //# sourceMappingURL=h3-utils.js.map
}}),
"[project]/node_modules/@deck.gl/geo-layers/dist/h3-layers/h3-hexagon-layer.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$h3$2d$js$2f$dist$2f$browser$2f$h3$2d$js$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/h3-js/dist/browser/h3-js.es.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$composite$2d$layer$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__CompositeLayer$3e$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/core/dist/lib/composite-layer.js [client] (ecmascript) <export default as CompositeLayer>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$utils$2f$iterable$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/core/dist/utils/iterable-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$layers$2f$dist$2f$column$2d$layer$2f$column$2d$layer$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ColumnLayer$3e$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/layers/dist/column-layer/column-layer.js [client] (ecmascript) <export default as ColumnLayer>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$layers$2f$dist$2f$polygon$2d$layer$2f$polygon$2d$layer$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__PolygonLayer$3e$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/layers/dist/polygon-layer/polygon-layer.js [client] (ecmascript) <export default as PolygonLayer>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$h3$2d$layers$2f$h3$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/geo-layers/dist/h3-layers/h3-utils.js [client] (ecmascript)");
;
;
;
;
// There is a cost to updating the instanced geometries when using highPrecision: false
// This constant defines the distance between two hexagons that leads to "significant
// distortion." Smaller value makes the column layer more sensitive to viewport change.
const UPDATE_THRESHOLD_KM = 10;
function mergeTriggers(getHexagon, coverage) {
    let trigger;
    if (getHexagon === undefined || getHexagon === null) {
        trigger = coverage;
    } else if (typeof getHexagon === 'object') {
        trigger = {
            ...getHexagon,
            coverage
        };
    } else {
        trigger = {
            getHexagon,
            coverage
        };
    }
    return trigger;
}
const defaultProps = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$layers$2f$dist$2f$polygon$2d$layer$2f$polygon$2d$layer$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__PolygonLayer$3e$__["PolygonLayer"].defaultProps,
    highPrecision: 'auto',
    coverage: {
        type: 'number',
        min: 0,
        max: 1,
        value: 1
    },
    centerHexagon: null,
    getHexagon: {
        type: 'accessor',
        value: (x)=>x.hexagon
    },
    extruded: true
};
/**
 * Render hexagons from the [H3](https://h3geo.org/) geospatial indexing system.
 */ class H3HexagonLayer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$composite$2d$layer$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__CompositeLayer$3e$__["CompositeLayer"] {
    initializeState() {
        H3HexagonLayer._checkH3Lib();
        this.state = {
            edgeLengthKM: 0,
            resolution: -1
        };
    }
    shouldUpdateState({ changeFlags }) {
        return this._shouldUseHighPrecision() ? changeFlags.propsOrDataChanged : changeFlags.somethingChanged;
    }
    updateState({ props, changeFlags }) {
        if (props.highPrecision !== true && (changeFlags.dataChanged || changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getHexagon)) {
            const dataProps = this._calculateH3DataProps();
            this.setState(dataProps);
        }
        this._updateVertices(this.context.viewport);
    }
    _calculateH3DataProps() {
        let resolution = -1;
        let hasPentagon = false;
        let hasMultipleRes = false;
        const { iterable, objectInfo } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$utils$2f$iterable$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["createIterable"])(this.props.data);
        for (const object of iterable){
            objectInfo.index++;
            const hexId = this.props.getHexagon(object, objectInfo);
            // Take the resolution of the first hex
            const hexResolution = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$h3$2d$js$2f$dist$2f$browser$2f$h3$2d$js$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getResolution"])(hexId);
            if (resolution < 0) {
                resolution = hexResolution;
                if (!this.props.highPrecision) break;
            } else if (resolution !== hexResolution) {
                hasMultipleRes = true;
                break;
            }
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$h3$2d$js$2f$dist$2f$browser$2f$h3$2d$js$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isPentagon"])(hexId)) {
                hasPentagon = true;
                break;
            }
        }
        return {
            resolution,
            edgeLengthKM: resolution >= 0 ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$h3$2d$js$2f$dist$2f$browser$2f$h3$2d$js$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getHexagonEdgeLengthAvg"])(resolution, 'km') : 0,
            hasMultipleRes,
            hasPentagon
        };
    }
    _shouldUseHighPrecision() {
        if (this.props.highPrecision === 'auto') {
            const { resolution, hasPentagon, hasMultipleRes } = this.state;
            const { viewport } = this.context;
            return Boolean(viewport?.resolution) || hasMultipleRes || hasPentagon || resolution >= 0 && resolution <= 5;
        }
        return this.props.highPrecision;
    }
    _updateVertices(viewport) {
        if (this._shouldUseHighPrecision()) {
            return;
        }
        const { resolution, edgeLengthKM, centerHex } = this.state;
        if (resolution < 0) {
            return;
        }
        const hex = this.props.centerHexagon || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$h3$2d$js$2f$dist$2f$browser$2f$h3$2d$js$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["latLngToCell"])(viewport.latitude, viewport.longitude, resolution);
        if (centerHex === hex) {
            return;
        }
        if (centerHex) {
            try {
                const distance = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$h3$2d$js$2f$dist$2f$browser$2f$h3$2d$js$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["gridDistance"])(centerHex, hex);
                if (distance * edgeLengthKM < UPDATE_THRESHOLD_KM) {
                    return;
                }
            } catch  {
            // gridDistance throws if the distance could not be computed
            // due to the two indexes very far apart or on opposite sides of a pentagon.
            }
        }
        const { unitsPerMeter } = viewport.distanceScales;
        let vertices = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$h3$2d$layers$2f$h3$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["h3ToPolygon"])(hex);
        const [centerLat, centerLng] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$h3$2d$js$2f$dist$2f$browser$2f$h3$2d$js$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["cellToLatLng"])(hex);
        const [centerX, centerY] = viewport.projectFlat([
            centerLng,
            centerLat
        ]);
        vertices = vertices.map((p)=>{
            const worldPosition = viewport.projectFlat(p);
            return [
                (worldPosition[0] - centerX) / unitsPerMeter[0],
                (worldPosition[1] - centerY) / unitsPerMeter[1]
            ];
        });
        this.setState({
            centerHex: hex,
            vertices
        });
    }
    renderLayers() {
        return this._shouldUseHighPrecision() ? this._renderPolygonLayer() : this._renderColumnLayer();
    }
    _getForwardProps() {
        const { elevationScale, material, coverage, extruded, wireframe, stroked, filled, lineWidthUnits, lineWidthScale, lineWidthMinPixels, lineWidthMaxPixels, getFillColor, getElevation, getLineColor, getLineWidth, transitions, updateTriggers } = this.props;
        return {
            elevationScale,
            extruded,
            coverage,
            wireframe,
            stroked,
            filled,
            lineWidthUnits,
            lineWidthScale,
            lineWidthMinPixels,
            lineWidthMaxPixels,
            material,
            getElevation,
            getFillColor,
            getLineColor,
            getLineWidth,
            transitions,
            updateTriggers: {
                getFillColor: updateTriggers.getFillColor,
                getElevation: updateTriggers.getElevation,
                getLineColor: updateTriggers.getLineColor,
                getLineWidth: updateTriggers.getLineWidth
            }
        };
    }
    _renderPolygonLayer() {
        const { data, getHexagon, updateTriggers, coverage } = this.props;
        const SubLayerClass = this.getSubLayerClass('hexagon-cell-hifi', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$layers$2f$dist$2f$polygon$2d$layer$2f$polygon$2d$layer$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__PolygonLayer$3e$__["PolygonLayer"]);
        const forwardProps = this._getForwardProps();
        forwardProps.updateTriggers.getPolygon = mergeTriggers(updateTriggers.getHexagon, coverage);
        return new SubLayerClass(forwardProps, this.getSubLayerProps({
            id: 'hexagon-cell-hifi',
            updateTriggers: forwardProps.updateTriggers
        }), {
            data,
            _normalize: false,
            _windingOrder: 'CCW',
            positionFormat: 'XY',
            getPolygon: (object, objectInfo)=>{
                const hexagonId = getHexagon(object, objectInfo);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$h3$2d$layers$2f$h3$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["flattenPolygon"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$h3$2d$layers$2f$h3$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["h3ToPolygon"])(hexagonId, coverage));
            }
        });
    }
    _renderColumnLayer() {
        const { data, getHexagon, updateTriggers } = this.props;
        const SubLayerClass = this.getSubLayerClass('hexagon-cell', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$layers$2f$dist$2f$column$2d$layer$2f$column$2d$layer$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ColumnLayer$3e$__["ColumnLayer"]);
        const forwardProps = this._getForwardProps();
        forwardProps.updateTriggers.getPosition = updateTriggers.getHexagon;
        return new SubLayerClass(forwardProps, this.getSubLayerProps({
            id: 'hexagon-cell',
            flatShading: true,
            updateTriggers: forwardProps.updateTriggers
        }), {
            data,
            diskResolution: 6,
            radius: 1,
            vertices: this.state.vertices,
            getPosition: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$h3$2d$layers$2f$h3$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getHexagonCentroid"].bind(null, getHexagon)
        });
    }
}
H3HexagonLayer.defaultProps = defaultProps;
H3HexagonLayer.layerName = 'H3HexagonLayer';
// See `main/bundle.ts`
H3HexagonLayer._checkH3Lib = ()=>{};
const __TURBOPACK__default__export__ = H3HexagonLayer;
 //# sourceMappingURL=h3-hexagon-layer.js.map
}}),
"[project]/node_modules/@deck.gl/geo-layers/dist/h3-layers/h3-hexagon-layer.js [client] (ecmascript) <export default as H3HexagonLayer>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "H3HexagonLayer": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$h3$2d$layers$2f$h3$2d$hexagon$2d$layer$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$h3$2d$layers$2f$h3$2d$hexagon$2d$layer$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/geo-layers/dist/h3-layers/h3-hexagon-layer.js [client] (ecmascript)");
}}),
"[project]/node_modules/@deck.gl/geo-layers/dist/geo-cell-layer/GeoCellLayer.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$composite$2d$layer$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__CompositeLayer$3e$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/core/dist/lib/composite-layer.js [client] (ecmascript) <export default as CompositeLayer>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$layers$2f$dist$2f$polygon$2d$layer$2f$polygon$2d$layer$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__PolygonLayer$3e$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/layers/dist/polygon-layer/polygon-layer.js [client] (ecmascript) <export default as PolygonLayer>");
;
;
const defaultProps = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$layers$2f$dist$2f$polygon$2d$layer$2f$polygon$2d$layer$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__PolygonLayer$3e$__["PolygonLayer"].defaultProps
};
class GeoCellLayer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$composite$2d$layer$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__CompositeLayer$3e$__["CompositeLayer"] {
    /** Implement to generate props to create geometry. */ indexToBounds() {
        return null;
    }
    renderLayers() {
        // Rendering props underlying layer
        const { elevationScale, extruded, wireframe, filled, stroked, lineWidthUnits, lineWidthScale, lineWidthMinPixels, lineWidthMaxPixels, lineJointRounded, lineMiterLimit, lineDashJustified, getElevation, getFillColor, getLineColor, getLineWidth } = this.props;
        // Accessor props for underlying layers
        const { updateTriggers, material, transitions } = this.props;
        // Filled Polygon Layer
        const CellLayer = this.getSubLayerClass('cell', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$layers$2f$dist$2f$polygon$2d$layer$2f$polygon$2d$layer$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__PolygonLayer$3e$__["PolygonLayer"]);
        const { updateTriggers: boundsUpdateTriggers, ...boundsProps } = this.indexToBounds() || {};
        return new CellLayer({
            filled,
            wireframe,
            extruded,
            elevationScale,
            stroked,
            lineWidthUnits,
            lineWidthScale,
            lineWidthMinPixels,
            lineWidthMaxPixels,
            lineJointRounded,
            lineMiterLimit,
            lineDashJustified,
            material,
            transitions,
            getElevation,
            getFillColor,
            getLineColor,
            getLineWidth
        }, this.getSubLayerProps({
            id: 'cell',
            updateTriggers: updateTriggers && {
                ...boundsUpdateTriggers,
                getElevation: updateTriggers.getElevation,
                getFillColor: updateTriggers.getFillColor,
                getLineColor: updateTriggers.getLineColor,
                getLineWidth: updateTriggers.getLineWidth
            }
        }), boundsProps);
    }
}
GeoCellLayer.layerName = 'GeoCellLayer';
GeoCellLayer.defaultProps = defaultProps;
const __TURBOPACK__default__export__ = GeoCellLayer;
 //# sourceMappingURL=GeoCellLayer.js.map
}}),
"[project]/node_modules/@deck.gl/geo-layers/dist/geo-cell-layer/GeoCellLayer.js [client] (ecmascript) <export default as _GeoCellLayer>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "_GeoCellLayer": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$geo$2d$cell$2d$layer$2f$GeoCellLayer$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$geo$2d$cell$2d$layer$2f$GeoCellLayer$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/geo-layers/dist/geo-cell-layer/GeoCellLayer.js [client] (ecmascript)");
}}),
"[project]/node_modules/@deck.gl/geo-layers/dist/mvt-layer/coordinate-transform.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "transform": (()=>transform)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$common$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/lib/common.js [client] (ecmascript)");
;
const availableTransformations = {
    Point,
    MultiPoint,
    LineString,
    MultiLineString,
    Polygon,
    MultiPolygon
};
function Point([pointX, pointY], [nw, se], viewport) {
    const x = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$common$2e$js__$5b$client$5d$__$28$ecmascript$29$__["lerp"])(nw[0], se[0], pointX);
    const y = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$common$2e$js__$5b$client$5d$__$28$ecmascript$29$__["lerp"])(nw[1], se[1], pointY);
    return viewport.unprojectFlat([
        x,
        y
    ]);
}
function getPoints(geometry, bbox, viewport) {
    return geometry.map((g)=>Point(g, bbox, viewport));
}
function MultiPoint(multiPoint, bbox, viewport) {
    return getPoints(multiPoint, bbox, viewport);
}
function LineString(line, bbox, viewport) {
    return getPoints(line, bbox, viewport);
}
function MultiLineString(multiLineString, bbox, viewport) {
    return multiLineString.map((lineString)=>LineString(lineString, bbox, viewport));
}
function Polygon(polygon, bbox, viewport) {
    return polygon.map((polygonRing)=>getPoints(polygonRing, bbox, viewport));
}
function MultiPolygon(multiPolygon, bbox, viewport) {
    return multiPolygon.map((polygon)=>Polygon(polygon, bbox, viewport));
}
function transform(geometry, bbox, viewport) {
    const nw = viewport.projectFlat([
        bbox.west,
        bbox.north
    ]);
    const se = viewport.projectFlat([
        bbox.east,
        bbox.south
    ]);
    const projectedBbox = [
        nw,
        se
    ];
    return {
        ...geometry,
        coordinates: availableTransformations[geometry.type](geometry.coordinates, projectedBbox, viewport)
    };
} //# sourceMappingURL=coordinate-transform.js.map
}}),
"[project]/node_modules/@deck.gl/geo-layers/dist/mvt-layer/find-index-binary.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "default": (()=>findIndexBinary)
});
const GEOM_TYPES = [
    'points',
    'lines',
    'polygons'
];
function findIndexBinary(data, uniqueIdProperty, featureId, layerName // the layer to search in
) {
    for (const gt of GEOM_TYPES){
        const index = data[gt] && findIndexByType(data[gt], uniqueIdProperty, featureId, layerName);
        if (index >= 0) {
            return index;
        }
    }
    return -1;
}
function findIndexByType(geomData, uniqueIdProperty, featureId, layerName) {
    const featureIds = geomData.featureIds.value;
    if (!featureIds.length) {
        return -1;
    }
    let startFeatureIndex = 0;
    let endFeatureIndex = featureIds[featureIds.length - 1] + 1;
    if (layerName) {
        const layerRange = getLayerRange(geomData, layerName);
        if (layerRange) {
            startFeatureIndex = layerRange[0];
            endFeatureIndex = layerRange[1] + 1;
        } else {
            return -1;
        }
    }
    // Look for the uniqueIdProperty
    let featureIndex = -1;
    if (uniqueIdProperty in geomData.numericProps) {
        const vertexIndex = geomData.numericProps[uniqueIdProperty].value.findIndex((x, i)=>x === featureId && featureIds[i] >= startFeatureIndex && featureIds[i] < endFeatureIndex);
        return vertexIndex >= 0 ? geomData.globalFeatureIds.value[vertexIndex] : -1;
    } else if (uniqueIdProperty) {
        featureIndex = findIndex(geomData.properties, (elem)=>elem[uniqueIdProperty] === featureId, startFeatureIndex, endFeatureIndex);
    } else if (geomData.fields) {
        featureIndex = findIndex(geomData.fields, (elem)=>elem.id === featureId, startFeatureIndex, endFeatureIndex);
    }
    return featureIndex >= 0 ? getGlobalFeatureId(geomData, featureIndex) : -1;
}
// Returns [firstFeatureIndex, lastFeatureIndex]
// MVTLoader parses tiles layer-by-layer, so each layer is a continuous range
function getLayerRange(geomData, layerName) {
    if (!geomData.__layers) {
        // Cache a map from properties.layerName to index ranges
        const layerNames = {};
        const { properties } = geomData;
        for(let i = 0; i < properties.length; i++){
            const { layerName: key } = properties[i];
            if (!key) {
            // ignore
            } else if (layerNames[key]) {
                layerNames[key][1] = i;
            } else {
                layerNames[key] = [
                    i,
                    i
                ];
            }
        }
        geomData.__layers = layerNames;
    }
    return geomData.__layers[layerName];
}
// Returns global feature id
function getGlobalFeatureId(geomData, featureIndex) {
    if (!geomData.__ids) {
        // Cache a map from featureId to globalFeatureId
        const result = [];
        const featureIds = geomData.featureIds.value;
        const globalFeatureIds = geomData.globalFeatureIds.value;
        for(let i = 0; i < featureIds.length; i++){
            result[featureIds[i]] = globalFeatureIds[i];
        }
        geomData.__ids = result;
    }
    return geomData.__ids[featureIndex];
}
// Like array.findIndex, but only search within a range
function findIndex(array, predicate, startIndex, endIndex) {
    for(let i = startIndex; i < endIndex; i++){
        if (predicate(array[i], i)) {
            return i;
        }
    }
    return -1;
} //# sourceMappingURL=find-index-binary.js.map
}}),
"[project]/node_modules/@deck.gl/geo-layers/dist/mvt-layer/mvt-layer.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__log$3e$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/core/dist/utils/log.js [client] (ecmascript) <export default as log>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/core/dist/lib/constants.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$layers$2f$dist$2f$geojson$2d$layer$2f$geojson$2d$layer$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__GeoJsonLayer$3e$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/layers/dist/geojson-layer/geojson-layer.js [client] (ecmascript) <export default as GeoJsonLayer>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$extensions$2f$dist$2f$clip$2f$clip$2d$extension$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ClipExtension$3e$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/extensions/dist/clip/clip-extension.js [client] (ecmascript) <export default as ClipExtension>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix4$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/classes/matrix4.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$mvt$2f$dist$2f$mvt$2d$loader$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/mvt/dist/mvt-loader.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$gis$2f$dist$2f$lib$2f$binary$2d$features$2f$binary$2d$to$2d$geojson$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/gis/dist/lib/binary-features/binary-to-geojson.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$mvt$2d$layer$2f$coordinate$2d$transform$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/geo-layers/dist/mvt-layer/coordinate-transform.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$mvt$2d$layer$2f$find$2d$index$2d$binary$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/geo-layers/dist/mvt-layer/find-index-binary.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tile$2d$layer$2f$tile$2d$layer$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/geo-layers/dist/tile-layer/tile-layer.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/geo-layers/dist/tileset-2d/utils.js [client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
const WORLD_SIZE = 512;
const defaultProps = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$layers$2f$dist$2f$geojson$2d$layer$2f$geojson$2d$layer$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__GeoJsonLayer$3e$__["GeoJsonLayer"].defaultProps,
    data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["urlType"],
    onDataLoad: {
        type: 'function',
        value: null,
        optional: true,
        compare: false
    },
    uniqueIdProperty: '',
    highlightedFeatureId: null,
    loaders: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$mvt$2f$dist$2f$mvt$2d$loader$2e$js__$5b$client$5d$__$28$ecmascript$29$__["MVTWorkerLoader"]
    ],
    binary: true
};
/** Render data formatted as [Mapbox Vector Tiles](https://docs.mapbox.com/vector-tiles/specification/). */ class MVTLayer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tile$2d$layer$2f$tile$2d$layer$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"] {
    initializeState() {
        super.initializeState();
        // GlobeView doesn't work well with binary data
        const binary = this.context.viewport.resolution !== undefined ? false : this.props.binary;
        this.setState({
            binary,
            data: null,
            tileJSON: null,
            hoveredFeatureId: null,
            hoveredFeatureLayerName: null
        });
    }
    get isLoaded() {
        return Boolean(this.state?.data && super.isLoaded);
    }
    updateState({ props, oldProps, context, changeFlags }) {
        if (changeFlags.dataChanged) {
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            this._updateTileData();
        }
        if (this.state?.data) {
            super.updateState({
                props,
                oldProps,
                context,
                changeFlags
            });
            this._setWGS84PropertyForTiles();
        }
        const { highlightColor } = props;
        if (highlightColor !== oldProps.highlightColor && Array.isArray(highlightColor)) {
            this.setState({
                highlightColor
            });
        }
    }
    /* eslint-disable complexity */ async _updateTileData() {
        let data = this.props.data;
        let tileJSON = null;
        if (typeof data === 'string' && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isURLTemplate"])(data)) {
            const { onDataLoad, fetch } = this.props;
            this.setState({
                data: null,
                tileJSON: null
            });
            try {
                tileJSON = await fetch(data, {
                    propName: 'data',
                    layer: this,
                    loaders: []
                });
            } catch (error) {
                this.raiseError(error, 'loading TileJSON');
                data = null;
            }
            if (onDataLoad) {
                onDataLoad(tileJSON, {
                    propName: 'data',
                    layer: this
                });
            }
        } else if (data && typeof data === 'object' && 'tilejson' in data) {
            tileJSON = data;
        }
        if (tileJSON) {
            data = tileJSON.tiles;
        }
        this.setState({
            data,
            tileJSON
        });
    }
    _getTilesetOptions() {
        const opts = super._getTilesetOptions();
        const tileJSON = this.state.tileJSON;
        const { minZoom, maxZoom } = this.props;
        if (tileJSON) {
            if (Number.isFinite(tileJSON.minzoom) && tileJSON.minzoom > minZoom) {
                opts.minZoom = tileJSON.minzoom;
            }
            if (Number.isFinite(tileJSON.maxzoom) && (!Number.isFinite(maxZoom) || tileJSON.maxzoom < maxZoom)) {
                opts.maxZoom = tileJSON.maxzoom;
            }
        }
        return opts;
    }
    /* eslint-disable complexity */ renderLayers() {
        if (!this.state?.data) return null;
        return super.renderLayers();
    }
    getTileData(loadProps) {
        const { data, binary } = this.state;
        const { index, signal } = loadProps;
        const url = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getURLFromTemplate"])(data, loadProps);
        if (!url) {
            return Promise.reject('Invalid URL');
        }
        let loadOptions = this.getLoadOptions();
        const { fetch } = this.props;
        loadOptions = {
            ...loadOptions,
            mimeType: 'application/x-protobuf',
            mvt: {
                ...loadOptions?.mvt,
                coordinates: this.context.viewport.resolution ? 'wgs84' : 'local',
                tileIndex: index
            },
            gis: binary ? {
                format: 'binary'
            } : {}
        };
        return fetch(url, {
            propName: 'data',
            layer: this,
            loadOptions,
            signal
        });
    }
    renderSubLayers(props) {
        const { x, y, z } = props.tile.index;
        const worldScale = Math.pow(2, z);
        const xScale = WORLD_SIZE / worldScale;
        const yScale = -xScale;
        const xOffset = WORLD_SIZE * x / worldScale;
        const yOffset = WORLD_SIZE * (1 - y / worldScale);
        const modelMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix4$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix4"]().scale([
            xScale,
            yScale,
            1
        ]);
        props.autoHighlight = false;
        if (!this.context.viewport.resolution) {
            props.modelMatrix = modelMatrix;
            props.coordinateOrigin = [
                xOffset,
                yOffset,
                0
            ];
            props.coordinateSystem = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["COORDINATE_SYSTEM"].CARTESIAN;
            props.extensions = [
                ...props.extensions || [],
                new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$extensions$2f$dist$2f$clip$2f$clip$2d$extension$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ClipExtension$3e$__["ClipExtension"]()
            ];
        }
        const subLayers = super.renderSubLayers(props);
        if (this.state.binary && !(subLayers instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$layers$2f$dist$2f$geojson$2d$layer$2f$geojson$2d$layer$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__GeoJsonLayer$3e$__["GeoJsonLayer"])) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__log$3e$__["log"].warn('renderSubLayers() must return GeoJsonLayer when using binary:true')();
        }
        return subLayers;
    }
    _updateAutoHighlight(info) {
        const { uniqueIdProperty } = this.props;
        const { hoveredFeatureId, hoveredFeatureLayerName } = this.state;
        const hoveredFeature = info.object;
        let newHoveredFeatureId = null;
        let newHoveredFeatureLayerName = null;
        if (hoveredFeature) {
            newHoveredFeatureId = getFeatureUniqueId(hoveredFeature, uniqueIdProperty);
            newHoveredFeatureLayerName = getFeatureLayerName(hoveredFeature);
        }
        let { highlightColor } = this.props;
        if (typeof highlightColor === 'function') {
            highlightColor = highlightColor(info);
        }
        if (hoveredFeatureId !== newHoveredFeatureId || hoveredFeatureLayerName !== newHoveredFeatureLayerName) {
            this.setState({
                highlightColor,
                hoveredFeatureId: newHoveredFeatureId,
                hoveredFeatureLayerName: newHoveredFeatureLayerName
            });
        }
    }
    _isWGS84() {
        return Boolean(this.context.viewport.resolution);
    }
    getPickingInfo(params) {
        const info = super.getPickingInfo(params);
        if (this.state.binary && info.index !== -1) {
            const { data } = params.sourceLayer.props;
            info.object = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$gis$2f$dist$2f$lib$2f$binary$2d$features$2f$binary$2d$to$2d$geojson$2e$js__$5b$client$5d$__$28$ecmascript$29$__["binaryToGeojson"])(data, {
                globalFeatureId: info.index
            });
        }
        if (info.object && !this._isWGS84()) {
            info.object = transformTileCoordsToWGS84(info.object, info.tile.bbox, this.context.viewport);
        }
        return info;
    }
    getSubLayerPropsByTile(tile) {
        return {
            highlightedObjectIndex: this.getHighlightedObjectIndex(tile),
            highlightColor: this.state.highlightColor
        };
    }
    getHighlightedObjectIndex(tile) {
        const { hoveredFeatureId, hoveredFeatureLayerName, binary } = this.state;
        const { uniqueIdProperty, highlightedFeatureId } = this.props;
        const data = tile.content;
        const isHighlighted = isFeatureIdDefined(highlightedFeatureId);
        const isFeatureIdPresent = isFeatureIdDefined(hoveredFeatureId) || isHighlighted;
        if (!isFeatureIdPresent) {
            return -1;
        }
        const featureIdToHighlight = isHighlighted ? highlightedFeatureId : hoveredFeatureId;
        // Iterable data
        if (Array.isArray(data)) {
            return data.findIndex((feature)=>{
                const isMatchingId = getFeatureUniqueId(feature, uniqueIdProperty) === featureIdToHighlight;
                const isMatchingLayer = isHighlighted || getFeatureLayerName(feature) === hoveredFeatureLayerName;
                return isMatchingId && isMatchingLayer;
            });
        // Non-iterable data
        } else if (data && binary) {
            // Get the feature index of the selected item to highlight
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$mvt$2d$layer$2f$find$2d$index$2d$binary$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(data, uniqueIdProperty, featureIdToHighlight, isHighlighted ? '' : hoveredFeatureLayerName);
        }
        return -1;
    }
    _pickObjects(maxObjects) {
        const { deck, viewport } = this.context;
        const width = viewport.width;
        const height = viewport.height;
        const x = viewport.x;
        const y = viewport.y;
        const layerIds = [
            this.id
        ];
        return deck.pickObjects({
            x,
            y,
            width,
            height,
            layerIds,
            maxObjects
        });
    }
    /** Get the rendered features in the current viewport. */ getRenderedFeatures(maxFeatures = null) {
        const features = this._pickObjects(maxFeatures);
        const featureCache = new Set();
        const renderedFeatures = [];
        for (const f of features){
            const featureId = getFeatureUniqueId(f.object, this.props.uniqueIdProperty);
            if (featureId === undefined) {
                // we have no id for the feature, we just add to the list
                renderedFeatures.push(f.object);
            } else if (!featureCache.has(featureId)) {
                // Add removing duplicates
                featureCache.add(featureId);
                renderedFeatures.push(f.object);
            }
        }
        return renderedFeatures;
    }
    _setWGS84PropertyForTiles() {
        const propName = 'dataInWGS84';
        const tileset = this.state.tileset;
        // @ts-expect-error selectedTiles are always initialized when tile is being processed
        tileset.selectedTiles.forEach((tile)=>{
            if (!tile.hasOwnProperty(propName)) {
                // eslint-disable-next-line accessor-pairs
                Object.defineProperty(tile, propName, {
                    get: ()=>{
                        // Still loading or encountered an error
                        if (!tile.content) {
                            return null;
                        }
                        if (this.state.binary && Array.isArray(tile.content) && !tile.content.length) {
                            // TODO: @loaders.gl/mvt returns [] when no content. It should return a valid empty binary.
                            // https://github.com/visgl/loaders.gl/pull/1137
                            return [];
                        }
                        const { bbox } = tile;
                        if (tile._contentWGS84 === undefined && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isGeoBoundingBox"])(bbox)) {
                            // Create a cache to transform only once
                            const content = this.state.binary ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$gis$2f$dist$2f$lib$2f$binary$2d$features$2f$binary$2d$to$2d$geojson$2e$js__$5b$client$5d$__$28$ecmascript$29$__["binaryToGeojson"])(tile.content) : tile.content;
                            tile._contentWGS84 = content.map((feature)=>transformTileCoordsToWGS84(feature, bbox, this.context.viewport));
                        }
                        return tile._contentWGS84;
                    }
                });
            }
        });
    }
}
MVTLayer.layerName = 'MVTLayer';
MVTLayer.defaultProps = defaultProps;
const __TURBOPACK__default__export__ = MVTLayer;
function getFeatureUniqueId(feature, uniqueIdProperty) {
    if (feature.properties && uniqueIdProperty) {
        return feature.properties[uniqueIdProperty];
    }
    if ('id' in feature) {
        return feature.id;
    }
    return undefined;
}
function getFeatureLayerName(feature) {
    return feature.properties?.layerName || null;
}
function isFeatureIdDefined(value) {
    return value !== undefined && value !== null && value !== '';
}
function transformTileCoordsToWGS84(object, bbox, viewport) {
    const feature = {
        ...object,
        geometry: {
            type: object.geometry.type
        }
    };
    // eslint-disable-next-line accessor-pairs
    Object.defineProperty(feature.geometry, 'coordinates', {
        get: ()=>{
            const wgs84Geom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$mvt$2d$layer$2f$coordinate$2d$transform$2e$js__$5b$client$5d$__$28$ecmascript$29$__["transform"])(object.geometry, bbox, viewport);
            return wgs84Geom.coordinates;
        }
    });
    return feature;
} //# sourceMappingURL=mvt-layer.js.map
}}),
"[project]/node_modules/@deck.gl/geo-layers/dist/mvt-layer/mvt-layer.js [client] (ecmascript) <export default as MVTLayer>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "MVTLayer": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$mvt$2d$layer$2f$mvt$2d$layer$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$mvt$2d$layer$2f$mvt$2d$layer$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/geo-layers/dist/mvt-layer/mvt-layer.js [client] (ecmascript)");
}}),
"[project]/node_modules/@deck.gl/geo-layers/dist/tileset-2d/utils.js [client] (ecmascript) <export getURLFromTemplate as _getURLFromTemplate>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "_getURLFromTemplate": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getURLFromTemplate"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/geo-layers/dist/tileset-2d/utils.js [client] (ecmascript)");
}}),
"[project]/node_modules/@deck.gl/extensions/dist/clip/clip-extension.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$layer$2d$extension$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__LayerExtension$3e$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/core/dist/lib/layer-extension.js [client] (ecmascript) <export default as LayerExtension>");
;
const defaultProps = {
    clipBounds: [
        0,
        0,
        1,
        1
    ],
    clipByInstance: undefined
};
const shaderFunction = /* glsl */ `
uniform clipUniforms {
  vec4 bounds;
} clip;

bool clip_isInBounds(vec2 position) {
  return position.x >= clip.bounds[0] && position.y >= clip.bounds[1] && position.x < clip.bounds[2] && position.y < clip.bounds[3];
}
`;
/*
 * The vertex-shader version clips geometries by their anchor position
 * e.g. ScatterplotLayer - show if the center of a circle is within bounds
 */ const shaderModuleVs = {
    name: 'clip',
    vs: shaderFunction,
    uniformTypes: {
        bounds: 'vec4<f32>'
    }
};
const injectionVs = {
    'vs:#decl': /* glsl */ `
out float clip_isVisible;
`,
    'vs:DECKGL_FILTER_GL_POSITION': /* glsl */ `
  clip_isVisible = float(clip_isInBounds(geometry.worldPosition.xy));
`,
    'fs:#decl': /* glsl */ `
in float clip_isVisible;
`,
    'fs:DECKGL_FILTER_COLOR': /* glsl */ `
  if (clip_isVisible < 0.5) discard;
`
};
/*
 * The fragment-shader version clips pixels at the bounds
 * e.g. PolygonLayer - show the part of the polygon that intersect with the bounds
 */ const shaderModuleFs = {
    name: 'clip',
    fs: shaderFunction,
    uniformTypes: {
        bounds: 'vec4<f32>'
    }
};
const injectionFs = {
    'vs:#decl': /* glsl */ `
out vec2 clip_commonPosition;
`,
    'vs:DECKGL_FILTER_GL_POSITION': /* glsl */ `
  clip_commonPosition = geometry.position.xy;
`,
    'fs:#decl': /* glsl */ `
in vec2 clip_commonPosition;
`,
    'fs:DECKGL_FILTER_COLOR': /* glsl */ `
  if (!clip_isInBounds(clip_commonPosition)) discard;
`
};
/** Adds support for clipping rendered layers by rectangular bounds. */ class ClipExtension extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$layer$2d$extension$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__LayerExtension$3e$__["LayerExtension"] {
    getShaders() {
        // If `clipByInstance: true`, the entire object is shown/hidden based on its anchor position (done by vertex shader)
        // Otherwise, the object is trimmed by the clip bounds (done by fragment shader)
        // Default behavior: consider a layer instanced if it has attribute `instancePositions`
        let clipByInstance = 'instancePositions' in this.getAttributeManager().attributes;
        // Users can override by setting the `clipByInstance` prop
        if (this.props.clipByInstance !== undefined) {
            clipByInstance = Boolean(this.props.clipByInstance);
        }
        this.state.clipByInstance = clipByInstance;
        return clipByInstance ? {
            modules: [
                shaderModuleVs
            ],
            inject: injectionVs
        } : {
            modules: [
                shaderModuleFs
            ],
            inject: injectionFs
        };
    }
    /* eslint-disable camelcase */ draw() {
        const { clipBounds } = this.props;
        const clipProps = {};
        if (this.state.clipByInstance) {
            clipProps.bounds = clipBounds;
        } else {
            const corner0 = this.projectPosition([
                clipBounds[0],
                clipBounds[1],
                0
            ]);
            const corner1 = this.projectPosition([
                clipBounds[2],
                clipBounds[3],
                0
            ]);
            clipProps.bounds = [
                Math.min(corner0[0], corner1[0]),
                Math.min(corner0[1], corner1[1]),
                Math.max(corner0[0], corner1[0]),
                Math.max(corner0[1], corner1[1])
            ];
        }
        this.setShaderModuleProps({
            clip: clipProps
        });
    }
}
ClipExtension.defaultProps = defaultProps;
ClipExtension.extensionName = 'ClipExtension';
const __TURBOPACK__default__export__ = ClipExtension;
 //# sourceMappingURL=clip-extension.js.map
}}),
"[project]/node_modules/@deck.gl/extensions/dist/clip/clip-extension.js [client] (ecmascript) <export default as ClipExtension>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "ClipExtension": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$extensions$2f$dist$2f$clip$2f$clip$2d$extension$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$extensions$2f$dist$2f$clip$2f$clip$2d$extension$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/extensions/dist/clip/clip-extension.js [client] (ecmascript)");
}}),
"[project]/node_modules/@deck.gl/extensions/dist/collision-filter/shader-module.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$shaderlib$2f$project$2f$project$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__project$3e$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/core/dist/shaderlib/project/project.js [client] (ecmascript) <export default as project>");
;
const vs = /* glsl */ `
in float collisionPriorities;

uniform sampler2D collision_texture;

uniform collisionUniforms {
  bool sort;
  bool enabled;
} collision;

vec2 collision_getCoords(vec4 position) {
  vec4 collision_clipspace = project_common_position_to_clipspace(position);
  return (1.0 + collision_clipspace.xy / collision_clipspace.w) / 2.0;
}

float collision_match(vec2 tex, vec3 pickingColor) {
  vec4 collision_pickingColor = texture(collision_texture, tex);
  float delta = dot(abs(collision_pickingColor.rgb - pickingColor), vec3(1.0));
  float e = 0.001;
  return step(delta, e);
}

float collision_isVisible(vec2 texCoords, vec3 pickingColor) {
  if (!collision.enabled) {
    return 1.0;
  }

  // Visibility test, sample area of 5x5 pixels in order to fade in/out.
  // Due to the locality, the lookups will be cached
  // This reduces the flicker present when objects are shown/hidden
  const int N = 2;
  float accumulator = 0.0;
  vec2 step = vec2(1.0 / project.viewportSize);

  const float floatN = float(N);
  vec2 delta = -floatN * step;
  for(int i = -N; i <= N; i++) {
    delta.x = -step.x * floatN;
    for(int j = -N; j <= N; j++) {
      accumulator += collision_match(texCoords + delta, pickingColor);
      delta.x += step.x;
    }
    delta.y += step.y;
  }

  float W = 2.0 * floatN + 1.0;
  return pow(accumulator / (W * W), 2.2);
}
`;
const inject = {
    'vs:#decl': /* glsl */ `
  float collision_fade = 1.0;
`,
    'vs:DECKGL_FILTER_GL_POSITION': /* glsl */ `
  if (collision.sort) {
    float collisionPriority = collisionPriorities;
    position.z = -0.001 * collisionPriority * position.w; // Support range -1000 -> 1000
  }

  if (collision.enabled) {
    vec4 collision_common_position = project_position(vec4(geometry.worldPosition, 1.0));
    vec2 collision_texCoords = collision_getCoords(collision_common_position);
    collision_fade = collision_isVisible(collision_texCoords, geometry.pickingColor / 255.0);
    if (collision_fade < 0.0001) {
      // Position outside clip space bounds to discard
      position = vec4(0.0, 0.0, 2.0, 1.0);
    }
  }
  `,
    'vs:DECKGL_FILTER_COLOR': /* glsl */ `
  color.a *= collision_fade;
  `
};
const getCollisionUniforms = (opts)=>{
    if (!opts || !('dummyCollisionMap' in opts)) {
        return {};
    }
    const { enabled, collisionFBO, drawToCollisionMap, dummyCollisionMap } = opts;
    return {
        enabled: enabled && !drawToCollisionMap,
        sort: Boolean(drawToCollisionMap),
        collision_texture: !drawToCollisionMap && collisionFBO ? collisionFBO.colorAttachments[0] : dummyCollisionMap
    };
};
const __TURBOPACK__default__export__ = {
    name: 'collision',
    dependencies: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$shaderlib$2f$project$2f$project$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__project$3e$__["project"]
    ],
    vs,
    inject,
    getUniforms: getCollisionUniforms,
    uniformTypes: {
        sort: 'i32',
        enabled: 'i32'
    }
};
 //# sourceMappingURL=shader-module.js.map
}}),
"[project]/node_modules/@deck.gl/extensions/dist/collision-filter/collision-filter-pass.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "default": (()=>CollisionFilterPass)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$passes$2f$layers$2d$pass$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__$5f$LayersPass$3e$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/core/dist/passes/layers-pass.js [client] (ecmascript) <export default as _LayersPass>");
;
class CollisionFilterPass extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$passes$2f$layers$2d$pass$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__$5f$LayersPass$3e$__["_LayersPass"] {
    renderCollisionMap(target, options) {
        const padding = 1;
        const clearColor = [
            0,
            0,
            0,
            0
        ];
        const scissorRect = [
            padding,
            padding,
            target.width - 2 * padding,
            target.height - 2 * padding
        ];
        this.render({
            ...options,
            clearColor,
            scissorRect,
            target,
            pass: 'collision'
        });
    }
    getLayerParameters(layer, layerIndex, viewport) {
        return {
            ...layer.props.parameters,
            blend: false,
            depthWriteEnabled: true,
            depthCompare: 'less-equal'
        };
    }
    getShaderModuleProps() {
        // Draw picking colors into collision FBO
        return {
            collision: {
                drawToCollisionMap: true
            },
            picking: {
                isActive: 1,
                isAttribute: false
            },
            lighting: {
                enabled: false
            }
        };
    }
} //# sourceMappingURL=collision-filter-pass.js.map
}}),
"[project]/node_modules/@deck.gl/extensions/dist/collision-filter/collision-filter-effect.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "default": (()=>CollisionFilterEffect)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$common$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/lib/common.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$utils$2f$deep$2d$equal$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__deepEqual__as__$5f$deepEqual$3e$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/core/dist/utils/deep-equal.js [client] (ecmascript) <export deepEqual as _deepEqual>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$extensions$2f$dist$2f$collision$2d$filter$2f$collision$2d$filter$2d$pass$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/extensions/dist/collision-filter/collision-filter-pass.js [client] (ecmascript)");
;
;
;
// Factor by which to downscale Collision FBO relative to canvas
const DOWNSCALE = 2;
class CollisionFilterEffect {
    constructor(){
        this.id = 'collision-filter-effect';
        this.props = null;
        this.useInPicking = true;
        this.order = 1;
        this.channels = {};
        this.collisionFBOs = {};
    }
    setup(context) {
        this.context = context;
        const { device } = context;
        this.dummyCollisionMap = device.createTexture({
            width: 1,
            height: 1
        });
        this.collisionFilterPass = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$extensions$2f$dist$2f$collision$2d$filter$2f$collision$2d$filter$2d$pass$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"](device, {
            id: 'default-collision-filter'
        });
    }
    preRender({ effects: allEffects, layers, layerFilter, viewports, onViewportActive, views, isPicking, preRenderStats = {} }) {
        // This can only be called in preRender() after setup() where context is populated
        const { device } = this.context;
        if (isPicking) {
            // Do not update on picking pass
            return;
        }
        const collisionLayers = layers.filter(// @ts-ignore
        ({ props: { visible, collisionEnabled } })=>visible && collisionEnabled);
        if (collisionLayers.length === 0) {
            this.channels = {};
            return;
        }
        // Detect if mask has rendered. TODO: better dependency system for Effects
        const effects = allEffects?.filter((e)=>e.useInPicking && preRenderStats[e.id]);
        const maskEffectRendered = preRenderStats['mask-effect']?.didRender;
        // Collect layers to render
        const channels = this._groupByCollisionGroup(device, collisionLayers);
        const viewport = viewports[0];
        const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport) || maskEffectRendered;
        // Resize framebuffers to match canvas
        for(const collisionGroup in channels){
            const collisionFBO = this.collisionFBOs[collisionGroup];
            const renderInfo = channels[collisionGroup];
            // @ts-expect-error TODO - assuming WebGL context
            const [width, height] = device.canvasContext.getPixelSize();
            collisionFBO.resize({
                width: width / DOWNSCALE,
                height: height / DOWNSCALE
            });
            this._render(renderInfo, {
                effects,
                layerFilter,
                onViewportActive,
                views,
                viewport,
                viewportChanged
            });
        }
    // debugFBO(this.collisionFBOs[Object.keys(channels)[0]], {minimap: true});
    }
    _render(renderInfo, { effects, layerFilter, onViewportActive, views, viewport, viewportChanged }) {
        const { collisionGroup } = renderInfo;
        const oldRenderInfo = this.channels[collisionGroup];
        if (!oldRenderInfo) {
            return;
        }
        const needsRender = viewportChanged || // If render info is new
        renderInfo === oldRenderInfo || // If sublayers have changed
        !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$utils$2f$deep$2d$equal$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__deepEqual__as__$5f$deepEqual$3e$__["_deepEqual"])(oldRenderInfo.layers, renderInfo.layers, 1) || // If a sublayer's bounds have been updated
        renderInfo.layerBounds.some((b, i)=>!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$common$2e$js__$5b$client$5d$__$28$ecmascript$29$__["equals"])(b, oldRenderInfo.layerBounds[i])) || // If a sublayer's isLoaded state has been updated
        renderInfo.allLayersLoaded !== oldRenderInfo.allLayersLoaded || // Some prop is in transition
        renderInfo.layers.some((layer)=>layer.props.transitions);
        this.channels[collisionGroup] = renderInfo;
        if (needsRender) {
            this.lastViewport = viewport;
            const collisionFBO = this.collisionFBOs[collisionGroup];
            // Rerender collision FBO
            this.collisionFilterPass.renderCollisionMap(collisionFBO, {
                pass: 'collision-filter',
                isPicking: true,
                layers: renderInfo.layers,
                effects,
                layerFilter,
                viewports: viewport ? [
                    viewport
                ] : [],
                onViewportActive,
                views,
                shaderModuleProps: {
                    collision: {
                        enabled: true,
                        // To avoid feedback loop forming between Framebuffer and active Texture.
                        dummyCollisionMap: this.dummyCollisionMap
                    },
                    project: {
                        // @ts-expect-error TODO - assuming WebGL context
                        devicePixelRatio: collisionFBO.device.canvasContext.getDevicePixelRatio() / DOWNSCALE
                    }
                }
            });
        }
    }
    /**
     * Group layers by collisionGroup
     * Returns a map from collisionGroup to render info
     */ _groupByCollisionGroup(device, collisionLayers) {
        const channelMap = {};
        for (const layer of collisionLayers){
            const collisionGroup = layer.props.collisionGroup;
            let channelInfo = channelMap[collisionGroup];
            if (!channelInfo) {
                channelInfo = {
                    collisionGroup,
                    layers: [],
                    layerBounds: [],
                    allLayersLoaded: true
                };
                channelMap[collisionGroup] = channelInfo;
            }
            channelInfo.layers.push(layer);
            channelInfo.layerBounds.push(layer.getBounds());
            if (!layer.isLoaded) {
                channelInfo.allLayersLoaded = false;
            }
        }
        // Create any new passes and remove any old ones
        for (const collisionGroup of Object.keys(channelMap)){
            if (!this.collisionFBOs[collisionGroup]) {
                this.createFBO(device, collisionGroup);
            }
            if (!this.channels[collisionGroup]) {
                this.channels[collisionGroup] = channelMap[collisionGroup];
            }
        }
        for (const collisionGroup of Object.keys(this.collisionFBOs)){
            if (!channelMap[collisionGroup]) {
                this.destroyFBO(collisionGroup);
            }
        }
        return channelMap;
    }
    getShaderModuleProps(layer) {
        const { collisionGroup, collisionEnabled } = layer.props;
        const { collisionFBOs, dummyCollisionMap } = this;
        const collisionFBO = collisionFBOs[collisionGroup];
        const enabled = collisionEnabled && Boolean(collisionFBO);
        return {
            collision: {
                enabled,
                collisionFBO,
                dummyCollisionMap: dummyCollisionMap
            }
        };
    }
    cleanup() {
        if (this.dummyCollisionMap) {
            this.dummyCollisionMap.delete();
            this.dummyCollisionMap = undefined;
        }
        this.channels = {};
        for (const collisionGroup of Object.keys(this.collisionFBOs)){
            this.destroyFBO(collisionGroup);
        }
        this.collisionFBOs = {};
        this.lastViewport = undefined;
    }
    createFBO(device, collisionGroup) {
        // @ts-expect-error
        const { width, height } = device.gl.canvas;
        const collisionMap = device.createTexture({
            format: 'rgba8unorm',
            width,
            height,
            sampler: {
                minFilter: 'nearest',
                magFilter: 'nearest',
                addressModeU: 'clamp-to-edge',
                addressModeV: 'clamp-to-edge'
            }
        });
        // @ts-ignore
        const depthStencilAttachment = device.createTexture({
            format: 'depth16unorm',
            width,
            height,
            mipmaps: false
        });
        this.collisionFBOs[collisionGroup] = device.createFramebuffer({
            id: `collision-${collisionGroup}`,
            width,
            height,
            colorAttachments: [
                collisionMap
            ],
            depthStencilAttachment
        });
    }
    destroyFBO(collisionGroup) {
        const fbo = this.collisionFBOs[collisionGroup];
        fbo.colorAttachments[0]?.destroy();
        fbo.depthStencilAttachment?.destroy();
        fbo.destroy();
        delete this.collisionFBOs[collisionGroup];
    }
} //# sourceMappingURL=collision-filter-effect.js.map
}}),
"[project]/node_modules/@deck.gl/extensions/dist/collision-filter/collision-filter-extension.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$layer$2d$extension$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__LayerExtension$3e$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/core/dist/lib/layer-extension.js [client] (ecmascript) <export default as LayerExtension>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$extensions$2f$dist$2f$collision$2d$filter$2f$shader$2d$module$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/extensions/dist/collision-filter/shader-module.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$extensions$2f$dist$2f$collision$2d$filter$2f$collision$2d$filter$2d$effect$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/extensions/dist/collision-filter/collision-filter-effect.js [client] (ecmascript)");
;
;
;
const defaultProps = {
    getCollisionPriority: {
        type: 'accessor',
        value: 0
    },
    collisionEnabled: true,
    collisionGroup: {
        type: 'string',
        value: 'default'
    },
    collisionTestProps: {}
};
/** Allows layers to hide overlapping objects. */ class CollisionFilterExtension extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$layer$2d$extension$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__LayerExtension$3e$__["LayerExtension"] {
    getShaders() {
        return {
            modules: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$extensions$2f$dist$2f$collision$2d$filter$2f$shader$2d$module$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"]
            ]
        };
    }
    /* eslint-disable camelcase */ draw({ shaderModuleProps }) {
        if (shaderModuleProps.collision?.drawToCollisionMap) {
            // Override any props with those defined in collisionTestProps
            // @ts-ignore
            this.props = this.clone(this.props.collisionTestProps).props;
        }
    }
    initializeState(context, extension) {
        if (this.getAttributeManager() === null) {
            return;
        }
        this.context.deck?._addDefaultEffect(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$extensions$2f$dist$2f$collision$2d$filter$2f$collision$2d$filter$2d$effect$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"]());
        const attributeManager = this.getAttributeManager();
        attributeManager.add({
            collisionPriorities: {
                size: 1,
                stepMode: 'dynamic',
                accessor: 'getCollisionPriority'
            }
        });
    }
    getNeedsPickingBuffer() {
        return this.props.collisionEnabled;
    }
}
CollisionFilterExtension.defaultProps = defaultProps;
CollisionFilterExtension.extensionName = 'CollisionFilterExtension';
const __TURBOPACK__default__export__ = CollisionFilterExtension;
 //# sourceMappingURL=collision-filter-extension.js.map
}}),
"[project]/node_modules/@deck.gl/extensions/dist/collision-filter/collision-filter-extension.js [client] (ecmascript) <export default as CollisionFilterExtension>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "CollisionFilterExtension": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$extensions$2f$dist$2f$collision$2d$filter$2f$collision$2d$filter$2d$extension$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$extensions$2f$dist$2f$collision$2d$filter$2f$collision$2d$filter$2d$extension$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/extensions/dist/collision-filter/collision-filter-extension.js [client] (ecmascript)");
}}),
}]);

//# sourceMappingURL=node_modules_%40deck_gl_623e23e0._.js.map