(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_d7aa4dd8._.js", {

"[project]/node_modules/@luma.gl/engine/dist/animation/timeline.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "Timeline": (()=>Timeline)
});
let channelHandles = 1;
let animationHandles = 1;
class Timeline {
    time = 0;
    channels = new Map();
    animations = new Map();
    playing = false;
    lastEngineTime = -1;
    constructor(){}
    addChannel(props) {
        const { delay = 0, duration = Number.POSITIVE_INFINITY, rate = 1, repeat = 1 } = props;
        const channelId = channelHandles++;
        const channel = {
            time: 0,
            delay,
            duration,
            rate,
            repeat
        };
        this._setChannelTime(channel, this.time);
        this.channels.set(channelId, channel);
        return channelId;
    }
    removeChannel(channelId) {
        this.channels.delete(channelId);
        for (const [animationHandle, animation] of this.animations){
            if (animation.channel === channelId) {
                this.detachAnimation(animationHandle);
            }
        }
    }
    isFinished(channelId) {
        const channel = this.channels.get(channelId);
        if (channel === undefined) {
            return false;
        }
        return this.time >= channel.delay + channel.duration * channel.repeat;
    }
    getTime(channelId) {
        if (channelId === undefined) {
            return this.time;
        }
        const channel = this.channels.get(channelId);
        if (channel === undefined) {
            return -1;
        }
        return channel.time;
    }
    setTime(time) {
        this.time = Math.max(0, time);
        const channels = this.channels.values();
        for (const channel of channels){
            this._setChannelTime(channel, this.time);
        }
        const animations = this.animations.values();
        for (const animationData of animations){
            const { animation, channel } = animationData;
            animation.setTime(this.getTime(channel));
        }
    }
    play() {
        this.playing = true;
    }
    pause() {
        this.playing = false;
        this.lastEngineTime = -1;
    }
    reset() {
        this.setTime(0);
    }
    attachAnimation(animation, channelHandle) {
        const animationHandle = animationHandles++;
        this.animations.set(animationHandle, {
            animation,
            channel: channelHandle
        });
        animation.setTime(this.getTime(channelHandle));
        return animationHandle;
    }
    detachAnimation(channelId) {
        this.animations.delete(channelId);
    }
    update(engineTime) {
        if (this.playing) {
            if (this.lastEngineTime === -1) {
                this.lastEngineTime = engineTime;
            }
            this.setTime(this.time + (engineTime - this.lastEngineTime));
            this.lastEngineTime = engineTime;
        }
    }
    _setChannelTime(channel, time) {
        const offsetTime = time - channel.delay;
        const totalDuration = channel.duration * channel.repeat;
        // Note(Tarek): Don't loop on final repeat.
        if (offsetTime >= totalDuration) {
            channel.time = channel.duration * channel.rate;
        } else {
            channel.time = Math.max(0, offsetTime) % channel.duration;
            channel.time *= channel.rate;
        }
    }
} //# sourceMappingURL=timeline.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/animation-loop/request-animation-frame.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/* global window, setTimeout, clearTimeout */ /** Node.js polyfill for requestAnimationFrame */ // / <reference types="@types/node" />
__turbopack_context__.s({
    "cancelAnimationFramePolyfill": (()=>cancelAnimationFramePolyfill),
    "requestAnimationFramePolyfill": (()=>requestAnimationFramePolyfill)
});
function requestAnimationFramePolyfill(callback) {
    return typeof window !== 'undefined' && window.requestAnimationFrame ? window.requestAnimationFrame(callback) : setTimeout(callback, 1000 / 60);
}
function cancelAnimationFramePolyfill(timerId) {
    return typeof window !== 'undefined' && window.cancelAnimationFrame ? window.cancelAnimationFrame(timerId) : clearTimeout(timerId);
} //# sourceMappingURL=request-animation-frame.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/animation-loop/animation-loop.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "AnimationLoop": (()=>AnimationLoop)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$luma$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/core/dist/adapter/luma.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$animation$2d$loop$2f$request$2d$animation$2d$frame$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/engine/dist/animation-loop/request-animation-frame.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/stats/dist/index.js [client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$lib$2f$stats$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Stats$3e$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/stats/dist/lib/stats.js [client] (ecmascript) <export default as Stats>");
;
;
;
let statIdCounter = 0;
const DEFAULT_ANIMATION_LOOP_PROPS = {
    device: null,
    onAddHTML: ()=>'',
    onInitialize: async ()=>{
        return null;
    },
    onRender: ()=>{},
    onFinalize: ()=>{},
    onError: (error)=>console.error(error),
    stats: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$luma$2e$js__$5b$client$5d$__$28$ecmascript$29$__["luma"].stats.get(`animation-loop-${statIdCounter++}`),
    // view parameters
    useDevicePixels: true,
    autoResizeViewport: false,
    autoResizeDrawingBuffer: false
};
class AnimationLoop {
    device = null;
    canvas = null;
    props;
    animationProps = null;
    timeline = null;
    stats;
    cpuTime;
    gpuTime;
    frameRate;
    display;
    needsRedraw = 'initialized';
    _initialized = false;
    _running = false;
    _animationFrameId = null;
    _nextFramePromise = null;
    _resolveNextFrame = null;
    _cpuStartTime = 0;
    _error = null;
    // _gpuTimeQuery: Query | null = null;
    /*
     * @param {HTMLCanvasElement} canvas - if provided, width and height will be passed to context
     */ constructor(props){
        this.props = {
            ...DEFAULT_ANIMATION_LOOP_PROPS,
            ...props
        };
        props = this.props;
        if (!props.device) {
            throw new Error('No device provided');
        }
        const { useDevicePixels = true } = this.props;
        // state
        this.stats = props.stats || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$lib$2f$stats$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Stats$3e$__["Stats"]({
            id: 'animation-loop-stats'
        });
        this.cpuTime = this.stats.get('CPU Time');
        this.gpuTime = this.stats.get('GPU Time');
        this.frameRate = this.stats.get('Frame Rate');
        this.setProps({
            autoResizeViewport: props.autoResizeViewport,
            autoResizeDrawingBuffer: props.autoResizeDrawingBuffer,
            useDevicePixels
        });
        // Bind methods
        this.start = this.start.bind(this);
        this.stop = this.stop.bind(this);
        this._onMousemove = this._onMousemove.bind(this);
        this._onMouseleave = this._onMouseleave.bind(this);
    }
    destroy() {
        this.stop();
        this._setDisplay(null);
    }
    /** @deprecated Use .destroy() */ delete() {
        this.destroy();
    }
    setError(error) {
        this.props.onError(error);
        this._error = Error();
        const canvas = this.device?.canvasContext?.canvas;
        if (canvas instanceof HTMLCanvasElement) {
            const errorDiv = document.createElement('h1');
            errorDiv.innerHTML = error.message;
            errorDiv.style.position = 'absolute';
            errorDiv.style.top = '20%'; // left: 50%; transform: translate(-50%, -50%);';
            errorDiv.style.left = '10px';
            errorDiv.style.color = 'black';
            errorDiv.style.backgroundColor = 'red';
            document.body.appendChild(errorDiv);
        // canvas.style.position = 'absolute';
        }
    }
    /** Flags this animation loop as needing redraw */ setNeedsRedraw(reason) {
        this.needsRedraw = this.needsRedraw || reason;
        return this;
    }
    /** TODO - move these props to CanvasContext? */ setProps(props) {
        if ('autoResizeViewport' in props) {
            this.props.autoResizeViewport = props.autoResizeViewport || false;
        }
        if ('autoResizeDrawingBuffer' in props) {
            this.props.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer || false;
        }
        if ('useDevicePixels' in props) {
            this.props.useDevicePixels = props.useDevicePixels || false;
        }
        return this;
    }
    /** Starts a render loop if not already running */ async start() {
        if (this._running) {
            return this;
        }
        this._running = true;
        try {
            let appContext;
            if (!this._initialized) {
                this._initialized = true;
                // Create the WebGL context
                await this._initDevice();
                this._initialize();
                // Note: onIntialize can return a promise (e.g. in case app needs to load resources)
                await this.props.onInitialize(this._getAnimationProps());
            }
            // check that we haven't been stopped
            if (!this._running) {
                return null;
            }
            // Start the loop
            if (appContext !== false) {
                // cancel any pending renders to ensure only one loop can ever run
                this._cancelAnimationFrame();
                this._requestAnimationFrame();
            }
            return this;
        } catch (err) {
            const error = err instanceof Error ? err : new Error('Unknown error');
            this.props.onError(error);
            // this._running = false; // TODO
            throw error;
        }
    }
    /** Stops a render loop if already running, finalizing */ stop() {
        // console.debug(`Stopping ${this.constructor.name}`);
        if (this._running) {
            // call callback
            // If stop is called immediately, we can end up in a state where props haven't been initialized...
            if (this.animationProps && !this._error) {
                this.props.onFinalize(this.animationProps);
            }
            this._cancelAnimationFrame();
            this._nextFramePromise = null;
            this._resolveNextFrame = null;
            this._running = false;
        }
        return this;
    }
    /** Explicitly draw a frame */ redraw() {
        if (this.device?.isLost || this._error) {
            return this;
        }
        this._beginFrameTimers();
        this._setupFrame();
        this._updateAnimationProps();
        this._renderFrame(this._getAnimationProps());
        // clear needsRedraw flag
        this._clearNeedsRedraw();
        if (this._resolveNextFrame) {
            this._resolveNextFrame(this);
            this._nextFramePromise = null;
            this._resolveNextFrame = null;
        }
        this._endFrameTimers();
        return this;
    }
    /** Add a timeline, it will be automatically updated by the animation loop. */ attachTimeline(timeline) {
        this.timeline = timeline;
        return this.timeline;
    }
    /** Remove a timeline */ detachTimeline() {
        this.timeline = null;
    }
    /** Wait until a render completes */ waitForRender() {
        this.setNeedsRedraw('waitForRender');
        if (!this._nextFramePromise) {
            this._nextFramePromise = new Promise((resolve)=>{
                this._resolveNextFrame = resolve;
            });
        }
        return this._nextFramePromise;
    }
    /** TODO - should use device.deviceContext */ async toDataURL() {
        this.setNeedsRedraw('toDataURL');
        await this.waitForRender();
        if (this.canvas instanceof HTMLCanvasElement) {
            return this.canvas.toDataURL();
        }
        throw new Error('OffscreenCanvas');
    }
    // PRIVATE METHODS
    _initialize() {
        this._startEventHandling();
        // Initialize the callback data
        this._initializeAnimationProps();
        this._updateAnimationProps();
        // Default viewport setup, in case onInitialize wants to render
        this._resizeCanvasDrawingBuffer();
        this._resizeViewport();
    // this._gpuTimeQuery = Query.isSupported(this.gl, ['timers']) ? new Query(this.gl) : null;
    }
    _setDisplay(display) {
        if (this.display) {
            this.display.destroy();
            this.display.animationLoop = null;
        }
        // store animation loop on the display
        if (display) {
            display.animationLoop = this;
        }
        this.display = display;
    }
    _requestAnimationFrame() {
        if (!this._running) {
            return;
        }
        // VR display has a separate animation frame to sync with headset
        // TODO WebVR API discontinued, replaced by WebXR: https://immersive-web.github.io/webxr/
        // See https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/requestAnimationFrame
        // if (this.display && this.display.requestAnimationFrame) {
        //   this._animationFrameId = this.display.requestAnimationFrame(this._animationFrame.bind(this));
        // }
        this._animationFrameId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$animation$2d$loop$2f$request$2d$animation$2d$frame$2e$js__$5b$client$5d$__$28$ecmascript$29$__["requestAnimationFramePolyfill"])(this._animationFrame.bind(this));
    }
    _cancelAnimationFrame() {
        if (this._animationFrameId === null) {
            return;
        }
        // VR display has a separate animation frame to sync with headset
        // TODO WebVR API discontinued, replaced by WebXR: https://immersive-web.github.io/webxr/
        // See https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/requestAnimationFrame
        // if (this.display && this.display.cancelAnimationFramePolyfill) {
        //   this.display.cancelAnimationFrame(this._animationFrameId);
        // }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$animation$2d$loop$2f$request$2d$animation$2d$frame$2e$js__$5b$client$5d$__$28$ecmascript$29$__["cancelAnimationFramePolyfill"])(this._animationFrameId);
        this._animationFrameId = null;
    }
    _animationFrame() {
        if (!this._running) {
            return;
        }
        this.redraw();
        this._requestAnimationFrame();
    }
    // Called on each frame, can be overridden to call onRender multiple times
    // to support e.g. stereoscopic rendering
    _renderFrame(animationProps) {
        // Allow e.g. VR display to render multiple frames.
        if (this.display) {
            this.display._renderFrame(animationProps);
            return;
        }
        // call callback
        this.props.onRender(this._getAnimationProps());
        // end callback
        // Submit commands (necessary on WebGPU)
        this.device?.submit();
    }
    _clearNeedsRedraw() {
        this.needsRedraw = false;
    }
    _setupFrame() {
        this._resizeCanvasDrawingBuffer();
        this._resizeViewport();
    }
    // Initialize the  object that will be passed to app callbacks
    _initializeAnimationProps() {
        const canvas = this.device?.canvasContext?.canvas;
        if (!this.device || !canvas) {
            throw new Error('loop');
        }
        this.animationProps = {
            animationLoop: this,
            device: this.device,
            canvas,
            timeline: this.timeline,
            // Initial values
            useDevicePixels: this.props.useDevicePixels,
            needsRedraw: false,
            // Placeholders
            width: 1,
            height: 1,
            aspect: 1,
            // Animation props
            time: 0,
            startTime: Date.now(),
            engineTime: 0,
            tick: 0,
            tock: 0,
            // Experimental
            _mousePosition: null // Event props
        };
    }
    _getAnimationProps() {
        if (!this.animationProps) {
            throw new Error('animationProps');
        }
        return this.animationProps;
    }
    // Update the context object that will be passed to app callbacks
    _updateAnimationProps() {
        if (!this.animationProps) {
            return;
        }
        // Can this be replaced with canvas context?
        const { width, height, aspect } = this._getSizeAndAspect();
        if (width !== this.animationProps.width || height !== this.animationProps.height) {
            this.setNeedsRedraw('drawing buffer resized');
        }
        if (aspect !== this.animationProps.aspect) {
            this.setNeedsRedraw('drawing buffer aspect changed');
        }
        this.animationProps.width = width;
        this.animationProps.height = height;
        this.animationProps.aspect = aspect;
        this.animationProps.needsRedraw = this.needsRedraw;
        // Update time properties
        this.animationProps.engineTime = Date.now() - this.animationProps.startTime;
        if (this.timeline) {
            this.timeline.update(this.animationProps.engineTime);
        }
        this.animationProps.tick = Math.floor(this.animationProps.time / 1000 * 60);
        this.animationProps.tock++;
        // For back compatibility
        this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;
    }
    /** Wait for supplied device */ async _initDevice() {
        this.device = await this.props.device;
        if (!this.device) {
            throw new Error('No device provided');
        }
        this.canvas = this.device.canvasContext?.canvas || null;
    // this._createInfoDiv();
    }
    _createInfoDiv() {
        if (this.canvas && this.props.onAddHTML) {
            const wrapperDiv = document.createElement('div');
            document.body.appendChild(wrapperDiv);
            wrapperDiv.style.position = 'relative';
            const div = document.createElement('div');
            div.style.position = 'absolute';
            div.style.left = '10px';
            div.style.bottom = '10px';
            div.style.width = '300px';
            div.style.background = 'white';
            if (this.canvas instanceof HTMLCanvasElement) {
                wrapperDiv.appendChild(this.canvas);
            }
            wrapperDiv.appendChild(div);
            const html = this.props.onAddHTML(div);
            if (html) {
                div.innerHTML = html;
            }
        }
    }
    _getSizeAndAspect() {
        if (!this.device) {
            return {
                width: 1,
                height: 1,
                aspect: 1
            };
        }
        // https://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
        const [width, height] = this.device?.canvasContext?.getPixelSize() || [
            1,
            1
        ];
        // https://webglfundamentals.org/webgl/lessons/webgl-anti-patterns.html
        let aspect = 1;
        const canvas = this.device?.canvasContext?.canvas;
        // @ts-expect-error
        if (canvas && canvas.clientHeight) {
            // @ts-expect-error
            aspect = canvas.clientWidth / canvas.clientHeight;
        } else if (width > 0 && height > 0) {
            aspect = width / height;
        }
        return {
            width,
            height,
            aspect
        };
    }
    /** Default viewport setup */ _resizeViewport() {
        // TODO can we use canvas context to code this in a portable way?
        // @ts-expect-error Expose on canvasContext
        if (this.props.autoResizeViewport && this.device.gl) {
            // @ts-expect-error Expose canvasContext
            this.device.gl.viewport(0, 0, // @ts-expect-error Expose canvasContext
            this.device.gl.drawingBufferWidth, // @ts-expect-error Expose canvasContext
            this.device.gl.drawingBufferHeight);
        }
    }
    /**
     * Resize the render buffer of the canvas to match canvas client size
     * Optionally multiplying with devicePixel ratio
     */ _resizeCanvasDrawingBuffer() {
        if (this.props.autoResizeDrawingBuffer) {
            this.device?.canvasContext?.resize({
                useDevicePixels: this.props.useDevicePixels
            });
        }
    }
    _beginFrameTimers() {
        this.frameRate.timeEnd();
        this.frameRate.timeStart();
        // Check if timer for last frame has completed.
        // GPU timer results are never available in the same
        // frame they are captured.
        // if (
        //   this._gpuTimeQuery &&
        //   this._gpuTimeQuery.isResultAvailable() &&
        //   !this._gpuTimeQuery.isTimerDisjoint()
        // ) {
        //   this.stats.get('GPU Time').addTime(this._gpuTimeQuery.getTimerMilliseconds());
        // }
        // if (this._gpuTimeQuery) {
        //   // GPU time query start
        //   this._gpuTimeQuery.beginTimeElapsedQuery();
        // }
        this.cpuTime.timeStart();
    }
    _endFrameTimers() {
        this.cpuTime.timeEnd();
    // if (this._gpuTimeQuery) {
    //   // GPU time query end. Results will be available on next frame.
    //   this._gpuTimeQuery.end();
    // }
    }
    // Event handling
    _startEventHandling() {
        if (this.canvas) {
            this.canvas.addEventListener('mousemove', this._onMousemove.bind(this));
            this.canvas.addEventListener('mouseleave', this._onMouseleave.bind(this));
        }
    }
    _onMousemove(event) {
        if (event instanceof MouseEvent) {
            this._getAnimationProps()._mousePosition = [
                event.offsetX,
                event.offsetY
            ];
        }
    }
    _onMouseleave(event) {
        this._getAnimationProps()._mousePosition = null;
    }
} //# sourceMappingURL=animation-loop.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/utils/uid.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "uid": (()=>uid)
});
const uidCounters = {};
function uid(id = 'id') {
    uidCounters[id] = uidCounters[id] || 1;
    const count = uidCounters[id]++;
    return `${id}-${count}`;
} //# sourceMappingURL=uid.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/geometry/gpu-geometry.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "GPUGeometry": (()=>GPUGeometry),
    "getAttributeBuffersFromGeometry": (()=>getAttributeBuffersFromGeometry),
    "getIndexBufferFromGeometry": (()=>getIndexBufferFromGeometry),
    "makeGPUGeometry": (()=>makeGPUGeometry)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$buffer$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/core/dist/adapter/resources/buffer.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$gpu$2d$type$2d$utils$2f$vertex$2d$format$2d$from$2d$attribute$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/core/dist/gpu-type-utils/vertex-format-from-attribute.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$utils$2f$uid$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/engine/dist/utils/uid.js [client] (ecmascript)");
;
;
class GPUGeometry {
    id;
    userData = {};
    /** Determines how vertices are read from the 'vertex' attributes */ topology;
    bufferLayout = [];
    vertexCount;
    indices;
    attributes;
    constructor(props){
        this.id = props.id || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$utils$2f$uid$2e$js__$5b$client$5d$__$28$ecmascript$29$__["uid"])('geometry');
        this.topology = props.topology;
        this.indices = props.indices || null;
        this.attributes = props.attributes;
        this.vertexCount = props.vertexCount;
        this.bufferLayout = props.bufferLayout || [];
        if (this.indices) {
            if (!(this.indices.usage & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$buffer$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"].INDEX)) {
                throw new Error('Index buffer must have INDEX usage');
            }
        }
    }
    destroy() {
        this.indices?.destroy();
        for (const attribute of Object.values(this.attributes)){
            attribute.destroy();
        }
    }
    getVertexCount() {
        return this.vertexCount;
    }
    getAttributes() {
        return this.attributes;
    }
    getIndexes() {
        return this.indices || null;
    }
    _calculateVertexCount(positions) {
        // Assume that positions is a fully packed float32x3 buffer
        const vertexCount = positions.byteLength / 12;
        return vertexCount;
    }
}
function makeGPUGeometry(device, geometry) {
    if (geometry instanceof GPUGeometry) {
        return geometry;
    }
    const indices = getIndexBufferFromGeometry(device, geometry);
    const { attributes, bufferLayout } = getAttributeBuffersFromGeometry(device, geometry);
    return new GPUGeometry({
        topology: geometry.topology || 'triangle-list',
        bufferLayout,
        vertexCount: geometry.vertexCount,
        indices,
        attributes
    });
}
function getIndexBufferFromGeometry(device, geometry) {
    if (!geometry.indices) {
        return undefined;
    }
    const data = geometry.indices.value;
    return device.createBuffer({
        usage: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$buffer$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"].INDEX,
        data
    });
}
function getAttributeBuffersFromGeometry(device, geometry) {
    const bufferLayout = [];
    const attributes = {};
    for (const [attributeName, attribute] of Object.entries(geometry.attributes)){
        let name = attributeName;
        // TODO Map some GLTF attribute names (is this still needed?)
        switch(attributeName){
            case 'POSITION':
                name = 'positions';
                break;
            case 'NORMAL':
                name = 'normals';
                break;
            case 'TEXCOORD_0':
                name = 'texCoords';
                break;
            case 'COLOR_0':
                name = 'colors';
                break;
        }
        if (attribute) {
            attributes[name] = device.createBuffer({
                data: attribute.value,
                id: `${attributeName}-buffer`
            });
            const { value, size, normalized } = attribute;
            // @ts-expect-error
            bufferLayout.push({
                name,
                format: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$gpu$2d$type$2d$utils$2f$vertex$2d$format$2d$from$2d$attribute$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getVertexFormatFromAttribute"])(value, size, normalized)
            });
        }
    }
    const vertexCount = geometry._calculateVertexCount(geometry.attributes, geometry.indices);
    return {
        attributes,
        bufferLayout,
        vertexCount
    };
} //# sourceMappingURL=gpu-geometry.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/factories/pipeline-factory.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "PipelineFactory": (()=>PipelineFactory)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$render$2d$pipeline$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/core/dist/adapter/resources/render-pipeline.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$compute$2d$pipeline$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/core/dist/adapter/resources/compute-pipeline.js [client] (ecmascript)");
;
class PipelineFactory {
    static defaultProps = {
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$render$2d$pipeline$2e$js__$5b$client$5d$__$28$ecmascript$29$__["RenderPipeline"].defaultProps
    };
    /** Get the singleton default pipeline factory for the specified device */ static getDefaultPipelineFactory(device) {
        device._lumaData.defaultPipelineFactory = device._lumaData.defaultPipelineFactory || new PipelineFactory(device);
        return device._lumaData.defaultPipelineFactory;
    }
    device;
    destroyPolicy;
    _hashCounter = 0;
    _hashes = {};
    _renderPipelineCache = {};
    _computePipelineCache = {};
    constructor(device){
        this.device = device;
        this.destroyPolicy = device.props._factoryDestroyPolicy;
    }
    /** Return a RenderPipeline matching props. Reuses a similar pipeline if already created. */ createRenderPipeline(props) {
        const allProps = {
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$render$2d$pipeline$2e$js__$5b$client$5d$__$28$ecmascript$29$__["RenderPipeline"].defaultProps,
            ...props
        };
        const hash = this._hashRenderPipeline(allProps);
        if (!this._renderPipelineCache[hash]) {
            const pipeline = this.device.createRenderPipeline({
                ...allProps,
                id: allProps.id ? `${allProps.id}-cached` : undefined
            });
            pipeline.hash = hash;
            this._renderPipelineCache[hash] = {
                pipeline,
                useCount: 0
            };
        }
        this._renderPipelineCache[hash].useCount++;
        return this._renderPipelineCache[hash].pipeline;
    }
    createComputePipeline(props) {
        const allProps = {
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$compute$2d$pipeline$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ComputePipeline"].defaultProps,
            ...props
        };
        const hash = this._hashComputePipeline(allProps);
        if (!this._computePipelineCache[hash]) {
            const pipeline = this.device.createComputePipeline({
                ...allProps,
                id: allProps.id ? `${allProps.id}-cached` : undefined
            });
            pipeline.hash = hash;
            this._computePipelineCache[hash] = {
                pipeline,
                useCount: 0
            };
        }
        this._computePipelineCache[hash].useCount++;
        return this._computePipelineCache[hash].pipeline;
    }
    release(pipeline) {
        const hash = pipeline.hash;
        const cache = pipeline instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$compute$2d$pipeline$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ComputePipeline"] ? this._computePipelineCache : this._renderPipelineCache;
        cache[hash].useCount--;
        if (cache[hash].useCount === 0) {
            if (this.destroyPolicy === 'unused') {
                cache[hash].pipeline.destroy();
                delete cache[hash];
            }
        }
    }
    // PRIVATE
    _hashComputePipeline(props) {
        const shaderHash = this._getHash(props.shader.source);
        return `${shaderHash}`;
    }
    /** Calculate a hash based on all the inputs for a render pipeline */ _hashRenderPipeline(props) {
        const vsHash = props.vs ? this._getHash(props.vs.source) : 0;
        const fsHash = props.fs ? this._getHash(props.fs.source) : 0;
        // WebGL specific
        // const {varyings = [], bufferMode = {}} = props;
        // const varyingHashes = varyings.map((v) => this._getHash(v));
        const varyingHash = '-'; // `${varyingHashes.join('/')}B${bufferMode}`
        const bufferLayoutHash = this._getHash(JSON.stringify(props.bufferLayout));
        switch(this.device.type){
            case 'webgl':
                // WebGL is more dynamic
                return `${vsHash}/${fsHash}V${varyingHash}BL${bufferLayoutHash}`;
            default:
                // On WebGPU we need to rebuild the pipeline if topology, parameters or bufferLayout change
                const parameterHash = this._getHash(JSON.stringify(props.parameters));
                // TODO - Can json.stringify() generate different strings for equivalent objects if order of params is different?
                // create a deepHash() to deduplicate?
                return `${vsHash}/${fsHash}V${varyingHash}T${props.topology}P${parameterHash}BL${bufferLayoutHash}`;
        }
    }
    _getHash(key) {
        if (this._hashes[key] === undefined) {
            this._hashes[key] = this._hashCounter++;
        }
        return this._hashes[key];
    }
} //# sourceMappingURL=pipeline-factory.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/factories/shader-factory.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "ShaderFactory": (()=>ShaderFactory)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$shader$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/core/dist/adapter/resources/shader.js [client] (ecmascript)");
;
class ShaderFactory {
    static defaultProps = {
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$shader$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Shader"].defaultProps
    };
    /** Returns the default ShaderFactory for the given {@link Device}, creating one if necessary. */ static getDefaultShaderFactory(device) {
        device._lumaData.defaultShaderFactory ||= new ShaderFactory(device);
        return device._lumaData.defaultShaderFactory;
    }
    device;
    destroyPolicy;
    _cache = {};
    /** @internal */ constructor(device){
        this.device = device;
        this.destroyPolicy = device.props._factoryDestroyPolicy;
    }
    /** Requests a {@link Shader} from the cache, creating a new Shader only if necessary. */ createShader(props) {
        const key = this._hashShader(props);
        let cacheEntry = this._cache[key];
        if (!cacheEntry) {
            const shader = this.device.createShader({
                ...props,
                id: props.id ? `${props.id}-cached` : undefined
            });
            this._cache[key] = cacheEntry = {
                shader,
                useCount: 0
            };
        }
        cacheEntry.useCount++;
        return cacheEntry.shader;
    }
    /** Releases a previously-requested {@link Shader}, destroying it if no users remain. */ release(shader) {
        const key = this._hashShader(shader);
        const cacheEntry = this._cache[key];
        if (cacheEntry) {
            cacheEntry.useCount--;
            if (cacheEntry.useCount === 0) {
                if (this.destroyPolicy === 'unused') {
                    delete this._cache[key];
                    cacheEntry.shader.destroy();
                }
            }
        }
    }
    // PRIVATE
    _hashShader(value) {
        return `${value.stage}:${value.source}`;
    }
} //# sourceMappingURL=shader-factory.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/debug/debug-shader-layout.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/**
 * Extracts a table suitable for `console.table()` from a shader layout to assist in debugging.
 * @param layout shader layout
 * @param name app should provide the most meaningful name, usually the model or pipeline name / id.
 * @returns
 */ __turbopack_context__.s({
    "getDebugTableForShaderLayout": (()=>getDebugTableForShaderLayout)
});
function getDebugTableForShaderLayout(layout, name) {
    const table = {};
    const header = 'Values'; // '`Shader Layout for ${name}`;
    if (layout.attributes.length === 0 && !layout.varyings?.length) {
        return {
            'No attributes or varyings': {
                [header]: 'N/A'
            }
        };
    }
    for (const attributeDeclaration of layout.attributes){
        if (attributeDeclaration) {
            const glslDeclaration = `${attributeDeclaration.location} ${attributeDeclaration.name}: ${attributeDeclaration.type}`;
            table[`in ${glslDeclaration}`] = {
                [header]: attributeDeclaration.stepMode || 'vertex'
            };
        }
    }
    for (const varyingDeclaration of layout.varyings || []){
        const glslDeclaration = `${varyingDeclaration.location} ${varyingDeclaration.name}`;
        table[`out ${glslDeclaration}`] = {
            [header]: JSON.stringify(varyingDeclaration)
        };
    }
    return table;
} //# sourceMappingURL=debug-shader-layout.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/debug/debug-framebuffer.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// import {copyTextureToImage} from '../debug/copy-texture-to-image';
/** Only works with 1st device? */ __turbopack_context__.s({
    "debugFramebuffer": (()=>debugFramebuffer)
});
let canvas = null;
let ctx = null;
function debugFramebuffer(fbo, { id, minimap, opaque, top = '0', left = '0', rgbaScale = 1 }) {
    if (!canvas) {
        canvas = document.createElement('canvas');
        canvas.id = id;
        canvas.title = id;
        canvas.style.zIndex = '100';
        canvas.style.position = 'absolute';
        canvas.style.top = top; // ⚠️
        canvas.style.left = left; // ⚠️
        canvas.style.border = 'blue 5px solid';
        canvas.style.transform = 'scaleY(-1)';
        document.body.appendChild(canvas);
        ctx = canvas.getContext('2d');
    // targetImage = new Image();
    }
    // const canvasHeight = (minimap ? 2 : 1) * fbo.height;
    if (canvas.width !== fbo.width || canvas.height !== fbo.height) {
        canvas.width = fbo.width / 2;
        canvas.height = fbo.height / 2;
        canvas.style.width = '400px';
        canvas.style.height = '400px';
    }
    // const image = copyTextureToImage(fbo, {targetMaxHeight: 100, targetImage});
    // ctx.drawImage(image, 0, 0);
    const color = fbo.device.readPixelsToArrayWebGL(fbo);
    const imageData = ctx?.createImageData(fbo.width, fbo.height);
    if (imageData) {
        // Full map
        const offset = 0;
        // if (color.some((v) => v > 0)) {
        //   console.error('THERE IS NON-ZERO DATA IN THE FBO!');
        // }
        for(let i = 0; i < color.length; i += 4){
            imageData.data[offset + i + 0] = color[i + 0] * rgbaScale;
            imageData.data[offset + i + 1] = color[i + 1] * rgbaScale;
            imageData.data[offset + i + 2] = color[i + 2] * rgbaScale;
            imageData.data[offset + i + 3] = opaque ? 255 : color[i + 3] * rgbaScale;
        }
        ctx?.putImageData(imageData, 0, 0);
    }
} //# sourceMappingURL=debug-framebuffer.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/utils/deep-equal.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/**
 * Fast partial deep equal for prop.
 *
 * @param a Prop
 * @param b Prop to compare against `a`
 * @param depth Depth to which to recurse in nested Objects/Arrays. Use 0 (default) for shallow comparison, -1 for infinite depth
 */ /* eslint-disable complexity */ __turbopack_context__.s({
    "deepEqual": (()=>deepEqual)
});
function deepEqual(a, b, depth) {
    if (a === b) {
        return true;
    }
    if (!depth || !a || !b) {
        return false;
    }
    if (Array.isArray(a)) {
        if (!Array.isArray(b) || a.length !== b.length) {
            return false;
        }
        for(let i = 0; i < a.length; i++){
            if (!deepEqual(a[i], b[i], depth - 1)) {
                return false;
            }
        }
        return true;
    }
    if (Array.isArray(b)) {
        return false;
    }
    if (typeof a === 'object' && typeof b === 'object') {
        const aKeys = Object.keys(a);
        const bKeys = Object.keys(b);
        if (aKeys.length !== bKeys.length) {
            return false;
        }
        for (const key of aKeys){
            if (!b.hasOwnProperty(key)) {
                return false;
            }
            if (!deepEqual(a[key], b[key], depth - 1)) {
                return false;
            }
        }
        return true;
    }
    return false;
} //# sourceMappingURL=deep-equal.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/model/split-uniforms-and-bindings.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "isUniformValue": (()=>isUniformValue),
    "splitUniformsAndBindings": (()=>splitUniformsAndBindings)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$types$2f$dist$2f$is$2d$array$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/types/dist/is-array.js [client] (ecmascript)");
;
function isUniformValue(value) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$types$2f$dist$2f$is$2d$array$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isNumericArray"])(value) || typeof value === 'number' || typeof value === 'boolean';
}
function splitUniformsAndBindings(uniforms) {
    const result = {
        bindings: {},
        uniforms: {}
    };
    Object.keys(uniforms).forEach((name)=>{
        const uniform = uniforms[name];
        if (isUniformValue(uniform)) {
            result.uniforms[name] = uniform;
        } else {
            result.bindings[name] = uniform;
        }
    });
    return result;
} //# sourceMappingURL=split-uniforms-and-bindings.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/shader-inputs.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "ShaderInputs": (()=>ShaderInputs)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/core/dist/utils/log.js [client] (ecmascript)");
// import type {ShaderUniformType, UniformValue, UniformFormat, UniformInfoDevice, Texture, Sampler} from '@luma.gl/core';
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$module$2f$shader$2d$module$2d$dependencies$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-module/shader-module-dependencies.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$model$2f$split$2d$uniforms$2d$and$2d$bindings$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/engine/dist/model/split-uniforms-and-bindings.js [client] (ecmascript)");
;
;
;
class ShaderInputs {
    options = {
        disableWarnings: false
    };
    /**
     * The map of modules
     * @todo should should this include the resolved dependencies?
     */ // @ts-ignore Fix typings
    modules;
    /** Stores the uniform values for each module */ moduleUniforms;
    /** Stores the uniform bindings for each module  */ moduleBindings;
    /** Tracks if uniforms have changed */ // moduleUniformsChanged: Record<keyof ShaderPropsT, false | string>;
    /**
     * Create a new UniformStore instance
     * @param modules
     */ constructor(// @ts-ignore Fix typings
    modules, options){
        Object.assign(this.options, options);
        // Extract modules with dependencies
        const resolvedModules = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$module$2f$shader$2d$module$2d$dependencies$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getShaderModuleDependencies"])(Object.values(modules).filter((module)=>module.dependencies));
        for (const resolvedModule of resolvedModules){
            // @ts-ignore
            modules[resolvedModule.name] = resolvedModule;
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].log(1, 'Creating ShaderInputs with modules', Object.keys(modules))();
        // Store the module definitions and create storage for uniform values and binding values, per module
        // @ts-ignore Fix typings
        this.modules = modules;
        this.moduleUniforms = {};
        this.moduleBindings = {};
        // Initialize the modules
        for (const [name, module] of Object.entries(modules)){
            this._addModule(module);
            if (module.name && name !== module.name && !this.options.disableWarnings) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].warn(`Module name: ${name} vs ${module.name}`)();
            }
        }
    }
    /** Destroy */ destroy() {}
    /**
     * Set module props
     */ setProps(props) {
        for (const name of Object.keys(props)){
            const moduleName = name;
            const moduleProps = props[moduleName] || {};
            const module = this.modules[moduleName];
            if (!module) {
                // Ignore props for unregistered modules
                if (!this.options.disableWarnings) {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].warn(`Module ${name} not found`)();
                }
                continue; // eslint-disable-line no-continue
            }
            const oldUniforms = this.moduleUniforms[moduleName];
            const oldBindings = this.moduleBindings[moduleName];
            const uniformsAndBindings = module.getUniforms?.(moduleProps, oldUniforms) || moduleProps;
            const { uniforms, bindings } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$model$2f$split$2d$uniforms$2d$and$2d$bindings$2e$js__$5b$client$5d$__$28$ecmascript$29$__["splitUniformsAndBindings"])(uniformsAndBindings);
            this.moduleUniforms[moduleName] = {
                ...oldUniforms,
                ...uniforms
            };
            this.moduleBindings[moduleName] = {
                ...oldBindings,
                ...bindings
            };
        // this.moduleUniformsChanged ||= moduleName;
        // console.log(`setProps(${String(moduleName)}`, moduleName, this.moduleUniforms[moduleName])
        }
    }
    /**
     * Return the map of modules
     * @todo should should this include the resolved dependencies?
     */ getModules() {
        return Object.values(this.modules);
    }
    /** Get all uniform values for all modules */ getUniformValues() {
        return this.moduleUniforms;
    }
    /** Merges all bindings for the shader (from the various modules) */ getBindingValues() {
        const bindings = {};
        for (const moduleBindings of Object.values(this.moduleBindings)){
            Object.assign(bindings, moduleBindings);
        }
        return bindings;
    }
    // INTERNAL
    /** Return a debug table that can be used for console.table() or log.table() */ getDebugTable() {
        const table = {};
        for (const [moduleName, module] of Object.entries(this.moduleUniforms)){
            for (const [key, value] of Object.entries(module)){
                table[`${moduleName}.${key}`] = {
                    type: this.modules[moduleName].uniformTypes?.[key],
                    value: String(value)
                };
            }
        }
        return table;
    }
    _addModule(module) {
        const moduleName = module.name;
        // Get default uniforms from module
        this.moduleUniforms[moduleName] = module.defaultUniforms || {};
        this.moduleBindings[moduleName] = {};
    }
} //# sourceMappingURL=shader-inputs.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/application-utils/load-file.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "loadImage": (()=>loadImage),
    "loadImageBitmap": (()=>loadImageBitmap),
    "setPathPrefix": (()=>setPathPrefix)
});
let pathPrefix = '';
function setPathPrefix(prefix) {
    pathPrefix = prefix;
}
async function loadImageBitmap(url, opts) {
    const image = new Image();
    image.crossOrigin = opts?.crossOrigin || 'anonymous';
    image.src = url.startsWith('http') ? url : pathPrefix + url;
    await image.decode();
    return opts ? await createImageBitmap(image, opts) : await createImageBitmap(image);
}
async function loadImage(url, opts) {
    return await new Promise((resolve, reject)=>{
        try {
            const image = new Image();
            image.onload = ()=>resolve(image);
            image.onerror = ()=>reject(new Error(`Could not load image ${url}.`));
            image.crossOrigin = opts?.crossOrigin || 'anonymous';
            image.src = url.startsWith('http') ? url : pathPrefix + url;
        } catch (error) {
            reject(error);
        }
    });
} //# sourceMappingURL=load-file.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/async-texture/async-texture.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl, MIT license
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "AsyncTexture": (()=>AsyncTexture)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$application$2d$utils$2f$load$2d$file$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/engine/dist/application-utils/load-file.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$utils$2f$uid$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/engine/dist/utils/uid.js [client] (ecmascript)");
;
;
class AsyncTexture {
    device;
    id;
    // TODO - should we type these as possibly `null`? It will make usage harder?
    // @ts-expect-error
    texture;
    // @ts-expect-error
    sampler;
    // @ts-expect-error
    view;
    ready;
    isReady = false;
    destroyed = false;
    resolveReady = ()=>{};
    rejectReady = ()=>{};
    get [Symbol.toStringTag]() {
        return 'AsyncTexture';
    }
    toString() {
        return `AsyncTexture:"${this.id}"(${this.isReady ? 'ready' : 'loading'})`;
    }
    constructor(device, props){
        this.device = device;
        this.id = props.id || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$utils$2f$uid$2e$js__$5b$client$5d$__$28$ecmascript$29$__["uid"])('async-texture');
        // this.id = typeof props?.data === 'string' ? props.data.slice(-20) : uid('async-texture');
        // Signature: new AsyncTexture(device, {data: url})
        if (typeof props?.data === 'string' && props.dimension === '2d') {
            props = {
                ...props,
                data: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$application$2d$utils$2f$load$2d$file$2e$js__$5b$client$5d$__$28$ecmascript$29$__["loadImageBitmap"])(props.data)
            };
        }
        this.ready = new Promise((resolve, reject)=>{
            this.resolveReady = ()=>{
                this.isReady = true;
                resolve();
            };
            this.rejectReady = reject;
        });
        this.initAsync(props);
    }
    async initAsync(props) {
        let resolveReady;
        let rejectReady;
        const asyncData = props.data;
        const data = await awaitAllPromises(asyncData).then(resolveReady, rejectReady);
        // Check that we haven't been destroyed while waiting for texture data to load
        if (this.destroyed) {
            return;
        }
        // Now we can actually create the texture
        // @ts-expect-error Discriminated union
        const syncProps = {
            ...props,
            data
        };
        this.texture = this.device.createTexture(syncProps);
        this.sampler = this.texture.sampler;
        this.view = this.texture.view;
        this.isReady = true;
    }
    destroy() {
        if (this.texture) {
            this.texture.destroy();
            // @ts-expect-error
            this.texture = null;
        }
        this.destroyed = true;
    }
    /**
     * Textures are immutable and cannot be resized after creation,
     * but we can create a similar texture with the same parameters but a new size.
     * @note Does not copy contents of the texture
     * @todo Abort pending promise and create a texture with the new size?
     */ resize(size) {
        if (!this.isReady) {
            throw new Error('Cannot resize texture before it is ready');
        }
        if (size.width === this.texture.width && size.height === this.texture.height) {
            return false;
        }
        if (this.texture) {
            const texture = this.texture;
            this.texture = texture.clone(size);
            texture.destroy();
        }
        return true;
    }
}
// HELPERS
/** Resolve all promises in a nested data structure */ async function awaitAllPromises(x) {
    x = await x;
    if (Array.isArray(x)) {
        return await Promise.all(x.map(awaitAllPromises));
    }
    if (x && typeof x === 'object' && x.constructor === Object) {
        const object = x;
        const values = await Promise.all(Object.values(object));
        const keys = Object.keys(object);
        const resolvedObject = {};
        for(let i = 0; i < keys.length; i++){
            resolvedObject[keys[i]] = values[i];
        }
        return resolvedObject;
    }
    return x;
} //# sourceMappingURL=async-texture.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/model/model.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "Model": (()=>Model),
    "getPlatformInfo": (()=>getPlatformInfo)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$buffer$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/core/dist/adapter/resources/buffer.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$texture$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/core/dist/adapter/resources/texture.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$texture$2d$view$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/core/dist/adapter/resources/texture-view.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$sampler$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/core/dist/adapter/resources/sampler.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$render$2d$pipeline$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/core/dist/adapter/resources/render-pipeline.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$portable$2f$uniform$2d$store$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/core/dist/portable/uniform-store.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/core/dist/utils/log.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$gpu$2d$type$2d$utils$2f$vertex$2d$format$2d$from$2d$attribute$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/core/dist/gpu-type-utils/vertex-format-from-attribute.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2d$utils$2f$get$2d$attribute$2d$from$2d$layouts$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/core/dist/adapter-utils/get-attribute-from-layouts.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2d$utils$2f$buffer$2d$layout$2d$helper$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__BufferLayoutHelper__as__$5f$BufferLayoutHelper$3e$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/core/dist/adapter-utils/buffer-layout-helper.js [client] (ecmascript) <export BufferLayoutHelper as _BufferLayoutHelper>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembler$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-assembler.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$wgsl$2f$get$2d$shader$2d$layout$2d$wgsl$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/shadertools/dist/lib/wgsl/get-shader-layout-wgsl.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$geometry$2f$gpu$2d$geometry$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/engine/dist/geometry/gpu-geometry.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$factories$2f$pipeline$2d$factory$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/engine/dist/factories/pipeline-factory.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$factories$2f$shader$2d$factory$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/engine/dist/factories/shader-factory.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$debug$2f$debug$2d$shader$2d$layout$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/engine/dist/debug/debug-shader-layout.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$debug$2f$debug$2d$framebuffer$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/engine/dist/debug/debug-framebuffer.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$utils$2f$deep$2d$equal$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/engine/dist/utils/deep-equal.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$utils$2f$uid$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/engine/dist/utils/uid.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$shader$2d$inputs$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/engine/dist/shader-inputs.js [client] (ecmascript)");
// import type {AsyncTextureProps} from '../async-texture/async-texture';
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$async$2d$texture$2f$async$2d$texture$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/engine/dist/async-texture/async-texture.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$model$2f$split$2d$uniforms$2d$and$2d$bindings$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/engine/dist/model/split-uniforms-and-bindings.js [client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
const LOG_DRAW_PRIORITY = 2;
const LOG_DRAW_TIMEOUT = 10000;
class Model {
    static defaultProps = {
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$render$2d$pipeline$2e$js__$5b$client$5d$__$28$ecmascript$29$__["RenderPipeline"].defaultProps,
        source: undefined,
        vs: null,
        fs: null,
        id: 'unnamed',
        handle: undefined,
        userData: {},
        defines: {},
        modules: [],
        moduleSettings: undefined,
        geometry: null,
        indexBuffer: null,
        attributes: {},
        constantAttributes: {},
        varyings: [],
        isInstanced: undefined,
        instanceCount: 0,
        vertexCount: 0,
        shaderInputs: undefined,
        pipelineFactory: undefined,
        shaderFactory: undefined,
        transformFeedback: undefined,
        shaderAssembler: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembler$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ShaderAssembler"].getDefaultShaderAssembler(),
        debugShaders: undefined,
        disableWarnings: undefined
    };
    device;
    id;
    // @ts-expect-error assigned in function called from constructor
    source;
    // @ts-expect-error assigned in function called from constructor
    vs;
    // @ts-expect-error assigned in function called from constructor
    fs;
    pipelineFactory;
    shaderFactory;
    userData = {};
    // Fixed properties (change can trigger pipeline rebuild)
    /** The render pipeline GPU parameters, depth testing etc */ parameters;
    /** The primitive topology */ topology;
    /** Buffer layout */ bufferLayout;
    // Dynamic properties
    /** Use instanced rendering */ isInstanced = undefined;
    /** instance count. `undefined` means not instanced */ instanceCount = 0;
    /** Vertex count */ vertexCount;
    /** Index buffer */ indexBuffer = null;
    /** Buffer-valued attributes */ bufferAttributes = {};
    /** Constant-valued attributes */ constantAttributes = {};
    /** Bindings (textures, samplers, uniform buffers) */ bindings = {};
    /** Sets uniforms @deprecated Use uniform buffers and setBindings() for portability*/ uniforms = {};
    /**
     * VertexArray
     * @note not implemented: if bufferLayout is updated, vertex array has to be rebuilt!
     * @todo - allow application to define multiple vertex arrays?
     * */ vertexArray;
    /** TransformFeedback, WebGL 2 only. */ transformFeedback = null;
    /** The underlying GPU "program". @note May be recreated if parameters change */ pipeline;
    /** ShaderInputs instance */ // @ts-expect-error Assigned in function called by constructor
    shaderInputs;
    // @ts-expect-error Assigned in function called by constructor
    _uniformStore;
    _attributeInfos = {};
    _gpuGeometry = null;
    _getModuleUniforms;
    props;
    _pipelineNeedsUpdate = 'newly created';
    _needsRedraw = 'initializing';
    _destroyed = false;
    /** "Time" of last draw. Monotonically increasing timestamp */ _lastDrawTimestamp = -1;
    get [Symbol.toStringTag]() {
        return 'Model';
    }
    toString() {
        return `Model(${this.id})`;
    }
    constructor(device, props){
        this.props = {
            ...Model.defaultProps,
            ...props
        };
        props = this.props;
        this.id = props.id || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$utils$2f$uid$2e$js__$5b$client$5d$__$28$ecmascript$29$__["uid"])('model');
        this.device = device;
        Object.assign(this.userData, props.userData);
        // Setup shader module inputs
        const moduleMap = Object.fromEntries(this.props.modules?.map((module)=>[
                module.name,
                module
            ]) || []);
        const shaderInputs = props.shaderInputs || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$shader$2d$inputs$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ShaderInputs"](moduleMap, {
            disableWarnings: this.props.disableWarnings
        });
        // @ts-ignore
        this.setShaderInputs(shaderInputs);
        // Setup shader assembler
        const platformInfo = getPlatformInfo(device);
        // Extract modules from shader inputs if not supplied
        const modules = // @ts-ignore shaderInputs is assigned in setShaderInputs above.
        (this.props.modules?.length > 0 ? this.props.modules : this.shaderInputs?.getModules()) || [];
        const isWebGPU = this.device.type === 'webgpu';
        // WebGPU
        // TODO - hack to support unified WGSL shader
        // TODO - this is wrong, compile a single shader
        if (isWebGPU && this.props.source) {
            // WGSL
            const { source, getUniforms } = this.props.shaderAssembler.assembleWGSLShader({
                platformInfo,
                ...this.props,
                modules
            });
            this.source = source;
            // @ts-expect-error
            this._getModuleUniforms = getUniforms;
            // Extract shader layout after modules have been added to WGSL source, to include any bindings added by modules
            this.props.shaderLayout ||= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$wgsl$2f$get$2d$shader$2d$layout$2d$wgsl$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getShaderLayoutFromWGSL"])(this.source);
        } else {
            // GLSL
            const { vs, fs, getUniforms } = this.props.shaderAssembler.assembleGLSLShaderPair({
                platformInfo,
                ...this.props,
                modules
            });
            this.vs = vs;
            this.fs = fs;
            // @ts-expect-error
            this._getModuleUniforms = getUniforms;
        }
        this.vertexCount = this.props.vertexCount;
        this.instanceCount = this.props.instanceCount;
        this.topology = this.props.topology;
        this.bufferLayout = this.props.bufferLayout;
        this.parameters = this.props.parameters;
        // Geometry, if provided, sets topology and vertex cound
        if (props.geometry) {
            this.setGeometry(props.geometry);
        }
        this.pipelineFactory = props.pipelineFactory || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$factories$2f$pipeline$2d$factory$2e$js__$5b$client$5d$__$28$ecmascript$29$__["PipelineFactory"].getDefaultPipelineFactory(this.device);
        this.shaderFactory = props.shaderFactory || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$factories$2f$shader$2d$factory$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ShaderFactory"].getDefaultShaderFactory(this.device);
        // Create the pipeline
        // @note order is important
        this.pipeline = this._updatePipeline();
        this.vertexArray = device.createVertexArray({
            renderPipeline: this.pipeline
        });
        // Now we can apply geometry attributes
        if (this._gpuGeometry) {
            this._setGeometryAttributes(this._gpuGeometry);
        }
        // Apply any dynamic settings that will not trigger pipeline change
        if ('isInstanced' in props) {
            this.isInstanced = props.isInstanced;
        }
        if (props.instanceCount) {
            this.setInstanceCount(props.instanceCount);
        }
        if (props.vertexCount) {
            this.setVertexCount(props.vertexCount);
        }
        if (props.indexBuffer) {
            this.setIndexBuffer(props.indexBuffer);
        }
        if (props.attributes) {
            this.setAttributes(props.attributes);
        }
        if (props.constantAttributes) {
            this.setConstantAttributes(props.constantAttributes);
        }
        if (props.bindings) {
            this.setBindings(props.bindings);
        }
        if (props.uniforms) {
            this.setUniformsWebGL(props.uniforms);
        }
        if (props.moduleSettings) {
            // log.warn('Model.props.moduleSettings is deprecated. Use Model.shaderInputs.setProps()')();
            this.updateModuleSettingsWebGL(props.moduleSettings);
        }
        if (props.transformFeedback) {
            this.transformFeedback = props.transformFeedback;
        }
        // Catch any access to non-standard props
        Object.seal(this);
    }
    destroy() {
        if (this._destroyed) return;
        this.pipelineFactory.release(this.pipeline);
        this.shaderFactory.release(this.pipeline.vs);
        if (this.pipeline.fs) {
            this.shaderFactory.release(this.pipeline.fs);
        }
        this._uniformStore.destroy();
        // TODO - mark resource as managed and destroyIfManaged() ?
        this._gpuGeometry?.destroy();
        this._destroyed = true;
    }
    // Draw call
    /** Query redraw status. Clears the status. */ needsRedraw() {
        // Catch any writes to already bound resources
        if (this._getBindingsUpdateTimestamp() > this._lastDrawTimestamp) {
            this.setNeedsRedraw('contents of bound textures or buffers updated');
        }
        const needsRedraw = this._needsRedraw;
        this._needsRedraw = false;
        return needsRedraw;
    }
    /** Mark the model as needing a redraw */ setNeedsRedraw(reason) {
        this._needsRedraw ||= reason;
    }
    predraw() {
        // Update uniform buffers if needed
        this.updateShaderInputs();
        // Check if the pipeline is invalidated
        this.pipeline = this._updatePipeline();
    }
    draw(renderPass) {
        const loadingBinding = this._areBindingsLoading();
        if (loadingBinding) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].info(LOG_DRAW_PRIORITY, `>>> DRAWING ABORTED ${this.id}: ${loadingBinding} not loaded`)();
            return false;
        }
        try {
            renderPass.pushDebugGroup(`${this}.predraw(${renderPass})`);
            this.predraw();
        } finally{
            renderPass.popDebugGroup();
        }
        let drawSuccess;
        try {
            renderPass.pushDebugGroup(`${this}.draw(${renderPass})`);
            this._logDrawCallStart();
            // Update the pipeline if invalidated
            // TODO - inside RenderPass is likely the worst place to do this from performance perspective.
            // Application can call Model.predraw() to avoid this.
            this.pipeline = this._updatePipeline();
            // Set pipeline state, we may be sharing a pipeline so we need to set all state on every draw
            // Any caching needs to be done inside the pipeline functions
            // TODO this is a busy initialized check for all bindings every frame
            const syncBindings = this._getBindings();
            this.pipeline.setBindings(syncBindings, {
                disableWarnings: this.props.disableWarnings
            });
            if (!isObjectEmpty(this.uniforms)) {
                this.pipeline.setUniformsWebGL(this.uniforms);
            }
            const { indexBuffer } = this.vertexArray;
            const indexCount = indexBuffer ? indexBuffer.byteLength / (indexBuffer.indexType === 'uint32' ? 4 : 2) : undefined;
            drawSuccess = this.pipeline.draw({
                renderPass,
                vertexArray: this.vertexArray,
                isInstanced: this.isInstanced,
                vertexCount: this.vertexCount,
                instanceCount: this.instanceCount,
                indexCount,
                transformFeedback: this.transformFeedback || undefined,
                // WebGL shares underlying cached pipelines even for models that have different parameters and topology,
                // so we must provide our unique parameters to each draw
                // (In WebGPU most parameters are encoded in the pipeline and cannot be changed per draw call)
                parameters: this.parameters,
                topology: this.topology
            });
        } finally{
            renderPass.popDebugGroup();
            this._logDrawCallEnd();
        }
        this._logFramebuffer(renderPass);
        // Update needsRedraw flag
        if (drawSuccess) {
            this._lastDrawTimestamp = this.device.timestamp;
            this._needsRedraw = false;
        } else {
            this._needsRedraw = 'waiting for resource initialization';
        }
        return drawSuccess;
    }
    // Update fixed fields (can trigger pipeline rebuild)
    /**
     * Updates the optional geometry
     * Geometry, set topology and bufferLayout
     * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU
     */ setGeometry(geometry) {
        this._gpuGeometry?.destroy();
        const gpuGeometry = geometry && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$geometry$2f$gpu$2d$geometry$2e$js__$5b$client$5d$__$28$ecmascript$29$__["makeGPUGeometry"])(this.device, geometry);
        if (gpuGeometry) {
            this.setTopology(gpuGeometry.topology || 'triangle-list');
            const bufferLayoutHelper = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2d$utils$2f$buffer$2d$layout$2d$helper$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__BufferLayoutHelper__as__$5f$BufferLayoutHelper$3e$__["_BufferLayoutHelper"](this.bufferLayout);
            this.bufferLayout = bufferLayoutHelper.mergeBufferLayouts(gpuGeometry.bufferLayout, this.bufferLayout);
            if (this.vertexArray) {
                this._setGeometryAttributes(gpuGeometry);
            }
        }
        this._gpuGeometry = gpuGeometry;
    }
    /**
     * Updates the primitive topology ('triangle-list', 'triangle-strip' etc).
     * @note Triggers a pipeline rebuild / pipeline cache fetch on WebGPU
     */ setTopology(topology) {
        if (topology !== this.topology) {
            this.topology = topology;
            this._setPipelineNeedsUpdate('topology');
        }
    }
    /**
     * Updates the buffer layout.
     * @note Triggers a pipeline rebuild / pipeline cache fetch
     */ setBufferLayout(bufferLayout) {
        const bufferLayoutHelper = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2d$utils$2f$buffer$2d$layout$2d$helper$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__BufferLayoutHelper__as__$5f$BufferLayoutHelper$3e$__["_BufferLayoutHelper"](this.bufferLayout);
        this.bufferLayout = this._gpuGeometry ? bufferLayoutHelper.mergeBufferLayouts(bufferLayout, this._gpuGeometry.bufferLayout) : bufferLayout;
        this._setPipelineNeedsUpdate('bufferLayout');
        // Recreate the pipeline
        this.pipeline = this._updatePipeline();
        // vertex array needs to be updated if we update buffer layout,
        // but not if we update parameters
        this.vertexArray = this.device.createVertexArray({
            renderPipeline: this.pipeline
        });
        // Reapply geometry attributes to the new vertex array
        if (this._gpuGeometry) {
            this._setGeometryAttributes(this._gpuGeometry);
        }
    }
    /**
     * Set GPU parameters.
     * @note Can trigger a pipeline rebuild / pipeline cache fetch.
     * @param parameters
     */ setParameters(parameters) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$utils$2f$deep$2d$equal$2e$js__$5b$client$5d$__$28$ecmascript$29$__["deepEqual"])(parameters, this.parameters, 2)) {
            this.parameters = parameters;
            this._setPipelineNeedsUpdate('parameters');
        }
    }
    // Update dynamic fields
    /**
     * Updates the instance count (used in draw calls)
     * @note Any attributes with stepMode=instance need to be at least this big
     */ setInstanceCount(instanceCount) {
        this.instanceCount = instanceCount;
        // luma.gl examples don't set props.isInstanced and rely on auto-detection
        // but deck.gl sets instanceCount even for models that are not instanced.
        if (this.isInstanced === undefined && instanceCount > 0) {
            this.isInstanced = true;
        }
        this.setNeedsRedraw('instanceCount');
    }
    /**
     * Updates the vertex count (used in draw calls)
     * @note Any attributes with stepMode=vertex need to be at least this big
     */ setVertexCount(vertexCount) {
        this.vertexCount = vertexCount;
        this.setNeedsRedraw('vertexCount');
    }
    /** Set the shader inputs */ setShaderInputs(shaderInputs) {
        this.shaderInputs = shaderInputs;
        this._uniformStore = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$portable$2f$uniform$2d$store$2e$js__$5b$client$5d$__$28$ecmascript$29$__["UniformStore"](this.shaderInputs.modules);
        // Create uniform buffer bindings for all modules that actually have uniforms
        for (const [moduleName, module] of Object.entries(this.shaderInputs.modules)){
            if (shaderModuleHasUniforms(module)) {
                const uniformBuffer = this._uniformStore.getManagedUniformBuffer(this.device, moduleName);
                this.bindings[`${moduleName}Uniforms`] = uniformBuffer;
            }
        }
        this.setNeedsRedraw('shaderInputs');
    }
    /** Update uniform buffers from the model's shader inputs */ updateShaderInputs() {
        this._uniformStore.setUniforms(this.shaderInputs.getUniformValues());
        this.setBindings(this.shaderInputs.getBindingValues());
        // TODO - this is already tracked through buffer/texture update times?
        this.setNeedsRedraw('shaderInputs');
    }
    /**
     * Sets bindings (textures, samplers, uniform buffers)
     */ setBindings(bindings) {
        Object.assign(this.bindings, bindings);
        this.setNeedsRedraw('bindings');
    }
    /**
     * Updates optional transform feedback. WebGL only.
     */ setTransformFeedback(transformFeedback) {
        this.transformFeedback = transformFeedback;
        this.setNeedsRedraw('transformFeedback');
    }
    /**
     * Sets the index buffer
     * @todo - how to unset it if we change geometry?
     */ setIndexBuffer(indexBuffer) {
        this.vertexArray.setIndexBuffer(indexBuffer);
        this.setNeedsRedraw('indexBuffer');
    }
    /**
     * Sets attributes (buffers)
     * @note Overrides any attributes previously set with the same name
     */ setAttributes(buffers, options) {
        const disableWarnings = options?.disableWarnings ?? this.props.disableWarnings;
        if (buffers.indices) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].warn(`Model:${this.id} setAttributes() - indexBuffer should be set using setIndexBuffer()`)();
        }
        const bufferLayoutHelper = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2d$utils$2f$buffer$2d$layout$2d$helper$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__BufferLayoutHelper__as__$5f$BufferLayoutHelper$3e$__["_BufferLayoutHelper"](this.bufferLayout);
        // Check if all buffers have a layout
        for (const [bufferName, buffer] of Object.entries(buffers)){
            const bufferLayout = bufferLayoutHelper.getBufferLayout(bufferName);
            if (!bufferLayout) {
                if (!disableWarnings) {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].warn(`Model(${this.id}): Missing layout for buffer "${bufferName}".`)();
                }
                continue; // eslint-disable-line no-continue
            }
            // For an interleaved attribute we may need to set multiple attributes
            const attributeNames = bufferLayoutHelper.getAttributeNamesForBuffer(bufferLayout);
            let set = false;
            for (const attributeName of attributeNames){
                const attributeInfo = this._attributeInfos[attributeName];
                if (attributeInfo) {
                    this.vertexArray.setBuffer(attributeInfo.location, buffer);
                    set = true;
                }
            }
            if (!set && !disableWarnings) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].warn(`Model(${this.id}): Ignoring buffer "${buffer.id}" for unknown attribute "${bufferName}"`)();
            }
        }
        this.setNeedsRedraw('attributes');
    }
    /**
     * Sets constant attributes
     * @note Overrides any attributes previously set with the same name
     * Constant attributes are only supported in WebGL, not in WebGPU
     * Any attribute that is disabled in the current vertex array object
     * is read from the context's global constant value for that attribute location.
     * @param constantAttributes
     */ setConstantAttributes(attributes, options) {
        for (const [attributeName, value] of Object.entries(attributes)){
            const attributeInfo = this._attributeInfos[attributeName];
            if (attributeInfo) {
                this.vertexArray.setConstantWebGL(attributeInfo.location, value);
            } else if (!(options?.disableWarnings ?? this.props.disableWarnings)) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].warn(`Model "${this.id}: Ignoring constant supplied for unknown attribute "${attributeName}"`)();
            }
        }
        this.setNeedsRedraw('constants');
    }
    // DEPRECATED METHODS
    /**
     * Sets individual uniforms
     * @deprecated WebGL only, use uniform buffers for portability
     * @param uniforms
     */ setUniforms(uniforms) {
        this.setUniformsWebGL(uniforms);
    }
    /**
     * Sets individual uniforms
     * @deprecated WebGL only, use uniform buffers for portability
     * @param uniforms
     */ setUniformsWebGL(uniforms) {
        if (!isObjectEmpty(uniforms)) {
            this.pipeline.setUniformsWebGL(uniforms);
            Object.assign(this.uniforms, uniforms);
        }
        this.setNeedsRedraw('uniforms');
    }
    /**
     * @deprecated Updates shader module settings (which results in uniforms being set)
     */ updateModuleSettingsWebGL(props) {
        // log.warn('Model.updateModuleSettings is deprecated. Use Model.shaderInputs.setProps()')();
        const { bindings, uniforms } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$model$2f$split$2d$uniforms$2d$and$2d$bindings$2e$js__$5b$client$5d$__$28$ecmascript$29$__["splitUniformsAndBindings"])(this._getModuleUniforms(props));
        Object.assign(this.bindings, bindings);
        Object.assign(this.uniforms, uniforms);
        this.setNeedsRedraw('moduleSettings');
    }
    // Internal methods
    /** Check that bindings are loaded. Returns id of first binding that is still loading. */ _areBindingsLoading() {
        for (const binding of Object.values(this.bindings)){
            if (binding instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$async$2d$texture$2f$async$2d$texture$2e$js__$5b$client$5d$__$28$ecmascript$29$__["AsyncTexture"] && !binding.isReady) {
                return binding.id;
            }
        }
        return false;
    }
    /** Extracts texture view from loaded async textures. Returns null if any textures have not yet been loaded. */ _getBindings() {
        const validBindings = {};
        for (const [name, binding] of Object.entries(this.bindings)){
            if (binding instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$async$2d$texture$2f$async$2d$texture$2e$js__$5b$client$5d$__$28$ecmascript$29$__["AsyncTexture"]) {
                // Check that async textures are loaded
                if (binding.isReady) {
                    validBindings[name] = binding.texture;
                }
            } else {
                validBindings[name] = binding;
            }
        }
        return validBindings;
    }
    /** Get the timestamp of the latest updated bound GPU memory resource (buffer/texture). */ _getBindingsUpdateTimestamp() {
        let timestamp = 0;
        for (const binding of Object.values(this.bindings)){
            if (binding instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$texture$2d$view$2e$js__$5b$client$5d$__$28$ecmascript$29$__["TextureView"]) {
                timestamp = Math.max(timestamp, binding.texture.updateTimestamp);
            } else if (binding instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$buffer$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"] || binding instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$texture$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Texture"]) {
                timestamp = Math.max(timestamp, binding.updateTimestamp);
            } else if (binding instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$async$2d$texture$2f$async$2d$texture$2e$js__$5b$client$5d$__$28$ecmascript$29$__["AsyncTexture"]) {
                timestamp = binding.texture ? Math.max(timestamp, binding.texture.updateTimestamp) : Infinity;
            } else if (!(binding instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$sampler$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Sampler"])) {
                timestamp = Math.max(timestamp, binding.buffer.updateTimestamp);
            }
        }
        return timestamp;
    }
    /**
     * Updates the optional geometry attributes
     * Geometry, sets several attributes, indexBuffer, and also vertex count
     * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU
     */ _setGeometryAttributes(gpuGeometry) {
        // Filter geometry attribute so that we don't issue warnings for unused attributes
        const attributes = {
            ...gpuGeometry.attributes
        };
        for (const [attributeName] of Object.entries(attributes)){
            if (!this.pipeline.shaderLayout.attributes.find((layout)=>layout.name === attributeName) && attributeName !== 'positions') {
                delete attributes[attributeName];
            }
        }
        // TODO - delete previous geometry?
        this.vertexCount = gpuGeometry.vertexCount;
        this.setIndexBuffer(gpuGeometry.indices || null);
        this.setAttributes(gpuGeometry.attributes, {
            disableWarnings: true
        });
        this.setAttributes(attributes, {
            disableWarnings: this.props.disableWarnings
        });
        this.setNeedsRedraw('geometry attributes');
    }
    /** Mark pipeline as needing update */ _setPipelineNeedsUpdate(reason) {
        this._pipelineNeedsUpdate ||= reason;
        this.setNeedsRedraw(reason);
    }
    /** Update pipeline if needed */ _updatePipeline() {
        if (this._pipelineNeedsUpdate) {
            let prevShaderVs = null;
            let prevShaderFs = null;
            if (this.pipeline) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].log(1, `Model ${this.id}: Recreating pipeline because "${this._pipelineNeedsUpdate}".`)();
                prevShaderVs = this.pipeline.vs;
                prevShaderFs = this.pipeline.fs;
            }
            this._pipelineNeedsUpdate = false;
            const vs = this.shaderFactory.createShader({
                id: `${this.id}-vertex`,
                stage: 'vertex',
                source: this.source || this.vs,
                debugShaders: this.props.debugShaders
            });
            let fs = null;
            if (this.source) {
                fs = vs;
            } else if (this.fs) {
                fs = this.shaderFactory.createShader({
                    id: `${this.id}-fragment`,
                    stage: 'fragment',
                    source: this.source || this.fs,
                    debugShaders: this.props.debugShaders
                });
            }
            this.pipeline = this.pipelineFactory.createRenderPipeline({
                ...this.props,
                bufferLayout: this.bufferLayout,
                topology: this.topology,
                parameters: this.parameters,
                // TODO - why set bindings here when we reset them every frame?
                // Should we expose a BindGroup abstraction?
                bindings: this._getBindings(),
                vs,
                fs
            });
            this._attributeInfos = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2d$utils$2f$get$2d$attribute$2d$from$2d$layouts$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getAttributeInfosFromLayouts"])(this.pipeline.shaderLayout, this.bufferLayout);
            if (prevShaderVs) this.shaderFactory.release(prevShaderVs);
            if (prevShaderFs) this.shaderFactory.release(prevShaderFs);
        }
        return this.pipeline;
    }
    /** Throttle draw call logging */ _lastLogTime = 0;
    _logOpen = false;
    _logDrawCallStart() {
        // IF level is 4 or higher, log every frame.
        const logDrawTimeout = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].level > 3 ? 0 : LOG_DRAW_TIMEOUT;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].level < 2 || Date.now() - this._lastLogTime < logDrawTimeout) {
            return;
        }
        this._lastLogTime = Date.now();
        this._logOpen = true;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, {
            collapsed: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].level <= 2
        })();
    }
    _logDrawCallEnd() {
        if (this._logOpen) {
            const shaderLayoutTable = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$debug$2f$debug$2d$shader$2d$layout$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getDebugTableForShaderLayout"])(this.pipeline.shaderLayout, this.id);
            // log.table(logLevel, attributeTable)();
            // log.table(logLevel, uniformTable)();
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].table(LOG_DRAW_PRIORITY, shaderLayoutTable)();
            const uniformTable = this.shaderInputs.getDebugTable();
            // Add any global uniforms
            for (const [name, value] of Object.entries(this.uniforms)){
                uniformTable[name] = {
                    value
                };
            }
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].table(LOG_DRAW_PRIORITY, uniformTable)();
            const attributeTable = this._getAttributeDebugTable();
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].table(LOG_DRAW_PRIORITY, this._attributeInfos)();
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].table(LOG_DRAW_PRIORITY, attributeTable)();
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].groupEnd(LOG_DRAW_PRIORITY)();
            this._logOpen = false;
        }
    }
    _drawCount = 0;
    _logFramebuffer(renderPass) {
        const debugFramebuffers = this.device.props.debugFramebuffers;
        this._drawCount++;
        // Update first 3 frames and then every 60 frames
        if (!debugFramebuffers) {
            // } || (this._drawCount++ > 3 && this._drawCount % 60)) {
            return;
        }
        // TODO - display framebuffer output in debug window
        const framebuffer = renderPass.props.framebuffer;
        if (framebuffer) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$debug$2f$debug$2d$framebuffer$2e$js__$5b$client$5d$__$28$ecmascript$29$__["debugFramebuffer"])(framebuffer, {
                id: framebuffer.id,
                minimap: true
            });
        // log.image({logLevel: LOG_DRAW_PRIORITY, message: `${framebuffer.id} %c sup?`, image})();
        }
    }
    _getAttributeDebugTable() {
        const table = {};
        for (const [name, attributeInfo] of Object.entries(this._attributeInfos)){
            const values = this.vertexArray.attributes[attributeInfo.location];
            table[attributeInfo.location] = {
                name,
                type: attributeInfo.shaderType,
                values: values ? this._getBufferOrConstantValues(values, attributeInfo.bufferDataType) : 'null'
            };
        }
        if (this.vertexArray.indexBuffer) {
            const { indexBuffer } = this.vertexArray;
            const values = indexBuffer.indexType === 'uint32' ? new Uint32Array(indexBuffer.debugData) : new Uint16Array(indexBuffer.debugData);
            table.indices = {
                name: 'indices',
                type: indexBuffer.indexType,
                values: values.toString()
            };
        }
        return table;
    }
    // TODO - fix typing of luma data types
    _getBufferOrConstantValues(attribute, dataType) {
        const TypedArrayConstructor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$gpu$2d$type$2d$utils$2f$vertex$2d$format$2d$from$2d$attribute$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getTypedArrayFromDataType"])(dataType);
        const typedArray = attribute instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$buffer$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"] ? new TypedArrayConstructor(attribute.debugData) : attribute;
        return typedArray.toString();
    }
}
function shaderModuleHasUniforms(module) {
    return Boolean(module.uniformTypes && !isObjectEmpty(module.uniformTypes));
}
function getPlatformInfo(device) {
    return {
        type: device.type,
        shaderLanguage: device.info.shadingLanguage,
        shaderLanguageVersion: device.info.shadingLanguageVersion,
        gpu: device.info.gpu,
        // HACK - we pretend that the DeviceFeatures is a Set, it has a similar API
        features: device.features
    };
}
/** Returns true if given object is empty, false otherwise. */ function isObjectEmpty(obj) {
    // @ts-ignore key is unused
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    for(const key in obj){
        return false;
    }
    return true;
} //# sourceMappingURL=model.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/compute/buffer-transform.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "BufferTransform": (()=>BufferTransform)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$buffer$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/core/dist/adapter/resources/buffer.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$glsl$2d$utils$2f$shader$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/shadertools/dist/lib/glsl-utils/shader-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$model$2f$model$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/engine/dist/model/model.js [client] (ecmascript)");
;
;
;
class BufferTransform {
    device;
    model;
    transformFeedback;
    static defaultProps = {
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$model$2f$model$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Model"].defaultProps,
        outputs: undefined,
        feedbackBuffers: undefined
    };
    static isSupported(device) {
        return device?.info?.type === 'webgl';
    }
    constructor(device, props = BufferTransform.defaultProps){
        if (!BufferTransform.isSupported(device)) {
            throw new Error('BufferTransform not yet implemented on WebGPU');
        }
        this.device = device;
        this.model = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$model$2f$model$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Model"](this.device, {
            id: props.id || 'buffer-transform-model',
            fs: props.fs || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$glsl$2d$utils$2f$shader$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getPassthroughFS"])(),
            topology: props.topology || 'point-list',
            varyings: props.outputs || props.varyings,
            ...props
        });
        this.transformFeedback = this.device.createTransformFeedback({
            layout: this.model.pipeline.shaderLayout,
            // @ts-expect-error TODO
            buffers: props.feedbackBuffers
        });
        this.model.setTransformFeedback(this.transformFeedback);
        Object.seal(this);
    }
    /** Destroy owned resources. */ destroy() {
        if (this.model) {
            this.model.destroy();
        }
    }
    /** @deprecated Use {@link destroy}. */ delete() {
        this.destroy();
    }
    /** Run one transform loop. */ run(options) {
        if (options?.inputBuffers) {
            this.model.setAttributes(options.inputBuffers);
        }
        if (options?.outputBuffers) {
            this.transformFeedback.setBuffers(options.outputBuffers);
        }
        const renderPass = this.device.beginRenderPass(options);
        this.model.draw(renderPass);
        renderPass.end();
    }
    // DEPRECATED METHODS
    /** @deprecated App knows what buffers it is passing in - Returns the {@link Buffer} or {@link BufferRange} for given varying name. */ getBuffer(varyingName) {
        return this.transformFeedback.getBuffer(varyingName);
    }
    /** @deprecated App knows what buffers it is passing in - Reads the {@link Buffer} or {@link BufferRange} for given varying name. */ readAsync(varyingName) {
        const result = this.getBuffer(varyingName);
        if (!result) {
            throw new Error('BufferTransform#getBuffer');
        }
        if (result instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$adapter$2f$resources$2f$buffer$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"]) {
            return result.readAsync();
        }
        const { buffer, byteOffset = 0, byteLength = buffer.byteLength } = result;
        return buffer.readAsync(byteOffset, byteLength);
    }
} //# sourceMappingURL=buffer-transform.js.map
}}),
"[project]/node_modules/@luma.gl/engine/dist/geometry/geometry.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "Geometry": (()=>Geometry)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$utils$2f$uid$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/engine/dist/utils/uid.js [client] (ecmascript)");
;
class Geometry {
    id;
    /** Determines how vertices are read from the 'vertex' attributes */ topology;
    vertexCount;
    indices;
    attributes;
    userData = {};
    constructor(props){
        const { attributes = {}, indices = null, vertexCount = null } = props;
        this.id = props.id || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$engine$2f$dist$2f$utils$2f$uid$2e$js__$5b$client$5d$__$28$ecmascript$29$__["uid"])('geometry');
        this.topology = props.topology;
        if (indices) {
            this.indices = ArrayBuffer.isView(indices) ? {
                value: indices,
                size: 1
            } : indices;
        }
        // @ts-expect-error
        this.attributes = {};
        for (const [attributeName, attributeValue] of Object.entries(attributes)){
            // Wrap "unwrapped" arrays and try to autodetect their type
            const attribute = ArrayBuffer.isView(attributeValue) ? {
                value: attributeValue
            } : attributeValue;
            if (!ArrayBuffer.isView(attribute.value)) {
                throw new Error(`${this._print(attributeName)}: must be typed array or object with value as typed array`);
            }
            if ((attributeName === 'POSITION' || attributeName === 'positions') && !attribute.size) {
                attribute.size = 3;
            }
            // Move indices to separate field
            if (attributeName === 'indices') {
                if (this.indices) {
                    throw new Error('Multiple indices detected');
                }
                this.indices = attribute;
            } else {
                this.attributes[attributeName] = attribute;
            }
        }
        if (this.indices && this.indices.isIndexed !== undefined) {
            this.indices = Object.assign({}, this.indices);
            delete this.indices.isIndexed;
        }
        this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);
    }
    getVertexCount() {
        return this.vertexCount;
    }
    /**
     * Return an object with all attributes plus indices added as a field.
     * TODO Geometry types are a mess
     */ getAttributes() {
        return this.indices ? {
            indices: this.indices,
            ...this.attributes
        } : this.attributes;
    }
    // PRIVATE
    _print(attributeName) {
        return `Geometry ${this.id} attribute ${attributeName}`;
    }
    /**
     * GeometryAttribute
     * value: typed array
     * type: indices, vertices, uvs
     * size: elements per vertex
     * target: WebGL buffer type (string or constant)
     *
     * @param attributes
     * @param indices
     * @returns
     */ _setAttributes(attributes, indices) {
        return this;
    }
    _calculateVertexCount(attributes, indices) {
        if (indices) {
            return indices.value.length;
        }
        let vertexCount = Infinity;
        for (const attribute of Object.values(attributes)){
            const { value, size, constant } = attribute;
            if (!constant && value && size !== undefined && size >= 1) {
                vertexCount = Math.min(vertexCount, value.length / size);
            }
        }
        // assert(Number.isFinite(vertexCount));
        return vertexCount;
    }
} //# sourceMappingURL=geometry.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/lib/utils/assert.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// Recommendation is to ignore message but current test suite checks agains the
// message so keep it for now.
__turbopack_context__.s({
    "assert": (()=>assert)
});
function assert(condition, message) {
    if (!condition) {
        throw new Error(message || 'shadertools: assertion failed.');
    }
} //# sourceMappingURL=assert.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/lib/filters/prop-types.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "getValidatedProperties": (()=>getValidatedProperties),
    "makePropValidators": (()=>makePropValidators)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/shadertools/dist/lib/utils/assert.js [client] (ecmascript)");
;
/** Minimal validators for number and array types */ const DEFAULT_PROP_VALIDATORS = {
    number: {
        type: 'number',
        validate (value, propType) {
            return Number.isFinite(value) && typeof propType === 'object' && (propType.max === undefined || value <= propType.max) && (propType.min === undefined || value >= propType.min);
        }
    },
    array: {
        type: 'array',
        validate (value, propType) {
            return Array.isArray(value) || ArrayBuffer.isView(value);
        }
    }
};
function makePropValidators(propTypes) {
    const propValidators = {};
    for (const [name, propType] of Object.entries(propTypes)){
        propValidators[name] = makePropValidator(propType);
    }
    return propValidators;
}
function getValidatedProperties(properties, propValidators, errorMessage) {
    const validated = {};
    for (const [key, propsValidator] of Object.entries(propValidators)){
        if (properties && key in properties && !propsValidator.private) {
            if (propsValidator.validate) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(propsValidator.validate(properties[key], propsValidator), `${errorMessage}: invalid ${key}`);
            }
            validated[key] = properties[key];
        } else {
            // property not supplied - use default value
            validated[key] = propsValidator.value;
        }
    }
    // TODO - warn for unused properties that don't match a validator?
    return validated;
}
/**
 * Creates a property validator for a prop type. Either contains:
 * - a valid prop type object ({type, ...})
 * - or just a default value, in which case type and name inference is used
 */ function makePropValidator(propType) {
    let type = getTypeOf(propType);
    if (type !== 'object') {
        return {
            value: propType,
            ...DEFAULT_PROP_VALIDATORS[type],
            type
        };
    }
    // Special handling for objects
    if (typeof propType === 'object') {
        if (!propType) {
            return {
                type: 'object',
                value: null
            };
        }
        if (propType.type !== undefined) {
            return {
                ...propType,
                ...DEFAULT_PROP_VALIDATORS[propType.type],
                type: propType.type
            };
        }
        // If no type and value this object is likely the value
        if (propType.value === undefined) {
            return {
                type: 'object',
                value: propType
            };
        }
        type = getTypeOf(propType.value);
        return {
            ...propType,
            ...DEFAULT_PROP_VALIDATORS[type],
            type
        };
    }
    throw new Error('props');
}
/**
 * "improved" version of javascript typeof that can distinguish arrays and null values
 */ function getTypeOf(value) {
    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
        return 'array';
    }
    return typeof value;
} //# sourceMappingURL=prop-types.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/module-injectors.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "MODULE_INJECTORS_FS": (()=>MODULE_INJECTORS_FS),
    "MODULE_INJECTORS_VS": (()=>MODULE_INJECTORS_VS)
});
const MODULE_INJECTORS_VS = /* glsl */ `\
#ifdef MODULE_LOGDEPTH
  logdepth_adjustPosition(gl_Position);
#endif
`;
const MODULE_INJECTORS_FS = /* glsl */ `\
#ifdef MODULE_MATERIAL
  fragColor = material_filterColor(fragColor);
#endif

#ifdef MODULE_LIGHTING
  fragColor = lighting_filterColor(fragColor);
#endif

#ifdef MODULE_FOG
  fragColor = fog_filterColor(fragColor);
#endif

#ifdef MODULE_PICKING
  fragColor = picking_filterHighlightColor(fragColor);
  fragColor = picking_filterPickingColor(fragColor);
#endif

#ifdef MODULE_LOGDEPTH
  logdepth_setFragDepth();
#endif
`; //# sourceMappingURL=module-injectors.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/shader-injections.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "DECLARATION_INJECT_MARKER": (()=>DECLARATION_INJECT_MARKER),
    "combineInjects": (()=>combineInjects),
    "injectShader": (()=>injectShader),
    "normalizeInjections": (()=>normalizeInjections)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$module$2d$injectors$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/shadertools/dist/module-injectors.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/shadertools/dist/lib/utils/assert.js [client] (ecmascript)");
;
;
// TODO - experimental
const MODULE_INJECTORS = {
    vertex: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$module$2d$injectors$2e$js__$5b$client$5d$__$28$ecmascript$29$__["MODULE_INJECTORS_VS"],
    fragment: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$module$2d$injectors$2e$js__$5b$client$5d$__$28$ecmascript$29$__["MODULE_INJECTORS_FS"]
};
const REGEX_START_OF_MAIN = /void\s+main\s*\([^)]*\)\s*\{\n?/; // Beginning of main
const REGEX_END_OF_MAIN = /}\n?[^{}]*$/; // End of main, assumes main is last function
const fragments = [];
const DECLARATION_INJECT_MARKER = '__LUMA_INJECT_DECLARATIONS__';
function normalizeInjections(injections) {
    const result = {
        vertex: {},
        fragment: {}
    };
    for(const hook in injections){
        let injection = injections[hook];
        const stage = getHookStage(hook);
        if (typeof injection === 'string') {
            injection = {
                order: 0,
                injection
            };
        }
        result[stage][hook] = injection;
    }
    return result;
}
function getHookStage(hook) {
    const type = hook.slice(0, 2);
    switch(type){
        case 'vs':
            return 'vertex';
        case 'fs':
            return 'fragment';
        default:
            throw new Error(type);
    }
}
function injectShader(source, stage, inject, injectStandardStubs = false) {
    const isVertex = stage === 'vertex';
    for(const key in inject){
        const fragmentData = inject[key];
        fragmentData.sort((a, b)=>a.order - b.order);
        fragments.length = fragmentData.length;
        for(let i = 0, len = fragmentData.length; i < len; ++i){
            fragments[i] = fragmentData[i].injection;
        }
        const fragmentString = `${fragments.join('\n')}\n`;
        switch(key){
            // declarations are injected before the main function
            case 'vs:#decl':
                if (isVertex) {
                    source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);
                }
                break;
            // inject code at the beginning of the main function
            case 'vs:#main-start':
                if (isVertex) {
                    source = source.replace(REGEX_START_OF_MAIN, (match)=>match + fragmentString);
                }
                break;
            // inject code at the end of main function
            case 'vs:#main-end':
                if (isVertex) {
                    source = source.replace(REGEX_END_OF_MAIN, (match)=>fragmentString + match);
                }
                break;
            // declarations are injected before the main function
            case 'fs:#decl':
                if (!isVertex) {
                    source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);
                }
                break;
            // inject code at the beginning of the main function
            case 'fs:#main-start':
                if (!isVertex) {
                    source = source.replace(REGEX_START_OF_MAIN, (match)=>match + fragmentString);
                }
                break;
            // inject code at the end of main function
            case 'fs:#main-end':
                if (!isVertex) {
                    source = source.replace(REGEX_END_OF_MAIN, (match)=>fragmentString + match);
                }
                break;
            default:
                // TODO(Tarek): I think this usage should be deprecated.
                // inject code after key, leaving key in place
                source = source.replace(key, (match)=>match + fragmentString);
        }
    }
    // Remove if it hasn't already been replaced
    source = source.replace(DECLARATION_INJECT_MARKER, '');
    // Finally, if requested, insert an automatic module injector chunk
    if (injectStandardStubs) {
        source = source.replace(/\}\s*$/, (match)=>match + MODULE_INJECTORS[stage]);
    }
    return source;
}
function combineInjects(injects) {
    const result = {};
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(Array.isArray(injects) && injects.length > 1);
    injects.forEach((inject)=>{
        for(const key in inject){
            result[key] = result[key] ? `${result[key]}\n${inject[key]}` : inject[key];
        }
    });
    return result;
} //# sourceMappingURL=shader-injections.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-module/shader-module.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "checkShaderModuleDeprecations": (()=>checkShaderModuleDeprecations),
    "getShaderModuleUniforms": (()=>getShaderModuleUniforms),
    "initializeShaderModule": (()=>initializeShaderModule),
    "initializeShaderModules": (()=>initializeShaderModules)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$filters$2f$prop$2d$types$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/shadertools/dist/lib/filters/prop-types.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembly$2f$shader$2d$injections$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/shader-injections.js [client] (ecmascript)");
;
;
function initializeShaderModules(modules) {
    modules.map((module)=>initializeShaderModule(module));
}
function initializeShaderModule(module) {
    if (module.instance) {
        return;
    }
    initializeShaderModules(module.dependencies || []);
    const { propTypes = {}, deprecations = [], // defines = {},
    inject = {} } = module;
    const instance = {
        normalizedInjections: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembly$2f$shader$2d$injections$2e$js__$5b$client$5d$__$28$ecmascript$29$__["normalizeInjections"])(inject),
        parsedDeprecations: parseDeprecationDefinitions(deprecations)
    };
    if (propTypes) {
        instance.propValidators = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$filters$2f$prop$2d$types$2e$js__$5b$client$5d$__$28$ecmascript$29$__["makePropValidators"])(propTypes);
    }
    module.instance = instance;
    // TODO(ib) - we need to apply the original prop types to the default uniforms
    let defaultProps = {};
    if (propTypes) {
        defaultProps = Object.entries(propTypes).reduce((obj, [key, propType])=>{
            // @ts-expect-error
            const value = propType?.value;
            if (value) {
                // @ts-expect-error
                obj[key] = value;
            }
            return obj;
        }, {});
    }
    module.defaultUniforms = {
        ...module.defaultUniforms,
        ...defaultProps
    };
}
function getShaderModuleUniforms(module, props, oldUniforms) {
    initializeShaderModule(module);
    const uniforms = oldUniforms || {
        ...module.defaultUniforms
    };
    // If module has a getUniforms function, use it
    if (props && module.getUniforms) {
        return module.getUniforms(props, uniforms);
    }
    // Build uniforms from the uniforms array
    // @ts-expect-error
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$filters$2f$prop$2d$types$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getValidatedProperties"])(props, module.instance?.propValidators, module.name);
}
function checkShaderModuleDeprecations(shaderModule, shaderSource, log) {
    shaderModule.deprecations?.forEach((def)=>{
        if (def.regex?.test(shaderSource)) {
            if (def.deprecated) {
                log.deprecated(def.old, def.new)();
            } else {
                log.removed(def.old, def.new)();
            }
        }
    });
}
// HELPERS
function parseDeprecationDefinitions(deprecations) {
    deprecations.forEach((def)=>{
        switch(def.type){
            case 'function':
                def.regex = new RegExp(`\\b${def.old}\\(`);
                break;
            default:
                def.regex = new RegExp(`${def.type} ${def.old};`);
        }
    });
    return deprecations;
} //# sourceMappingURL=shader-module.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-module/shader-module-dependencies.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "getDependencyGraph": (()=>getDependencyGraph),
    "getShaderDependencies": (()=>getShaderDependencies),
    "getShaderModuleDependencies": (()=>getShaderModuleDependencies),
    "resolveModules": (()=>resolveModules)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$module$2f$shader$2d$module$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-module/shader-module.js [client] (ecmascript)");
;
function getShaderModuleDependencies(modules) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$module$2f$shader$2d$module$2e$js__$5b$client$5d$__$28$ecmascript$29$__["initializeShaderModules"])(modules);
    const moduleMap = {};
    const moduleDepth = {};
    getDependencyGraph({
        modules,
        level: 0,
        moduleMap,
        moduleDepth
    });
    // Return a reverse sort so that dependencies come before the modules that use them
    const dependencies = Object.keys(moduleDepth).sort((a, b)=>moduleDepth[b] - moduleDepth[a]).map((name)=>moduleMap[name]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$module$2f$shader$2d$module$2e$js__$5b$client$5d$__$28$ecmascript$29$__["initializeShaderModules"])(dependencies);
    return dependencies;
}
function getDependencyGraph(options) {
    const { modules, level, moduleMap, moduleDepth } = options;
    if (level >= 5) {
        throw new Error('Possible loop in shader dependency graph');
    }
    // Update level on all current modules
    for (const module of modules){
        moduleMap[module.name] = module;
        if (moduleDepth[module.name] === undefined || moduleDepth[module.name] < level) {
            moduleDepth[module.name] = level;
        }
    }
    // Recurse
    for (const module of modules){
        if (module.dependencies) {
            getDependencyGraph({
                modules: module.dependencies,
                level: level + 1,
                moduleMap,
                moduleDepth
            });
        }
    }
}
function getShaderDependencies(modules) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$module$2f$shader$2d$module$2e$js__$5b$client$5d$__$28$ecmascript$29$__["initializeShaderModules"])(modules);
    const moduleMap = {};
    const moduleDepth = {};
    getDependencyGraph({
        modules,
        level: 0,
        moduleMap,
        moduleDepth
    });
    // Return a reverse sort so that dependencies come before the modules that use them
    modules = Object.keys(moduleDepth).sort((a, b)=>moduleDepth[b] - moduleDepth[a]).map((name)=>moduleMap[name]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$module$2f$shader$2d$module$2e$js__$5b$client$5d$__$28$ecmascript$29$__["initializeShaderModules"])(modules);
    return modules;
}
function resolveModules(modules) {
    return getShaderDependencies(modules);
} //# sourceMappingURL=shader-module-dependencies.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/platform-defines.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/** Adds defines to help identify GPU architecture / platform */ __turbopack_context__.s({
    "getPlatformShaderDefines": (()=>getPlatformShaderDefines)
});
function getPlatformShaderDefines(platformInfo) {
    switch(platformInfo?.gpu.toLowerCase()){
        case 'apple':
            return /* glsl */ `\
#define APPLE_GPU
// Apple optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
        case 'nvidia':
            return /* glsl */ `\
#define NVIDIA_GPU
// Nvidia optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
`;
        case 'intel':
            return /* glsl */ `\
#define INTEL_GPU
// Intel optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Intel's built-in 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
        case 'amd':
            // AMD Does not eliminate fp64 code
            return /* glsl */ `\
#define AMD_GPU
`;
        default:
            // We don't know what GPU it is, could be that the GPU driver or
            // browser is not implementing UNMASKED_RENDERER constant and not
            // reporting a correct name
            return /* glsl */ `\
#define DEFAULT_GPU
// Prevent driver from optimizing away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Headless Chrome's software shader 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// If the GPU doesn't have full 32 bits precision, will causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
    }
} //# sourceMappingURL=platform-defines.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-transpiler/transpile-glsl-shader.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// TRANSPILATION TABLES
/**
 * Transpiles GLSL 3.00 shader source code to target GLSL version (3.00 or 1.00)
 *
 * @note We always run transpiler even if same version e.g. 3.00 => 3.00
 * @note For texture sampling transpilation, apps need to use non-standard texture* calls in GLSL 3.00 source
 * RFC: https://github.com/visgl/luma.gl/blob/7.0-release/dev-docs/RFCs/v6.0/portable-glsl-300-rfc.md
 */ __turbopack_context__.s({
    "transpileGLSLShader": (()=>transpileGLSLShader)
});
function transpileGLSLShader(source, stage) {
    const sourceGLSLVersion = Number(source.match(/^#version[ \t]+(\d+)/m)?.[1] || 100);
    if (sourceGLSLVersion !== 300) {
        // TODO - we splurge on a longer error message to help deck.gl custom layer developers
        throw new Error('luma.gl v9 only supports GLSL 3.00 shader sources');
    }
    switch(stage){
        case 'vertex':
            source = convertShader(source, ES300_VERTEX_REPLACEMENTS);
            return source;
        case 'fragment':
            source = convertShader(source, ES300_FRAGMENT_REPLACEMENTS);
            return source;
        default:
            // Unknown shader stage
            throw new Error(stage);
    }
}
/** Simple regex replacements for GLSL ES 1.00 syntax that has changed in GLSL ES 3.00 */ const ES300_REPLACEMENTS = [
    // Fix poorly formatted version directive
    [
        /^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/,
        '#version 300 es\n'
    ],
    // The individual `texture...()` functions were replaced with `texture()` overloads
    [
        /\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g,
        'textureLod('
    ],
    [
        /\btexture(2D|2DProj|Cube)(EXT)?\(/g,
        'texture('
    ]
];
const ES300_VERTEX_REPLACEMENTS = [
    ...ES300_REPLACEMENTS,
    // `attribute` keyword replaced with `in`
    [
        makeVariableTextRegExp('attribute'),
        'in $1'
    ],
    // `varying` keyword replaced with `out`
    [
        makeVariableTextRegExp('varying'),
        'out $1'
    ]
];
/** Simple regex replacements for GLSL ES 1.00 syntax that has changed in GLSL ES 3.00 */ const ES300_FRAGMENT_REPLACEMENTS = [
    ...ES300_REPLACEMENTS,
    // `varying` keyword replaced with `in`
    [
        makeVariableTextRegExp('varying'),
        'in $1'
    ]
];
function convertShader(source, replacements) {
    for (const [pattern, replacement] of replacements){
        source = source.replace(pattern, replacement);
    }
    return source;
}
/**
 * Creates a regexp that tests for a specific variable type
 * @example
 *   should match:
 *     in float weight;
 *     out vec4 positions[2];
 *   should not match:
 *     void f(out float a, in float b) {}
 */ function makeVariableTextRegExp(qualifier) {
    return new RegExp(`\\b${qualifier}[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)`, 'g');
} //# sourceMappingURL=transpile-glsl-shader.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/shader-hooks.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/** Generate hook source code */ __turbopack_context__.s({
    "getShaderHooks": (()=>getShaderHooks),
    "normalizeShaderHooks": (()=>normalizeShaderHooks)
});
function getShaderHooks(hookFunctions, hookInjections) {
    let result = '';
    for(const hookName in hookFunctions){
        const hookFunction = hookFunctions[hookName];
        result += `void ${hookFunction.signature} {\n`;
        if (hookFunction.header) {
            result += `  ${hookFunction.header}`;
        }
        if (hookInjections[hookName]) {
            const injections = hookInjections[hookName];
            injections.sort((a, b)=>a.order - b.order);
            for (const injection of injections){
                result += `  ${injection.injection}\n`;
            }
        }
        if (hookFunction.footer) {
            result += `  ${hookFunction.footer}`;
        }
        result += '}\n';
    }
    return result;
}
function normalizeShaderHooks(hookFunctions) {
    const result = {
        vertex: {},
        fragment: {}
    };
    for (const hookFunction of hookFunctions){
        let opts;
        let hook;
        if (typeof hookFunction !== 'string') {
            opts = hookFunction;
            hook = opts.hook;
        } else {
            opts = {};
            hook = hookFunction;
        }
        hook = hook.trim();
        const [shaderStage, signature] = hook.split(':');
        const name = hook.replace(/\(.+/, '');
        const normalizedHook = Object.assign(opts, {
            signature
        });
        switch(shaderStage){
            case 'vs':
                result.vertex[name] = normalizedHook;
                break;
            case 'fs':
                result.fragment[name] = normalizedHook;
                break;
            default:
                throw new Error(shaderStage);
        }
    }
    return result;
} //# sourceMappingURL=shader-hooks.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/lib/glsl-utils/get-shader-info.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/** Extracts information from shader source code */ __turbopack_context__.s({
    "getShaderInfo": (()=>getShaderInfo)
});
function getShaderInfo(source, defaultName) {
    return {
        name: getShaderName(source, defaultName),
        language: 'glsl',
        version: getShaderVersion(source)
    };
}
/** Extracts GLSLIFY style naming of shaders: `#define SHADER_NAME ...` */ function getShaderName(shader, defaultName = 'unnamed') {
    const SHADER_NAME_REGEXP = /#define[^\S\r\n]*SHADER_NAME[^\S\r\n]*([A-Za-z0-9_-]+)\s*/;
    const match = SHADER_NAME_REGEXP.exec(shader);
    return match ? match[1] : defaultName;
}
/** returns GLSL shader version of given shader string */ function getShaderVersion(source) {
    let version = 100;
    const words = source.match(/[^\s]+/g);
    if (words && words.length >= 2 && words[0] === '#version') {
        const parsedVersion = parseInt(words[1], 10);
        if (Number.isFinite(parsedVersion)) {
            version = parsedVersion;
        }
    }
    if (version !== 100 && version !== 300) {
        throw new Error(`Invalid GLSL version ${version}`);
    }
    return version;
} //# sourceMappingURL=get-shader-info.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/assemble-shaders.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "assembleGLSLShaderPair": (()=>assembleGLSLShaderPair),
    "assembleGetUniforms": (()=>assembleGetUniforms),
    "assembleShaderWGSL": (()=>assembleShaderWGSL),
    "assembleWGSLShader": (()=>assembleWGSLShader),
    "getShaderModuleSource": (()=>getShaderModuleSource)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$module$2f$shader$2d$module$2d$dependencies$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-module/shader-module-dependencies.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembly$2f$platform$2d$defines$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/platform-defines.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembly$2f$shader$2d$injections$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/shader-injections.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$transpiler$2f$transpile$2d$glsl$2d$shader$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-transpiler/transpile-glsl-shader.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$module$2f$shader$2d$module$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-module/shader-module.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembly$2f$shader$2d$hooks$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/shader-hooks.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/shadertools/dist/lib/utils/assert.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$glsl$2d$utils$2f$get$2d$shader$2d$info$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/shadertools/dist/lib/glsl-utils/get-shader-info.js [client] (ecmascript)");
;
;
;
;
;
;
;
;
const INJECT_SHADER_DECLARATIONS = `\n\n${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembly$2f$shader$2d$injections$2e$js__$5b$client$5d$__$28$ecmascript$29$__["DECLARATION_INJECT_MARKER"]}\n`;
/**
 * Precision prologue to inject before functions are injected in shader
 * TODO - extract any existing prologue in the fragment source and move it up...
 */ const FRAGMENT_SHADER_PROLOGUE = /* glsl */ `\
precision highp float;
`;
function assembleWGSLShader(options) {
    const modules = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$module$2f$shader$2d$module$2d$dependencies$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getShaderModuleDependencies"])(options.modules || []);
    return {
        source: assembleShaderWGSL(options.platformInfo, {
            ...options,
            source: options.source,
            stage: 'vertex',
            modules
        }),
        getUniforms: assembleGetUniforms(modules)
    };
}
function assembleGLSLShaderPair(options) {
    const { vs, fs } = options;
    const modules = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$module$2f$shader$2d$module$2d$dependencies$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getShaderModuleDependencies"])(options.modules || []);
    return {
        vs: assembleShaderGLSL(options.platformInfo, {
            ...options,
            source: vs,
            stage: 'vertex',
            modules
        }),
        fs: assembleShaderGLSL(options.platformInfo, {
            ...options,
            // @ts-expect-error
            source: fs,
            stage: 'fragment',
            modules
        }),
        getUniforms: assembleGetUniforms(modules)
    };
}
function assembleShaderWGSL(platformInfo, options) {
    const { // id,
    source, stage, modules, // defines = {},
    hookFunctions = [], inject = {}, log } = options;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(typeof source === 'string', 'shader source must be a string');
    // const isVertex = type === 'vs';
    // const sourceLines = source.split('\n');
    const coreSource = source;
    // Combine Module and Application Defines
    // const allDefines = {};
    // modules.forEach(module => {
    //   Object.assign(allDefines, module.getDefines());
    // });
    // Object.assign(allDefines, defines);
    // Add platform defines (use these to work around platform-specific bugs and limitations)
    // Add common defines (GLSL version compatibility, feature detection)
    // Add precision declaration for fragment shaders
    let assembledSource = '';
    //   prologue
    //     ? `\
    // ${getShaderNameDefine({id, source, type})}
    // ${getShaderType(type)}
    // ${getPlatformShaderDefines(platformInfo)}
    // ${getApplicationDefines(allDefines)}
    // ${isVertex ? '' : FRAGMENT_SHADER_PROLOGUE}
    // `
    // `;
    const hookFunctionMap = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembly$2f$shader$2d$hooks$2e$js__$5b$client$5d$__$28$ecmascript$29$__["normalizeShaderHooks"])(hookFunctions);
    // Add source of dependent modules in resolved order
    const hookInjections = {};
    const declInjections = {};
    const mainInjections = {};
    for(const key in inject){
        const injection = typeof inject[key] === 'string' ? {
            injection: inject[key],
            order: 0
        } : inject[key];
        const match = /^(v|f)s:(#)?([\w-]+)$/.exec(key);
        if (match) {
            const hash = match[2];
            const name = match[3];
            if (hash) {
                if (name === 'decl') {
                    declInjections[key] = [
                        injection
                    ];
                } else {
                    mainInjections[key] = [
                        injection
                    ];
                }
            } else {
                hookInjections[key] = [
                    injection
                ];
            }
        } else {
            // Regex injection
            mainInjections[key] = [
                injection
            ];
        }
    }
    // TODO - hack until shadertool modules support WebGPU
    const modulesToInject = modules;
    for (const module of modulesToInject){
        if (log) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$module$2f$shader$2d$module$2e$js__$5b$client$5d$__$28$ecmascript$29$__["checkShaderModuleDeprecations"])(module, coreSource, log);
        }
        const moduleSource = getShaderModuleSource(module, 'wgsl');
        // Add the module source, and a #define that declares it presence
        assembledSource += moduleSource;
        const injections = module.injections?.[stage] || {};
        for(const key in injections){
            const match = /^(v|f)s:#([\w-]+)$/.exec(key);
            if (match) {
                const name = match[2];
                const injectionType = name === 'decl' ? declInjections : mainInjections;
                injectionType[key] = injectionType[key] || [];
                injectionType[key].push(injections[key]);
            } else {
                hookInjections[key] = hookInjections[key] || [];
                hookInjections[key].push(injections[key]);
            }
        }
    }
    // For injectShader
    assembledSource += INJECT_SHADER_DECLARATIONS;
    assembledSource = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembly$2f$shader$2d$injections$2e$js__$5b$client$5d$__$28$ecmascript$29$__["injectShader"])(assembledSource, stage, declInjections);
    assembledSource += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembly$2f$shader$2d$hooks$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getShaderHooks"])(hookFunctionMap[stage], hookInjections);
    // Add the version directive and actual source of this shader
    assembledSource += coreSource;
    // Apply any requested shader injections
    assembledSource = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembly$2f$shader$2d$injections$2e$js__$5b$client$5d$__$28$ecmascript$29$__["injectShader"])(assembledSource, stage, mainInjections);
    return assembledSource;
}
/**
 * Pulls together complete source code for either a vertex or a fragment shader
 * adding prologues, requested module chunks, and any final injections.
 * @param gl
 * @param options
 * @returns
 */ function assembleShaderGLSL(platformInfo, options) {
    const { id, source, stage, language = 'glsl', modules, defines = {}, hookFunctions = [], inject = {}, prologue = true, log } = options;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(typeof source === 'string', 'shader source must be a string');
    const sourceVersion = language === 'glsl' ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$glsl$2d$utils$2f$get$2d$shader$2d$info$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getShaderInfo"])(source).version : -1;
    const targetVersion = platformInfo.shaderLanguageVersion;
    const sourceVersionDirective = sourceVersion === 100 ? '#version 100' : '#version 300 es';
    const sourceLines = source.split('\n');
    // TODO : keep all pre-processor statements at the beginning of the shader.
    const coreSource = sourceLines.slice(1).join('\n');
    // Combine Module and Application Defines
    const allDefines = {};
    modules.forEach((module)=>{
        Object.assign(allDefines, module.defines);
    });
    Object.assign(allDefines, defines);
    // Add platform defines (use these to work around platform-specific bugs and limitations)
    // Add common defines (GLSL version compatibility, feature detection)
    // Add precision declaration for fragment shaders
    let assembledSource = '';
    switch(language){
        case 'wgsl':
            break;
        case 'glsl':
            assembledSource = prologue ? `\
${sourceVersionDirective}

// ----- PROLOGUE -------------------------
${getShaderNameDefine({
                id,
                source,
                stage
            })}
${`#define SHADER_TYPE_${stage.toUpperCase()}`}

${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembly$2f$platform$2d$defines$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getPlatformShaderDefines"])(platformInfo)}
${stage === 'fragment' ? FRAGMENT_SHADER_PROLOGUE : ''}

// ----- APPLICATION DEFINES -------------------------

${getApplicationDefines(allDefines)}

` : `${sourceVersionDirective}
`;
            break;
    }
    const hookFunctionMap = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembly$2f$shader$2d$hooks$2e$js__$5b$client$5d$__$28$ecmascript$29$__["normalizeShaderHooks"])(hookFunctions);
    // Add source of dependent modules in resolved order
    const hookInjections = {};
    const declInjections = {};
    const mainInjections = {};
    for(const key in inject){
        const injection = typeof inject[key] === 'string' ? {
            injection: inject[key],
            order: 0
        } : inject[key];
        const match = /^(v|f)s:(#)?([\w-]+)$/.exec(key);
        if (match) {
            const hash = match[2];
            const name = match[3];
            if (hash) {
                if (name === 'decl') {
                    declInjections[key] = [
                        injection
                    ];
                } else {
                    mainInjections[key] = [
                        injection
                    ];
                }
            } else {
                hookInjections[key] = [
                    injection
                ];
            }
        } else {
            // Regex injection
            mainInjections[key] = [
                injection
            ];
        }
    }
    for (const module of modules){
        if (log) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$module$2f$shader$2d$module$2e$js__$5b$client$5d$__$28$ecmascript$29$__["checkShaderModuleDeprecations"])(module, coreSource, log);
        }
        const moduleSource = getShaderModuleSource(module, stage);
        // Add the module source, and a #define that declares it presence
        assembledSource += moduleSource;
        const injections = module.instance?.normalizedInjections[stage] || {};
        for(const key in injections){
            const match = /^(v|f)s:#([\w-]+)$/.exec(key);
            if (match) {
                const name = match[2];
                const injectionType = name === 'decl' ? declInjections : mainInjections;
                injectionType[key] = injectionType[key] || [];
                injectionType[key].push(injections[key]);
            } else {
                hookInjections[key] = hookInjections[key] || [];
                hookInjections[key].push(injections[key]);
            }
        }
    }
    assembledSource += '// ----- MAIN SHADER SOURCE -------------------------';
    // For injectShader
    assembledSource += INJECT_SHADER_DECLARATIONS;
    assembledSource = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembly$2f$shader$2d$injections$2e$js__$5b$client$5d$__$28$ecmascript$29$__["injectShader"])(assembledSource, stage, declInjections);
    assembledSource += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembly$2f$shader$2d$hooks$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getShaderHooks"])(hookFunctionMap[stage], hookInjections);
    // Add the version directive and actual source of this shader
    assembledSource += coreSource;
    // Apply any requested shader injections
    assembledSource = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembly$2f$shader$2d$injections$2e$js__$5b$client$5d$__$28$ecmascript$29$__["injectShader"])(assembledSource, stage, mainInjections);
    if (language === 'glsl' && sourceVersion !== targetVersion) {
        assembledSource = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$transpiler$2f$transpile$2d$glsl$2d$shader$2e$js__$5b$client$5d$__$28$ecmascript$29$__["transpileGLSLShader"])(assembledSource, stage);
    }
    return assembledSource.trim();
}
function assembleGetUniforms(modules) {
    return function getUniforms(opts) {
        const uniforms = {};
        for (const module of modules){
            // `modules` is already sorted by dependency level. This guarantees that
            // modules have access to the uniforms that are generated by their dependencies.
            const moduleUniforms = module.getUniforms?.(opts, uniforms);
            Object.assign(uniforms, moduleUniforms);
        }
        return uniforms;
    };
}
/**
 * Generate "glslify-compatible" SHADER_NAME defines
 * These are understood by the GLSL error parsing function
 * If id is provided and no SHADER_NAME constant is present in source, create one
 */ function getShaderNameDefine(options) {
    const { id, source, stage } = options;
    const injectShaderName = id && source.indexOf('SHADER_NAME') === -1;
    return injectShaderName ? `
#define SHADER_NAME ${id}_${stage}` : '';
}
/** Generates application defines from an object of key value pairs */ function getApplicationDefines(defines = {}) {
    let sourceText = '';
    for(const define in defines){
        const value = defines[define];
        if (value || Number.isFinite(value)) {
            sourceText += `#define ${define.toUpperCase()} ${defines[define]}\n`;
        }
    }
    return sourceText;
}
function getShaderModuleSource(module, stage) {
    let moduleSource;
    switch(stage){
        case 'vertex':
            moduleSource = module.vs || '';
            break;
        case 'fragment':
            moduleSource = module.fs || '';
            break;
        case 'wgsl':
            moduleSource = module.source || '';
            break;
        default:
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(false);
    }
    if (!module.name) {
        throw new Error('Shader module must have a name');
    }
    const moduleName = module.name.toUpperCase().replace(/[^0-9a-z]/gi, '_');
    let source = `\
// ----- MODULE ${module.name} ---------------

`;
    if (stage !== 'wgsl') {
        source += `#define MODULE_${moduleName}\n`;
    }
    source += `${moduleSource}\n`;
    return source;
} /*
function getHookFunctions(
  hookFunctions: Record<string, HookFunction>,
  hookInjections: Record<string, Injection[]>
): string {
  let result = '';
  for (const hookName in hookFunctions) {
    const hookFunction = hookFunctions[hookName];
    result += `void ${hookFunction.signature} {\n`;
    if (hookFunction.header) {
      result += `  ${hookFunction.header}`;
    }
    if (hookInjections[hookName]) {
      const injections = hookInjections[hookName];
      injections.sort((a: {order: number}, b: {order: number}): number => a.order - b.order);
      for (const injection of injections) {
        result += `  ${injection.injection}\n`;
      }
    }
    if (hookFunction.footer) {
      result += `  ${hookFunction.footer}`;
    }
    result += '}\n';
  }

  return result;
}

function normalizeHookFunctions(hookFunctions: (string | HookFunction)[]): {
  vs: Record<string, HookFunction>;
  fs: Record<string, HookFunction>;
} {
  const result: {vs: Record<string, any>; fs: Record<string, any>} = {
    vs: {},
    fs: {}
  };

  hookFunctions.forEach((hookFunction: string | HookFunction) => {
    let opts: HookFunction;
    let hook: string;
    if (typeof hookFunction !== 'string') {
      opts = hookFunction;
      hook = opts.hook;
    } else {
      opts = {} as HookFunction;
      hook = hookFunction;
    }
    hook = hook.trim();
    const [stage, signature] = hook.split(':');
    const name = hook.replace(/\(.+/, '');
    if (stage !== 'vs' && stage !== 'fs') {
      throw new Error(stage);
    }
    result[stage][name] = Object.assign(opts, {signature});
  });

  return result;
}
*/  //# sourceMappingURL=assemble-shaders.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/lib/preprocessor/preprocessor.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "preprocess": (()=>preprocess)
});
const IFDEF_REGEXP = /^\s*\#\s*ifdef\s*([a-zA-Z_]+)\s*$/;
const ENDIF_REGEXP = /^\s*\#\s*endif\s*$/;
function preprocess(source, options) {
    const lines = source.split('\n');
    const output = [];
    let conditional = true;
    let currentDefine = null;
    for (const line of lines){
        const matchIf = line.match(IFDEF_REGEXP);
        const matchEnd = line.match(ENDIF_REGEXP);
        if (matchIf) {
            currentDefine = matchIf[1];
            conditional = Boolean(options?.defines?.[currentDefine]);
        } else if (matchEnd) {
            conditional = true;
        } else if (conditional) {
            output.push(line);
        }
    }
    return output.join('\n');
} //# sourceMappingURL=preprocessor.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-assembler.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "ShaderAssembler": (()=>ShaderAssembler)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$module$2f$shader$2d$module$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-module/shader-module.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembly$2f$assemble$2d$shaders$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/assemble-shaders.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$preprocessor$2f$preprocessor$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/shadertools/dist/lib/preprocessor/preprocessor.js [client] (ecmascript)");
;
;
;
class ShaderAssembler {
    /** Default ShaderAssembler instance */ static defaultShaderAssembler;
    /** Hook functions */ _hookFunctions = [];
    /** Shader modules */ _defaultModules = [];
    /**
     * A default shader assembler instance - the natural place to register default modules and hooks
     * @returns
     */ static getDefaultShaderAssembler() {
        ShaderAssembler.defaultShaderAssembler = ShaderAssembler.defaultShaderAssembler || new ShaderAssembler();
        return ShaderAssembler.defaultShaderAssembler;
    }
    /**
     * Add a default module that does not have to be provided with every call to assembleShaders()
     */ addDefaultModule(module) {
        if (!this._defaultModules.find((m)=>m.name === (typeof module === 'string' ? module : module.name))) {
            this._defaultModules.push(module);
        }
    }
    /**
     * Remove a default module
     */ removeDefaultModule(module) {
        const moduleName = typeof module === 'string' ? module : module.name;
        this._defaultModules = this._defaultModules.filter((m)=>m.name !== moduleName);
    }
    /**
     * Register a shader hook
     * @param hook
     * @param opts
     */ addShaderHook(hook, opts) {
        if (opts) {
            hook = Object.assign(opts, {
                hook
            });
        }
        this._hookFunctions.push(hook);
    }
    /**
     * Assemble a WGSL unified shader
     * @param platformInfo
     * @param props
     * @returns
     */ assembleWGSLShader(props) {
        const modules = this._getModuleList(props.modules); // Combine with default modules
        const hookFunctions = this._hookFunctions; // TODO - combine with default hook functions
        const { source, getUniforms } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembly$2f$assemble$2d$shaders$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assembleWGSLShader"])({
            ...props,
            // @ts-expect-error
            source: props.source,
            modules,
            hookFunctions
        });
        // WGSL does not have built-in preprocessing support (just compile time constants)
        const preprocessedSource = props.platformInfo.shaderLanguage === 'wgsl' ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$preprocessor$2f$preprocessor$2e$js__$5b$client$5d$__$28$ecmascript$29$__["preprocess"])(source) : source;
        return {
            source: preprocessedSource,
            getUniforms,
            modules
        };
    }
    /**
     * Assemble a pair of shaders into a single shader program
     * @param platformInfo
     * @param props
     * @returns
     */ assembleGLSLShaderPair(props) {
        const modules = this._getModuleList(props.modules); // Combine with default modules
        const hookFunctions = this._hookFunctions; // TODO - combine with default hook functions
        const assembled = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$assembly$2f$assemble$2d$shaders$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assembleGLSLShaderPair"])({
            ...props,
            // @ts-expect-error
            vs: props.vs,
            // @ts-expect-error
            fs: props.fs,
            modules,
            hookFunctions
        });
        return {
            ...assembled,
            modules
        };
    }
    /**
     * Dedupe and combine with default modules
     */ _getModuleList(appModules = []) {
        const modules = new Array(this._defaultModules.length + appModules.length);
        const seen = {};
        let count = 0;
        for(let i = 0, len = this._defaultModules.length; i < len; ++i){
            const module = this._defaultModules[i];
            const name = module.name;
            modules[count++] = module;
            seen[name] = true;
        }
        for(let i = 0, len = appModules.length; i < len; ++i){
            const module = appModules[i];
            const name = module.name;
            if (!seen[name]) {
                modules[count++] = module;
                seen[name] = true;
            }
        }
        modules.length = count;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$lib$2f$shader$2d$module$2f$shader$2d$module$2e$js__$5b$client$5d$__$28$ecmascript$29$__["initializeShaderModules"])(modules);
        return modules;
    }
} //# sourceMappingURL=shader-assembler.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/modules/math/fp32/fp32.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// import {ShaderModule} from '../../types';
__turbopack_context__.s({
    "fp32": (()=>fp32)
});
const fp32shader = /* glsl */ `\
#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND

// All these functions are for substituting tan() function from Intel GPU only
const float TWO_PI = 6.2831854820251465;
const float PI_2 = 1.5707963705062866;
const float PI_16 = 0.1963495463132858;

const float SIN_TABLE_0 = 0.19509032368659973;
const float SIN_TABLE_1 = 0.3826834261417389;
const float SIN_TABLE_2 = 0.5555702447891235;
const float SIN_TABLE_3 = 0.7071067690849304;

const float COS_TABLE_0 = 0.9807852506637573;
const float COS_TABLE_1 = 0.9238795042037964;
const float COS_TABLE_2 = 0.8314695954322815;
const float COS_TABLE_3 = 0.7071067690849304;

const float INVERSE_FACTORIAL_3 = 1.666666716337204e-01; // 1/3!
const float INVERSE_FACTORIAL_5 = 8.333333767950535e-03; // 1/5!
const float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04; // 1/7!
const float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06; // 1/9!

float sin_taylor_fp32(float a) {
  float r, s, t, x;

  if (a == 0.0) {
    return 0.0;
  }

  x = -a * a;
  s = a;
  r = a;

  r = r * x;
  t = r * INVERSE_FACTORIAL_3;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_5;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_7;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_9;
  s = s + t;

  return s;
}

void sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {
  if (a == 0.0) {
    sin_t = 0.0;
    cos_t = 1.0;
  }
  sin_t = sin_taylor_fp32(a);
  cos_t = sqrt(1.0 - sin_t * sin_t);
}

float tan_taylor_fp32(float a) {
    float sin_a;
    float cos_a;

    if (a == 0.0) {
        return 0.0;
    }

    // 2pi range reduction
    float z = floor(a / TWO_PI);
    float r = a - TWO_PI * z;

    float t;
    float q = floor(r / PI_2 + 0.5);
    int j = int(q);

    if (j < -2 || j > 2) {
        return 1.0 / 0.0;
    }

    t = r - PI_2 * q;

    q = floor(t / PI_16 + 0.5);
    int k = int(q);
    int abs_k = int(abs(float(k)));

    if (abs_k > 4) {
        return 1.0 / 0.0;
    } else {
        t = t - PI_16 * q;
    }

    float u = 0.0;
    float v = 0.0;

    float sin_t, cos_t;
    float s, c;
    sincos_taylor_fp32(t, sin_t, cos_t);

    if (k == 0) {
        s = sin_t;
        c = cos_t;
    } else {
        if (abs(float(abs_k) - 1.0) < 0.5) {
            u = COS_TABLE_0;
            v = SIN_TABLE_0;
        } else if (abs(float(abs_k) - 2.0) < 0.5) {
            u = COS_TABLE_1;
            v = SIN_TABLE_1;
        } else if (abs(float(abs_k) - 3.0) < 0.5) {
            u = COS_TABLE_2;
            v = SIN_TABLE_2;
        } else if (abs(float(abs_k) - 4.0) < 0.5) {
            u = COS_TABLE_3;
            v = SIN_TABLE_3;
        }
        if (k > 0) {
            s = u * sin_t + v * cos_t;
            c = u * cos_t - v * sin_t;
        } else {
            s = u * sin_t - v * cos_t;
            c = u * cos_t + v * sin_t;
        }
    }

    if (j == 0) {
        sin_a = s;
        cos_a = c;
    } else if (j == 1) {
        sin_a = c;
        cos_a = -s;
    } else if (j == -1) {
        sin_a = -c;
        cos_a = s;
    } else {
        sin_a = -s;
        cos_a = -c;
    }
    return sin_a / cos_a;
}
#endif

float tan_fp32(float a) {
#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
  return tan_taylor_fp32(a);
#else
  return tan(a);
#endif
}
`;
const fp32 = {
    name: 'fp32',
    vs: fp32shader
}; //# sourceMappingURL=fp32.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/lib/glsl-utils/shader-utils.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "convertToVec4": (()=>convertToVec4),
    "getPassthroughFS": (()=>getPassthroughFS),
    "getQualifierDetails": (()=>getQualifierDetails),
    "typeToChannelCount": (()=>typeToChannelCount),
    "typeToChannelSuffix": (()=>typeToChannelSuffix)
});
const FS_GLES = /* glsl */ `\
out vec4 transform_output;
void main() {
  transform_output = vec4(0);
}`;
const FS300 = `#version 300 es\n${FS_GLES}`;
function getQualifierDetails(line, qualifiers) {
    qualifiers = Array.isArray(qualifiers) ? qualifiers : [
        qualifiers
    ];
    const words = line.replace(/^\s+/, '').split(/\s+/);
    // TODO add support for precession qualifiers (highp, mediump and lowp)
    const [qualifier, type, definition] = words;
    if (!qualifiers.includes(qualifier) || !type || !definition) {
        return null;
    }
    const name = definition.split(';')[0];
    return {
        qualifier,
        type,
        name
    };
}
function getPassthroughFS(options) {
    const { input, inputChannels, output } = options || {};
    if (!input) {
        // Default shader
        return FS300;
    }
    if (!inputChannels) {
        throw new Error('inputChannels');
    }
    const inputType = channelCountToType(inputChannels);
    const outputValue = convertToVec4(input, inputChannels);
    return `\
#version 300 es
in ${inputType} ${input};
out vec4 ${output};
void main() {
  ${output} = ${outputValue};
}`;
}
function typeToChannelSuffix(type) {
    // prettier-ignore
    switch(type){
        case 'float':
            return 'x';
        case 'vec2':
            return 'xy';
        case 'vec3':
            return 'xyz';
        case 'vec4':
            return 'xyzw';
        default:
            throw new Error(type);
    }
}
function typeToChannelCount(type) {
    // prettier-ignore
    switch(type){
        case 'float':
            return 1;
        case 'vec2':
            return 2;
        case 'vec3':
            return 3;
        case 'vec4':
            return 4;
        default:
            throw new Error(type);
    }
}
function channelCountToType(channels) {
    // prettier-ignore
    switch(channels){
        case 1:
            return 'float';
        case 2:
            return 'vec2';
        case 3:
            return 'vec3';
        case 4:
            return 'vec4';
        default:
            throw new Error(`invalid channels: ${channels}`);
    }
}
function convertToVec4(variable, channels) {
    // prettier-ignore
    switch(channels){
        case 1:
            return `vec4(${variable}, 0.0, 0.0, 1.0)`;
        case 2:
            return `vec4(${variable}, 0.0, 1.0)`;
        case 3:
            return `vec4(${variable}, 1.0)`;
        case 4:
            return variable;
        default:
            throw new Error(`invalid channels: ${channels}`);
    }
} //# sourceMappingURL=shader-utils.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/lib/wgsl/get-shader-layout-wgsl.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "getShaderLayoutFromWGSL": (()=>getShaderLayoutFromWGSL)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/core/dist/utils/log.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wgsl_reflect$2f$wgsl_reflect$2e$module$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/wgsl_reflect/wgsl_reflect.module.js [client] (ecmascript)");
;
;
function getShaderLayoutFromWGSL(source) {
    const shaderLayout = {
        attributes: [],
        bindings: []
    };
    let parsedWGSL;
    try {
        parsedWGSL = parseWGSL(source);
    } catch (error) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].error(error.message)();
        return shaderLayout;
    }
    for (const uniform of parsedWGSL.uniforms){
        const members = [];
        for (const attribute of uniform.type?.members || []){
            members.push({
                name: attribute.name,
                type: getType(attribute.type)
            });
        }
        shaderLayout.bindings.push({
            type: 'uniform',
            name: uniform.name,
            group: uniform.group,
            location: uniform.binding,
            // @ts-expect-error TODO - unused for now but needs fixing
            members
        });
    }
    for (const texture of parsedWGSL.textures){
        shaderLayout.bindings.push({
            type: 'texture',
            name: texture.name,
            group: texture.group,
            location: texture.binding
        });
    }
    for (const sampler of parsedWGSL.samplers){
        shaderLayout.bindings.push({
            type: 'sampler',
            name: sampler.name,
            group: sampler.group,
            location: sampler.binding
        });
    }
    const vertex = parsedWGSL.entry.vertex[0]; // "main"
    // Vertex shader inputs
    const attributeCount = vertex?.inputs.length || 0; // inputs to "main"
    for(let i = 0; i < attributeCount; i++){
        const wgslAttribute = vertex.inputs[i];
        // locationType can be "builtin"
        if (wgslAttribute.locationType === 'location') {
            const type = getType(wgslAttribute.type);
            shaderLayout.attributes.push({
                name: wgslAttribute.name,
                location: Number(wgslAttribute.location),
                type
            });
        }
    }
    return shaderLayout;
}
/** Get a valid shader attribute type string from a wgsl-reflect type */ function getType(type) {
    return type.format ? `${type.name}<${type.format.name}>` : type.name;
}
function parseWGSL(source) {
    try {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wgsl_reflect$2f$wgsl_reflect$2e$module$2e$js__$5b$client$5d$__$28$ecmascript$29$__["WgslReflect"](source);
    } catch (error) {
        if (error instanceof Error) {
            throw error;
        }
        let message = 'WGSL parse error';
        if (typeof error === 'object' && error?.message) {
            message += `: ${error.message} `;
        }
        if (typeof error === 'object' && error?.token) {
            message += error.token.line || '';
        }
        throw new Error(message, {
            cause: error
        });
    }
} //# sourceMappingURL=get-shader-layout-wgsl.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/modules/math/fp64/fp64-utils.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/**
 * Calculate WebGL 64 bit float
 * @param a  - the input float number
 * @param out - the output array. If not supplied, a new array is created.
 * @param startIndex - the index in the output array to fill from. Default 0.
 * @returns - the fp64 representation of the input number
 */ __turbopack_context__.s({
    "fp64LowPart": (()=>fp64LowPart),
    "fp64ify": (()=>fp64ify),
    "fp64ifyMatrix4": (()=>fp64ifyMatrix4)
});
function fp64ify(a, out = [], startIndex = 0) {
    const hiPart = Math.fround(a);
    const loPart = a - hiPart;
    out[startIndex] = hiPart;
    out[startIndex + 1] = loPart;
    return out;
}
function fp64LowPart(a) {
    return a - Math.fround(a);
}
function fp64ifyMatrix4(matrix) {
    // Transpose the projection matrix to column major for GLSL.
    const matrixFP64 = new Float32Array(32);
    for(let i = 0; i < 4; ++i){
        for(let j = 0; j < 4; ++j){
            const index = i * 4 + j;
            fp64ify(matrix[j * 4 + i], matrixFP64, index * 2);
        }
    }
    return matrixFP64;
} //# sourceMappingURL=fp64-utils.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/modules/math/fp64/fp64-arithmetic-glsl.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "fp64arithmeticShader": (()=>fp64arithmeticShader)
});
const fp64arithmeticShader = /* glsl */ `\

uniform fp64arithmeticUniforms {
  uniform float ONE;
} fp64;

/*
About LUMA_FP64_CODE_ELIMINATION_WORKAROUND

The purpose of this workaround is to prevent shader compilers from
optimizing away necessary arithmetic operations by swapping their sequences
or transform the equation to some 'equivalent' form.

The method is to multiply an artifical variable, ONE, which will be known to
the compiler to be 1 only at runtime. The whole expression is then represented
as a polynomial with respective to ONE. In the coefficients of all terms, only one a
and one b should appear

err = (a + b) * ONE^6 - a * ONE^5 - (a + b) * ONE^4 + a * ONE^3 - b - (a + b) * ONE^2 + a * ONE
*/

// Divide float number to high and low floats to extend fraction bits
vec2 split(float a) {
  const float SPLIT = 4097.0;
  float t = a * SPLIT;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float a_hi = t * fp64.ONE - (t - a);
  float a_lo = a * fp64.ONE - a_hi;
#else
  float a_hi = t - (t - a);
  float a_lo = a - a_hi;
#endif
  return vec2(a_hi, a_lo);
}

// Divide float number again when high float uses too many fraction bits
vec2 split2(vec2 a) {
  vec2 b = split(a.x);
  b.y += a.y;
  return b;
}

// Special sum operation when a > b
vec2 quickTwoSum(float a, float b) {
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float sum = (a + b) * fp64.ONE;
  float err = b - (sum - a) * fp64.ONE;
#else
  float sum = a + b;
  float err = b - (sum - a);
#endif
  return vec2(sum, err);
}

// General sum operation
vec2 twoSum(float a, float b) {
  float s = (a + b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float v = (s * fp64.ONE - a) * fp64.ONE;
  float err = (a - (s - v) * fp64.ONE) * fp64.ONE * fp64.ONE * fp64.ONE + (b - v);
#else
  float v = s - a;
  float err = (a - (s - v)) + (b - v);
#endif
  return vec2(s, err);
}

vec2 twoSub(float a, float b) {
  float s = (a - b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float v = (s * fp64.ONE - a) * fp64.ONE;
  float err = (a - (s - v) * fp64.ONE) * fp64.ONE * fp64.ONE * fp64.ONE - (b + v);
#else
  float v = s - a;
  float err = (a - (s - v)) - (b + v);
#endif
  return vec2(s, err);
}

vec2 twoSqr(float a) {
  float prod = a * a;
  vec2 a_fp64 = split(a);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float err = ((a_fp64.x * a_fp64.x - prod) * fp64.ONE + 2.0 * a_fp64.x *
    a_fp64.y * fp64.ONE * fp64.ONE) + a_fp64.y * a_fp64.y * fp64.ONE * fp64.ONE * fp64.ONE;
#else
  float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;
#endif
  return vec2(prod, err);
}

vec2 twoProd(float a, float b) {
  float prod = a * b;
  vec2 a_fp64 = split(a);
  vec2 b_fp64 = split(b);
  float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +
    a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;
  return vec2(prod, err);
}

vec2 sum_fp64(vec2 a, vec2 b) {
  vec2 s, t;
  s = twoSum(a.x, b.x);
  t = twoSum(a.y, b.y);
  s.y += t.x;
  s = quickTwoSum(s.x, s.y);
  s.y += t.y;
  s = quickTwoSum(s.x, s.y);
  return s;
}

vec2 sub_fp64(vec2 a, vec2 b) {
  vec2 s, t;
  s = twoSub(a.x, b.x);
  t = twoSub(a.y, b.y);
  s.y += t.x;
  s = quickTwoSum(s.x, s.y);
  s.y += t.y;
  s = quickTwoSum(s.x, s.y);
  return s;
}

vec2 mul_fp64(vec2 a, vec2 b) {
  vec2 prod = twoProd(a.x, b.x);
  // y component is for the error
  prod.y += a.x * b.y;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  prod = split2(prod);
#endif
  prod = quickTwoSum(prod.x, prod.y);
  prod.y += a.y * b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  prod = split2(prod);
#endif
  prod = quickTwoSum(prod.x, prod.y);
  return prod;
}

vec2 div_fp64(vec2 a, vec2 b) {
  float xn = 1.0 / b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  vec2 yn = mul_fp64(a, vec2(xn, 0));
#else
  vec2 yn = a * xn;
#endif
  float diff = (sub_fp64(a, mul_fp64(b, yn))).x;
  vec2 prod = twoProd(xn, diff);
  return sum_fp64(yn, prod);
}

vec2 sqrt_fp64(vec2 a) {
  if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);
  if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);

  float x = 1.0 / sqrt(a.x);
  float yn = a.x * x;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  vec2 yn_sqr = twoSqr(yn) * fp64.ONE;
#else
  vec2 yn_sqr = twoSqr(yn);
#endif
  float diff = sub_fp64(a, yn_sqr).x;
  vec2 prod = twoProd(x * 0.5, diff);
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  return sum_fp64(split(yn), prod);
#else
  return sum_fp64(vec2(yn, 0.0), prod);
#endif
}
`; //# sourceMappingURL=fp64-arithmetic-glsl.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/modules/math/fp64/fp64-functions-glsl.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "fp64functionShader": (()=>fp64functionShader)
});
const fp64functionShader = /* glsl */ `\
const vec2 E_FP64 = vec2(2.7182817459106445e+00, 8.254840366817007e-08);
const vec2 LOG2_FP64 = vec2(0.6931471824645996e+00, -1.9046542121259336e-09);
const vec2 PI_FP64 = vec2(3.1415927410125732, -8.742278012618954e-8);
const vec2 TWO_PI_FP64 = vec2(6.2831854820251465, -1.7484556025237907e-7);
const vec2 PI_2_FP64 = vec2(1.5707963705062866, -4.371139006309477e-8);
const vec2 PI_4_FP64 = vec2(0.7853981852531433, -2.1855695031547384e-8);
const vec2 PI_16_FP64 = vec2(0.19634954631328583, -5.463923757886846e-9);
const vec2 PI_16_2_FP64 = vec2(0.39269909262657166, -1.0927847515773692e-8);
const vec2 PI_16_3_FP64 = vec2(0.5890486240386963, -1.4906100798128818e-9);
const vec2 PI_180_FP64 = vec2(0.01745329238474369, 1.3519960498364902e-10);

const vec2 SIN_TABLE_0_FP64 = vec2(0.19509032368659973, -1.6704714833615242e-9);
const vec2 SIN_TABLE_1_FP64 = vec2(0.3826834261417389, 6.22335089017767e-9);
const vec2 SIN_TABLE_2_FP64 = vec2(0.5555702447891235, -1.1769521357507529e-8);
const vec2 SIN_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617041793133e-8);

const vec2 COS_TABLE_0_FP64 = vec2(0.9807852506637573, 2.9739473106360492e-8);
const vec2 COS_TABLE_1_FP64 = vec2(0.9238795042037964, 2.8307490351764386e-8);
const vec2 COS_TABLE_2_FP64 = vec2(0.8314695954322815, 1.6870263741530778e-8);
const vec2 COS_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617152815436e-8);

const vec2 INVERSE_FACTORIAL_3_FP64 = vec2(1.666666716337204e-01, -4.967053879312289e-09); // 1/3!
const vec2 INVERSE_FACTORIAL_4_FP64 = vec2(4.16666679084301e-02, -1.2417634698280722e-09); // 1/4!
const vec2 INVERSE_FACTORIAL_5_FP64 = vec2(8.333333767950535e-03, -4.34617203337595e-10); // 1/5!
const vec2 INVERSE_FACTORIAL_6_FP64 = vec2(1.3888889225199819e-03, -3.3631094437103215e-11); // 1/6!
const vec2 INVERSE_FACTORIAL_7_FP64 = vec2(1.9841270113829523e-04,  -2.725596874933456e-12); // 1/7!
const vec2 INVERSE_FACTORIAL_8_FP64 = vec2(2.4801587642286904e-05, -3.406996025904184e-13); // 1/8!
const vec2 INVERSE_FACTORIAL_9_FP64 = vec2(2.75573188446287533e-06, 3.7935713937038186e-14); // 1/9!
const vec2 INVERSE_FACTORIAL_10_FP64 = vec2(2.755731998149713e-07, -7.575112367869873e-15); // 1/10!

float nint(float d) {
    if (d == floor(d)) return d;
    return floor(d + 0.5);
}

vec2 nint_fp64(vec2 a) {
    float hi = nint(a.x);
    float lo;
    vec2 tmp;
    if (hi == a.x) {
        lo = nint(a.y);
        tmp = quickTwoSum(hi, lo);
    } else {
        lo = 0.0;
        if (abs(hi - a.x) == 0.5 && a.y < 0.0) {
            hi -= 1.0;
        }
        tmp = vec2(hi, lo);
    }
    return tmp;
}

/* k_power controls how much range reduction we would like to have
Range reduction uses the following method:
assume a = k_power * r + m * log(2), k and m being integers.
Set k_power = 4 (we can choose other k to trade accuracy with performance.
we only need to calculate exp(r) and using exp(a) = 2^m * exp(r)^k_power;
*/

vec2 exp_fp64(vec2 a) {
  // We need to make sure these two numbers match
  // as bit-wise shift is not available in GLSL 1.0
  const int k_power = 4;
  const float k = 16.0;

  const float inv_k = 1.0 / k;

  if (a.x <= -88.0) return vec2(0.0, 0.0);
  if (a.x >= 88.0) return vec2(1.0 / 0.0, 1.0 / 0.0);
  if (a.x == 0.0 && a.y == 0.0) return vec2(1.0, 0.0);
  if (a.x == 1.0 && a.y == 0.0) return E_FP64;

  float m = floor(a.x / LOG2_FP64.x + 0.5);
  vec2 r = sub_fp64(a, mul_fp64(LOG2_FP64, vec2(m, 0.0))) * inv_k;
  vec2 s, t, p;

  p = mul_fp64(r, r);
  s = sum_fp64(r, p * 0.5);
  p = mul_fp64(p, r);
  t = mul_fp64(p, INVERSE_FACTORIAL_3_FP64);

  s = sum_fp64(s, t);
  p = mul_fp64(p, r);
  t = mul_fp64(p, INVERSE_FACTORIAL_4_FP64);

  s = sum_fp64(s, t);
  p = mul_fp64(p, r);
  t = mul_fp64(p, INVERSE_FACTORIAL_5_FP64);

  // s = sum_fp64(s, t);
  // p = mul_fp64(p, r);
  // t = mul_fp64(p, INVERSE_FACTORIAL_6_FP64);

  // s = sum_fp64(s, t);
  // p = mul_fp64(p, r);
  // t = mul_fp64(p, INVERSE_FACTORIAL_7_FP64);

  s = sum_fp64(s, t);


  // At this point, s = exp(r) - 1; but after following 4 recursions, we will get exp(r) ^ 512 - 1.
  for (int i = 0; i < k_power; i++) {
    s = sum_fp64(s * 2.0, mul_fp64(s, s));
  }

#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
  s = sum_fp64(s, vec2(fp64.ONE, 0.0));
#else
  s = sum_fp64(s, vec2(1.0, 0.0));
#endif

  return s * pow(2.0, m);
//   return r;
}

vec2 log_fp64(vec2 a)
{
  if (a.x == 1.0 && a.y == 0.0) return vec2(0.0, 0.0);
  if (a.x <= 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);
  vec2 x = vec2(log(a.x), 0.0);
  vec2 s;
#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
  s = vec2(fp64.ONE, 0.0);
#else
  s = vec2(1.0, 0.0);
#endif

  x = sub_fp64(sum_fp64(x, mul_fp64(a, exp_fp64(-x))), s);
  return x;
}

vec2 sin_taylor_fp64(vec2 a) {
  vec2 r, s, t, x;

  if (a.x == 0.0 && a.y == 0.0) {
    return vec2(0.0, 0.0);
  }

  x = -mul_fp64(a, a);
  s = a;
  r = a;

  r = mul_fp64(r, x);
  t = mul_fp64(r, INVERSE_FACTORIAL_3_FP64);
  s = sum_fp64(s, t);

  r = mul_fp64(r, x);
  t = mul_fp64(r, INVERSE_FACTORIAL_5_FP64);
  s = sum_fp64(s, t);

  /* keep the following commented code in case we need them
  for extra accuracy from the Taylor expansion*/

  // r = mul_fp64(r, x);
  // t = mul_fp64(r, INVERSE_FACTORIAL_7_FP64);
  // s = sum_fp64(s, t);

  // r = mul_fp64(r, x);
  // t = mul_fp64(r, INVERSE_FACTORIAL_9_FP64);
  // s = sum_fp64(s, t);

  return s;
}

vec2 cos_taylor_fp64(vec2 a) {
  vec2 r, s, t, x;

  if (a.x == 0.0 && a.y == 0.0) {
    return vec2(1.0, 0.0);
  }

  x = -mul_fp64(a, a);
  r = x;
  s = sum_fp64(vec2(1.0, 0.0), r * 0.5);

  r = mul_fp64(r, x);
  t = mul_fp64(r, INVERSE_FACTORIAL_4_FP64);
  s = sum_fp64(s, t);

  r = mul_fp64(r, x);
  t = mul_fp64(r, INVERSE_FACTORIAL_6_FP64);
  s = sum_fp64(s, t);

  /* keep the following commented code in case we need them
  for extra accuracy from the Taylor expansion*/

  // r = mul_fp64(r, x);
  // t = mul_fp64(r, INVERSE_FACTORIAL_8_FP64);
  // s = sum_fp64(s, t);

  // r = mul_fp64(r, x);
  // t = mul_fp64(r, INVERSE_FACTORIAL_10_FP64);
  // s = sum_fp64(s, t);

  return s;
}

void sincos_taylor_fp64(vec2 a, out vec2 sin_t, out vec2 cos_t) {
  if (a.x == 0.0 && a.y == 0.0) {
    sin_t = vec2(0.0, 0.0);
    cos_t = vec2(1.0, 0.0);
  }

  sin_t = sin_taylor_fp64(a);
  cos_t = sqrt_fp64(sub_fp64(vec2(1.0, 0.0), mul_fp64(sin_t, sin_t)));
}

vec2 sin_fp64(vec2 a) {
    if (a.x == 0.0 && a.y == 0.0) {
        return vec2(0.0, 0.0);
    }

    // 2pi range reduction
    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));
    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));

    vec2 t;
    float q = floor(r.x / PI_2_FP64.x + 0.5);
    int j = int(q);

    if (j < -2 || j > 2) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    }

    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));

    q = floor(t.x / PI_16_FP64.x + 0.5);
    int k = int(q);

    if (k == 0) {
        if (j == 0) {
            return sin_taylor_fp64(t);
        } else if (j == 1) {
            return cos_taylor_fp64(t);
        } else if (j == -1) {
            return -cos_taylor_fp64(t);
        } else {
            return -sin_taylor_fp64(t);
        }
    }

    int abs_k = int(abs(float(k)));

    if (abs_k > 4) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    } else {
        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));
    }

    vec2 u = vec2(0.0, 0.0);
    vec2 v = vec2(0.0, 0.0);

#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
    if (abs(float(abs_k) - 1.0) < 0.5) {
        u = COS_TABLE_0_FP64;
        v = SIN_TABLE_0_FP64;
    } else if (abs(float(abs_k) - 2.0) < 0.5) {
        u = COS_TABLE_1_FP64;
        v = SIN_TABLE_1_FP64;
    } else if (abs(float(abs_k) - 3.0) < 0.5) {
        u = COS_TABLE_2_FP64;
        v = SIN_TABLE_2_FP64;
    } else if (abs(float(abs_k) - 4.0) < 0.5) {
        u = COS_TABLE_3_FP64;
        v = SIN_TABLE_3_FP64;
    }
#else
    if (abs_k == 1) {
        u = COS_TABLE_0_FP64;
        v = SIN_TABLE_0_FP64;
    } else if (abs_k == 2) {
        u = COS_TABLE_1_FP64;
        v = SIN_TABLE_1_FP64;
    } else if (abs_k == 3) {
        u = COS_TABLE_2_FP64;
        v = SIN_TABLE_2_FP64;
    } else if (abs_k == 4) {
        u = COS_TABLE_3_FP64;
        v = SIN_TABLE_3_FP64;
    }
#endif

    vec2 sin_t, cos_t;
    sincos_taylor_fp64(t, sin_t, cos_t);



    vec2 result = vec2(0.0, 0.0);
    if (j == 0) {
        if (k > 0) {
            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        } else {
            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        }
    } else if (j == 1) {
        if (k > 0) {
            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        } else {
            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        }
    } else if (j == -1) {
        if (k > 0) {
            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));
        } else {
            result = -sum_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));
        }
    } else {
        if (k > 0) {
            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        } else {
            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));
        }
    }

    return result;
}

vec2 cos_fp64(vec2 a) {
    if (a.x == 0.0 && a.y == 0.0) {
        return vec2(1.0, 0.0);
    }

    // 2pi range reduction
    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));
    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));

    vec2 t;
    float q = floor(r.x / PI_2_FP64.x + 0.5);
    int j = int(q);

    if (j < -2 || j > 2) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    }

    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));

    q = floor(t.x / PI_16_FP64.x + 0.5);
    int k = int(q);

    if (k == 0) {
        if (j == 0) {
            return cos_taylor_fp64(t);
        } else if (j == 1) {
            return -sin_taylor_fp64(t);
        } else if (j == -1) {
            return sin_taylor_fp64(t);
        } else {
            return -cos_taylor_fp64(t);
        }
    }

    int abs_k = int(abs(float(k)));

    if (abs_k > 4) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    } else {
        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));
    }

    vec2 u = vec2(0.0, 0.0);
    vec2 v = vec2(0.0, 0.0);

#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
    if (abs(float(abs_k) - 1.0) < 0.5) {
        u = COS_TABLE_0_FP64;
        v = SIN_TABLE_0_FP64;
    } else if (abs(float(abs_k) - 2.0) < 0.5) {
        u = COS_TABLE_1_FP64;
        v = SIN_TABLE_1_FP64;
    } else if (abs(float(abs_k) - 3.0) < 0.5) {
        u = COS_TABLE_2_FP64;
        v = SIN_TABLE_2_FP64;
    } else if (abs(float(abs_k) - 4.0) < 0.5) {
        u = COS_TABLE_3_FP64;
        v = SIN_TABLE_3_FP64;
    }
#else
    if (abs_k == 1) {
        u = COS_TABLE_0_FP64;
        v = SIN_TABLE_0_FP64;
    } else if (abs_k == 2) {
        u = COS_TABLE_1_FP64;
        v = SIN_TABLE_1_FP64;
    } else if (abs_k == 3) {
        u = COS_TABLE_2_FP64;
        v = SIN_TABLE_2_FP64;
    } else if (abs_k == 4) {
        u = COS_TABLE_3_FP64;
        v = SIN_TABLE_3_FP64;
    }
#endif

    vec2 sin_t, cos_t;
    sincos_taylor_fp64(t, sin_t, cos_t);

    vec2 result = vec2(0.0, 0.0);
    if (j == 0) {
        if (k > 0) {
            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        } else {
            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        }
    } else if (j == 1) {
        if (k > 0) {
            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        } else {
            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));
        }
    } else if (j == -1) {
        if (k > 0) {
            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        } else {
            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        }
    } else {
        if (k > 0) {
            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));
        } else {
            result = -sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        }
    }

    return result;
}

vec2 tan_fp64(vec2 a) {
    vec2 sin_a;
    vec2 cos_a;

    if (a.x == 0.0 && a.y == 0.0) {
        return vec2(0.0, 0.0);
    }

    // 2pi range reduction
    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));
    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));

    vec2 t;
    float q = floor(r.x / PI_2_FP64.x + 0.5);
    int j = int(q);


    if (j < -2 || j > 2) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    }

    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));

    q = floor(t.x / PI_16_FP64.x + 0.5);
    int k = int(q);
    int abs_k = int(abs(float(k)));

    // We just can't get PI/16 * 3.0 very accurately.
    // so let's just store it
    if (abs_k > 4) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    } else {
        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));
    }


    vec2 u = vec2(0.0, 0.0);
    vec2 v = vec2(0.0, 0.0);

    vec2 sin_t, cos_t;
    vec2 s, c;
    sincos_taylor_fp64(t, sin_t, cos_t);

    if (k == 0) {
        s = sin_t;
        c = cos_t;
    } else {
#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
        if (abs(float(abs_k) - 1.0) < 0.5) {
            u = COS_TABLE_0_FP64;
            v = SIN_TABLE_0_FP64;
        } else if (abs(float(abs_k) - 2.0) < 0.5) {
            u = COS_TABLE_1_FP64;
            v = SIN_TABLE_1_FP64;
        } else if (abs(float(abs_k) - 3.0) < 0.5) {
            u = COS_TABLE_2_FP64;
            v = SIN_TABLE_2_FP64;
        } else if (abs(float(abs_k) - 4.0) < 0.5) {
            u = COS_TABLE_3_FP64;
            v = SIN_TABLE_3_FP64;
        }
#else
        if (abs_k == 1) {
            u = COS_TABLE_0_FP64;
            v = SIN_TABLE_0_FP64;
        } else if (abs_k == 2) {
            u = COS_TABLE_1_FP64;
            v = SIN_TABLE_1_FP64;
        } else if (abs_k == 3) {
            u = COS_TABLE_2_FP64;
            v = SIN_TABLE_2_FP64;
        } else if (abs_k == 4) {
            u = COS_TABLE_3_FP64;
            v = SIN_TABLE_3_FP64;
        }
#endif
        if (k > 0) {
            s = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
            c = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        } else {
            s = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
            c = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        }
    }

    if (j == 0) {
        sin_a = s;
        cos_a = c;
    } else if (j == 1) {
        sin_a = c;
        cos_a = -s;
    } else if (j == -1) {
        sin_a = -c;
        cos_a = s;
    } else {
        sin_a = -s;
        cos_a = -c;
    }
    return div_fp64(sin_a, cos_a);
}

vec2 radians_fp64(vec2 degree) {
  return mul_fp64(degree, PI_180_FP64);
}

vec2 mix_fp64(vec2 a, vec2 b, float x) {
  vec2 range = sub_fp64(b, a);
  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));
}

// Vector functions
// vec2 functions
void vec2_sum_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
    out_val[0] = sum_fp64(a[0], b[0]);
    out_val[1] = sum_fp64(a[1], b[1]);
}

void vec2_sub_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
    out_val[0] = sub_fp64(a[0], b[0]);
    out_val[1] = sub_fp64(a[1], b[1]);
}

void vec2_mul_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
    out_val[0] = mul_fp64(a[0], b[0]);
    out_val[1] = mul_fp64(a[1], b[1]);
}

void vec2_div_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
    out_val[0] = div_fp64(a[0], b[0]);
    out_val[1] = div_fp64(a[1], b[1]);
}

void vec2_mix_fp64(vec2 x[2], vec2 y[2], float a, out vec2 out_val[2]) {
  vec2 range[2];
  vec2_sub_fp64(y, x, range);
  vec2 portion[2];
  portion[0] = range[0] * a;
  portion[1] = range[1] * a;
  vec2_sum_fp64(x, portion, out_val);
}

vec2 vec2_length_fp64(vec2 x[2]) {
  return sqrt_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])));
}

void vec2_normalize_fp64(vec2 x[2], out vec2 out_val[2]) {
  vec2 length = vec2_length_fp64(x);
  vec2 length_vec2[2];
  length_vec2[0] = length;
  length_vec2[1] = length;

  vec2_div_fp64(x, length_vec2, out_val);
}

vec2 vec2_distance_fp64(vec2 x[2], vec2 y[2]) {
  vec2 diff[2];
  vec2_sub_fp64(x, y, diff);
  return vec2_length_fp64(diff);
}

vec2 vec2_dot_fp64(vec2 a[2], vec2 b[2]) {
  vec2 v[2];

  v[0] = mul_fp64(a[0], b[0]);
  v[1] = mul_fp64(a[1], b[1]);

  return sum_fp64(v[0], v[1]);
}

// vec3 functions
void vec3_sub_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {
  for (int i = 0; i < 3; i++) {
    out_val[i] = sum_fp64(a[i], b[i]);
  }
}

void vec3_sum_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {
  for (int i = 0; i < 3; i++) {
    out_val[i] = sum_fp64(a[i], b[i]);
  }
}

vec2 vec3_length_fp64(vec2 x[3]) {
  return sqrt_fp64(sum_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])),
    mul_fp64(x[2], x[2])));
}

vec2 vec3_distance_fp64(vec2 x[3], vec2 y[3]) {
  vec2 diff[3];
  vec3_sub_fp64(x, y, diff);
  return vec3_length_fp64(diff);
}

// vec4 functions
void vec4_fp64(vec4 a, out vec2 out_val[4]) {
  out_val[0].x = a[0];
  out_val[0].y = 0.0;

  out_val[1].x = a[1];
  out_val[1].y = 0.0;

  out_val[2].x = a[2];
  out_val[2].y = 0.0;

  out_val[3].x = a[3];
  out_val[3].y = 0.0;
}

void vec4_scalar_mul_fp64(vec2 a[4], vec2 b, out vec2 out_val[4]) {
  out_val[0] = mul_fp64(a[0], b);
  out_val[1] = mul_fp64(a[1], b);
  out_val[2] = mul_fp64(a[2], b);
  out_val[3] = mul_fp64(a[3], b);
}

void vec4_sum_fp64(vec2 a[4], vec2 b[4], out vec2 out_val[4]) {
  for (int i = 0; i < 4; i++) {
    out_val[i] = sum_fp64(a[i], b[i]);
  }
}

void vec4_dot_fp64(vec2 a[4], vec2 b[4], out vec2 out_val) {
  vec2 v[4];

  v[0] = mul_fp64(a[0], b[0]);
  v[1] = mul_fp64(a[1], b[1]);
  v[2] = mul_fp64(a[2], b[2]);
  v[3] = mul_fp64(a[3], b[3]);

  out_val = sum_fp64(sum_fp64(v[0], v[1]), sum_fp64(v[2], v[3]));
}

void mat4_vec4_mul_fp64(vec2 b[16], vec2 a[4], out vec2 out_val[4]) {
  vec2 tmp[4];

  for (int i = 0; i < 4; i++)
  {
    for (int j = 0; j < 4; j++)
    {
      tmp[j] = b[j + i * 4];
    }
    vec4_dot_fp64(a, tmp, out_val[i]);
  }
}
`; //# sourceMappingURL=fp64-functions-glsl.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/modules/math/fp64/fp64.js [client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "fp64": (()=>fp64),
    "fp64arithmetic": (()=>fp64arithmetic)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$math$2f$fp64$2f$fp64$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/shadertools/dist/modules/math/fp64/fp64-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$math$2f$fp64$2f$fp64$2d$arithmetic$2d$glsl$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/shadertools/dist/modules/math/fp64/fp64-arithmetic-glsl.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$math$2f$fp64$2f$fp64$2d$functions$2d$glsl$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/shadertools/dist/modules/math/fp64/fp64-functions-glsl.js [client] (ecmascript)");
;
;
;
const defaultUniforms = {
    // Used in LUMA_FP64_CODE_ELIMINATION_WORKAROUND
    ONE: 1.0
};
const fp64arithmetic = {
    name: 'fp64arithmetic',
    vs: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$math$2f$fp64$2f$fp64$2d$arithmetic$2d$glsl$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fp64arithmeticShader"],
    defaultUniforms,
    uniformTypes: {
        ONE: 'f32'
    },
    // Additional Functions
    fp64ify: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$math$2f$fp64$2f$fp64$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fp64ify"],
    fp64LowPart: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$math$2f$fp64$2f$fp64$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fp64LowPart"],
    fp64ifyMatrix4: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$math$2f$fp64$2f$fp64$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fp64ifyMatrix4"]
};
const fp64 = {
    name: 'fp64',
    vs: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$math$2f$fp64$2f$fp64$2d$functions$2d$glsl$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fp64functionShader"],
    dependencies: [
        fp64arithmetic
    ],
    // Additional Functions
    fp64ify: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$math$2f$fp64$2f$fp64$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fp64ify"],
    fp64LowPart: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$math$2f$fp64$2f$fp64$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fp64LowPart"],
    fp64ifyMatrix4: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$math$2f$fp64$2f$fp64$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fp64ifyMatrix4"]
};
;
 //# sourceMappingURL=fp64.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/modules/engine/picking/picking.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// cyan color
__turbopack_context__.s({
    "picking": (()=>picking)
});
const DEFAULT_HIGHLIGHT_COLOR = [
    0,
    1,
    1,
    1
];
const vs = /* glsl */ `\
uniform pickingUniforms {
  float isActive;
  float isAttribute;
  float isHighlightActive;
  float useFloatColors;
  vec3 highlightedObjectColor;
  vec4 highlightColor;
} picking;

out vec4 picking_vRGBcolor_Avalid;

// Normalize unsigned byte color to 0-1 range
vec3 picking_normalizeColor(vec3 color) {
  return picking.useFloatColors > 0.5 ? color : color / 255.0;
}

// Normalize unsigned byte color to 0-1 range
vec4 picking_normalizeColor(vec4 color) {
  return picking.useFloatColors > 0.5 ? color : color / 255.0;
}

bool picking_isColorZero(vec3 color) {
  return dot(color, vec3(1.0)) < 0.00001;
}

bool picking_isColorValid(vec3 color) {
  return dot(color, vec3(1.0)) > 0.00001;
}

// Check if this vertex is highlighted 
bool isVertexHighlighted(vec3 vertexColor) {
  vec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);
  return
    bool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));
}

// Set the current picking color
void picking_setPickingColor(vec3 pickingColor) {
  pickingColor = picking_normalizeColor(pickingColor);

  if (bool(picking.isActive)) {
    // Use alpha as the validity flag. If pickingColor is [0, 0, 0] fragment is non-pickable
    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));

    if (!bool(picking.isAttribute)) {
      // Stores the picking color so that the fragment shader can render it during picking
      picking_vRGBcolor_Avalid.rgb = pickingColor;
    }
  } else {
    // Do the comparison with selected item color in vertex shader as it should mean fewer compares
    picking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));
  }
}

void picking_setPickingAttribute(float value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.r = value;
  }
}

void picking_setPickingAttribute(vec2 value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.rg = value;
  }
}

void picking_setPickingAttribute(vec3 value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.rgb = value;
  }
}
`;
const fs = /* glsl */ `\
uniform pickingUniforms {
  float isActive;
  float isAttribute;
  float isHighlightActive;
  float useFloatColors;
  vec3 highlightedObjectColor;
  vec4 highlightColor;
} picking;

in vec4 picking_vRGBcolor_Avalid;

/*
 * Returns highlight color if this item is selected.
 */
vec4 picking_filterHighlightColor(vec4 color) {
  // If we are still picking, we don't highlight
  if (picking.isActive > 0.5) {
    return color;
  }

  bool selected = bool(picking_vRGBcolor_Avalid.a);

  if (selected) {
    // Blend in highlight color based on its alpha value
    float highLightAlpha = picking.highlightColor.a;
    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);
    float highLightRatio = highLightAlpha / blendedAlpha;

    vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);
    return vec4(blendedRGB, blendedAlpha);
  } else {
    return color;
  }
}

/*
 * Returns picking color if picking enabled else unmodified argument.
 */
vec4 picking_filterPickingColor(vec4 color) {
  if (bool(picking.isActive)) {
    if (picking_vRGBcolor_Avalid.a == 0.0) {
      discard;
    }
    return picking_vRGBcolor_Avalid;
  }
  return color;
}

/*
 * Returns picking color if picking is enabled if not
 * highlight color if this item is selected, otherwise unmodified argument.
 */
vec4 picking_filterColor(vec4 color) {
  vec4 highlightColor = picking_filterHighlightColor(color);
  return picking_filterPickingColor(highlightColor);
}
`;
const picking = {
    props: {},
    uniforms: {},
    name: 'picking',
    uniformTypes: {
        isActive: 'f32',
        isAttribute: 'f32',
        isHighlightActive: 'f32',
        useFloatColors: 'f32',
        highlightedObjectColor: 'vec3<f32>',
        highlightColor: 'vec4<f32>'
    },
    defaultUniforms: {
        isActive: false,
        isAttribute: false,
        isHighlightActive: false,
        useFloatColors: true,
        highlightedObjectColor: [
            0,
            0,
            0
        ],
        highlightColor: DEFAULT_HIGHLIGHT_COLOR
    },
    vs,
    fs,
    getUniforms
};
function getUniforms(opts = {}, prevUniforms) {
    const uniforms = {};
    if (opts.highlightedObjectColor === undefined) {
    // Unless highlightedObjectColor explicitly null or set, do not update state
    } else if (opts.highlightedObjectColor === null) {
        uniforms.isHighlightActive = false;
    } else {
        uniforms.isHighlightActive = true;
        const highlightedObjectColor = opts.highlightedObjectColor.slice(0, 3);
        uniforms.highlightedObjectColor = highlightedObjectColor;
    }
    if (opts.highlightColor) {
        const color = Array.from(opts.highlightColor, (x)=>x / 255);
        if (!Number.isFinite(color[3])) {
            color[3] = 1;
        }
        uniforms.highlightColor = color;
    }
    if (opts.isActive !== undefined) {
        uniforms.isActive = Boolean(opts.isActive);
        uniforms.isAttribute = Boolean(opts.isAttribute);
    }
    if (opts.useFloatColors !== undefined) {
        uniforms.useFloatColors = Boolean(opts.useFloatColors);
    }
    return uniforms;
} //# sourceMappingURL=picking.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/modules/lighting/lights/lighting-uniforms-glsl.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "lightingUniformsGLSL": (()=>lightingUniformsGLSL)
});
const lightingUniformsGLSL = /* glsl */ `\
precision highp int;

// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))
struct AmbientLight {
  vec3 color;
};

struct PointLight {
  vec3 color;
  vec3 position;
  vec3 attenuation; // 2nd order x:Constant-y:Linear-z:Exponential
};

struct DirectionalLight {
  vec3 color;
  vec3 direction;
};

uniform lightingUniforms {
  int enabled;
  int lightType;

  int directionalLightCount;
  int pointLightCount;

  vec3 ambientColor;

  vec3 lightColor0;
  vec3 lightPosition0;
  vec3 lightDirection0;
  vec3 lightAttenuation0;

  vec3 lightColor1;
  vec3 lightPosition1;
  vec3 lightDirection1;
  vec3 lightAttenuation1;

  vec3 lightColor2;
  vec3 lightPosition2;
  vec3 lightDirection2;
  vec3 lightAttenuation2;
} lighting;

PointLight lighting_getPointLight(int index) {
  switch (index) {
    case 0:
      return PointLight(lighting.lightColor0, lighting.lightPosition0, lighting.lightAttenuation0);
    case 1:
      return PointLight(lighting.lightColor1, lighting.lightPosition1, lighting.lightAttenuation1);
    case 2:
    default:  
      return PointLight(lighting.lightColor2, lighting.lightPosition2, lighting.lightAttenuation2);
  }
}

DirectionalLight lighting_getDirectionalLight(int index) {
  switch (index) {
    case 0:
      return DirectionalLight(lighting.lightColor0, lighting.lightDirection0);
    case 1:
      return DirectionalLight(lighting.lightColor1, lighting.lightDirection1);
    case 2:
    default:   
      return DirectionalLight(lighting.lightColor2, lighting.lightDirection2);
  }
} 

float getPointLightAttenuation(PointLight pointLight, float distance) {
  return pointLight.attenuation.x
       + pointLight.attenuation.y * distance
       + pointLight.attenuation.z * distance * distance;
}

// #endif
`; //# sourceMappingURL=lighting-uniforms-glsl.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/modules/lighting/lights/lighting-uniforms-wgsl.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "lightingUniformsWGSL": (()=>lightingUniformsWGSL)
});
const lightingUniformsWGSL = /* wgsl */ `\
// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))
struct AmbientLight {
  color: vec3<f32>,
};

struct PointLight {
  color: vec3<f32>,
  position: vec3<f32>,
  attenuation: vec3<f32>, // 2nd order x:Constant-y:Linear-z:Exponential
};

struct DirectionalLight {
  color: vec3<f32>,
  direction: vec3<f32>,
};

struct lightingUniforms {
  enabled: i32,
  poightCount: i32,
  directionalLightCount: i32,

  ambientColor: vec3<f32>,

  // TODO - support multiple lights by uncommenting arrays below
  lightType: i32,
  lightColor: vec3<f32>,
  lightDirection: vec3<f32>,
  lightPosition: vec3<f32>,
  lightAttenuation: vec3<f32>,

  // AmbientLight ambientLight;
  // PointLight pointLight[MAX_LIGHTS];
  // DirectionalLight directionalLight[MAX_LIGHTS];
};

// Binding 0:1 is reserved for lighting (Note: could go into separate bind group as it is stable across draw calls)
@binding(1) @group(0) var<uniform> lighting : lightingUniforms;

fn lighting_getPointLight(index: i32) -> PointLight {
  return PointLight(lighting.lightColor, lighting.lightPosition, lighting.lightAttenuation);
}

fn lighting_getDirectionalLight(index: i32) -> DirectionalLight {
  return DirectionalLight(lighting.lightColor, lighting.lightDirection);
} 

fn getPointLightAttenuation(pointLight: PointLight, distance: f32) -> f32 {
  return pointLight.attenuation.x
       + pointLight.attenuation.y * distance
       + pointLight.attenuation.z * distance * distance;
}
`; //# sourceMappingURL=lighting-uniforms-wgsl.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/modules/lighting/lights/lighting.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "LIGHT_TYPE": (()=>LIGHT_TYPE),
    "lighting": (()=>lighting)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/core/dist/utils/log.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$lighting$2f$lights$2f$lighting$2d$uniforms$2d$glsl$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/shadertools/dist/modules/lighting/lights/lighting-uniforms-glsl.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$lighting$2f$lights$2f$lighting$2d$uniforms$2d$wgsl$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/shadertools/dist/modules/lighting/lights/lighting-uniforms-wgsl.js [client] (ecmascript)");
;
;
;
/** Max number of supported lights (in addition to ambient light */ const MAX_LIGHTS = 3;
/** Whether to divide */ const COLOR_FACTOR = 255.0;
var LIGHT_TYPE;
(function(LIGHT_TYPE) {
    LIGHT_TYPE[LIGHT_TYPE["POINT"] = 0] = "POINT";
    LIGHT_TYPE[LIGHT_TYPE["DIRECTIONAL"] = 1] = "DIRECTIONAL";
})(LIGHT_TYPE || (LIGHT_TYPE = {}));
const lighting = {
    props: {},
    uniforms: {},
    name: 'lighting',
    defines: {
        MAX_LIGHTS
    },
    uniformTypes: {
        enabled: 'i32',
        lightType: 'i32',
        directionalLightCount: 'i32',
        pointLightCount: 'i32',
        ambientLightColor: 'vec3<f32>',
        // TODO define as arrays once we have appropriate uniformTypes
        lightColor0: 'vec3<f32>',
        lightPosition0: 'vec3<f32>',
        // TODO - could combine direction and attenuation
        lightDirection0: 'vec3<f32>',
        lightAttenuation0: 'vec3<f32>',
        lightColor1: 'vec3<f32>',
        lightPosition1: 'vec3<f32>',
        lightDirection1: 'vec3<f32>',
        lightAttenuation1: 'vec3<f32>',
        lightColor2: 'vec3<f32>',
        lightPosition2: 'vec3<f32>',
        lightDirection2: 'vec3<f32>',
        lightAttenuation2: 'vec3<f32>'
    },
    defaultUniforms: {
        enabled: 1,
        lightType: LIGHT_TYPE.POINT,
        directionalLightCount: 0,
        pointLightCount: 0,
        ambientLightColor: [
            0.1,
            0.1,
            0.1
        ],
        lightColor0: [
            1,
            1,
            1
        ],
        lightPosition0: [
            1,
            1,
            2
        ],
        // TODO - could combine direction and attenuation
        lightDirection0: [
            1,
            1,
            1
        ],
        lightAttenuation0: [
            1,
            0,
            0
        ],
        lightColor1: [
            1,
            1,
            1
        ],
        lightPosition1: [
            1,
            1,
            2
        ],
        lightDirection1: [
            1,
            1,
            1
        ],
        lightAttenuation1: [
            1,
            0,
            0
        ],
        lightColor2: [
            1,
            1,
            1
        ],
        lightPosition2: [
            1,
            1,
            2
        ],
        lightDirection2: [
            1,
            1,
            1
        ],
        lightAttenuation2: [
            1,
            0,
            0
        ]
    },
    source: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$lighting$2f$lights$2f$lighting$2d$uniforms$2d$wgsl$2e$js__$5b$client$5d$__$28$ecmascript$29$__["lightingUniformsWGSL"],
    vs: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$lighting$2f$lights$2f$lighting$2d$uniforms$2d$glsl$2e$js__$5b$client$5d$__$28$ecmascript$29$__["lightingUniformsGLSL"],
    fs: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$lighting$2f$lights$2f$lighting$2d$uniforms$2d$glsl$2e$js__$5b$client$5d$__$28$ecmascript$29$__["lightingUniformsGLSL"],
    getUniforms
};
function getUniforms(props, prevUniforms = {}) {
    // Copy props so we can modify
    props = props ? {
        ...props
    } : props;
    // TODO legacy
    if (!props) {
        return {
            ...lighting.defaultUniforms
        };
    }
    // Support for array of lights. Type of light is detected by type field
    if (props.lights) {
        props = {
            ...props,
            ...extractLightTypes(props.lights),
            lights: undefined
        };
    }
    // Specify lights separately
    const { ambientLight, pointLights, directionalLights } = props || {};
    const hasLights = ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0;
    // TODO - this may not be the correct decision
    if (!hasLights) {
        return {
            ...lighting.defaultUniforms,
            enabled: 0
        };
    }
    const uniforms = {
        ...lighting.defaultUniforms,
        ...prevUniforms,
        ...getLightSourceUniforms({
            ambientLight,
            pointLights,
            directionalLights
        })
    };
    if (props.enabled !== undefined) {
        uniforms.enabled = props.enabled ? 1 : 0;
    }
    return uniforms;
}
function getLightSourceUniforms({ ambientLight, pointLights = [], directionalLights = [] }) {
    const lightSourceUniforms = {};
    lightSourceUniforms.ambientLightColor = convertColor(ambientLight);
    let currentLight = 0;
    for (const pointLight of pointLights){
        lightSourceUniforms.lightType = LIGHT_TYPE.POINT;
        const i = currentLight;
        lightSourceUniforms[`lightColor${i}`] = convertColor(pointLight);
        lightSourceUniforms[`lightPosition${i}`] = pointLight.position;
        lightSourceUniforms[`lightAttenuation${i}`] = pointLight.attenuation || [
            1,
            0,
            0
        ];
        currentLight++;
    }
    for (const directionalLight of directionalLights){
        lightSourceUniforms.lightType = LIGHT_TYPE.DIRECTIONAL;
        const i = currentLight;
        lightSourceUniforms[`lightColor${i}`] = convertColor(directionalLight);
        lightSourceUniforms[`lightDirection${i}`] = directionalLight.direction;
        currentLight++;
    }
    if (currentLight > MAX_LIGHTS) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$core$2f$dist$2f$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].warn('MAX_LIGHTS exceeded')();
    }
    lightSourceUniforms.directionalLightCount = directionalLights.length;
    lightSourceUniforms.pointLightCount = pointLights.length;
    return lightSourceUniforms;
}
function extractLightTypes(lights) {
    const lightSources = {
        pointLights: [],
        directionalLights: []
    };
    for (const light of lights || []){
        switch(light.type){
            case 'ambient':
                // Note: Only uses last ambient light
                // TODO - add ambient light sources on CPU?
                lightSources.ambientLight = light;
                break;
            case 'directional':
                lightSources.directionalLights?.push(light);
                break;
            case 'point':
                lightSources.pointLights?.push(light);
                break;
            default:
        }
    }
    return lightSources;
}
/** Take color 0-255 and intensity as input and output 0.0-1.0 range */ function convertColor(colorDef = {}) {
    const { color = [
        0,
        0,
        0
    ], intensity = 1.0 } = colorDef;
    return color.map((component)=>component * intensity / COLOR_FACTOR);
} //# sourceMappingURL=lighting.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/modules/lighting/phong-material/phong-shaders-glsl.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "PHONG_FS": (()=>PHONG_FS),
    "PHONG_VS": (()=>PHONG_VS)
});
const PHONG_VS = /* glsl */ `\
uniform phongMaterialUniforms {
  uniform float ambient;
  uniform float diffuse;
  uniform float shininess;
  uniform vec3  specularColor;
} material;
`;
const PHONG_FS = /* glsl */ `\
uniform phongMaterialUniforms {
  uniform float ambient;
  uniform float diffuse;
  uniform float shininess;
  uniform vec3  specularColor;
} material;

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {
  vec3 halfway_direction = normalize(light_direction + view_direction);
  float lambertian = dot(light_direction, normal_worldspace);
  float specular = 0.0;
  if (lambertian > 0.0) {
    float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
    specular = pow(specular_angle, material.shininess);
  }
  lambertian = max(lambertian, 0.0);
  return (lambertian * material.diffuse * surfaceColor + specular * material.specularColor) * color;
}

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
  vec3 lightColor = surfaceColor;

  if (lighting.enabled == 0) {
    return lightColor;
  }

  vec3 view_direction = normalize(cameraPosition - position_worldspace);
  lightColor = material.ambient * surfaceColor * lighting.ambientColor;

  for (int i = 0; i < lighting.pointLightCount; i++) {
    PointLight pointLight = lighting_getPointLight(i);
    vec3 light_position_worldspace = pointLight.position;
    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
    float light_attenuation = getPointLightAttenuation(pointLight, distance(light_position_worldspace, position_worldspace));
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color / light_attenuation);
  }

  int totalLights = min(MAX_LIGHTS, lighting.pointLightCount + lighting.directionalLightCount);
  for (int i = lighting.pointLightCount; i < totalLights; i++) {
    DirectionalLight directionalLight = lighting_getDirectionalLight(i);
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  
  return lightColor;
}
`; //# sourceMappingURL=phong-shaders-glsl.js.map
}}),
"[project]/node_modules/@luma.gl/shadertools/dist/modules/lighting/gouraud-material/gouraud-material.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "gouraudMaterial": (()=>gouraudMaterial)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$lighting$2f$lights$2f$lighting$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/shadertools/dist/modules/lighting/lights/lighting.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$lighting$2f$phong$2d$material$2f$phong$2d$shaders$2d$glsl$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@luma.gl/shadertools/dist/modules/lighting/phong-material/phong-shaders-glsl.js [client] (ecmascript)");
;
;
const gouraudMaterial = {
    props: {},
    name: 'gouraudMaterial',
    // Note these are switched between phong and gouraud
    vs: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$lighting$2f$phong$2d$material$2f$phong$2d$shaders$2d$glsl$2e$js__$5b$client$5d$__$28$ecmascript$29$__["PHONG_FS"].replace('phongMaterial', 'gouraudMaterial'),
    fs: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$lighting$2f$phong$2d$material$2f$phong$2d$shaders$2d$glsl$2e$js__$5b$client$5d$__$28$ecmascript$29$__["PHONG_VS"].replace('phongMaterial', 'gouraudMaterial'),
    defines: {
        LIGHTING_VERTEX: 1
    },
    dependencies: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$luma$2e$gl$2f$shadertools$2f$dist$2f$modules$2f$lighting$2f$lights$2f$lighting$2e$js__$5b$client$5d$__$28$ecmascript$29$__["lighting"]
    ],
    uniformTypes: {
        ambient: 'f32',
        diffuse: 'f32',
        shininess: 'f32',
        specularColor: 'vec3<f32>'
    },
    defaultUniforms: {
        ambient: 0.35,
        diffuse: 0.6,
        shininess: 32,
        specularColor: [
            0.15,
            0.15,
            0.15
        ]
    },
    getUniforms (props) {
        const uniforms = {
            ...props
        };
        if (uniforms.specularColor) {
            uniforms.specularColor = uniforms.specularColor.map((x)=>x / 255);
        }
        return {
            ...gouraudMaterial.defaultUniforms,
            ...uniforms
        };
    }
}; //# sourceMappingURL=gouraud-material.js.map
}}),
"[project]/node_modules/@probe.gl/env/dist/index.js [client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Extract injected version from package.json (injected by babel plugin)
// @ts-expect-error
__turbopack_context__.s({
    "VERSION": (()=>VERSION)
});
const VERSION = typeof "4.1.0" !== 'undefined' ? "4.1.0" : 'untranspiled source';
;
;
;
;
;
 // TODO - wish we could just export a constant
 // export const isBrowser = checkIfBrowser();
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@probe.gl/env/dist/lib/is-electron.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// based on https://github.com/cheton/is-electron
// https://github.com/electron/electron/issues/2288
/* eslint-disable complexity */ __turbopack_context__.s({
    "isElectron": (()=>isElectron)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
function isElectron(mockUserAgent) {
    // Renderer process
    // @ts-expect-error
    if (typeof window !== 'undefined' && window.process?.type === 'renderer') {
        return true;
    }
    // Main process
    // eslint-disable-next-line
    if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"] !== 'undefined' && Boolean(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].versions?.['electron'])) {
        return true;
    }
    // Detect the user agent when the `nodeIntegration` option is set to true
    const realUserAgent = typeof navigator !== 'undefined' && navigator.userAgent;
    const userAgent = mockUserAgent || realUserAgent;
    return Boolean(userAgent && userAgent.indexOf('Electron') >= 0);
} //# sourceMappingURL=is-electron.js.map
}}),
"[project]/node_modules/@probe.gl/env/dist/lib/is-browser.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// This function is needed in initialization stages,
// make sure it can be imported in isolation
__turbopack_context__.s({
    "isBrowser": (()=>isBrowser)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$is$2d$electron$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/env/dist/lib/is-electron.js [client] (ecmascript)");
;
function isBrowser() {
    const isNode = // @ts-expect-error
    typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"] === 'object' && String(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"]) === '[object process]' && !("TURBOPACK compile-time value", true);
    return !isNode || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$is$2d$electron$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isElectron"])();
} //# sourceMappingURL=is-browser.js.map
}}),
"[project]/node_modules/@probe.gl/env/dist/lib/globals.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Do not name these variables the same as the global objects - will break bundling
__turbopack_context__.s({
    "console": (()=>console_),
    "document": (()=>document_),
    "global": (()=>global_),
    "navigator": (()=>navigator_),
    "process": (()=>process_),
    "self": (()=>global_),
    "window": (()=>window_)
});
const global_ = globalThis;
const window_ = globalThis;
const document_ = globalThis.document || {};
const process_ = globalThis.process || {};
const console_ = globalThis.console;
const navigator_ = globalThis.navigator || {};
;
 //# sourceMappingURL=globals.js.map
}}),
"[project]/node_modules/@probe.gl/env/dist/lib/get-browser.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
// This function is needed in initialization stages,
// make sure it can be imported in isolation
__turbopack_context__.s({
    "getBrowser": (()=>getBrowser),
    "isMobile": (()=>isMobile)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$is$2d$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/env/dist/lib/is-browser.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$is$2d$electron$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/env/dist/lib/is-electron.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/env/dist/lib/globals.js [client] (ecmascript)");
;
;
;
function isMobile() {
    return typeof globalThis.orientation !== 'undefined';
}
function getBrowser(mockUserAgent) {
    if (!mockUserAgent && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$is$2d$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBrowser"])()) {
        return 'Node';
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$is$2d$electron$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isElectron"])(mockUserAgent)) {
        return 'Electron';
    }
    const userAgent = mockUserAgent || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__["navigator"].userAgent || '';
    // NOTE: Order of tests matter, as many agents list Chrome etc.
    if (userAgent.indexOf('Edge') > -1) {
        return 'Edge';
    }
    if (globalThis.chrome) {
        return 'Chrome';
    }
    if (globalThis.safari) {
        return 'Safari';
    }
    if (globalThis.mozInnerScreenX) {
        return 'Firefox';
    }
    return 'Unknown';
} //# sourceMappingURL=get-browser.js.map
}}),
"[project]/node_modules/@probe.gl/log/dist/utils/local-storage.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// probe.gl, MIT license
__turbopack_context__.s({
    "LocalStorage": (()=>LocalStorage)
});
function getStorage(type) {
    try {
        const storage = window[type];
        const x = '__storage_test__';
        storage.setItem(x, x);
        storage.removeItem(x);
        return storage;
    } catch (e) {
        return null;
    }
}
class LocalStorage {
    constructor(id, defaultConfig, type = 'sessionStorage'){
        this.storage = getStorage(type);
        this.id = id;
        this.config = defaultConfig;
        this._loadConfiguration();
    }
    getConfiguration() {
        return this.config;
    }
    setConfiguration(configuration) {
        Object.assign(this.config, configuration);
        if (this.storage) {
            const serialized = JSON.stringify(this.config);
            this.storage.setItem(this.id, serialized);
        }
    }
    // Get config from persistent store, if available
    _loadConfiguration() {
        let configuration = {};
        if (this.storage) {
            const serializedConfiguration = this.storage.getItem(this.id);
            configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
        }
        Object.assign(this.config, configuration);
        return this;
    }
} //# sourceMappingURL=local-storage.js.map
}}),
"[project]/node_modules/@probe.gl/log/dist/utils/formatters.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// probe.gl, MIT license
/**
 * Format time
 */ __turbopack_context__.s({
    "formatTime": (()=>formatTime),
    "formatValue": (()=>formatValue),
    "leftPad": (()=>leftPad),
    "rightPad": (()=>rightPad)
});
function formatTime(ms) {
    let formatted;
    if (ms < 10) {
        formatted = `${ms.toFixed(2)}ms`;
    } else if (ms < 100) {
        formatted = `${ms.toFixed(1)}ms`;
    } else if (ms < 1000) {
        formatted = `${ms.toFixed(0)}ms`;
    } else {
        formatted = `${(ms / 1000).toFixed(2)}s`;
    }
    return formatted;
}
function leftPad(string, length = 8) {
    const padLength = Math.max(length - string.length, 0);
    return `${' '.repeat(padLength)}${string}`;
}
function rightPad(string, length = 8) {
    const padLength = Math.max(length - string.length, 0);
    return `${string}${' '.repeat(padLength)}`;
}
function formatValue(v, options = {}) {
    const EPSILON = 1e-16;
    const { isInteger = false } = options;
    if (Array.isArray(v) || ArrayBuffer.isView(v)) {
        return formatArrayValue(v, options);
    }
    if (!Number.isFinite(v)) {
        return String(v);
    }
    // @ts-expect-error
    if (Math.abs(v) < EPSILON) {
        return isInteger ? '0' : '0.';
    }
    if (isInteger) {
        // @ts-expect-error
        return v.toFixed(0);
    }
    // @ts-expect-error
    if (Math.abs(v) > 100 && Math.abs(v) < 10000) {
        // @ts-expect-error
        return v.toFixed(0);
    }
    // @ts-expect-error
    const string = v.toPrecision(2);
    const decimal = string.indexOf('.0');
    return decimal === string.length - 2 ? string.slice(0, -1) : string;
}
/** Helper to formatValue */ function formatArrayValue(v, options) {
    const { maxElts = 16, size = 1 } = options;
    let string = '[';
    for(let i = 0; i < v.length && i < maxElts; ++i){
        if (i > 0) {
            string += `,${i % size === 0 ? ' ' : ''}`;
        }
        string += formatValue(v[i], options);
    }
    const terminator = v.length > maxElts ? '...' : ']';
    return `${string}${terminator}`;
} //# sourceMappingURL=formatters.js.map
}}),
"[project]/node_modules/@probe.gl/log/dist/utils/color.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "COLOR": (()=>COLOR),
    "addColor": (()=>addColor)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$is$2d$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/env/dist/lib/is-browser.js [client] (ecmascript)");
;
var COLOR;
(function(COLOR) {
    COLOR[COLOR["BLACK"] = 30] = "BLACK";
    COLOR[COLOR["RED"] = 31] = "RED";
    COLOR[COLOR["GREEN"] = 32] = "GREEN";
    COLOR[COLOR["YELLOW"] = 33] = "YELLOW";
    COLOR[COLOR["BLUE"] = 34] = "BLUE";
    COLOR[COLOR["MAGENTA"] = 35] = "MAGENTA";
    COLOR[COLOR["CYAN"] = 36] = "CYAN";
    COLOR[COLOR["WHITE"] = 37] = "WHITE";
    COLOR[COLOR["BRIGHT_BLACK"] = 90] = "BRIGHT_BLACK";
    COLOR[COLOR["BRIGHT_RED"] = 91] = "BRIGHT_RED";
    COLOR[COLOR["BRIGHT_GREEN"] = 92] = "BRIGHT_GREEN";
    COLOR[COLOR["BRIGHT_YELLOW"] = 93] = "BRIGHT_YELLOW";
    COLOR[COLOR["BRIGHT_BLUE"] = 94] = "BRIGHT_BLUE";
    COLOR[COLOR["BRIGHT_MAGENTA"] = 95] = "BRIGHT_MAGENTA";
    COLOR[COLOR["BRIGHT_CYAN"] = 96] = "BRIGHT_CYAN";
    COLOR[COLOR["BRIGHT_WHITE"] = 97] = "BRIGHT_WHITE";
})(COLOR || (COLOR = {}));
const BACKGROUND_INCREMENT = 10;
function getColor(color) {
    if (typeof color !== 'string') {
        return color;
    }
    color = color.toUpperCase();
    return COLOR[color] || COLOR.WHITE;
}
function addColor(string, color, background) {
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$is$2d$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBrowser"] && typeof string === 'string') {
        if (color) {
            const colorCode = getColor(color);
            string = `\u001b[${colorCode}m${string}\u001b[39m`;
        }
        if (background) {
            // background colors values are +10
            const colorCode = getColor(background);
            string = `\u001b[${colorCode + BACKGROUND_INCREMENT}m${string}\u001b[49m`;
        }
    }
    return string;
} //# sourceMappingURL=color.js.map
}}),
"[project]/node_modules/@probe.gl/log/dist/utils/autobind.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
/**
 * Binds the "this" argument of all functions on a class instance to the instance
 * @param obj - class instance (typically a react component)
 */ __turbopack_context__.s({
    "autobind": (()=>autobind)
});
function autobind(obj, predefined = [
    'constructor'
]) {
    const proto = Object.getPrototypeOf(obj);
    const propNames = Object.getOwnPropertyNames(proto);
    const object = obj;
    for (const key of propNames){
        const value = object[key];
        if (typeof value === 'function') {
            if (!predefined.find((name)=>key === name)) {
                object[key] = value.bind(obj);
            }
        }
    }
} //# sourceMappingURL=autobind.js.map
}}),
"[project]/node_modules/@probe.gl/log/dist/utils/assert.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>assert)
});
function assert(condition, message) {
    if (!condition) {
        throw new Error(message || 'Assertion failed');
    }
} //# sourceMappingURL=assert.js.map
}}),
"[project]/node_modules/@probe.gl/log/dist/utils/hi-res-timestamp.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// probe.gl, MIT license
__turbopack_context__.s({
    "getHiResTimestamp": (()=>getHiResTimestamp)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/env/dist/lib/globals.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$is$2d$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/env/dist/lib/is-browser.js [client] (ecmascript)");
;
function getHiResTimestamp() {
    let timestamp;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$is$2d$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBrowser"])() && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__["window"].performance) {
        timestamp = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__["window"]?.performance?.now?.();
    } else if ('hrtime' in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__["process"]) {
        // @ts-ignore
        const timeParts = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__["process"]?.hrtime?.();
        timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;
    } else {
        timestamp = Date.now();
    }
    return timestamp;
} //# sourceMappingURL=hi-res-timestamp.js.map
}}),
"[project]/node_modules/@probe.gl/log/dist/log.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// probe.gl, MIT license
/* eslint-disable no-console,prefer-rest-params */ __turbopack_context__.s({
    "Log": (()=>Log),
    "normalizeArguments": (()=>normalizeArguments)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/env/dist/index.js [client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$is$2d$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/env/dist/lib/is-browser.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$utils$2f$local$2d$storage$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/log/dist/utils/local-storage.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$utils$2f$formatters$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/log/dist/utils/formatters.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$utils$2f$color$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/log/dist/utils/color.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$utils$2f$autobind$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/log/dist/utils/autobind.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/log/dist/utils/assert.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$utils$2f$hi$2d$res$2d$timestamp$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/log/dist/utils/hi-res-timestamp.js [client] (ecmascript)");
;
;
;
;
;
;
;
// Instrumentation in other packages may override console methods, so preserve them here
const originalConsole = {
    debug: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$is$2d$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBrowser"])() ? console.debug || console.log : console.log,
    log: console.log,
    info: console.info,
    warn: console.warn,
    error: console.error
};
const DEFAULT_LOG_CONFIGURATION = {
    enabled: true,
    level: 0
};
function noop() {} // eslint-disable-line @typescript-eslint/no-empty-function
const cache = {};
const ONCE = {
    once: true
};
class Log {
    constructor({ id } = {
        id: ''
    }){
        this.VERSION = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["VERSION"];
        this._startTs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$utils$2f$hi$2d$res$2d$timestamp$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getHiResTimestamp"])();
        this._deltaTs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$utils$2f$hi$2d$res$2d$timestamp$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getHiResTimestamp"])();
        this.userData = {};
        // TODO - fix support from throttling groups
        this.LOG_THROTTLE_TIMEOUT = 0; // Time before throttled messages are logged again
        this.id = id;
        this.userData = {};
        this._storage = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$utils$2f$local$2d$storage$2e$js__$5b$client$5d$__$28$ecmascript$29$__["LocalStorage"](`__probe-${this.id}__`, DEFAULT_LOG_CONFIGURATION);
        this.timeStamp(`${this.id} started`);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$utils$2f$autobind$2e$js__$5b$client$5d$__$28$ecmascript$29$__["autobind"])(this);
        Object.seal(this);
    }
    set level(newLevel) {
        this.setLevel(newLevel);
    }
    get level() {
        return this.getLevel();
    }
    isEnabled() {
        return this._storage.config.enabled;
    }
    getLevel() {
        return this._storage.config.level;
    }
    /** @return milliseconds, with fractions */ getTotal() {
        return Number(((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$utils$2f$hi$2d$res$2d$timestamp$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getHiResTimestamp"])() - this._startTs).toPrecision(10));
    }
    /** @return milliseconds, with fractions */ getDelta() {
        return Number(((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$utils$2f$hi$2d$res$2d$timestamp$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getHiResTimestamp"])() - this._deltaTs).toPrecision(10));
    }
    /** @deprecated use logLevel */ set priority(newPriority) {
        this.level = newPriority;
    }
    /** @deprecated use logLevel */ get priority() {
        return this.level;
    }
    /** @deprecated use logLevel */ getPriority() {
        return this.level;
    }
    // Configure
    enable(enabled = true) {
        this._storage.setConfiguration({
            enabled
        });
        return this;
    }
    setLevel(level) {
        this._storage.setConfiguration({
            level
        });
        return this;
    }
    /** return the current status of the setting */ get(setting) {
        return this._storage.config[setting];
    }
    // update the status of the setting
    set(setting, value) {
        this._storage.setConfiguration({
            [setting]: value
        });
    }
    /** Logs the current settings as a table */ settings() {
        if (console.table) {
            console.table(this._storage.config);
        } else {
            console.log(this._storage.config);
        }
    }
    // Unconditional logging
    assert(condition, message) {
        if (!condition) {
            throw new Error(message || 'Assertion failed');
        }
    }
    warn(message) {
        return this._getLogFunction(0, message, originalConsole.warn, arguments, ONCE);
    }
    error(message) {
        return this._getLogFunction(0, message, originalConsole.error, arguments);
    }
    /** Print a deprecation warning */ deprecated(oldUsage, newUsage) {
        return this.warn(`\`${oldUsage}\` is deprecated and will be removed \
in a later version. Use \`${newUsage}\` instead`);
    }
    /** Print a removal warning */ removed(oldUsage, newUsage) {
        return this.error(`\`${oldUsage}\` has been removed. Use \`${newUsage}\` instead`);
    }
    probe(logLevel, message) {
        return this._getLogFunction(logLevel, message, originalConsole.log, arguments, {
            time: true,
            once: true
        });
    }
    log(logLevel, message) {
        return this._getLogFunction(logLevel, message, originalConsole.debug, arguments);
    }
    info(logLevel, message) {
        return this._getLogFunction(logLevel, message, console.info, arguments);
    }
    once(logLevel, message) {
        return this._getLogFunction(logLevel, message, originalConsole.debug || originalConsole.info, arguments, ONCE);
    }
    /** Logs an object as a table */ table(logLevel, table, columns) {
        if (table) {
            return this._getLogFunction(logLevel, table, console.table || noop, columns && [
                columns
            ], {
                tag: getTableHeader(table)
            });
        }
        return noop;
    }
    time(logLevel, message) {
        return this._getLogFunction(logLevel, message, console.time ? console.time : console.info);
    }
    timeEnd(logLevel, message) {
        return this._getLogFunction(logLevel, message, console.timeEnd ? console.timeEnd : console.info);
    }
    timeStamp(logLevel, message) {
        return this._getLogFunction(logLevel, message, console.timeStamp || noop);
    }
    group(logLevel, message, opts = {
        collapsed: false
    }) {
        const options = normalizeArguments({
            logLevel,
            message,
            opts
        });
        const { collapsed } = opts;
        // @ts-expect-error
        options.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
        return this._getLogFunction(options);
    }
    groupCollapsed(logLevel, message, opts = {}) {
        return this.group(logLevel, message, Object.assign({}, opts, {
            collapsed: true
        }));
    }
    groupEnd(logLevel) {
        return this._getLogFunction(logLevel, '', console.groupEnd || noop);
    }
    // EXPERIMENTAL
    withGroup(logLevel, message, func) {
        this.group(logLevel, message)();
        try {
            func();
        } finally{
            this.groupEnd(logLevel)();
        }
    }
    trace() {
        if (console.trace) {
            console.trace();
        }
    }
    // PRIVATE METHODS
    /** Deduces log level from a variety of arguments */ _shouldLog(logLevel) {
        return this.isEnabled() && this.getLevel() >= normalizeLogLevel(logLevel);
    }
    _getLogFunction(logLevel, message, method, args, opts) {
        if (this._shouldLog(logLevel)) {
            // normalized opts + timings
            opts = normalizeArguments({
                logLevel,
                message,
                args,
                opts
            });
            method = method || opts.method;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(method);
            opts.total = this.getTotal();
            opts.delta = this.getDelta();
            // reset delta timer
            this._deltaTs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$utils$2f$hi$2d$res$2d$timestamp$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getHiResTimestamp"])();
            const tag = opts.tag || opts.message;
            if (opts.once && tag) {
                if (!cache[tag]) {
                    cache[tag] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$utils$2f$hi$2d$res$2d$timestamp$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getHiResTimestamp"])();
                } else {
                    return noop;
                }
            }
            // TODO - Make throttling work with groups
            // if (opts.nothrottle || !throttle(tag, this.LOG_THROTTLE_TIMEOUT)) {
            //   return noop;
            // }
            message = decorateMessage(this.id, opts.message, opts);
            // Bind console function so that it can be called after being returned
            return method.bind(console, message, ...opts.args);
        }
        return noop;
    }
}
Log.VERSION = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["VERSION"];
/**
 * Get logLevel from first argument:
 * - log(logLevel, message, args) => logLevel
 * - log(message, args) => 0
 * - log({logLevel, ...}, message, args) => logLevel
 * - log({logLevel, message, args}) => logLevel
 */ function normalizeLogLevel(logLevel) {
    if (!logLevel) {
        return 0;
    }
    let resolvedLevel;
    switch(typeof logLevel){
        case 'number':
            resolvedLevel = logLevel;
            break;
        case 'object':
            // Backward compatibility
            // TODO - deprecate `priority`
            // @ts-expect-error
            resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
            break;
        default:
            return 0;
    }
    // 'log level must be a number'
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
    return resolvedLevel;
}
function normalizeArguments(opts) {
    const { logLevel, message } = opts;
    opts.logLevel = normalizeLogLevel(logLevel);
    // We use `arguments` instead of rest parameters (...args) because IE
    // does not support the syntax. Rest parameters is transpiled to code with
    // perf impact. Doing it here instead avoids constructing args when logging is
    // disabled.
    // TODO - remove when/if IE support is dropped
    const args = opts.args ? Array.from(opts.args) : [];
    // args should only contain arguments that appear after `message`
    // eslint-disable-next-line no-empty
    while(args.length && args.shift() !== message){}
    switch(typeof logLevel){
        case 'string':
        case 'function':
            if (message !== undefined) {
                args.unshift(message);
            }
            opts.message = logLevel;
            break;
        case 'object':
            Object.assign(opts, logLevel);
            break;
        default:
    }
    // Resolve functions into strings by calling them
    if (typeof opts.message === 'function') {
        opts.message = opts.message();
    }
    const messageType = typeof opts.message;
    // 'log message must be a string' or object
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(messageType === 'string' || messageType === 'object');
    // original opts + normalized opts + opts arg + fixed up message
    return Object.assign(opts, {
        args
    }, opts.opts);
}
function decorateMessage(id, message, opts) {
    if (typeof message === 'string') {
        const time = opts.time ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$utils$2f$formatters$2e$js__$5b$client$5d$__$28$ecmascript$29$__["leftPad"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$utils$2f$formatters$2e$js__$5b$client$5d$__$28$ecmascript$29$__["formatTime"])(opts.total)) : '';
        message = opts.time ? `${id}: ${time}  ${message}` : `${id}: ${message}`;
        message = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$utils$2f$color$2e$js__$5b$client$5d$__$28$ecmascript$29$__["addColor"])(message, opts.color, opts.background);
    }
    return message;
}
function getTableHeader(table) {
    for(const key in table){
        for(const title in table[key]){
            return title || 'untitled';
        }
    }
    return 'empty';
} //# sourceMappingURL=log.js.map
}}),
"[project]/node_modules/@probe.gl/stats/dist/utils/hi-res-timestamp.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
__turbopack_context__.s({
    "default": (()=>getHiResTimestamp)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
function getHiResTimestamp() {
    let timestamp;
    // Get best timer available.
    if (typeof window !== 'undefined' && window.performance) {
        timestamp = window.performance.now();
    } else if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"] !== 'undefined' && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].hrtime) {
        const timeParts = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].hrtime();
        timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;
    } else {
        timestamp = Date.now();
    }
    return timestamp;
} //# sourceMappingURL=hi-res-timestamp.js.map
}}),
"[project]/node_modules/@probe.gl/stats/dist/lib/stat.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>Stat)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$utils$2f$hi$2d$res$2d$timestamp$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/stats/dist/utils/hi-res-timestamp.js [client] (ecmascript)");
;
class Stat {
    constructor(name, type){
        this.sampleSize = 1;
        this.time = 0;
        this.count = 0;
        this.samples = 0;
        this.lastTiming = 0;
        this.lastSampleTime = 0;
        this.lastSampleCount = 0;
        this._count = 0;
        this._time = 0;
        this._samples = 0;
        this._startTime = 0;
        this._timerPending = false;
        this.name = name;
        this.type = type;
        this.reset();
    }
    reset() {
        this.time = 0;
        this.count = 0;
        this.samples = 0;
        this.lastTiming = 0;
        this.lastSampleTime = 0;
        this.lastSampleCount = 0;
        this._count = 0;
        this._time = 0;
        this._samples = 0;
        this._startTime = 0;
        this._timerPending = false;
        return this;
    }
    setSampleSize(samples) {
        this.sampleSize = samples;
        return this;
    }
    /** Call to increment count (+1) */ incrementCount() {
        this.addCount(1);
        return this;
    }
    /** Call to decrement count (-1) */ decrementCount() {
        this.subtractCount(1);
        return this;
    }
    /** Increase count */ addCount(value) {
        this._count += value;
        this._samples++;
        this._checkSampling();
        return this;
    }
    /** Decrease count */ subtractCount(value) {
        this._count -= value;
        this._samples++;
        this._checkSampling();
        return this;
    }
    /** Add an arbitrary timing and bump the count */ addTime(time) {
        this._time += time;
        this.lastTiming = time;
        this._samples++;
        this._checkSampling();
        return this;
    }
    /** Start a timer */ timeStart() {
        this._startTime = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$utils$2f$hi$2d$res$2d$timestamp$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])();
        this._timerPending = true;
        return this;
    }
    /** End a timer. Adds to time and bumps the timing count. */ timeEnd() {
        if (!this._timerPending) {
            return this;
        }
        this.addTime((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$utils$2f$hi$2d$res$2d$timestamp$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])() - this._startTime);
        this._timerPending = false;
        this._checkSampling();
        return this;
    }
    getSampleAverageCount() {
        return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
    }
    /** Calculate average time / count for the previous window */ getSampleAverageTime() {
        return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
    }
    /** Calculate counts per second for the previous window */ getSampleHz() {
        return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1000) : 0;
    }
    getAverageCount() {
        return this.samples > 0 ? this.count / this.samples : 0;
    }
    /** Calculate average time / count */ getAverageTime() {
        return this.samples > 0 ? this.time / this.samples : 0;
    }
    /** Calculate counts per second */ getHz() {
        return this.time > 0 ? this.samples / (this.time / 1000) : 0;
    }
    _checkSampling() {
        if (this._samples === this.sampleSize) {
            this.lastSampleTime = this._time;
            this.lastSampleCount = this._count;
            this.count += this._count;
            this.time += this._time;
            this.samples += this._samples;
            this._time = 0;
            this._count = 0;
            this._samples = 0;
        }
    }
} //# sourceMappingURL=stat.js.map
}}),
"[project]/node_modules/@probe.gl/stats/dist/lib/stats.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// probe.gl, MIT license
__turbopack_context__.s({
    "default": (()=>Stats)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$lib$2f$stat$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/stats/dist/lib/stat.js [client] (ecmascript)");
;
class Stats {
    constructor(options){
        this.stats = {};
        this.id = options.id;
        this.stats = {};
        this._initializeStats(options.stats);
        Object.seal(this);
    }
    /** Acquire a stat. Create if it doesn't exist. */ get(name, type = 'count') {
        return this._getOrCreate({
            name,
            type
        });
    }
    get size() {
        return Object.keys(this.stats).length;
    }
    /** Reset all stats */ reset() {
        for (const stat of Object.values(this.stats)){
            stat.reset();
        }
        return this;
    }
    forEach(fn) {
        for (const stat of Object.values(this.stats)){
            fn(stat);
        }
    }
    getTable() {
        const table = {};
        this.forEach((stat)=>{
            table[stat.name] = {
                time: stat.time || 0,
                count: stat.count || 0,
                average: stat.getAverageTime() || 0,
                hz: stat.getHz() || 0
            };
        });
        return table;
    }
    _initializeStats(stats = []) {
        stats.forEach((stat)=>this._getOrCreate(stat));
    }
    _getOrCreate(stat) {
        const { name, type } = stat;
        let result = this.stats[name];
        if (!result) {
            if (stat instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$lib$2f$stat$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"]) {
                result = stat;
            } else {
                result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$lib$2f$stat$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"](name, type);
            }
            this.stats[name] = result;
        }
        return result;
    }
} //# sourceMappingURL=stats.js.map
}}),
"[project]/node_modules/@probe.gl/stats/dist/index.js [client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
;
;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@probe.gl/stats/dist/index.js [client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$lib$2f$stats$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/stats/dist/lib/stats.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$lib$2f$stat$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/stats/dist/lib/stat.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$utils$2f$hi$2d$res$2d$timestamp$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/stats/dist/utils/hi-res-timestamp.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/stats/dist/index.js [client] (ecmascript) <locals>");
}}),
"[project]/node_modules/@probe.gl/stats/dist/lib/stats.js [client] (ecmascript) <export default as Stats>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "Stats": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$lib$2f$stats$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$lib$2f$stats$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/stats/dist/lib/stats.js [client] (ecmascript)");
}}),
"[project]/node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "isAsyncIterable": (()=>isAsyncIterable),
    "isBlob": (()=>isBlob),
    "isBuffer": (()=>isBuffer),
    "isFile": (()=>isFile),
    "isIterable": (()=>isIterable),
    "isIterator": (()=>isIterator),
    "isObject": (()=>isObject),
    "isPromise": (()=>isPromise),
    "isPureObject": (()=>isPureObject),
    "isReadableDOMStream": (()=>isReadableDOMStream),
    "isReadableNodeStream": (()=>isReadableNodeStream),
    "isReadableStream": (()=>isReadableStream),
    "isResponse": (()=>isResponse),
    "isWritableDOMStream": (()=>isWritableDOMStream),
    "isWritableNodeStream": (()=>isWritableNodeStream),
    "isWritableStream": (()=>isWritableStream)
});
const isBoolean = (x)=>typeof x === 'boolean';
const isFunction = (x)=>typeof x === 'function';
const isObject = (x)=>x !== null && typeof x === 'object';
const isPureObject = (x)=>isObject(x) && x.constructor === ({}).constructor;
const isPromise = (x)=>isObject(x) && isFunction(x.then);
const isIterable = (x)=>Boolean(x) && typeof x[Symbol.iterator] === 'function';
const isAsyncIterable = (x)=>x && typeof x[Symbol.asyncIterator] === 'function';
const isIterator = (x)=>x && isFunction(x.next);
const isResponse = (x)=>typeof Response !== 'undefined' && x instanceof Response || x && x.arrayBuffer && x.text && x.json;
const isFile = (x)=>typeof File !== 'undefined' && x instanceof File;
const isBlob = (x)=>typeof Blob !== 'undefined' && x instanceof Blob;
const isBuffer = (x)=>x && typeof x === 'object' && x.isBuffer;
const isWritableDOMStream = (x)=>isObject(x) && isFunction(x.abort) && isFunction(x.getWriter);
const isReadableDOMStream = (x)=>typeof ReadableStream !== 'undefined' && x instanceof ReadableStream || isObject(x) && isFunction(x.tee) && isFunction(x.cancel) && isFunction(x.getReader);
const isWritableNodeStream = (x)=>isObject(x) && isFunction(x.end) && isFunction(x.write) && isBoolean(x.writable);
const isReadableNodeStream = (x)=>isObject(x) && isFunction(x.read) && isFunction(x.pipe) && isBoolean(x.readable);
const isReadableStream = (x)=>isReadableDOMStream(x) || isReadableNodeStream(x);
const isWritableStream = (x)=>isWritableDOMStream(x) || isWritableNodeStream(x);
}}),
"[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/normalize-loader.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "isLoaderObject": (()=>isLoaderObject),
    "normalizeLoader": (()=>normalizeLoader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/assert.js [client] (ecmascript)");
;
function isLoaderObject(loader) {
    if (!loader) {
        return false;
    }
    if (Array.isArray(loader)) {
        loader = loader[0];
    }
    const hasExtensions = Array.isArray(loader?.extensions);
    /* Now handled by types and worker loaders do not have these
    let hasParser =
      loader.parseTextSync ||
      loader.parseSync ||
      loader.parse ||
      loader.parseStream || // TODO Remove, Replace with parseInBatches
      loader.parseInBatches;
    */ return hasExtensions;
}
function normalizeLoader(loader) {
    // This error is fairly easy to trigger by mixing up import statements etc
    // So we make an exception and add a developer error message for this case
    // To help new users from getting stuck here
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(loader, 'null loader');
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(isLoaderObject(loader), 'invalid loader');
    // NORMALIZE [LOADER, OPTIONS] => LOADER
    // If [loader, options], create a new loaders object with options merged in
    let options;
    if (Array.isArray(loader)) {
        options = loader[1];
        loader = loader[0];
        loader = {
            ...loader,
            options: {
                ...loader.options,
                ...options
            }
        };
    }
    // NORMALIZE text and binary flags
    // Ensure at least one of text/binary flags are properly set
    // @ts-expect-error
    if (loader?.parseTextSync || loader?.parseText) {
        loader.text = true;
    }
    if (!loader.text) {
        loader.binary = true;
    }
    return loader;
}
}}),
"[project]/node_modules/@loaders.gl/core/dist/lib/fetch/fetch-error.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "FetchError": (()=>FetchError)
});
class FetchError extends Error {
    constructor(message, info){
        super(message);
        this.reason = info.reason;
        this.url = info.url;
        this.response = info.response;
    }
    /** A best effort reason for why the fetch failed */ reason;
    /** The URL that failed to load. Empty string if not available. */ url;
    /** The Response object, if any. */ response;
}
}}),
"[project]/node_modules/@loaders.gl/core/dist/lib/utils/mime-type-utils.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// TODO - build/integrate proper MIME type parsing
// https://mimesniff.spec.whatwg.org/
__turbopack_context__.s({
    "compareMIMETypes": (()=>compareMIMETypes),
    "parseMIMEType": (()=>parseMIMEType),
    "parseMIMETypeFromURL": (()=>parseMIMETypeFromURL)
});
const DATA_URL_PATTERN = /^data:([-\w.]+\/[-\w.+]+)(;|,)/;
const MIME_TYPE_PATTERN = /^([-\w.]+\/[-\w.+]+)/;
function compareMIMETypes(mimeType1, mimeType2) {
    if (mimeType1.toLowerCase() === mimeType2.toLowerCase()) {
        return true;
    }
    return false;
}
function parseMIMEType(mimeString) {
    // If resource is a data url, extract any embedded mime type
    const matches = MIME_TYPE_PATTERN.exec(mimeString);
    if (matches) {
        return matches[1];
    }
    return mimeString;
}
function parseMIMETypeFromURL(url) {
    // If resource is a data URL, extract any embedded mime type
    const matches = DATA_URL_PATTERN.exec(url);
    if (matches) {
        return matches[1];
    }
    return '';
}
}}),
"[project]/node_modules/@loaders.gl/core/dist/lib/utils/url-utils.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "extractQueryString": (()=>extractQueryString),
    "shortenUrlForDisplay": (()=>shortenUrlForDisplay),
    "stripQueryString": (()=>stripQueryString)
});
const QUERY_STRING_PATTERN = /\?.*/;
function extractQueryString(url) {
    const matches = url.match(QUERY_STRING_PATTERN);
    return matches && matches[0];
}
function stripQueryString(url) {
    return url.replace(QUERY_STRING_PATTERN, '');
}
function shortenUrlForDisplay(url) {
    if (url.length < 50) {
        return url;
    }
    const urlEnd = url.slice(url.length - 15);
    const urlStart = url.substr(0, 32);
    return `${urlStart}...${urlEnd}`;
}
}}),
"[project]/node_modules/@loaders.gl/core/dist/lib/utils/resource-utils.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "getResourceContentLength": (()=>getResourceContentLength),
    "getResourceMIMEType": (()=>getResourceMIMEType),
    "getResourceUrl": (()=>getResourceUrl)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$mime$2d$type$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/utils/mime-type-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$url$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/utils/url-utils.js [client] (ecmascript)");
;
;
;
function getResourceUrl(resource) {
    // If resource is a `Response`, it contains the information directly as a field
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isResponse"])(resource)) {
        const response = resource;
        return response.url;
    }
    // If the resource is a Blob or a File (subclass of Blob)
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBlob"])(resource)) {
        const blob = resource;
        // File objects have a "name" property. Blob objects don't have any
        // url (name) information
        return blob.name || '';
    }
    if (typeof resource === 'string') {
        return resource;
    }
    // Unknown
    return '';
}
function getResourceMIMEType(resource) {
    // If resource is a response, it contains the information directly
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isResponse"])(resource)) {
        const response = resource;
        const contentTypeHeader = response.headers.get('content-type') || '';
        const noQueryUrl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$url$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["stripQueryString"])(response.url);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$mime$2d$type$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseMIMEType"])(contentTypeHeader) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$mime$2d$type$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseMIMETypeFromURL"])(noQueryUrl);
    }
    // If the resource is a Blob or a File (subclass of Blob)
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBlob"])(resource)) {
        const blob = resource;
        return blob.type || '';
    }
    if (typeof resource === 'string') {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$mime$2d$type$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseMIMETypeFromURL"])(resource);
    }
    // Unknown
    return '';
}
function getResourceContentLength(resource) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isResponse"])(resource)) {
        const response = resource;
        return response.headers['content-length'] || -1;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBlob"])(resource)) {
        const blob = resource;
        return blob.size;
    }
    if (typeof resource === 'string') {
        // TODO - handle data URL?
        return resource.length;
    }
    if (resource instanceof ArrayBuffer) {
        return resource.byteLength;
    }
    if (ArrayBuffer.isView(resource)) {
        return resource.byteLength;
    }
    return -1;
}
}}),
"[project]/node_modules/@loaders.gl/core/dist/lib/utils/response-utils.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "checkResponse": (()=>checkResponse),
    "checkResponseSync": (()=>checkResponseSync),
    "makeResponse": (()=>makeResponse)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$fetch$2f$fetch$2d$error$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/fetch/fetch-error.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$resource$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/utils/resource-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$url$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/utils/url-utils.js [client] (ecmascript)");
;
;
;
;
async function makeResponse(resource) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isResponse"])(resource)) {
        return resource;
    }
    // Add content-length header if possible
    const headers = {};
    const contentLength = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$resource$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getResourceContentLength"])(resource);
    if (contentLength >= 0) {
        headers['content-length'] = String(contentLength);
    }
    // `new Response(File)` does not preserve content-type and URL
    // so we add them here
    const url = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$resource$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getResourceUrl"])(resource);
    const type = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$resource$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getResourceMIMEType"])(resource);
    if (type) {
        headers['content-type'] = type;
    }
    // Add a custom header with initial bytes if available
    const initialDataUrl = await getInitialDataUrl(resource);
    if (initialDataUrl) {
        headers['x-first-bytes'] = initialDataUrl;
    }
    // TODO - is this the best way of handling strings?
    // Maybe package as data URL instead?
    if (typeof resource === 'string') {
        // Convert to ArrayBuffer to avoid Response treating it as a URL
        resource = new TextEncoder().encode(resource);
    }
    // Attempt to create a Response from the resource, adding headers and setting url
    const response = new Response(resource, {
        headers
    });
    // We can't control `Response.url` via constructor, use a property override to record URL.
    Object.defineProperty(response, 'url', {
        value: url
    });
    return response;
}
async function checkResponse(response) {
    if (!response.ok) {
        const error = await getResponseError(response);
        throw error;
    }
}
function checkResponseSync(response) {
    if (!response.ok) {
        let message = `${response.status} ${response.statusText}`;
        message = message.length > 60 ? `${message.slice(0, 60)}...` : message;
        throw new Error(message);
    }
}
// HELPERS
async function getResponseError(response) {
    const shortUrl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$url$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["shortenUrlForDisplay"])(response.url);
    let message = `Failed to fetch resource (${response.status}) ${response.statusText}: ${shortUrl}`;
    message = message.length > 100 ? `${message.slice(0, 100)}...` : message;
    const info = {
        reason: response.statusText,
        url: response.url,
        response
    };
    // See if we got an error message in the body
    try {
        const contentType = response.headers.get('Content-Type');
        info.reason = !response.bodyUsed && contentType?.includes('application/json') ? await response.json() : await response.text();
    } catch (error) {
    // eslint forbids return in a finally statement, so we just catch here
    }
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$fetch$2f$fetch$2d$error$2e$js__$5b$client$5d$__$28$ecmascript$29$__["FetchError"](message, info);
}
async function getInitialDataUrl(resource) {
    const INITIAL_DATA_LENGTH = 5;
    if (typeof resource === 'string') {
        return `data:,${resource.slice(0, INITIAL_DATA_LENGTH)}`;
    }
    if (resource instanceof Blob) {
        const blobSlice = resource.slice(0, 5);
        return await new Promise((resolve)=>{
            const reader = new FileReader();
            reader.onload = (event)=>resolve(event?.target?.result);
            reader.readAsDataURL(blobSlice);
        });
    }
    if (resource instanceof ArrayBuffer) {
        const slice = resource.slice(0, INITIAL_DATA_LENGTH);
        const base64 = arrayBufferToBase64(slice);
        return `data:base64,${base64}`;
    }
    return null;
}
// https://stackoverflow.com/questions/9267899/arraybuffer-to-base64-encoded-string
function arrayBufferToBase64(buffer) {
    let binary = '';
    const bytes = new Uint8Array(buffer);
    for(let i = 0; i < bytes.byteLength; i++){
        binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
}
}}),
"[project]/node_modules/@loaders.gl/core/dist/lib/fetch/fetch-file.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "fetchFile": (()=>fetchFile),
    "isDataURL": (()=>isDataURL),
    "isNodePath": (()=>isNodePath),
    "isRequestURL": (()=>isRequestURL)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$path$2d$utils$2f$file$2d$aliases$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/file-aliases.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$response$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/utils/response-utils.js [client] (ecmascript)");
;
;
function isNodePath(url) {
    return !isRequestURL(url) && !isDataURL(url);
}
function isRequestURL(url) {
    return url.startsWith('http:') || url.startsWith('https:');
}
function isDataURL(url) {
    return url.startsWith('data:');
}
async function fetchFile(urlOrData, fetchOptions) {
    if (typeof urlOrData === 'string') {
        const url = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$path$2d$utils$2f$file$2d$aliases$2e$js__$5b$client$5d$__$28$ecmascript$29$__["resolvePath"])(urlOrData);
        // Support fetching from local file system
        if (isNodePath(url)) {
            if (globalThis.loaders?.fetchNode) {
                return globalThis.loaders?.fetchNode(url, fetchOptions);
            }
        // throw new Error(
        //   'fetchFile: globalThis.loaders.fetchNode not defined. Install @loaders.gl/polyfills'
        // );
        }
        // Call global fetch
        return await fetch(url, fetchOptions);
    }
    // TODO - should we still call fetch on non-URL inputs?
    return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$response$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["makeResponse"])(urlOrData);
}
}}),
"[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/loggers.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// probe.gl Log compatible loggers
__turbopack_context__.s({
    "ConsoleLog": (()=>ConsoleLog),
    "NullLog": (()=>NullLog),
    "probeLog": (()=>probeLog)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/log/dist/log.js [client] (ecmascript)");
;
const probeLog = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Log"]({
    id: 'loaders.gl'
});
class NullLog {
    log() {
        return ()=>{};
    }
    info() {
        return ()=>{};
    }
    warn() {
        return ()=>{};
    }
    error() {
        return ()=>{};
    }
}
class ConsoleLog {
    console;
    constructor(){
        this.console = console; // eslint-disable-line
    }
    log(...args) {
        return this.console.log.bind(this.console, ...args);
    }
    info(...args) {
        return this.console.info.bind(this.console, ...args);
    }
    warn(...args) {
        return this.console.warn.bind(this.console, ...args);
    }
    error(...args) {
        return this.console.error.bind(this.console, ...args);
    }
}
}}),
"[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/option-defaults.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "DEFAULT_LOADER_OPTIONS": (()=>DEFAULT_LOADER_OPTIONS),
    "REMOVED_LOADER_OPTIONS": (()=>REMOVED_LOADER_OPTIONS)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/globals.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$loggers$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/loggers.js [client] (ecmascript)");
;
;
const DEFAULT_LOADER_OPTIONS = {
    // baseUri
    fetch: null,
    mimeType: undefined,
    nothrow: false,
    log: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$loggers$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ConsoleLog"](),
    useLocalLibraries: false,
    CDN: 'https://unpkg.com/@loaders.gl',
    worker: true,
    maxConcurrency: 3,
    maxMobileConcurrency: 1,
    reuseWorkers: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBrowser"],
    _nodeWorkers: false,
    _workerType: '',
    limit: 0,
    _limitMB: 0,
    batchSize: 'auto',
    batchDebounceMs: 0,
    metadata: false,
    transforms: []
};
const REMOVED_LOADER_OPTIONS = {
    throws: 'nothrow',
    dataType: '(no longer used)',
    uri: 'baseUri',
    // Warn if fetch options are used on top-level
    method: 'fetch.method',
    headers: 'fetch.headers',
    body: 'fetch.body',
    mode: 'fetch.mode',
    credentials: 'fetch.credentials',
    cache: 'fetch.cache',
    redirect: 'fetch.redirect',
    referrer: 'fetch.referrer',
    referrerPolicy: 'fetch.referrerPolicy',
    integrity: 'fetch.integrity',
    keepalive: 'fetch.keepalive',
    signal: 'fetch.signal'
};
}}),
"[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/option-utils.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "getGlobalLoaderOptions": (()=>getGlobalLoaderOptions),
    "getGlobalLoaderState": (()=>getGlobalLoaderState),
    "normalizeOptions": (()=>normalizeOptions),
    "setGlobalOptions": (()=>setGlobalOptions)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$module$2d$utils$2f$js$2d$module$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/module-utils/js-module-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$loggers$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/loggers.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$option$2d$defaults$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/option-defaults.js [client] (ecmascript)");
;
;
;
;
function getGlobalLoaderState() {
    // @ts-ignore
    globalThis.loaders = globalThis.loaders || {};
    // @ts-ignore
    const { loaders } = globalThis;
    // Add _state object to keep separate from modules added to globalThis.loaders
    if (!loaders._state) {
        loaders._state = {};
    }
    return loaders._state;
}
function getGlobalLoaderOptions() {
    const state = getGlobalLoaderState();
    // Ensure all default loader options from this library are mentioned
    state.globalOptions = state.globalOptions || {
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$option$2d$defaults$2e$js__$5b$client$5d$__$28$ecmascript$29$__["DEFAULT_LOADER_OPTIONS"]
    };
    return state.globalOptions;
}
function setGlobalOptions(options) {
    const state = getGlobalLoaderState();
    const globalOptions = getGlobalLoaderOptions();
    // @ts-expect-error First param looks incorrect
    state.globalOptions = normalizeOptionsInternal(globalOptions, options);
    // Make sure any new modules are registered
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$module$2d$utils$2f$js$2d$module$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["registerJSModules"])(options.modules);
}
function normalizeOptions(options, loader, loaders, url) {
    loaders = loaders || [];
    loaders = Array.isArray(loaders) ? loaders : [
        loaders
    ];
    validateOptions(options, loaders);
    return normalizeOptionsInternal(loader, options, url);
}
// VALIDATE OPTIONS
/**
 * Warn for unsupported options
 * @param options
 * @param loaders
 */ function validateOptions(options, loaders) {
    // Check top level options
    validateOptionsObject(options, null, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$option$2d$defaults$2e$js__$5b$client$5d$__$28$ecmascript$29$__["DEFAULT_LOADER_OPTIONS"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$option$2d$defaults$2e$js__$5b$client$5d$__$28$ecmascript$29$__["REMOVED_LOADER_OPTIONS"], loaders);
    for (const loader of loaders){
        // Get the scoped, loader specific options from the user supplied options
        const idOptions = options && options[loader.id] || {};
        // Get scoped, loader specific default and deprecated options from the selected loader
        const loaderOptions = loader.options && loader.options[loader.id] || {};
        const deprecatedOptions = loader.deprecatedOptions && loader.deprecatedOptions[loader.id] || {};
        // Validate loader specific options
        // @ts-ignore
        validateOptionsObject(idOptions, loader.id, loaderOptions, deprecatedOptions, loaders);
    }
}
// eslint-disable-next-line max-params, complexity
function validateOptionsObject(options, id, defaultOptions, deprecatedOptions, loaders) {
    const loaderName = id || 'Top level';
    const prefix = id ? `${id}.` : '';
    for(const key in options){
        // If top level option value is an object it could options for a loader, so ignore
        const isSubOptions = !id && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isObject"])(options[key]);
        const isBaseUriOption = key === 'baseUri' && !id;
        const isWorkerUrlOption = key === 'workerUrl' && id;
        // <loader>.workerUrl requires special handling as it is now auto-generated and no longer specified as a default option.
        if (!(key in defaultOptions) && !isBaseUriOption && !isWorkerUrlOption) {
            // Issue deprecation warnings
            if (key in deprecatedOptions) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$loggers$2e$js__$5b$client$5d$__$28$ecmascript$29$__["probeLog"].warn(`${loaderName} loader option \'${prefix}${key}\' no longer supported, use \'${deprecatedOptions[key]}\'`)();
            } else if (!isSubOptions) {
                const suggestion = findSimilarOption(key, loaders);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$loggers$2e$js__$5b$client$5d$__$28$ecmascript$29$__["probeLog"].warn(`${loaderName} loader option \'${prefix}${key}\' not recognized. ${suggestion}`)();
            }
        }
    }
}
function findSimilarOption(optionKey, loaders) {
    const lowerCaseOptionKey = optionKey.toLowerCase();
    let bestSuggestion = '';
    for (const loader of loaders){
        for(const key in loader.options){
            if (optionKey === key) {
                return `Did you mean \'${loader.id}.${key}\'?`;
            }
            const lowerCaseKey = key.toLowerCase();
            const isPartialMatch = lowerCaseOptionKey.startsWith(lowerCaseKey) || lowerCaseKey.startsWith(lowerCaseOptionKey);
            if (isPartialMatch) {
                bestSuggestion = bestSuggestion || `Did you mean \'${loader.id}.${key}\'?`;
            }
        }
    }
    return bestSuggestion;
}
function normalizeOptionsInternal(loader, options, url) {
    const loaderDefaultOptions = loader.options || {};
    const mergedOptions = {
        ...loaderDefaultOptions
    };
    addUrlOptions(mergedOptions, url);
    // LOGGING: options.log can be set to `null` to defeat logging
    if (mergedOptions.log === null) {
        mergedOptions.log = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$loggers$2e$js__$5b$client$5d$__$28$ecmascript$29$__["NullLog"]();
    }
    mergeNestedFields(mergedOptions, getGlobalLoaderOptions());
    mergeNestedFields(mergedOptions, options);
    return mergedOptions;
}
// Merge nested options objects
function mergeNestedFields(mergedOptions, options) {
    for(const key in options){
        // Check for nested options
        // object in options => either no key in defaultOptions or object in defaultOptions
        if (key in options) {
            const value = options[key];
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isPureObject"])(value) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isPureObject"])(mergedOptions[key])) {
                mergedOptions[key] = {
                    ...mergedOptions[key],
                    ...options[key]
                };
            } else {
                mergedOptions[key] = options[key];
            }
        }
    // else: No need to merge nested opts, and the initial merge already copied over the nested options
    }
}
/**
 * Harvest information from the url
 * @deprecated This is mainly there to support a hack in the GLTFLoader
 * TODO - baseUri should be a directory, i.e. remove file component from baseUri
 * TODO - extract extension?
 * TODO - extract query parameters?
 * TODO - should these be injected on context instead of options?
 */ function addUrlOptions(options, url) {
    if (url && !('baseUri' in options)) {
        options.baseUri = url;
    }
}
}}),
"[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/get-fetch-function.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "getFetchFunction": (()=>getFetchFunction)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$fetch$2f$fetch$2d$file$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/fetch/fetch-file.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$option$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/option-utils.js [client] (ecmascript)");
;
;
;
function getFetchFunction(options, context) {
    const globalOptions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$option$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getGlobalLoaderOptions"])();
    const loaderOptions = options || globalOptions;
    // options.fetch can be a function
    if (typeof loaderOptions.fetch === 'function') {
        return loaderOptions.fetch;
    }
    // options.fetch can be an options object
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isObject"])(loaderOptions.fetch)) {
        return (url)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$fetch$2f$fetch$2d$file$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fetchFile"])(url, loaderOptions.fetch);
    }
    // else refer to context (from parent loader) if available
    if (context?.fetch) {
        return context?.fetch;
    }
    // else return the default fetch function
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$fetch$2f$fetch$2d$file$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fetchFile"];
}
}}),
"[project]/node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-string-iterator.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "makeStringIterator": (()=>makeStringIterator)
});
const DEFAULT_CHUNK_SIZE = 256 * 1024;
function* makeStringIterator(string, options) {
    const chunkSize = options?.chunkSize || DEFAULT_CHUNK_SIZE;
    let offset = 0;
    const textEncoder = new TextEncoder();
    while(offset < string.length){
        // Create a chunk of the right size
        const chunkLength = Math.min(string.length - offset, chunkSize);
        const chunk = string.slice(offset, offset + chunkLength);
        offset += chunkLength;
        // yield an ArrayBuffer chunk
        yield textEncoder.encode(chunk);
    }
}
}}),
"[project]/node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-array-buffer-iterator.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "makeArrayBufferIterator": (()=>makeArrayBufferIterator)
});
const DEFAULT_CHUNK_SIZE = 256 * 1024;
function* makeArrayBufferIterator(arrayBuffer, options = {}) {
    const { chunkSize = DEFAULT_CHUNK_SIZE } = options;
    let byteOffset = 0;
    while(byteOffset < arrayBuffer.byteLength){
        // Create a chunk of the right size
        const chunkByteLength = Math.min(arrayBuffer.byteLength - byteOffset, chunkSize);
        const chunk = new ArrayBuffer(chunkByteLength);
        // Copy data from the big chunk
        const sourceArray = new Uint8Array(arrayBuffer, byteOffset, chunkByteLength);
        const chunkArray = new Uint8Array(chunk);
        chunkArray.set(sourceArray);
        // yield the chunk
        byteOffset += chunkByteLength;
        yield chunk;
    }
}
}}),
"[project]/node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-blob-iterator.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "makeBlobIterator": (()=>makeBlobIterator)
});
const DEFAULT_CHUNK_SIZE = 1024 * 1024; // 1MB — biggest value that keeps UI responsive
async function* makeBlobIterator(blob, options) {
    const chunkSize = options?.chunkSize || DEFAULT_CHUNK_SIZE;
    let offset = 0;
    while(offset < blob.size){
        const end = offset + chunkSize;
        const chunk = await blob.slice(offset, end).arrayBuffer();
        offset = end;
        yield chunk;
    }
}
}}),
"[project]/node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-stream-iterator.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "makeStreamIterator": (()=>makeStreamIterator)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/globals.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$binary$2d$utils$2f$memory$2d$conversion$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/memory-conversion-utils.js [client] (ecmascript)");
;
function makeStreamIterator(stream, options) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBrowser"] ? makeBrowserStreamIterator(stream, options) : makeNodeStreamIterator(stream, options);
}
/**
 * Returns an async iterable that reads from a DOM (browser) stream
 * @param stream stream to iterate from
 * @see https://jakearchibald.com/2017/async-iterators-and-generators/#making-streams-iterate
 */ async function* makeBrowserStreamIterator(stream, options) {
    // WhatWG: stream is supposed to have a `getIterator` method
    // if (typeof stream.getIterator === 'function') {
    //   return stream.getIterator();
    // }
    // if (typeof stream[Symbol.asyncIterator] === 'function') {
    //   return makeToArrayBufferIterator(stream);
    // }
    // In the browser, we first need to get a lock on the stream
    const reader = stream.getReader();
    let nextBatchPromise;
    try {
        // eslint-disable-next-line no-constant-condition
        while(true){
            const currentBatchPromise = nextBatchPromise || reader.read();
            // Issue a read for an additional batch, while we await the next batch
            // Idea is to make fetching happen in parallel with processing / parsing
            if (options?._streamReadAhead) {
                nextBatchPromise = reader.read();
            }
            // Read from the stream
            // value is a Uint8Array
            const { done, value } = await currentBatchPromise;
            // Exit if we're done
            if (done) {
                return;
            }
            // Else yield the chunk
            yield (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$binary$2d$utils$2f$memory$2d$conversion$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toArrayBuffer"])(value);
        }
    } catch (error) {
        // TODO - examples makes it look like this should always be called,
        // but that generates exceptions so only call it if we do not reach the end
        reader.releaseLock();
    }
}
/**
 * Returns an async iterable that reads from a DOM (browser) stream
 * @param stream stream to iterate from
 * @note Requires Node.js >= 10
 */ async function* makeNodeStreamIterator(stream, options) {
    // Hacky test for node version to ensure we don't call bad polyfills
    // NODE 10+: stream is an asyncIterator
    for await (const chunk of stream){
        yield (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$binary$2d$utils$2f$memory$2d$conversion$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toArrayBuffer"])(chunk); // Coerce each chunk to ArrayBuffer
    }
} /* TODO - remove NODE < 10
 * @see https://github.com/bustle/streaming-iterables, MIT license
 *
  if (typeof stream[Symbol.asyncIterator] === 'function') {
    return;
  }

  // TODO - check if is this ever used in Node 10+?
  // eslint-disable-next-line no-constant-condition
  while (true) {
    const data = stream.read();
    if (data !== null) {
      yield toArrayBuffer(data);
      // eslint-disable-next-line no-continue
      continue;
    }
    if (stream._readableState?.ended) {
      return;
    }
    await onceReadable(stream);
  }

async function onceReadable(stream: Readable): Promise<any> {
  return new Promise((resolve) => {
    stream.once('readable', resolve);
  });
}
  */ 
}}),
"[project]/node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-iterator.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "makeIterator": (()=>makeIterator)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$iterators$2f$make$2d$iterator$2f$make$2d$string$2d$iterator$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-string-iterator.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$iterators$2f$make$2d$iterator$2f$make$2d$array$2d$buffer$2d$iterator$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-array-buffer-iterator.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$iterators$2f$make$2d$iterator$2f$make$2d$blob$2d$iterator$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-blob-iterator.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$iterators$2f$make$2d$iterator$2f$make$2d$stream$2d$iterator$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-stream-iterator.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js [client] (ecmascript)");
;
;
;
;
;
function makeIterator(data, options) {
    if (typeof data === 'string') {
        // Note: Converts string chunks to binary
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$iterators$2f$make$2d$iterator$2f$make$2d$string$2d$iterator$2e$js__$5b$client$5d$__$28$ecmascript$29$__["makeStringIterator"])(data, options);
    }
    if (data instanceof ArrayBuffer) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$iterators$2f$make$2d$iterator$2f$make$2d$array$2d$buffer$2d$iterator$2e$js__$5b$client$5d$__$28$ecmascript$29$__["makeArrayBufferIterator"])(data, options);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBlob"])(data)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$iterators$2f$make$2d$iterator$2f$make$2d$blob$2d$iterator$2e$js__$5b$client$5d$__$28$ecmascript$29$__["makeBlobIterator"])(data, options);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isReadableStream"])(data)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$iterators$2f$make$2d$iterator$2f$make$2d$stream$2d$iterator$2e$js__$5b$client$5d$__$28$ecmascript$29$__["makeStreamIterator"])(data, options);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isResponse"])(data)) {
        const response = data;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$iterators$2f$make$2d$iterator$2f$make$2d$stream$2d$iterator$2e$js__$5b$client$5d$__$28$ecmascript$29$__["makeStreamIterator"])(response.body, options);
    }
    throw new Error('makeIterator');
}
}}),
"[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/get-data.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "getArrayBufferOrStringFromData": (()=>getArrayBufferOrStringFromData),
    "getArrayBufferOrStringFromDataSync": (()=>getArrayBufferOrStringFromDataSync),
    "getAsyncIterableFromData": (()=>getAsyncIterableFromData),
    "getReadableStream": (()=>getReadableStream)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$iterators$2f$async$2d$iteration$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/iterators/async-iteration.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$iterators$2f$make$2d$iterator$2f$make$2d$iterator$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-iterator.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$response$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/utils/response-utils.js [client] (ecmascript)");
;
;
;
;
const ERR_DATA = 'Cannot convert supplied data type';
function getArrayBufferOrStringFromDataSync(data, loader, options) {
    if (loader.text && typeof data === 'string') {
        return data;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBuffer"])(data)) {
        // @ts-ignore
        data = data.buffer;
    }
    if (data instanceof ArrayBuffer) {
        const arrayBuffer = data;
        if (loader.text && !loader.binary) {
            const textDecoder = new TextDecoder('utf8');
            return textDecoder.decode(arrayBuffer);
        }
        return arrayBuffer;
    }
    // We may need to handle offsets
    if (ArrayBuffer.isView(data)) {
        // TextDecoder is invoked on typed arrays and will handle offsets
        if (loader.text && !loader.binary) {
            const textDecoder = new TextDecoder('utf8');
            return textDecoder.decode(data);
        }
        let arrayBuffer = data.buffer;
        // Since we are returning the underlying arrayBuffer, we must create a new copy
        // if this typed array / Buffer is a partial view into the ArryayBuffer
        // TODO - this is a potentially unnecessary copy
        const byteLength = data.byteLength || data.length;
        if (data.byteOffset !== 0 || byteLength !== arrayBuffer.byteLength) {
            // console.warn(`loaders.gl copying arraybuffer of length ${byteLength}`);
            arrayBuffer = arrayBuffer.slice(data.byteOffset, data.byteOffset + byteLength);
        }
        return arrayBuffer;
    }
    throw new Error(ERR_DATA);
}
async function getArrayBufferOrStringFromData(data, loader, options) {
    const isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);
    if (typeof data === 'string' || isArrayBuffer) {
        return getArrayBufferOrStringFromDataSync(data, loader, options);
    }
    // Blobs and files are FileReader compatible
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBlob"])(data)) {
        data = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$response$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["makeResponse"])(data);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isResponse"])(data)) {
        const response = data;
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$response$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["checkResponse"])(response);
        return loader.binary ? await response.arrayBuffer() : await response.text();
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isReadableStream"])(data)) {
        // @ts-expect-error TS2559 options type
        data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$iterators$2f$make$2d$iterator$2f$make$2d$iterator$2e$js__$5b$client$5d$__$28$ecmascript$29$__["makeIterator"])(data, options);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isIterable"])(data) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isAsyncIterable"])(data)) {
        // Assume arrayBuffer iterator - attempt to concatenate
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$iterators$2f$async$2d$iteration$2e$js__$5b$client$5d$__$28$ecmascript$29$__["concatenateArrayBuffersAsync"])(data);
    }
    throw new Error(ERR_DATA);
}
async function getAsyncIterableFromData(data, options) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isIterator"])(data)) {
        return data;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isResponse"])(data)) {
        const response = data;
        // Note Since this function is not async, we currently can't load error message, just status
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$response$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["checkResponse"])(response);
        // TODO - bug in polyfill, body can be a Promise under Node.js
        // eslint-disable-next-line @typescript-eslint/await-thenable
        const body = await response.body;
        // TODO - body can be null?
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$iterators$2f$make$2d$iterator$2f$make$2d$iterator$2e$js__$5b$client$5d$__$28$ecmascript$29$__["makeIterator"])(body, options);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBlob"])(data) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isReadableStream"])(data)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$iterators$2f$make$2d$iterator$2f$make$2d$iterator$2e$js__$5b$client$5d$__$28$ecmascript$29$__["makeIterator"])(data, options);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isAsyncIterable"])(data)) {
        return data;
    }
    return getIterableFromData(data);
}
async function getReadableStream(data) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isReadableStream"])(data)) {
        return data;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isResponse"])(data)) {
        // @ts-ignore
        return data.body;
    }
    const response = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$response$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["makeResponse"])(data);
    // @ts-ignore
    return response.body;
}
// HELPERS
function getIterableFromData(data) {
    // generate an iterator that emits a single chunk
    if (ArrayBuffer.isView(data)) {
        return function* oneChunk() {
            yield data.buffer;
        }();
    }
    if (data instanceof ArrayBuffer) {
        return function* oneChunk() {
            yield data;
        }();
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isIterator"])(data)) {
        return data;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isIterable"])(data)) {
        return data[Symbol.iterator]();
    }
    throw new Error(ERR_DATA);
}
}}),
"[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/loader-context.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "getLoaderContext": (()=>getLoaderContext),
    "getLoadersFromContext": (()=>getLoadersFromContext)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$get$2d$fetch$2d$function$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/get-fetch-function.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$url$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/utils/url-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$path$2d$utils$2f$path$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__path$3e$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/path.js [client] (ecmascript) <export * as path>");
;
;
;
function getLoaderContext(context, options, parentContext) {
    // For recursive calls, we already have a context
    // TODO - add any additional loaders to context?
    if (parentContext) {
        return parentContext;
    }
    const newContext = {
        fetch: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$get$2d$fetch$2d$function$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getFetchFunction"])(options, context),
        ...context
    };
    // Parse URLs so that subloaders can easily generate correct strings
    if (newContext.url) {
        const baseUrl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$url$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["stripQueryString"])(newContext.url);
        newContext.baseUrl = baseUrl;
        newContext.queryString = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$url$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["extractQueryString"])(newContext.url);
        newContext.filename = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$path$2d$utils$2f$path$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__path$3e$__["path"].filename(baseUrl);
        newContext.baseUrl = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$path$2d$utils$2f$path$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__path$3e$__["path"].dirname(baseUrl);
    }
    // Recursive loading does not use single loader
    if (!Array.isArray(newContext.loaders)) {
        newContext.loaders = null;
    }
    return newContext;
}
function getLoadersFromContext(loaders, context) {
    // A single loader (non-array) indicates no selection desired. Force select.
    if (loaders && !Array.isArray(loaders)) {
        return loaders;
    }
    // Create a merged list
    let candidateLoaders;
    if (loaders) {
        candidateLoaders = Array.isArray(loaders) ? loaders : [
            loaders
        ];
    }
    if (context && context.loaders) {
        const contextLoaders = Array.isArray(context.loaders) ? context.loaders : [
            context.loaders
        ];
        candidateLoaders = candidateLoaders ? [
            ...candidateLoaders,
            ...contextLoaders
        ] : contextLoaders;
    }
    // If no loaders, return null to look in globally registered loaders
    return candidateLoaders && candidateLoaders.length ? candidateLoaders : undefined;
}
}}),
"[project]/node_modules/@loaders.gl/core/dist/lib/api/register-loaders.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "_unregisterLoaders": (()=>_unregisterLoaders),
    "getRegisteredLoaders": (()=>getRegisteredLoaders),
    "registerLoaders": (()=>registerLoaders)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$normalize$2d$loader$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/normalize-loader.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$option$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/option-utils.js [client] (ecmascript)");
;
;
/**
 * Store global registered loaders on the global object to increase chances of cross loaders-version interoperability
 * This use case is not reliable but can help when testing new versions of loaders.gl with existing frameworks
 */ const getGlobalLoaderRegistry = ()=>{
    const state = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$option$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getGlobalLoaderState"])();
    state.loaderRegistry = state.loaderRegistry || [];
    return state.loaderRegistry;
};
function registerLoaders(loaders) {
    const loaderRegistry = getGlobalLoaderRegistry();
    loaders = Array.isArray(loaders) ? loaders : [
        loaders
    ];
    for (const loader of loaders){
        const normalizedLoader = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$normalize$2d$loader$2e$js__$5b$client$5d$__$28$ecmascript$29$__["normalizeLoader"])(loader);
        if (!loaderRegistry.find((registeredLoader)=>normalizedLoader === registeredLoader)) {
            // add to the beginning of the loaderRegistry, so the last registeredLoader get picked
            loaderRegistry.unshift(normalizedLoader);
        }
    }
}
function getRegisteredLoaders() {
    return getGlobalLoaderRegistry();
}
function _unregisterLoaders() {
    const state = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$option$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getGlobalLoaderState"])();
    state.loaderRegistry = [];
}
}}),
"[project]/node_modules/@loaders.gl/core/dist/lib/api/select-loader.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "selectLoader": (()=>selectLoader),
    "selectLoaderSync": (()=>selectLoaderSync)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$binary$2d$utils$2f$array$2d$buffer$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/array-buffer-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$path$2d$utils$2f$path$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__path$3e$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/path.js [client] (ecmascript) <export * as path>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$log$2d$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/log-utils/log.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$normalize$2d$loader$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/normalize-loader.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$resource$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/utils/resource-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$mime$2d$type$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/utils/mime-type-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$api$2f$register$2d$loaders$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/api/register-loaders.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$url$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/utils/url-utils.js [client] (ecmascript)");
;
;
;
;
;
;
;
const EXT_PATTERN = /\.([^.]+)$/;
async function selectLoader(data, loaders = [], options, context) {
    if (!validHTTPResponse(data)) {
        return null;
    }
    // First make a sync attempt, disabling exceptions
    let loader = selectLoaderSync(data, loaders, {
        ...options,
        nothrow: true
    }, context);
    if (loader) {
        return loader;
    }
    // For Blobs and Files, try to asynchronously read a small initial slice and test again with that
    // to see if we can detect by initial content
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBlob"])(data)) {
        data = await data.slice(0, 10).arrayBuffer();
        loader = selectLoaderSync(data, loaders, options, context);
    }
    // no loader available
    if (!loader && !options?.nothrow) {
        throw new Error(getNoValidLoaderMessage(data));
    }
    return loader;
}
function selectLoaderSync(data, loaders = [], options, context) {
    if (!validHTTPResponse(data)) {
        return null;
    }
    // eslint-disable-next-line complexity
    // if only a single loader was provided (not as array), force its use
    // TODO - Should this behavior be kept and documented?
    if (loaders && !Array.isArray(loaders)) {
        // TODO - remove support for legacy loaders
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$normalize$2d$loader$2e$js__$5b$client$5d$__$28$ecmascript$29$__["normalizeLoader"])(loaders);
    }
    // Build list of candidate loaders that will be searched in order for a match
    let candidateLoaders = [];
    // First search supplied loaders
    if (loaders) {
        candidateLoaders = candidateLoaders.concat(loaders);
    }
    // Then fall back to registered loaders
    if (!options?.ignoreRegisteredLoaders) {
        candidateLoaders.push(...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$api$2f$register$2d$loaders$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getRegisteredLoaders"])());
    }
    // TODO - remove support for legacy loaders
    normalizeLoaders(candidateLoaders);
    const loader = selectLoaderInternal(data, candidateLoaders, options, context);
    // no loader available
    if (!loader && !options?.nothrow) {
        throw new Error(getNoValidLoaderMessage(data));
    }
    return loader;
}
/** Implements loaders selection logic */ // eslint-disable-next-line complexity
function selectLoaderInternal(data, loaders, options, context) {
    const url = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$resource$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getResourceUrl"])(data);
    const type = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$resource$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getResourceMIMEType"])(data);
    const testUrl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$url$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["stripQueryString"])(url) || context?.url;
    let loader = null;
    let reason = '';
    // if options.mimeType is supplied, it takes precedence
    if (options?.mimeType) {
        loader = findLoaderByMIMEType(loaders, options?.mimeType);
        reason = `match forced by supplied MIME type ${options?.mimeType}`;
    }
    // Look up loader by url
    loader = loader || findLoaderByUrl(loaders, testUrl);
    reason = reason || (loader ? `matched url ${testUrl}` : '');
    // Look up loader by mime type
    loader = loader || findLoaderByMIMEType(loaders, type);
    reason = reason || (loader ? `matched MIME type ${type}` : '');
    // Look for loader via initial bytes (Note: not always accessible (e.g. Response, stream, async iterator)
    // @ts-ignore Blob | Response
    loader = loader || findLoaderByInitialBytes(loaders, data);
    // @ts-ignore Blob | Response
    reason = reason || (loader ? `matched initial data ${getFirstCharacters(data)}` : '');
    // Look up loader by fallback mime type
    if (options?.fallbackMimeType) {
        loader = loader || findLoaderByMIMEType(loaders, options?.fallbackMimeType);
        reason = reason || (loader ? `matched fallback MIME type ${type}` : '');
    }
    if (reason) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$log$2d$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].log(1, `selectLoader selected ${loader?.name}: ${reason}.`);
    }
    return loader;
}
/** Check HTTP Response */ function validHTTPResponse(data) {
    // HANDLE HTTP status
    if (data instanceof Response) {
        // 204 - NO CONTENT. This handles cases where e.g. a tile server responds with 204 for a missing tile
        if (data.status === 204) {
            return false;
        }
    }
    return true;
}
/** Generate a helpful message to help explain why loader selection failed. */ function getNoValidLoaderMessage(data) {
    const url = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$resource$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getResourceUrl"])(data);
    const type = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$resource$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getResourceMIMEType"])(data);
    let message = 'No valid loader found (';
    message += url ? `${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$path$2d$utils$2f$path$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__path$3e$__["path"].filename(url)}, ` : 'no url provided, ';
    message += `MIME type: ${type ? `"${type}"` : 'not provided'}, `;
    // First characters are only accessible when called on data (string or arrayBuffer).
    // @ts-ignore Blob | Response
    const firstCharacters = data ? getFirstCharacters(data) : '';
    message += firstCharacters ? ` first bytes: "${firstCharacters}"` : 'first bytes: not available';
    message += ')';
    return message;
}
function normalizeLoaders(loaders) {
    for (const loader of loaders){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$normalize$2d$loader$2e$js__$5b$client$5d$__$28$ecmascript$29$__["normalizeLoader"])(loader);
    }
}
// TODO - Would be nice to support http://example.com/file.glb?parameter=1
// E.g: x = new URL('http://example.com/file.glb?load=1'; x.pathname
function findLoaderByUrl(loaders, url) {
    // Get extension
    const match = url && EXT_PATTERN.exec(url);
    const extension = match && match[1];
    return extension ? findLoaderByExtension(loaders, extension) : null;
}
function findLoaderByExtension(loaders, extension) {
    extension = extension.toLowerCase();
    for (const loader of loaders){
        for (const loaderExtension of loader.extensions){
            if (loaderExtension.toLowerCase() === extension) {
                return loader;
            }
        }
    }
    return null;
}
function findLoaderByMIMEType(loaders, mimeType) {
    for (const loader of loaders){
        if (loader.mimeTypes?.some((mimeType1)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$mime$2d$type$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["compareMIMETypes"])(mimeType, mimeType1))) {
            return loader;
        }
        // Support referring to loaders using the "unregistered tree"
        // https://en.wikipedia.org/wiki/Media_type#Unregistered_tree
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$mime$2d$type$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["compareMIMETypes"])(mimeType, `application/x.${loader.id}`)) {
            return loader;
        }
    }
    return null;
}
function findLoaderByInitialBytes(loaders, data) {
    if (!data) {
        return null;
    }
    for (const loader of loaders){
        if (typeof data === 'string') {
            if (testDataAgainstText(data, loader)) {
                return loader;
            }
        } else if (ArrayBuffer.isView(data)) {
            // Typed Arrays can have offsets into underlying buffer
            if (testDataAgainstBinary(data.buffer, data.byteOffset, loader)) {
                return loader;
            }
        } else if (data instanceof ArrayBuffer) {
            const byteOffset = 0;
            if (testDataAgainstBinary(data, byteOffset, loader)) {
                return loader;
            }
        }
    // TODO Handle streaming case (requires creating a new AsyncIterator)
    }
    return null;
}
function testDataAgainstText(data, loader) {
    if (loader.testText) {
        return loader.testText(data);
    }
    const tests = Array.isArray(loader.tests) ? loader.tests : [
        loader.tests
    ];
    return tests.some((test)=>data.startsWith(test));
}
function testDataAgainstBinary(data, byteOffset, loader) {
    const tests = Array.isArray(loader.tests) ? loader.tests : [
        loader.tests
    ];
    return tests.some((test)=>testBinary(data, byteOffset, loader, test));
}
function testBinary(data, byteOffset, loader, test) {
    if (test instanceof ArrayBuffer) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$binary$2d$utils$2f$array$2d$buffer$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["compareArrayBuffers"])(test, data, test.byteLength);
    }
    switch(typeof test){
        case 'function':
            return test(data);
        case 'string':
            // Magic bytes check: If `test` is a string, check if binary data starts with that strings
            const magic = getMagicString(data, byteOffset, test.length);
            return test === magic;
        default:
            return false;
    }
}
function getFirstCharacters(data, length = 5) {
    if (typeof data === 'string') {
        return data.slice(0, length);
    } else if (ArrayBuffer.isView(data)) {
        // Typed Arrays can have offsets into underlying buffer
        return getMagicString(data.buffer, data.byteOffset, length);
    } else if (data instanceof ArrayBuffer) {
        const byteOffset = 0;
        return getMagicString(data, byteOffset, length);
    }
    return '';
}
function getMagicString(arrayBuffer, byteOffset, length) {
    if (arrayBuffer.byteLength < byteOffset + length) {
        return '';
    }
    const dataView = new DataView(arrayBuffer);
    let magic = '';
    for(let i = 0; i < length; i++){
        magic += String.fromCharCode(dataView.getUint8(byteOffset + i));
    }
    return magic;
}
}}),
"[project]/node_modules/@loaders.gl/core/dist/lib/api/parse.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "parse": (()=>parse)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$worker$2d$loader$2d$utils$2f$parse$2d$with$2d$worker$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/worker-loader-utils/parse-with-worker.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$option$2d$utils$2f$merge$2d$loader$2d$options$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/option-utils/merge-loader-options.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/assert.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$api$2f$validate$2d$worker$2d$version$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/worker-api/validate-worker-version.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$normalize$2d$loader$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/normalize-loader.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$option$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/option-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$get$2d$data$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/get-data.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$loader$2d$context$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/loader-context.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$resource$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/utils/resource-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$api$2f$select$2d$loader$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/api/select-loader.js [client] (ecmascript)");
;
;
;
;
;
;
;
;
;
async function parse(data, loaders, options, context) {
    // Signature: parse(data, options, context | url)
    // Uses registered loaders
    if (loaders && !Array.isArray(loaders) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$normalize$2d$loader$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isLoaderObject"])(loaders)) {
        context = undefined; // context not supported in short signature
        options = loaders;
        loaders = undefined;
    }
    data = await data; // Resolve any promise
    options = options || {}; // Could be invalid...
    // Extract a url for auto detection
    const url = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$utils$2f$resource$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getResourceUrl"])(data);
    // Chooses a loader (and normalizes it)
    // Also use any loaders in the context, new loaders take priority
    const typedLoaders = loaders;
    const candidateLoaders = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$loader$2d$context$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getLoadersFromContext"])(typedLoaders, context);
    // todo hacky type cast
    const loader = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$api$2f$select$2d$loader$2e$js__$5b$client$5d$__$28$ecmascript$29$__["selectLoader"])(data, candidateLoaders, options);
    // Note: if no loader was found, if so just return null
    if (!loader) {
        return null;
    }
    // Normalize options
    // @ts-expect-error
    options = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$option$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["normalizeOptions"])(options, loader, candidateLoaders, url); // Could be invalid...
    // Get a context (if already present, will be unchanged)
    context = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$loader$2d$context$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getLoaderContext"])(// @ts-expect-error
    {
        url,
        _parse: parse,
        loaders: candidateLoaders
    }, options, context || null);
    return await parseWithLoader(loader, data, options, context);
}
// TODO: support progress and abort
// TODO - should accept loader.parseAsyncIterator and concatenate.
async function parseWithLoader(loader, data, options, context) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$api$2f$validate$2d$worker$2d$version$2e$js__$5b$client$5d$__$28$ecmascript$29$__["validateWorkerVersion"])(loader);
    options = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$option$2d$utils$2f$merge$2d$loader$2d$options$2e$js__$5b$client$5d$__$28$ecmascript$29$__["mergeLoaderOptions"])(loader.options, options);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isResponse"])(data)) {
        // Serialize to support passing the response to web worker
        const response = data;
        const { ok, redirected, status, statusText, type, url } = response;
        const headers = Object.fromEntries(response.headers.entries());
        // @ts-expect-error TODO - fix this
        context.response = {
            headers,
            ok,
            redirected,
            status,
            statusText,
            type,
            url
        };
    }
    data = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$get$2d$data$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getArrayBufferOrStringFromData"])(data, loader, options);
    const loaderWithParser = loader;
    // First check for synchronous text parser, wrap results in promises
    if (loaderWithParser.parseTextSync && typeof data === 'string') {
        return loaderWithParser.parseTextSync(data, options, context);
    }
    // If we have a workerUrl and the loader can parse the given options efficiently in a worker
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$worker$2d$loader$2d$utils$2f$parse$2d$with$2d$worker$2e$js__$5b$client$5d$__$28$ecmascript$29$__["canParseWithWorker"])(loader, options)) {
        return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$worker$2d$loader$2d$utils$2f$parse$2d$with$2d$worker$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseWithWorker"])(loader, data, options, context, parse);
    }
    // Check for asynchronous parser
    if (loaderWithParser.parseText && typeof data === 'string') {
        return await loaderWithParser.parseText(data, options, context);
    }
    if (loaderWithParser.parse) {
        return await loaderWithParser.parse(data, options, context);
    }
    // This should not happen, all sync loaders should also offer `parse` function
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(!loaderWithParser.parseSync);
    // TBD - If asynchronous parser not available, return null
    throw new Error(`${loader.id} loader - no parser found and worker is disabled`);
}
}}),
"[project]/node_modules/@loaders.gl/core/dist/lib/api/load.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "load": (()=>load)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$normalize$2d$loader$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/normalize-loader.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$get$2d$fetch$2d$function$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/loader-utils/get-fetch-function.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$api$2f$parse$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/core/dist/lib/api/parse.js [client] (ecmascript)");
;
;
;
;
async function load(url, loaders, options, context) {
    let resolvedLoaders;
    let resolvedOptions;
    // Signature: load(url, options)
    if (!Array.isArray(loaders) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$normalize$2d$loader$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isLoaderObject"])(loaders)) {
        resolvedLoaders = [];
        resolvedOptions = loaders;
        context = undefined; // context not supported in short signature
    } else {
        resolvedLoaders = loaders;
        resolvedOptions = options;
    }
    // Select fetch function
    const fetch = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$loader$2d$utils$2f$get$2d$fetch$2d$function$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getFetchFunction"])(resolvedOptions);
    // at this point, `url` could be already loaded binary data
    let data = url;
    // url is a string, fetch the url
    if (typeof url === 'string') {
        data = await fetch(url);
    // URL is Blob or File, fetchFile handles it (alt: we could generate ObjectURL here)
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$javascript$2d$utils$2f$is$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBlob"])(url)) {
        // The fetch response object will contain blob.name
        // @ts-expect-error TODO - This may not work for overridden fetch functions
        data = await fetch(url);
    }
    // Data is loaded (at least we have a `Response` object) so time to hand over to `parse`
    // return await parse(data, loaders as Loader[], options);
    return Array.isArray(resolvedLoaders) ? await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$api$2f$parse$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parse"])(data, resolvedLoaders, resolvedOptions) // loader array overload
     : await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$core$2f$dist$2f$lib$2f$api$2f$parse$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parse"])(data, resolvedLoaders, resolvedOptions); // single loader overload
}
}}),
"[project]/node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/assert.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Throws an `Error` with the optional `message` if `condition` is falsy
 * @note Replacement for the external assert method to reduce bundle size
 */ __turbopack_context__.s({
    "assert": (()=>assert)
});
function assert(condition, message) {
    if (!condition) {
        throw new Error(message || 'loader assertion failed.');
    }
}
}}),
"[project]/node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/file-aliases.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Simple file alias mechanisms for tests.
__turbopack_context__.s({
    "addAliases": (()=>addAliases),
    "getPathPrefix": (()=>getPathPrefix),
    "resolvePath": (()=>resolvePath),
    "setPathPrefix": (()=>setPathPrefix)
});
let pathPrefix = '';
const fileAliases = {};
function setPathPrefix(prefix) {
    pathPrefix = prefix;
}
function getPathPrefix() {
    return pathPrefix;
}
function addAliases(aliases) {
    Object.assign(fileAliases, aliases);
}
function resolvePath(filename) {
    for(const alias in fileAliases){
        if (filename.startsWith(alias)) {
            const replacement = fileAliases[alias];
            filename = filename.replace(alias, replacement);
        }
    }
    if (!filename.startsWith('http://') && !filename.startsWith('https://')) {
        filename = `${pathPrefix}${filename}`;
    }
    return filename;
}
}}),
"[project]/node_modules/@loaders.gl/loader-utils/dist/lib/log-utils/log.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "VERSION": (()=>VERSION),
    "log": (()=>log)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/log/dist/log.js [client] (ecmascript)");
;
const VERSION = typeof "4.3.2" !== 'undefined' ? "4.3.2" : 'latest';
const version = VERSION[0] >= '0' && VERSION[0] <= '9' ? `v${VERSION}` : '';
// Make sure we set the global variable
function createLog() {
    const log = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Log"]({
        id: 'loaders.gl'
    });
    globalThis.loaders = globalThis.loaders || {};
    globalThis.loaders.log = log;
    globalThis.loaders.version = version;
    globalThis.probe = globalThis.probe || {};
    globalThis.probe.loaders = log;
    return log;
}
const log = createLog();
}}),
"[project]/node_modules/@loaders.gl/loader-utils/dist/lib/module-utils/js-module-utils.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "checkJSModule": (()=>checkJSModule),
    "getJSModule": (()=>getJSModule),
    "getJSModuleOrNull": (()=>getJSModuleOrNull),
    "registerJSModules": (()=>registerJSModules)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$log$2d$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/log-utils/log.js [client] (ecmascript)");
;
function registerJSModules(modules) {
    globalThis.loaders ||= {};
    globalThis.loaders.modules ||= {};
    Object.assign(globalThis.loaders.modules, modules);
}
function checkJSModule(name, caller) {
    const module = globalThis.loaders?.modules?.[name];
    if (!module) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$log$2d$utils$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log"].warn(`${caller}: ${name} library not installed`)();
    }
}
function getJSModule(name, caller) {
    const module = globalThis.loaders?.modules?.[name];
    if (!module) {
        throw new Error(`${caller}: ${name} library not installed`);
    }
    return module;
}
function getJSModuleOrNull(name) {
    const module = globalThis.loaders?.modules?.[name];
    return module || null;
}
}}),
"[project]/node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/globals.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Purpose: include this in your module to avoid
// dependencies on micro modules like 'global' and 'is-browser';
/* eslint-disable no-restricted-globals */ __turbopack_context__.s({
    "document": (()=>document_),
    "global": (()=>global_),
    "isBrowser": (()=>isBrowser),
    "isWorker": (()=>isWorker),
    "nodeVersion": (()=>nodeVersion),
    "self": (()=>self_),
    "window": (()=>window_)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
const globals = {
    self: typeof self !== 'undefined' && self,
    window: typeof window !== 'undefined' && window,
    global: typeof global !== 'undefined' && global,
    document: typeof document !== 'undefined' && document
};
const self_ = globals.self || globals.window || globals.global || {};
const window_ = globals.window || globals.self || globals.global || {};
const global_ = globals.global || globals.self || globals.window || {};
const document_ = globals.document || {};
;
const isBrowser = // @ts-ignore process does not exist on browser
Boolean(typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"] !== 'object' || String(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"]) !== '[object process]' || ("TURBOPACK compile-time value", true));
const isWorker = typeof importScripts === 'function';
// Extract node major version
const matches = typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"] !== 'undefined' && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].version && /v([0-9]*)/.exec(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].version);
const nodeVersion = matches && parseFloat(matches[1]) || 0;
}}),
"[project]/node_modules/@loaders.gl/loader-utils/dist/lib/worker-loader-utils/parse-with-worker.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "canParseWithWorker": (()=>canParseWithWorker),
    "parseWithWorker": (()=>parseWithWorker)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/globals.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$farm$2f$worker$2d$farm$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__WorkerFarm$3e$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-farm.js [client] (ecmascript) <export default as WorkerFarm>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$api$2f$get$2d$worker$2d$url$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/worker-api/get-worker-url.js [client] (ecmascript)");
;
function canParseWithWorker(loader, options) {
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$farm$2f$worker$2d$farm$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__WorkerFarm$3e$__["WorkerFarm"].isSupported()) {
        return false;
    }
    // Node workers are still experimental
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBrowser"] && !options?._nodeWorkers) {
        return false;
    }
    return loader.worker && options?.worker;
}
async function parseWithWorker(loader, data, options, context, parseOnMainThread) {
    const name = loader.id; // TODO
    const url = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$api$2f$get$2d$worker$2d$url$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getWorkerURL"])(loader, options);
    const workerFarm = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$farm$2f$worker$2d$farm$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__WorkerFarm$3e$__["WorkerFarm"].getWorkerFarm(options);
    const workerPool = workerFarm.getWorkerPool({
        name,
        url
    });
    // options.log object contains functions which cannot be transferred
    // context.fetch & context.parse functions cannot be transferred
    // TODO - decide how to handle logging on workers
    options = JSON.parse(JSON.stringify(options));
    context = JSON.parse(JSON.stringify(context || {}));
    const job = await workerPool.startJob('process-on-worker', // @ts-expect-error
    onMessage.bind(null, parseOnMainThread) // eslint-disable-line @typescript-eslint/no-misused-promises
    );
    job.postMessage('process', {
        // @ts-ignore
        input: data,
        options,
        context
    });
    const result = await job.result;
    // TODO - what is going on here?
    return await result.result;
}
/**
 * Handle worker's responses to the main thread
 * @param job
 * @param type
 * @param payload
 */ async function onMessage(parseOnMainThread, job, type, payload) {
    switch(type){
        case 'done':
            job.done(payload);
            break;
        case 'error':
            job.error(new Error(payload.error));
            break;
        case 'process':
            // Worker is asking for main thread to parseO
            const { id, input, options } = payload;
            try {
                const result = await parseOnMainThread(input, options);
                job.postMessage('done', {
                    id,
                    result
                });
            } catch (error) {
                const message = error instanceof Error ? error.message : 'unknown error';
                job.postMessage('error', {
                    id,
                    error: message
                });
            }
            break;
        default:
            // eslint-disable-next-line
            console.warn(`parse-with-worker unknown message ${type}`);
    }
}
}}),
"[project]/node_modules/@loaders.gl/loader-utils/dist/lib/option-utils/merge-loader-options.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/**
 *
 * @param baseOptions Can be undefined, in which case a fresh options object will be minted
 * @param newOptions
 * @returns
 */ __turbopack_context__.s({
    "mergeLoaderOptions": (()=>mergeLoaderOptions)
});
function mergeLoaderOptions(baseOptions, newOptions) {
    return mergeOptionsRecursively(baseOptions || {}, newOptions);
}
function mergeOptionsRecursively(baseOptions, newOptions, level = 0) {
    // Sanity check (jest test runner overwrites the console object which can lead to infinite recursion)
    if (level > 3) {
        return newOptions;
    }
    const options = {
        ...baseOptions
    };
    for (const [key, newValue] of Object.entries(newOptions)){
        if (newValue && typeof newValue === 'object' && !Array.isArray(newValue)) {
            options[key] = mergeOptionsRecursively(options[key] || {}, newOptions[key], level + 1);
        // Object.assign(options[key] as object, newOptions[key]);
        } else {
            options[key] = newOptions[key];
        }
    }
    return options;
}
}}),
"[project]/node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/array-buffer-utils.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * compare two binary arrays for equality
 * @param a
 * @param b
 * @param byteLength
 */ __turbopack_context__.s({
    "compareArrayBuffers": (()=>compareArrayBuffers),
    "concatenateArrayBuffers": (()=>concatenateArrayBuffers),
    "concatenateArrayBuffersFromArray": (()=>concatenateArrayBuffersFromArray),
    "concatenateTypedArrays": (()=>concatenateTypedArrays),
    "sliceArrayBuffer": (()=>sliceArrayBuffer)
});
function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {
    byteLength = byteLength || arrayBuffer1.byteLength;
    if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {
        return false;
    }
    const array1 = new Uint8Array(arrayBuffer1);
    const array2 = new Uint8Array(arrayBuffer2);
    for(let i = 0; i < array1.length; ++i){
        if (array1[i] !== array2[i]) {
            return false;
        }
    }
    return true;
}
function concatenateArrayBuffers(...sources) {
    return concatenateArrayBuffersFromArray(sources);
}
function concatenateArrayBuffersFromArray(sources) {
    // Make sure all inputs are wrapped in typed arrays
    const sourceArrays = sources.map((source2)=>source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2);
    // Get length of all inputs
    const byteLength = sourceArrays.reduce((length, typedArray)=>length + typedArray.byteLength, 0);
    // Allocate array with space for all inputs
    const result = new Uint8Array(byteLength);
    // Copy the subarrays
    let offset = 0;
    for (const sourceArray of sourceArrays){
        result.set(sourceArray, offset);
        offset += sourceArray.byteLength;
    }
    // We work with ArrayBuffers, discard the typed array wrapper
    return result.buffer;
}
function concatenateTypedArrays(...typedArrays) {
    // @ts-ignore
    const arrays = typedArrays;
    // @ts-ignore
    const TypedArrayConstructor = arrays && arrays.length > 1 && arrays[0].constructor || null;
    if (!TypedArrayConstructor) {
        throw new Error('"concatenateTypedArrays" - incorrect quantity of arguments or arguments have incompatible data types');
    }
    const sumLength = arrays.reduce((acc, value)=>acc + value.length, 0);
    // @ts-ignore typescript does not like dynamic constructors
    const result = new TypedArrayConstructor(sumLength);
    let offset = 0;
    for (const array of arrays){
        result.set(array, offset);
        offset += array.length;
    }
    return result;
}
function sliceArrayBuffer(arrayBuffer, byteOffset, byteLength) {
    const subArray = byteLength !== undefined ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength) : new Uint8Array(arrayBuffer).subarray(byteOffset);
    const arrayCopy = new Uint8Array(subArray);
    return arrayCopy.buffer;
}
}}),
"[project]/node_modules/@loaders.gl/loader-utils/dist/lib/iterators/async-iteration.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "concatenateArrayBuffersAsync": (()=>concatenateArrayBuffersAsync),
    "concatenateStringsAsync": (()=>concatenateStringsAsync),
    "forEach": (()=>forEach)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$binary$2d$utils$2f$array$2d$buffer$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/array-buffer-utils.js [client] (ecmascript)");
;
async function forEach(iterator, visitor) {
    // eslint-disable-next-line
    while(true){
        const { done, value } = await iterator.next();
        if (done) {
            iterator.return();
            return;
        }
        const cancel = visitor(value);
        if (cancel) {
            return;
        }
    }
}
async function concatenateArrayBuffersAsync(asyncIterator) {
    const arrayBuffers = [];
    for await (const chunk of asyncIterator){
        arrayBuffers.push(chunk);
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$binary$2d$utils$2f$array$2d$buffer$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["concatenateArrayBuffers"])(...arrayBuffers);
}
async function concatenateStringsAsync(asyncIterator) {
    const strings = [];
    for await (const chunk of asyncIterator){
        strings.push(chunk);
    }
    return strings.join('');
}
}}),
"[project]/node_modules/@loaders.gl/loader-utils/dist/lib/node/buffer.browser.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// Isolates Buffer references to ensure they are only bundled under Node.js (avoids big webpack polyfill)
// this file is selected by the package.json "browser" field).
/**
 * Convert Buffer to ArrayBuffer
 * Converts Node.js `Buffer` to `ArrayBuffer` (without triggering bundler to include Buffer polyfill on browser)
 * @todo better data type
 */ __turbopack_context__.s({
    "toArrayBuffer": (()=>toArrayBuffer),
    "toBuffer": (()=>toBuffer)
});
function toArrayBuffer(buffer) {
    return buffer;
}
function toBuffer(binaryData) {
    throw new Error('Buffer not supported in browser');
}
}}),
"[project]/node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/memory-conversion-utils.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "isBuffer": (()=>isBuffer),
    "toArrayBuffer": (()=>toArrayBuffer),
    "toBuffer": (()=>toBuffer)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$node$2f$buffer$2e$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/node/buffer.browser.js [client] (ecmascript)");
;
function isBuffer(value) {
    return value && typeof value === 'object' && value.isBuffer;
}
function toBuffer(data) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$node$2f$buffer$2e$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toBuffer"] ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$node$2f$buffer$2e$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toBuffer"])(data) : data;
}
function toArrayBuffer(data) {
    // Note: Should be called first, Buffers can trigger other detections below
    if (isBuffer(data)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$node$2f$buffer$2e$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toArrayBuffer"])(data);
    }
    if (data instanceof ArrayBuffer) {
        return data;
    }
    // Careful - Node Buffers look like Uint8Arrays (keep after isBuffer)
    if (ArrayBuffer.isView(data)) {
        if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {
            return data.buffer;
        }
        return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
    }
    if (typeof data === 'string') {
        const text = data;
        const uint8Array = new TextEncoder().encode(text);
        return uint8Array.buffer;
    }
    // HACK to support Blob polyfill
    if (data && typeof data === 'object' && data._toArrayBuffer) {
        return data._toArrayBuffer();
    }
    throw new Error('toArrayBuffer');
}
}}),
"[project]/node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/get-cwd.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl MIT license
__turbopack_context__.s({
    "getCWD": (()=>getCWD)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
function getCWD() {
    if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"] !== 'undefined' && typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].cwd !== 'undefined') {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].cwd();
    }
    const pathname = window.location?.pathname;
    return pathname?.slice(0, pathname.lastIndexOf('/') + 1) || '';
}
}}),
"[project]/node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/path.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Beginning of a minimal implementation of the Node.js path API, that doesn't pull in big polyfills.
__turbopack_context__.s({
    "dirname": (()=>dirname),
    "filename": (()=>filename),
    "join": (()=>join),
    "resolve": (()=>resolve)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$path$2d$utils$2f$get$2d$cwd$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/get-cwd.js [client] (ecmascript)");
;
function filename(url) {
    const slashIndex = url ? url.lastIndexOf('/') : -1;
    return slashIndex >= 0 ? url.substr(slashIndex + 1) : '';
}
function dirname(url) {
    const slashIndex = url ? url.lastIndexOf('/') : -1;
    return slashIndex >= 0 ? url.substr(0, slashIndex) : '';
}
function join(...parts) {
    const separator = '/';
    parts = parts.map((part, index)=>{
        if (index) {
            part = part.replace(new RegExp(`^${separator}`), '');
        }
        if (index !== parts.length - 1) {
            part = part.replace(new RegExp(`${separator}$`), '');
        }
        return part;
    });
    return parts.join(separator);
}
function resolve(...components) {
    const paths = [];
    for(let _i = 0; _i < components.length; _i++){
        paths[_i] = components[_i];
    }
    let resolvedPath = '';
    let resolvedAbsolute = false;
    let cwd;
    for(let i = paths.length - 1; i >= -1 && !resolvedAbsolute; i--){
        let path;
        if (i >= 0) {
            path = paths[i];
        } else {
            if (cwd === undefined) {
                cwd = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$path$2d$utils$2f$get$2d$cwd$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getCWD"])();
            }
            path = cwd;
        }
        // Skip empty entries
        if (path.length === 0) {
            continue;
        }
        resolvedPath = `${path}/${resolvedPath}`;
        resolvedAbsolute = path.charCodeAt(0) === SLASH;
    }
    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)
    // Normalize the path (removes leading slash)
    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
    if (resolvedAbsolute) {
        return `/${resolvedPath}`;
    } else if (resolvedPath.length > 0) {
        return resolvedPath;
    }
    return '.';
}
const SLASH = 47;
const DOT = 46;
/**
 * Resolves . and .. elements in a path with directory names
 * Forked from BTOdell/path-resolve under MIT license
 * @see https://github.com/BTOdell/path-resolve/blob/master/LICENSE
 */ /* eslint-disable max-depth */ // eslint-disable-next-line complexity, max-statements
function normalizeStringPosix(path, allowAboveRoot) {
    let res = '';
    let lastSlash = -1;
    let dots = 0;
    let code;
    let isAboveRoot = false;
    for(let i = 0; i <= path.length; ++i){
        if (i < path.length) {
            code = path.charCodeAt(i);
        } else if (code === SLASH) {
            break;
        } else {
            code = SLASH;
        }
        if (code === SLASH) {
            if (lastSlash === i - 1 || dots === 1) {
            // NOOP
            } else if (lastSlash !== i - 1 && dots === 2) {
                if (res.length < 2 || !isAboveRoot || res.charCodeAt(res.length - 1) !== DOT || res.charCodeAt(res.length - 2) !== DOT) {
                    if (res.length > 2) {
                        const start = res.length - 1;
                        let j = start;
                        for(; j >= 0; --j){
                            if (res.charCodeAt(j) === SLASH) {
                                break;
                            }
                        }
                        if (j !== start) {
                            res = j === -1 ? '' : res.slice(0, j);
                            lastSlash = i;
                            dots = 0;
                            isAboveRoot = false;
                            continue;
                        }
                    } else if (res.length === 2 || res.length === 1) {
                        res = '';
                        lastSlash = i;
                        dots = 0;
                        isAboveRoot = false;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) {
                        res += '/..';
                    } else {
                        res = '..';
                    }
                    isAboveRoot = true;
                }
            } else {
                const slice = path.slice(lastSlash + 1, i);
                if (res.length > 0) {
                    res += `/${slice}`;
                } else {
                    res = slice;
                }
                isAboveRoot = false;
            }
            lastSlash = i;
            dots = 0;
        } else if (code === DOT && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
}}),
"[project]/node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/path.js [client] (ecmascript) <export * as path>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "path": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$path$2d$utils$2f$path$2e$js__$5b$client$5d$__$28$ecmascript$29$__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$path$2d$utils$2f$path$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/path.js [client] (ecmascript)");
}}),
"[project]/node_modules/@loaders.gl/loader-utils/dist/lib/request-utils/request-scheduler.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>RequestScheduler)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/stats/dist/index.js [client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$lib$2f$stats$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Stats$3e$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/stats/dist/lib/stats.js [client] (ecmascript) <export default as Stats>");
;
const STAT_QUEUED_REQUESTS = 'Queued Requests';
const STAT_ACTIVE_REQUESTS = 'Active Requests';
const STAT_CANCELLED_REQUESTS = 'Cancelled Requests';
const STAT_QUEUED_REQUESTS_EVER = 'Queued Requests Ever';
const STAT_ACTIVE_REQUESTS_EVER = 'Active Requests Ever';
const DEFAULT_PROPS = {
    id: 'request-scheduler',
    /** Specifies if the request scheduler should throttle incoming requests, mainly for comparative testing. */ throttleRequests: true,
    /** The maximum number of simultaneous active requests. Un-throttled requests do not observe this limit. */ maxRequests: 6,
    /**
     * Specifies a debounce time, in milliseconds. All requests are queued, until no new requests have
     * been added to the queue for this amount of time.
     */ debounceTime: 0
};
class RequestScheduler {
    props;
    stats;
    activeRequestCount = 0;
    /** Tracks the number of active requests and prioritizes/cancels queued requests. */ requestQueue = [];
    requestMap = new Map();
    updateTimer = null;
    constructor(props = {}){
        this.props = {
            ...DEFAULT_PROPS,
            ...props
        };
        // Returns the statistics used by the request scheduler.
        this.stats = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$lib$2f$stats$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Stats$3e$__["Stats"]({
            id: this.props.id
        });
        this.stats.get(STAT_QUEUED_REQUESTS);
        this.stats.get(STAT_ACTIVE_REQUESTS);
        this.stats.get(STAT_CANCELLED_REQUESTS);
        this.stats.get(STAT_QUEUED_REQUESTS_EVER);
        this.stats.get(STAT_ACTIVE_REQUESTS_EVER);
    }
    /**
     * Called by an application that wants to issue a request, without having it deeply queued by the browser
     *
     * When the returned promise resolved, it is OK for the application to issue a request.
     * The promise resolves to an object that contains a `done` method.
     * When the application's request has completed (or failed), the application must call the `done` function
     *
     * @param handle
     * @param getPriority will be called when request "slots" open up,
     *    allowing the caller to update priority or cancel the request
     *    Highest priority executes first, priority < 0 cancels the request
     * @returns a promise
     *   - resolves to a object (with a `done` field) when the request can be issued without queueing,
     *   - resolves to `null` if the request has been cancelled (by the callback return < 0).
     *     In this case the application should not issue the request
     */ scheduleRequest(handle, getPriority = ()=>0) {
        // Allows throttling to be disabled
        if (!this.props.throttleRequests) {
            return Promise.resolve({
                done: ()=>{}
            });
        }
        // dedupe
        if (this.requestMap.has(handle)) {
            return this.requestMap.get(handle);
        }
        const request = {
            handle,
            priority: 0,
            getPriority
        };
        const promise = new Promise((resolve)=>{
            // @ts-ignore
            request.resolve = resolve;
            return request;
        });
        this.requestQueue.push(request);
        this.requestMap.set(handle, promise);
        this._issueNewRequests();
        return promise;
    }
    // PRIVATE
    _issueRequest(request) {
        const { handle, resolve } = request;
        let isDone = false;
        const done = ()=>{
            // can only be called once
            if (!isDone) {
                isDone = true;
                // Stop tracking a request - it has completed, failed, cancelled etc
                this.requestMap.delete(handle);
                this.activeRequestCount--;
                // A slot just freed up, see if any queued requests are waiting
                this._issueNewRequests();
            }
        };
        // Track this request
        this.activeRequestCount++;
        return resolve ? resolve({
            done
        }) : Promise.resolve({
            done
        });
    }
    /** We check requests asynchronously, to prevent multiple updates */ _issueNewRequests() {
        if (this.updateTimer !== null) {
            clearTimeout(this.updateTimer);
        }
        this.updateTimer = setTimeout(()=>this._issueNewRequestsAsync(), this.props.debounceTime);
    }
    /** Refresh all requests  */ _issueNewRequestsAsync() {
        if (this.updateTimer !== null) {
            clearTimeout(this.updateTimer);
        }
        this.updateTimer = null;
        const freeSlots = Math.max(this.props.maxRequests - this.activeRequestCount, 0);
        if (freeSlots === 0) {
            return;
        }
        this._updateAllRequests();
        // Resolve pending promises for the top-priority requests
        for(let i = 0; i < freeSlots; ++i){
            const request = this.requestQueue.shift();
            if (request) {
                this._issueRequest(request); // eslint-disable-line @typescript-eslint/no-floating-promises
            }
        }
    // Uncomment to debug
    // console.log(`${freeSlots} free slots, ${this.requestQueue.length} queued requests`);
    }
    /** Ensure all requests have updated priorities, and that no longer valid requests are cancelled */ _updateAllRequests() {
        const requestQueue = this.requestQueue;
        for(let i = 0; i < requestQueue.length; ++i){
            const request = requestQueue[i];
            if (!this._updateRequest(request)) {
                // Remove the element and make sure to adjust the counter to account for shortened array
                requestQueue.splice(i, 1);
                this.requestMap.delete(request.handle);
                i--;
            }
        }
        // Sort the remaining requests based on priority
        requestQueue.sort((a, b)=>a.priority - b.priority);
    }
    /** Update a single request by calling the callback */ _updateRequest(request) {
        request.priority = request.getPriority(request.handle); // eslint-disable-line callback-return
        // by returning a negative priority, the callback cancels the request
        if (request.priority < 0) {
            request.resolve(null);
            return false;
        }
        return true;
    }
}
}}),
"[project]/node_modules/@loaders.gl/loader-utils/dist/lib/request-utils/request-scheduler.js [client] (ecmascript) <export default as RequestScheduler>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "RequestScheduler": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$request$2d$utils$2f$request$2d$scheduler$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$request$2d$utils$2f$request$2d$scheduler$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/request-utils/request-scheduler.js [client] (ecmascript)");
}}),
"[project]/node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/globals.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// Purpose: include this in your module to avoids adding dependencies on
// micro modules like 'global' and 'is-browser';
/* eslint-disable no-restricted-globals */ __turbopack_context__.s({
    "document": (()=>document_),
    "global": (()=>global_),
    "isBrowser": (()=>isBrowser),
    "isMobile": (()=>isMobile),
    "isWorker": (()=>isWorker),
    "nodeVersion": (()=>nodeVersion),
    "self": (()=>self_),
    "window": (()=>window_)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
const globals = {
    self: typeof self !== 'undefined' && self,
    window: typeof window !== 'undefined' && window,
    global: typeof global !== 'undefined' && global,
    document: typeof document !== 'undefined' && document
};
const self_ = globals.self || globals.window || globals.global || {};
const window_ = globals.window || globals.self || globals.global || {};
const global_ = globals.global || globals.self || globals.window || {};
const document_ = globals.document || {};
;
const isBrowser = // @ts-ignore process.browser
typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"] !== 'object' || String(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"]) !== '[object process]' || ("TURBOPACK compile-time value", true);
const isWorker = typeof importScripts === 'function';
const isMobile = typeof window !== 'undefined' && typeof window.orientation !== 'undefined';
// Extract node major version
const matches = typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"] !== 'undefined' && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].version && /v([0-9]*)/.exec(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].version);
const nodeVersion = matches && parseFloat(matches[1]) || 0;
}}),
"[project]/node_modules/@loaders.gl/worker-utils/dist/lib/node/worker_threads-browser.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/** Browser polyfill for Node.js built-in `worker_threads` module.
 * These fills are non-functional, and just intended to ensure that
 * `import 'worker_threads` doesn't break browser builds.
 * The replacement is done in package.json browser field
 */ __turbopack_context__.s({
    "NodeWorker": (()=>NodeWorker),
    "parentPort": (()=>parentPort)
});
class NodeWorker {
    terminate() {}
}
const parentPort = null;
}}),
"[project]/node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/assert.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// Replacement for the external assert method to reduce bundle size
// Note: We don't use the second "message" argument in calling code,
// so no need to support it here
/** Throws an `Error` with the optional `message` if `condition` is falsy */ __turbopack_context__.s({
    "assert": (()=>assert)
});
function assert(condition, message) {
    if (!condition) {
        throw new Error(message || 'loaders.gl assertion failed.');
    }
}
}}),
"[project]/node_modules/@loaders.gl/worker-utils/dist/lib/worker-utils/get-loadable-worker-url.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "getLoadableWorkerURL": (()=>getLoadableWorkerURL)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/assert.js [client] (ecmascript)");
;
const workerURLCache = new Map();
function getLoadableWorkerURL(props) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(props.source && !props.url || !props.source && props.url); // Either source or url must be defined
    let workerURL = workerURLCache.get(props.source || props.url);
    if (!workerURL) {
        // Differentiate worker urls from worker source code
        if (props.url) {
            workerURL = getLoadableWorkerURLFromURL(props.url);
            workerURLCache.set(props.url, workerURL);
        }
        if (props.source) {
            workerURL = getLoadableWorkerURLFromSource(props.source);
            workerURLCache.set(props.source, workerURL);
        }
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(workerURL);
    return workerURL;
}
/**
 * Build a loadable worker URL from worker URL
 * @param url
 * @returns loadable URL
 */ function getLoadableWorkerURLFromURL(url) {
    // A local script url, we can use it to initialize a Worker directly
    if (!url.startsWith('http')) {
        return url;
    }
    // A remote script, we need to use `importScripts` to load from different origin
    const workerSource = buildScriptSource(url);
    return getLoadableWorkerURLFromSource(workerSource);
}
/**
 * Build a loadable worker URL from worker source
 * @param workerSource
 * @returns loadable url
 */ function getLoadableWorkerURLFromSource(workerSource) {
    const blob = new Blob([
        workerSource
    ], {
        type: 'application/javascript'
    });
    return URL.createObjectURL(blob);
}
/**
 * Per spec, worker cannot be initialized with a script from a different origin
 * However a local worker script can still import scripts from other origins,
 * so we simply build a wrapper script.
 *
 * @param workerUrl
 * @returns source
 */ function buildScriptSource(workerUrl) {
    return `\
try {
  importScripts('${workerUrl}');
} catch (error) {
  console.error(error);
  throw error;
}`;
}
}}),
"[project]/node_modules/@loaders.gl/worker-utils/dist/lib/worker-utils/get-transfer-list.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// NOTE - there is a copy of this function is both in core and loader-utils
// core does not need all the utils in loader-utils, just this one.
/**
 * Returns an array of Transferrable objects that can be used with postMessage
 * https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage
 * @param object data to be sent via postMessage
 * @param recursive - not for application use
 * @param transfers - not for application use
 * @returns a transfer list that can be passed to postMessage
 */ __turbopack_context__.s({
    "getTransferList": (()=>getTransferList),
    "getTransferListForWriter": (()=>getTransferListForWriter)
});
function getTransferList(object, recursive = true, transfers) {
    // Make sure that items in the transfer list is unique
    const transfersSet = transfers || new Set();
    if (!object) {
    // ignore
    } else if (isTransferable(object)) {
        transfersSet.add(object);
    } else if (isTransferable(object.buffer)) {
        // Typed array
        transfersSet.add(object.buffer);
    } else if (ArrayBuffer.isView(object)) {
    // object is a TypeArray viewing into a SharedArrayBuffer (not transferable)
    // Do not iterate through the content in this case
    } else if (recursive && typeof object === 'object') {
        for(const key in object){
            // Avoid perf hit - only go one level deep
            getTransferList(object[key], recursive, transfersSet);
        }
    }
    // If transfers is defined, is internal recursive call
    // Otherwise it's called by the user
    return transfers === undefined ? Array.from(transfersSet) : [];
}
// https://developer.mozilla.org/en-US/docs/Web/API/Transferable
function isTransferable(object) {
    if (!object) {
        return false;
    }
    if (object instanceof ArrayBuffer) {
        return true;
    }
    if (typeof MessagePort !== 'undefined' && object instanceof MessagePort) {
        return true;
    }
    if (typeof ImageBitmap !== 'undefined' && object instanceof ImageBitmap) {
        return true;
    }
    // @ts-ignore
    if (typeof OffscreenCanvas !== 'undefined' && object instanceof OffscreenCanvas) {
        return true;
    }
    return false;
}
function getTransferListForWriter(object) {
    if (object === null) {
        return {};
    }
    const clone = Object.assign({}, object);
    Object.keys(clone).forEach((key)=>{
        // Typed Arrays and Arrays are passed with no change
        if (typeof object[key] === 'object' && !ArrayBuffer.isView(object[key]) && !(object[key] instanceof Array)) {
            clone[key] = getTransferListForWriter(object[key]);
        } else if (typeof clone[key] === 'function' || clone[key] instanceof RegExp) {
            clone[key] = {};
        } else {
            clone[key] = object[key];
        }
    });
    return clone;
}
}}),
"[project]/node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-thread.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "default": (()=>WorkerThread)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$node$2f$worker_threads$2d$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/node/worker_threads-browser.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/globals.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/assert.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$utils$2f$get$2d$loadable$2d$worker$2d$url$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/worker-utils/get-loadable-worker-url.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$utils$2f$get$2d$transfer$2d$list$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/worker-utils/get-transfer-list.js [client] (ecmascript)");
;
;
;
;
;
const NOOP = ()=>{};
class WorkerThread {
    name;
    source;
    url;
    terminated = false;
    worker;
    onMessage;
    onError;
    _loadableURL = '';
    /** Checks if workers are supported on this platform */ static isSupported() {
        return typeof Worker !== 'undefined' && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBrowser"] || typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$node$2f$worker_threads$2d$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__["NodeWorker"] !== 'undefined' && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBrowser"];
    }
    constructor(props){
        const { name, source, url } = props;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(source || url); // Either source or url must be defined
        this.name = name;
        this.source = source;
        this.url = url;
        this.onMessage = NOOP;
        this.onError = (error)=>console.log(error); // eslint-disable-line
        this.worker = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBrowser"] ? this._createBrowserWorker() : this._createNodeWorker();
    }
    /**
     * Terminate this worker thread
     * @note Can free up significant memory
     */ destroy() {
        this.onMessage = NOOP;
        this.onError = NOOP;
        this.worker.terminate(); // eslint-disable-line @typescript-eslint/no-floating-promises
        this.terminated = true;
    }
    get isRunning() {
        return Boolean(this.onMessage);
    }
    /**
     * Send a message to this worker thread
     * @param data any data structure, ideally consisting mostly of transferrable objects
     * @param transferList If not supplied, calculated automatically by traversing data
     */ postMessage(data, transferList) {
        transferList = transferList || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$utils$2f$get$2d$transfer$2d$list$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getTransferList"])(data);
        // @ts-ignore
        this.worker.postMessage(data, transferList);
    }
    // PRIVATE
    /**
     * Generate a standard Error from an ErrorEvent
     * @param event
     */ _getErrorFromErrorEvent(event) {
        // Note Error object does not have the expected fields if loading failed completely
        // https://developer.mozilla.org/en-US/docs/Web/API/Worker#Event_handlers
        // https://developer.mozilla.org/en-US/docs/Web/API/ErrorEvent
        let message = 'Failed to load ';
        message += `worker ${this.name} from ${this.url}. `;
        if (event.message) {
            message += `${event.message} in `;
        }
        // const hasFilename = event.filename && !event.filename.startsWith('blob:');
        // message += hasFilename ? event.filename : this.source.slice(0, 100);
        if (event.lineno) {
            message += `:${event.lineno}:${event.colno}`;
        }
        return new Error(message);
    }
    /**
     * Creates a worker thread on the browser
     */ _createBrowserWorker() {
        this._loadableURL = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$utils$2f$get$2d$loadable$2d$worker$2d$url$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getLoadableWorkerURL"])({
            source: this.source,
            url: this.url
        });
        const worker = new Worker(this._loadableURL, {
            name: this.name
        });
        worker.onmessage = (event)=>{
            if (!event.data) {
                this.onError(new Error('No data received'));
            } else {
                this.onMessage(event.data);
            }
        };
        // This callback represents an uncaught exception in the worker thread
        worker.onerror = (error)=>{
            this.onError(this._getErrorFromErrorEvent(error));
            this.terminated = true;
        };
        // TODO - not clear when this would be called, for now just log in case it happens
        worker.onmessageerror = (event)=>console.error(event); // eslint-disable-line
        return worker;
    }
    /**
     * Creates a worker thread in node.js
     * @todo https://nodejs.org/api/async_hooks.html#async-resource-worker-pool
     */ _createNodeWorker() {
        let worker;
        if (this.url) {
            // Make sure relative URLs start with './'
            const absolute = this.url.includes(':/') || this.url.startsWith('/');
            const url = absolute ? this.url : `./${this.url}`;
            // console.log('Starting work from', url);
            worker = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$node$2f$worker_threads$2d$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__["NodeWorker"](url, {
                eval: false
            });
        } else if (this.source) {
            worker = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$node$2f$worker_threads$2d$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__["NodeWorker"](this.source, {
                eval: true
            });
        } else {
            throw new Error('no worker');
        }
        worker.on('message', (data)=>{
            // console.error('message', data);
            this.onMessage(data);
        });
        worker.on('error', (error)=>{
            // console.error('error', error);
            this.onError(error);
        });
        worker.on('exit', (code)=>{
        // console.error('exit', code);
        });
        return worker;
    }
}
}}),
"[project]/node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-job.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "default": (()=>WorkerJob)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/assert.js [client] (ecmascript)");
;
class WorkerJob {
    name;
    workerThread;
    isRunning = true;
    /** Promise that resolves when Job is done */ result;
    _resolve = ()=>{};
    _reject = ()=>{};
    constructor(jobName, workerThread){
        this.name = jobName;
        this.workerThread = workerThread;
        this.result = new Promise((resolve, reject)=>{
            this._resolve = resolve;
            this._reject = reject;
        });
    }
    /**
     * Send a message to the job's worker thread
     * @param data any data structure, ideally consisting mostly of transferrable objects
     */ postMessage(type, payload) {
        this.workerThread.postMessage({
            source: 'loaders.gl',
            type,
            payload
        });
    }
    /**
     * Call to resolve the `result` Promise with the supplied value
     */ done(value) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(this.isRunning);
        this.isRunning = false;
        this._resolve(value);
    }
    /**
     * Call to reject the `result` Promise with the supplied error
     */ error(error) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(this.isRunning);
        this.isRunning = false;
        this._reject(error);
    }
}
}}),
"[project]/node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-pool.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "default": (()=>WorkerPool)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/globals.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$farm$2f$worker$2d$thread$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-thread.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$farm$2f$worker$2d$job$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-job.js [client] (ecmascript)");
;
;
;
class WorkerPool {
    name = 'unnamed';
    source;
    url;
    maxConcurrency = 1;
    maxMobileConcurrency = 1;
    onDebug = ()=>{};
    reuseWorkers = true;
    props = {};
    jobQueue = [];
    idleQueue = [];
    count = 0;
    isDestroyed = false;
    /** Checks if workers are supported on this platform */ static isSupported() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$farm$2f$worker$2d$thread$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].isSupported();
    }
    /**
     * @param processor - worker function
     * @param maxConcurrency - max count of workers
     */ constructor(props){
        this.source = props.source;
        this.url = props.url;
        this.setProps(props);
    }
    /**
     * Terminates all workers in the pool
     * @note Can free up significant memory
     */ destroy() {
        // Destroy idle workers, active Workers will be destroyed on completion
        this.idleQueue.forEach((worker)=>worker.destroy());
        this.isDestroyed = true;
    }
    setProps(props) {
        this.props = {
            ...this.props,
            ...props
        };
        if (props.name !== undefined) {
            this.name = props.name;
        }
        if (props.maxConcurrency !== undefined) {
            this.maxConcurrency = props.maxConcurrency;
        }
        if (props.maxMobileConcurrency !== undefined) {
            this.maxMobileConcurrency = props.maxMobileConcurrency;
        }
        if (props.reuseWorkers !== undefined) {
            this.reuseWorkers = props.reuseWorkers;
        }
        if (props.onDebug !== undefined) {
            this.onDebug = props.onDebug;
        }
    }
    async startJob(name, onMessage = (job, type, data)=>job.done(data), onError = (job, error)=>job.error(error)) {
        // Promise resolves when thread starts working on this job
        const startPromise = new Promise((onStart)=>{
            // Promise resolves when thread completes or fails working on this job
            this.jobQueue.push({
                name,
                onMessage,
                onError,
                onStart
            });
            return this;
        });
        this._startQueuedJob(); // eslint-disable-line @typescript-eslint/no-floating-promises
        return await startPromise;
    }
    // PRIVATE
    /**
     * Starts first queued job if worker is available or can be created
     * Called when job is started and whenever a worker returns to the idleQueue
     */ async _startQueuedJob() {
        if (!this.jobQueue.length) {
            return;
        }
        const workerThread = this._getAvailableWorker();
        if (!workerThread) {
            return;
        }
        // We have a worker, dequeue and start the job
        const queuedJob = this.jobQueue.shift();
        if (queuedJob) {
            // Emit a debug event
            // @ts-ignore
            this.onDebug({
                message: 'Starting job',
                name: queuedJob.name,
                workerThread,
                backlog: this.jobQueue.length
            });
            // Create a worker job to let the app access thread and manage job completion
            const job = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$farm$2f$worker$2d$job$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"](queuedJob.name, workerThread);
            // Set the worker thread's message handlers
            workerThread.onMessage = (data)=>queuedJob.onMessage(job, data.type, data.payload);
            workerThread.onError = (error)=>queuedJob.onError(job, error);
            // Resolve the start promise so that the app can start sending messages to worker
            queuedJob.onStart(job);
            // Wait for the app to signal that the job is complete, then return worker to queue
            try {
                await job.result;
            } catch (error) {
                // eslint-disable-next-line no-console
                console.error(`Worker exception: ${error}`);
            } finally{
                this.returnWorkerToQueue(workerThread);
            }
        }
    }
    /**
     * Returns a worker to the idle queue
     * Destroys the worker if
     *  - pool is destroyed
     *  - if this pool doesn't reuse workers
     *  - if maxConcurrency has been lowered
     * @param worker
     */ returnWorkerToQueue(worker) {
        const shouldDestroyWorker = // Workers on Node.js prevent the process from exiting.
        // Until we figure out how to close them before exit, we always destroy them
        !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBrowser"] || // If the pool is destroyed, there is no reason to keep the worker around
        this.isDestroyed || // If the app has disabled worker reuse, any completed workers should be destroyed
        !this.reuseWorkers || // If concurrency has been lowered, this worker might be surplus to requirements
        this.count > this._getMaxConcurrency();
        if (shouldDestroyWorker) {
            worker.destroy();
            this.count--;
        } else {
            this.idleQueue.push(worker);
        }
        if (!this.isDestroyed) {
            this._startQueuedJob(); // eslint-disable-line @typescript-eslint/no-floating-promises
        }
    }
    /**
     * Returns idle worker or creates new worker if maxConcurrency has not been reached
     */ _getAvailableWorker() {
        // If a worker has completed and returned to the queue, it can be used
        if (this.idleQueue.length > 0) {
            return this.idleQueue.shift() || null;
        }
        // Create fresh worker if we haven't yet created the max amount of worker threads for this worker source
        if (this.count < this._getMaxConcurrency()) {
            this.count++;
            const name = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$farm$2f$worker$2d$thread$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"]({
                name,
                source: this.source,
                url: this.url
            });
        }
        // No worker available, have to wait
        return null;
    }
    _getMaxConcurrency() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isMobile"] ? this.maxMobileConcurrency : this.maxConcurrency;
    }
}
}}),
"[project]/node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-farm.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "default": (()=>WorkerFarm)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$farm$2f$worker$2d$pool$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-pool.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$farm$2f$worker$2d$thread$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-thread.js [client] (ecmascript)");
;
;
const DEFAULT_PROPS = {
    maxConcurrency: 3,
    maxMobileConcurrency: 1,
    reuseWorkers: true,
    onDebug: ()=>{}
};
class WorkerFarm {
    props;
    workerPools = new Map();
    // singleton
    static _workerFarm;
    /** Checks if workers are supported on this platform */ static isSupported() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$farm$2f$worker$2d$thread$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].isSupported();
    }
    /** Get the singleton instance of the global worker farm */ static getWorkerFarm(props = {}) {
        WorkerFarm._workerFarm = WorkerFarm._workerFarm || new WorkerFarm({});
        WorkerFarm._workerFarm.setProps(props);
        return WorkerFarm._workerFarm;
    }
    /** get global instance with WorkerFarm.getWorkerFarm() */ constructor(props){
        this.props = {
            ...DEFAULT_PROPS
        };
        this.setProps(props);
        /** @type Map<string, WorkerPool>} */ this.workerPools = new Map();
    }
    /**
     * Terminate all workers in the farm
     * @note Can free up significant memory
     */ destroy() {
        for (const workerPool of this.workerPools.values()){
            workerPool.destroy();
        }
        this.workerPools = new Map();
    }
    /**
     * Set props used when initializing worker pools
     * @param props
     */ setProps(props) {
        this.props = {
            ...this.props,
            ...props
        };
        // Update worker pool props
        for (const workerPool of this.workerPools.values()){
            workerPool.setProps(this._getWorkerPoolProps());
        }
    }
    /**
     * Returns a worker pool for the specified worker
     * @param options - only used first time for a specific worker name
     * @param options.name - the name of the worker - used to identify worker pool
     * @param options.url -
     * @param options.source -
     * @example
     *   const job = WorkerFarm.getWorkerFarm().getWorkerPool({name, url}).startJob(...);
     */ getWorkerPool(options) {
        const { name, source, url } = options;
        let workerPool = this.workerPools.get(name);
        if (!workerPool) {
            workerPool = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$farm$2f$worker$2d$pool$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"]({
                name,
                source,
                url
            });
            workerPool.setProps(this._getWorkerPoolProps());
            this.workerPools.set(name, workerPool);
        }
        return workerPool;
    }
    _getWorkerPoolProps() {
        return {
            maxConcurrency: this.props.maxConcurrency,
            maxMobileConcurrency: this.props.maxMobileConcurrency,
            reuseWorkers: this.props.reuseWorkers,
            onDebug: this.props.onDebug
        };
    }
}
}}),
"[project]/node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-farm.js [client] (ecmascript) <export default as WorkerFarm>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "WorkerFarm": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$farm$2f$worker$2d$farm$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$worker$2d$farm$2f$worker$2d$farm$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-farm.js [client] (ecmascript)");
}}),
"[project]/node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/version.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// Version constant cannot be imported, it needs to correspond to the build version of **this** module.
/**
 * TODO - unpkg.com doesn't seem to have a `latest` specifier for alpha releases...
 * 'beta' on beta branch, 'latest' on prod branch
 */ __turbopack_context__.s({
    "NPM_TAG": (()=>NPM_TAG),
    "VERSION": (()=>VERSION)
});
const NPM_TAG = 'latest';
function getVersion() {
    if (!globalThis._loadersgl_?.version) {
        globalThis._loadersgl_ = globalThis._loadersgl_ || {};
        // __VERSION__ is injected by babel-plugin-version-inline
        if (typeof "4.3.2" === 'undefined') {
            // eslint-disable-next-line
            console.warn('loaders.gl: The __VERSION__ variable is not injected using babel plugin. Latest unstable workers would be fetched from the CDN.');
            globalThis._loadersgl_.version = NPM_TAG;
        } else {
            globalThis._loadersgl_.version = "4.3.2";
        }
    }
    return globalThis._loadersgl_.version;
}
const VERSION = getVersion();
}}),
"[project]/node_modules/@loaders.gl/worker-utils/dist/lib/worker-api/get-worker-url.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "getWorkerName": (()=>getWorkerName),
    "getWorkerURL": (()=>getWorkerURL)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/assert.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/globals.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$version$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/version.js [client] (ecmascript)");
;
;
;
function getWorkerName(worker) {
    const warning = worker.version !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$version$2e$js__$5b$client$5d$__$28$ecmascript$29$__["VERSION"] ? ` (worker-utils@${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$version$2e$js__$5b$client$5d$__$28$ecmascript$29$__["VERSION"]})` : '';
    return `${worker.name}@${worker.version}${warning}`;
}
function getWorkerURL(worker, options = {}) {
    const workerOptions = options[worker.id] || {};
    const workerFile = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBrowser"] ? `${worker.id}-worker.js` : `${worker.id}-worker-node.js`;
    let url = workerOptions.workerUrl;
    // HACK: Allow for non-nested workerUrl for the CompressionWorker.
    // For the compression worker, workerOptions is currently not nested correctly. For most loaders,
    // you'd have options within an object, i.e. `{mvt: {coordinates: ...}}` but the CompressionWorker
    // puts options at the top level, not within a `compression` key (its `id`). For this reason, the
    // above `workerOptions` will always be a string (i.e. `'gzip'`) for the CompressionWorker. To not
    // break backwards compatibility, we allow the CompressionWorker to have options at the top level.
    if (!url && worker.id === 'compression') {
        url = options.workerUrl;
    }
    // If URL is test, generate local loaders.gl url
    // @ts-ignore _workerType
    if (options._workerType === 'test') {
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBrowser"]) {
            url = `modules/${worker.module}/dist/${workerFile}`;
        } else {
            // In the test environment the ts-node loader requires TypeScript code
            url = `modules/${worker.module}/src/workers/${worker.id}-worker-node.ts`;
        }
    }
    // If url override is not provided, generate a URL to published version on npm CDN unpkg.com
    if (!url) {
        // GENERATE
        let version = worker.version;
        // On master we need to load npm alpha releases published with the `beta` tag
        if (version === 'latest') {
            // throw new Error('latest worker version specified');
            version = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$version$2e$js__$5b$client$5d$__$28$ecmascript$29$__["NPM_TAG"];
        }
        const versionTag = version ? `@${version}` : '';
        url = `https://unpkg.com/@loaders.gl/${worker.module}${versionTag}/dist/${workerFile}`;
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(url);
    // Allow user to override location
    return url;
}
}}),
"[project]/node_modules/@loaders.gl/worker-utils/dist/lib/worker-api/validate-worker-version.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "validateWorkerVersion": (()=>validateWorkerVersion)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/assert.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$version$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/version.js [client] (ecmascript)");
;
;
function validateWorkerVersion(worker, coreVersion = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$version$2e$js__$5b$client$5d$__$28$ecmascript$29$__["VERSION"]) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$worker$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(worker, 'no worker provided');
    const workerVersion = worker.version;
    if (!coreVersion || !workerVersion) {
        return false;
    }
    // TODO enable when fix the __version__ injection
    // const coreVersions = parseVersion(coreVersion);
    // const workerVersions = parseVersion(workerVersion);
    // assert(
    //   coreVersion.major === workerVersion.major && coreVersion.minor <= workerVersion.minor,
    //   `worker: ${worker.name} is not compatible. ${coreVersion.major}.${
    //     coreVersion.minor
    //   }+ is required.`
    // );
    return true;
}
// @ts-ignore
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function parseVersion(version) {
    const parts = version.split('.').map(Number);
    return {
        major: parts[0],
        minor: parts[1]
    };
}
}}),
"[project]/node_modules/@math.gl/web-mercator/dist/math-utils.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "clamp": (()=>clamp),
    "createMat4": (()=>createMat4),
    "lerp": (()=>lerp),
    "log2": (()=>log2),
    "mod": (()=>mod),
    "transformVector": (()=>transformVector)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec4$3e$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/gl-matrix/vec4.js [client] (ecmascript) <export * as vec4>");
;
function createMat4() {
    return [
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
    ];
}
function transformVector(matrix, vector) {
    const result = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec4$3e$__["vec4"].transformMat4([], vector, matrix);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec4$3e$__["vec4"].scale(result, result, 1 / result[3]);
    return result;
}
function mod(value, divisor) {
    const modulus = value % divisor;
    return modulus < 0 ? divisor + modulus : modulus;
}
function lerp(start, end, step) {
    return step * end + (1 - step) * start;
}
function clamp(x, min, max) {
    return x < min ? min : x > max ? max : x;
}
function ieLog2(x) {
    return Math.log(x) * Math.LOG2E;
}
const log2 = Math.log2 || ieLog2; //# sourceMappingURL=math-utils.js.map
}}),
"[project]/node_modules/@math.gl/web-mercator/dist/assert.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Replacement for the external assert method to reduce bundle size
// Note: We don't use the second "message" argument in calling code,
// so no need to support it here
__turbopack_context__.s({
    "assert": (()=>assert)
});
function assert(condition, message) {
    if (!condition) {
        throw new Error(message || '@math.gl/web-mercator: assertion failed.');
    }
} //# sourceMappingURL=assert.js.map
}}),
"[project]/node_modules/@math.gl/web-mercator/dist/web-mercator-utils.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// TODO - THE UTILITIES IN THIS FILE SHOULD BE IMPORTED FROM WEB-MERCATOR-VIEWPORT MODULE
__turbopack_context__.s({
    "DEFAULT_ALTITUDE": (()=>DEFAULT_ALTITUDE),
    "MAX_LATITUDE": (()=>MAX_LATITUDE),
    "addMetersToLngLat": (()=>addMetersToLngLat),
    "altitudeToFovy": (()=>altitudeToFovy),
    "fovyToAltitude": (()=>fovyToAltitude),
    "getDistanceScales": (()=>getDistanceScales),
    "getMeterZoom": (()=>getMeterZoom),
    "getProjectionMatrix": (()=>getProjectionMatrix),
    "getProjectionParameters": (()=>getProjectionParameters),
    "getViewMatrix": (()=>getViewMatrix),
    "lngLatToWorld": (()=>lngLatToWorld),
    "pixelsToWorld": (()=>pixelsToWorld),
    "scaleToZoom": (()=>scaleToZoom),
    "unitsPerMeter": (()=>unitsPerMeter),
    "worldToLngLat": (()=>worldToLngLat),
    "worldToPixels": (()=>worldToPixels),
    "zoomToScale": (()=>zoomToScale)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/math-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$mat4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__mat4$3e$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/gl-matrix/mat4.js [client] (ecmascript) <export * as mat4>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec2$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec2$3e$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/gl-matrix/vec2.js [client] (ecmascript) <export * as vec2>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec3$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec3$3e$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/gl-matrix/vec3.js [client] (ecmascript) <export * as vec3>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/assert.js [client] (ecmascript)");
;
;
;
// CONSTANTS
const PI = Math.PI;
const PI_4 = PI / 4;
const DEGREES_TO_RADIANS = PI / 180;
const RADIANS_TO_DEGREES = 180 / PI;
const TILE_SIZE = 512;
// Average circumference (40075 km equatorial, 40007 km meridional)
const EARTH_CIRCUMFERENCE = 40.03e6;
const MAX_LATITUDE = 85.051129;
const DEFAULT_ALTITUDE = 1.5;
function zoomToScale(zoom) {
    return Math.pow(2, zoom);
}
function scaleToZoom(scale) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log2"])(scale);
}
function lngLatToWorld(lngLat) {
    const [lng, lat] = lngLat;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(Number.isFinite(lng));
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(Number.isFinite(lat) && lat >= -90 && lat <= 90, 'invalid latitude');
    const lambda2 = lng * DEGREES_TO_RADIANS;
    const phi2 = lat * DEGREES_TO_RADIANS;
    const x = TILE_SIZE * (lambda2 + PI) / (2 * PI);
    const y = TILE_SIZE * (PI + Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);
    return [
        x,
        y
    ];
}
function worldToLngLat(xy) {
    const [x, y] = xy;
    const lambda2 = x / TILE_SIZE * (2 * PI) - PI;
    const phi2 = 2 * (Math.atan(Math.exp(y / TILE_SIZE * (2 * PI) - PI)) - PI_4);
    return [
        lambda2 * RADIANS_TO_DEGREES,
        phi2 * RADIANS_TO_DEGREES
    ];
}
function getMeterZoom(options) {
    const { latitude } = options;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(Number.isFinite(latitude));
    const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);
    return scaleToZoom(EARTH_CIRCUMFERENCE * latCosine) - 9;
}
function unitsPerMeter(latitude) {
    const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);
    return TILE_SIZE / EARTH_CIRCUMFERENCE / latCosine;
}
function getDistanceScales(options) {
    const { latitude, longitude, highPrecision = false } = options;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(Number.isFinite(latitude) && Number.isFinite(longitude));
    const worldSize = TILE_SIZE;
    const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);
    /**
     * Number of pixels occupied by one degree longitude around current lat/lon:
       unitsPerDegreeX = d(lngLatToWorld([lng, lat])[0])/d(lng)
         = scale * TILE_SIZE * DEGREES_TO_RADIANS / (2 * PI)
       unitsPerDegreeY = d(lngLatToWorld([lng, lat])[1])/d(lat)
         = -scale * TILE_SIZE * DEGREES_TO_RADIANS / cos(lat * DEGREES_TO_RADIANS)  / (2 * PI)
     */ const unitsPerDegreeX = worldSize / 360;
    const unitsPerDegreeY = unitsPerDegreeX / latCosine;
    /**
     * Number of pixels occupied by one meter around current lat/lon:
     */ const altUnitsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;
    /**
     * LngLat: longitude -> east and latitude -> north (bottom left)
     * UTM meter offset: x -> east and y -> north (bottom left)
     * World space: x -> east and y -> south (top left)
     *
     * Y needs to be flipped when converting delta degree/meter to delta pixels
     */ const result = {
        unitsPerMeter: [
            altUnitsPerMeter,
            altUnitsPerMeter,
            altUnitsPerMeter
        ],
        metersPerUnit: [
            1 / altUnitsPerMeter,
            1 / altUnitsPerMeter,
            1 / altUnitsPerMeter
        ],
        unitsPerDegree: [
            unitsPerDegreeX,
            unitsPerDegreeY,
            altUnitsPerMeter
        ],
        degreesPerUnit: [
            1 / unitsPerDegreeX,
            1 / unitsPerDegreeY,
            1 / altUnitsPerMeter
        ]
    };
    /**
     * Taylor series 2nd order for 1/latCosine
       f'(a) * (x - a)
         = d(1/cos(lat * DEGREES_TO_RADIANS))/d(lat) * dLat
         = DEGREES_TO_RADIANS * tan(lat * DEGREES_TO_RADIANS) / cos(lat * DEGREES_TO_RADIANS) * dLat
     */ if (highPrecision) {
        const latCosine2 = DEGREES_TO_RADIANS * Math.tan(latitude * DEGREES_TO_RADIANS) / latCosine;
        const unitsPerDegreeY2 = unitsPerDegreeX * latCosine2 / 2;
        const altUnitsPerDegree2 = worldSize / EARTH_CIRCUMFERENCE * latCosine2;
        const altUnitsPerMeter2 = altUnitsPerDegree2 / unitsPerDegreeY * altUnitsPerMeter;
        result.unitsPerDegree2 = [
            0,
            unitsPerDegreeY2,
            altUnitsPerDegree2
        ];
        result.unitsPerMeter2 = [
            altUnitsPerMeter2,
            0,
            altUnitsPerMeter2
        ];
    }
    // Main results, used for converting meters to latlng deltas and scaling offsets
    return result;
}
function addMetersToLngLat(lngLatZ, xyz) {
    const [longitude, latitude, z0] = lngLatZ;
    const [x, y, z] = xyz;
    // eslint-disable-next-line no-shadow
    const { unitsPerMeter, unitsPerMeter2 } = getDistanceScales({
        longitude,
        latitude,
        highPrecision: true
    });
    const worldspace = lngLatToWorld(lngLatZ);
    worldspace[0] += x * (unitsPerMeter[0] + unitsPerMeter2[0] * y);
    worldspace[1] += y * (unitsPerMeter[1] + unitsPerMeter2[1] * y);
    const newLngLat = worldToLngLat(worldspace);
    const newZ = (z0 || 0) + (z || 0);
    return Number.isFinite(z0) || Number.isFinite(z) ? [
        newLngLat[0],
        newLngLat[1],
        newZ
    ] : newLngLat;
}
function getViewMatrix(options) {
    const { // Viewport props
    height, pitch, bearing, altitude, // Pre-calculated parameters
    scale, center } = options;
    // VIEW MATRIX: PROJECTS MERCATOR WORLD COORDINATES
    // Note that mercator world coordinates typically need to be flipped
    //
    // Note: As usual, matrix operation orders should be read in reverse
    // since vectors will be multiplied from the right during transformation
    const vm = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["createMat4"])();
    // Move camera to altitude (along the pitch & bearing direction)
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$mat4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__mat4$3e$__["mat4"].translate(vm, vm, [
        0,
        0,
        -altitude
    ]);
    // Rotate by bearing, and then by pitch (which tilts the view)
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$mat4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__mat4$3e$__["mat4"].rotateX(vm, vm, -pitch * DEGREES_TO_RADIANS);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$mat4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__mat4$3e$__["mat4"].rotateZ(vm, vm, bearing * DEGREES_TO_RADIANS);
    const relativeScale = scale / height;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$mat4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__mat4$3e$__["mat4"].scale(vm, vm, [
        relativeScale,
        relativeScale,
        relativeScale
    ]);
    if (center) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$mat4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__mat4$3e$__["mat4"].translate(vm, vm, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec3$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec3$3e$__["vec3"].negate([], center));
    }
    return vm;
}
function getProjectionParameters(options) {
    const { width, height, altitude, pitch = 0, offset, center, scale, nearZMultiplier = 1, farZMultiplier = 1 } = options;
    let { fovy = altitudeToFovy(DEFAULT_ALTITUDE) } = options;
    // For back-compatibility allow field of view to be
    // derived from altitude
    if (altitude !== undefined) {
        fovy = altitudeToFovy(altitude);
    }
    const fovRadians = fovy * DEGREES_TO_RADIANS;
    const pitchRadians = pitch * DEGREES_TO_RADIANS;
    // Distance from camera to the target
    const focalDistance = fovyToAltitude(fovy);
    let cameraToSeaLevelDistance = focalDistance;
    if (center) {
        cameraToSeaLevelDistance += center[2] * scale / Math.cos(pitchRadians) / height;
    }
    const fovAboveCenter = fovRadians * (0.5 + (offset ? offset[1] : 0) / height);
    // Find the distance from the center point to the center top
    // in focal distance units using law of sines.
    const topHalfSurfaceDistance = Math.sin(fovAboveCenter) * cameraToSeaLevelDistance / Math.sin((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["clamp"])(Math.PI / 2 - pitchRadians - fovAboveCenter, 0.01, Math.PI - 0.01));
    // Calculate z distance of the farthest fragment that should be rendered.
    const furthestDistance = Math.sin(pitchRadians) * topHalfSurfaceDistance + cameraToSeaLevelDistance;
    // Matches mapbox limit
    const horizonDistance = cameraToSeaLevelDistance * 10;
    // Calculate z value of the farthest fragment that should be rendered.
    const farZ = Math.min(furthestDistance * farZMultiplier, horizonDistance);
    return {
        fov: fovRadians,
        aspect: width / height,
        focalDistance,
        near: nearZMultiplier,
        far: farZ
    };
}
function getProjectionMatrix(options) {
    const { fov, aspect, near, far } = getProjectionParameters(options);
    const projectionMatrix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$mat4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__mat4$3e$__["mat4"].perspective([], fov, aspect, near, far // far plane
    );
    return projectionMatrix;
}
function altitudeToFovy(altitude) {
    return 2 * Math.atan(0.5 / altitude) * RADIANS_TO_DEGREES;
}
function fovyToAltitude(fovy) {
    return 0.5 / Math.tan(0.5 * fovy * DEGREES_TO_RADIANS);
}
function worldToPixels(xyz, pixelProjectionMatrix) {
    const [x, y, z = 0] = xyz;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z));
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["transformVector"])(pixelProjectionMatrix, [
        x,
        y,
        z,
        1
    ]);
}
function pixelsToWorld(xyz, pixelUnprojectionMatrix, targetZ = 0) {
    const [x, y, z] = xyz;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(Number.isFinite(x) && Number.isFinite(y), 'invalid pixel coordinate');
    if (Number.isFinite(z)) {
        // Has depth component
        const coord = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["transformVector"])(pixelUnprojectionMatrix, [
            x,
            y,
            z,
            1
        ]);
        return coord;
    }
    // since we don't know the correct projected z value for the point,
    // unproject two points to get a line and then find the point on that line with z=0
    const coord0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["transformVector"])(pixelUnprojectionMatrix, [
        x,
        y,
        0,
        1
    ]);
    const coord1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["transformVector"])(pixelUnprojectionMatrix, [
        x,
        y,
        1,
        1
    ]);
    const z0 = coord0[2];
    const z1 = coord1[2];
    const t = z0 === z1 ? 0 : ((targetZ || 0) - z0) / (z1 - z0);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec2$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec2$3e$__["vec2"].lerp([], coord0, coord1, t);
} //# sourceMappingURL=web-mercator-utils.js.map
}}),
"[project]/node_modules/@math.gl/web-mercator/dist/fit-bounds.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "fitBounds": (()=>fitBounds)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/assert.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/math-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/web-mercator-utils.js [client] (ecmascript)");
;
;
;
function fitBounds(options) {
    const { width, height, bounds, minExtent = 0, maxZoom = 24, offset = [
        0,
        0
    ] } = options;
    const [[west, south], [east, north]] = bounds;
    const padding = getPaddingObject(options.padding);
    const nw = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["lngLatToWorld"])([
        west,
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["clamp"])(north, -__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["MAX_LATITUDE"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["MAX_LATITUDE"])
    ]);
    const se = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["lngLatToWorld"])([
        east,
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["clamp"])(south, -__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["MAX_LATITUDE"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["MAX_LATITUDE"])
    ]);
    // width/height on the Web Mercator plane
    const size = [
        Math.max(Math.abs(se[0] - nw[0]), minExtent),
        Math.max(Math.abs(se[1] - nw[1]), minExtent)
    ];
    const targetSize = [
        width - padding.left - padding.right - Math.abs(offset[0]) * 2,
        height - padding.top - padding.bottom - Math.abs(offset[1]) * 2
    ];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(targetSize[0] > 0 && targetSize[1] > 0);
    // scale = screen pixels per unit on the Web Mercator plane
    const scaleX = targetSize[0] / size[0];
    const scaleY = targetSize[1] / size[1];
    // Find how much we need to shift the center
    const offsetX = (padding.right - padding.left) / 2 / scaleX;
    const offsetY = (padding.top - padding.bottom) / 2 / scaleY;
    const center = [
        (se[0] + nw[0]) / 2 + offsetX,
        (se[1] + nw[1]) / 2 + offsetY
    ];
    const centerLngLat = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["worldToLngLat"])(center);
    const zoom = Math.min(maxZoom, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log2"])(Math.abs(Math.min(scaleX, scaleY))));
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(Number.isFinite(zoom));
    return {
        longitude: centerLngLat[0],
        latitude: centerLngLat[1],
        zoom
    };
}
// Helpers
function getPaddingObject(padding = 0) {
    if (typeof padding === 'number') {
        return {
            top: padding,
            bottom: padding,
            left: padding,
            right: padding
        };
    }
    // Make sure all the required properties are set
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(Number.isFinite(padding.top) && Number.isFinite(padding.bottom) && Number.isFinite(padding.left) && Number.isFinite(padding.right));
    return padding;
} //# sourceMappingURL=fit-bounds.js.map
}}),
"[project]/node_modules/@math.gl/web-mercator/dist/get-bounds.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* eslint-disable camelcase */ __turbopack_context__.s({
    "getBounds": (()=>getBounds)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec2$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec2$3e$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/gl-matrix/vec2.js [client] (ecmascript) <export * as vec2>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/web-mercator-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/math-utils.js [client] (ecmascript)");
;
;
;
const DEGREES_TO_RADIANS = Math.PI / 180;
function getBounds(viewport, z = 0) {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    const { width, height, unproject } = viewport;
    const unprojectOps = {
        targetZ: z
    };
    const bottomLeft = unproject([
        0,
        height
    ], unprojectOps);
    const bottomRight = unproject([
        width,
        height
    ], unprojectOps);
    let topLeft;
    let topRight;
    const halfFov = viewport.fovy ? 0.5 * viewport.fovy * DEGREES_TO_RADIANS : Math.atan(0.5 / viewport.altitude);
    const angleToGround = (90 - viewport.pitch) * DEGREES_TO_RADIANS;
    // The top plane is parallel to the ground if halfFov == angleToGround
    if (halfFov > angleToGround - 0.01) {
        // intersect with the far plane
        topLeft = unprojectOnFarPlane(viewport, 0, z);
        topRight = unprojectOnFarPlane(viewport, width, z);
    } else {
        // intersect with the top plane
        topLeft = unproject([
            0,
            0
        ], unprojectOps);
        topRight = unproject([
            width,
            0
        ], unprojectOps);
    }
    return [
        bottomLeft,
        bottomRight,
        topRight,
        topLeft
    ];
}
/*
 * Find a point on the far clipping plane of the viewport
 * @param {WebMercatorViewport} viewport
 * @param {Number} x - projected x in screen space
 * @param {Number} targetZ - the elevation of the point in meters
 */ function unprojectOnFarPlane(viewport, x, targetZ) {
    const { pixelUnprojectionMatrix } = viewport;
    const coord0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["transformVector"])(pixelUnprojectionMatrix, [
        x,
        0,
        1,
        1
    ]);
    const coord1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["transformVector"])(pixelUnprojectionMatrix, [
        x,
        viewport.height,
        1,
        1
    ]);
    const z = targetZ * viewport.distanceScales.unitsPerMeter[2];
    const t = (z - coord0[2]) / (coord1[2] - coord0[2]);
    const coord = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec2$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec2$3e$__["vec2"].lerp([], coord0, coord1, t);
    const result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["worldToLngLat"])(coord);
    result.push(targetZ);
    return result;
} //# sourceMappingURL=get-bounds.js.map
}}),
"[project]/node_modules/@math.gl/web-mercator/dist/web-mercator-viewport.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// View and Projection Matrix calculations for mapbox-js style map view properties
__turbopack_context__.s({
    "WebMercatorViewport": (()=>WebMercatorViewport)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/math-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/web-mercator-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$fit$2d$bounds$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/fit-bounds.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$get$2d$bounds$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/get-bounds.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$mat4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__mat4$3e$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/gl-matrix/mat4.js [client] (ecmascript) <export * as mat4>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec2$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec2$3e$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/gl-matrix/vec2.js [client] (ecmascript) <export * as vec2>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec3$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec3$3e$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/gl-matrix/vec3.js [client] (ecmascript) <export * as vec3>");
;
;
;
;
;
class WebMercatorViewport {
    /**
     * @classdesc
     * Creates view/projection matrices from mercator params
     * Note: The Viewport is immutable in the sense that it only has accessors.
     * A new viewport instance should be created if any parameters have changed.
     */ // eslint-disable-next-line max-statements
    constructor(props = {
        width: 1,
        height: 1
    }){
        /** Two viewports are equal if width and height are identical, and if
         * their view and projection matrices are (approximately) equal.
         */ this.equals = (viewport)=>{
            if (!(viewport instanceof WebMercatorViewport)) {
                return false;
            }
            return viewport.width === this.width && viewport.height === this.height && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$mat4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__mat4$3e$__["mat4"].equals(viewport.projectionMatrix, this.projectionMatrix) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$mat4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__mat4$3e$__["mat4"].equals(viewport.viewMatrix, this.viewMatrix);
        };
        /**
         * Projects xyz (possibly latitude and longitude) to pixel coordinates in window
         * using viewport projection parameters
         * - [longitude, latitude] to [x, y]
         * - [longitude, latitude, Z] => [x, y, z]
         * Note: By default, returns top-left coordinates for canvas/SVG type render
         *
         * @param lngLatZ - [lng, lat] or [lng, lat, Z]
         * @param options - options
         * @param options.topLeft=true - Whether projected coords are top left
         * @return - screen coordinates [x, y] or [x, y, z], z as pixel depth
         */ this.project = (lngLatZ, options = {})=>{
            const { topLeft = true } = options;
            const worldPosition = this.projectPosition(lngLatZ);
            const coord = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["worldToPixels"])(worldPosition, this.pixelProjectionMatrix);
            const [x, y] = coord;
            const y2 = topLeft ? y : this.height - y;
            return lngLatZ.length === 2 ? [
                x,
                y2
            ] : [
                x,
                y2,
                coord[2]
            ];
        };
        /**
         * Unproject pixel coordinates on screen onto world coordinates, possibly `[lon, lat]` on map.
         *
         * - [x, y] => [lng, lat]
         * - [x, y, z] => [lng, lat, Z]
         *
         * @param xyz - screen coordinates, z as pixel depth
         * @param options - options
         * @param options.topLeft=true - Whether projected coords are top left
         * @param options.targetZ=0 - If pixel depth is unknown, targetZ is used as
         *   the elevation plane to unproject onto
         * @return - [lng, lat, Z] or [X, Y, Z]
         */ this.unproject = (xyz, options = {})=>{
            const { topLeft = true, targetZ = undefined } = options;
            const [x, y, z] = xyz;
            const y2 = topLeft ? y : this.height - y;
            const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];
            const coord = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["pixelsToWorld"])([
                x,
                y2,
                z
            ], this.pixelUnprojectionMatrix, targetZWorld);
            const [X, Y, Z] = this.unprojectPosition(coord);
            if (Number.isFinite(z)) {
                return [
                    X,
                    Y,
                    Z
                ];
            }
            return Number.isFinite(targetZ) ? [
                X,
                Y,
                targetZ
            ] : [
                X,
                Y
            ];
        };
        // NON_LINEAR PROJECTION HOOKS
        // Used for web meractor projection
        this.projectPosition = (xyz)=>{
            const [X, Y] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["lngLatToWorld"])(xyz);
            const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];
            return [
                X,
                Y,
                Z
            ];
        };
        this.unprojectPosition = (xyz)=>{
            const [X, Y] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["worldToLngLat"])(xyz);
            const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];
            return [
                X,
                Y,
                Z
            ];
        };
        let { // Map state
        width, height, altitude = null, fovy = null } = props;
        const { latitude = 0, longitude = 0, zoom = 0, pitch = 0, bearing = 0, position = null, nearZMultiplier = 0.02, farZMultiplier = 1.01 } = props;
        // Silently allow apps to send in 0,0 to facilitate isomorphic render etc
        width = width || 1;
        height = height || 1;
        // `fovy` & `altitude` are independent parameters, one for the
        // projection and the latter for the view matrix. In the past,
        // the `fovy` was always derived from the `altitude`
        if (fovy === null && altitude === null) {
            altitude = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["DEFAULT_ALTITUDE"];
            fovy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["altitudeToFovy"])(altitude);
        } else if (fovy === null) {
            fovy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["altitudeToFovy"])(altitude);
        } else if (altitude === null) {
            altitude = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fovyToAltitude"])(fovy);
        }
        const scale = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["zoomToScale"])(zoom);
        // Altitude - prevent division by 0
        // TODO - just throw an Error instead?
        altitude = Math.max(0.75, altitude);
        const distanceScales = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getDistanceScales"])({
            longitude,
            latitude
        });
        const center = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["lngLatToWorld"])([
            longitude,
            latitude
        ]);
        center.push(0);
        if (position) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec3$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec3$3e$__["vec3"].add(center, center, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec3$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec3$3e$__["vec3"].mul([], position, distanceScales.unitsPerMeter));
        }
        this.projectionMatrix = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProjectionMatrix"])({
            width,
            height,
            scale,
            center,
            pitch,
            fovy,
            nearZMultiplier,
            farZMultiplier
        });
        this.viewMatrix = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getViewMatrix"])({
            height,
            scale,
            center,
            pitch,
            bearing,
            altitude
        });
        // Save parameters
        this.width = width;
        this.height = height;
        this.scale = scale;
        this.latitude = latitude;
        this.longitude = longitude;
        this.zoom = zoom;
        this.pitch = pitch;
        this.bearing = bearing;
        this.altitude = altitude;
        this.fovy = fovy;
        this.center = center;
        this.meterOffset = position || [
            0,
            0,
            0
        ];
        this.distanceScales = distanceScales;
        this._initMatrices();
        Object.freeze(this);
    }
    _initMatrices() {
        const { width, height, projectionMatrix, viewMatrix } = this;
        // Note: As usual, matrix operations should be applied in "reverse" order
        // since vectors will be multiplied in from the right during transformation
        const vpm = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["createMat4"])();
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$mat4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__mat4$3e$__["mat4"].multiply(vpm, vpm, projectionMatrix);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$mat4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__mat4$3e$__["mat4"].multiply(vpm, vpm, viewMatrix);
        this.viewProjectionMatrix = vpm;
        // Calculate matrices and scales needed for projection
        /**
         * Builds matrices that converts preprojected lngLats to screen pixels
         * and vice versa.
         * Note: Currently returns bottom-left coordinates!
         * Note: Starts with the GL projection matrix and adds steps to the
         *       scale and translate that matrix onto the window.
         * Note: WebGL controls clip space to screen projection with gl.viewport
         *       and does not need this step.
         */ const m = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["createMat4"])();
        // matrix for conversion from location to screen coordinates
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$mat4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__mat4$3e$__["mat4"].scale(m, m, [
            width / 2,
            -height / 2,
            1
        ]);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$mat4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__mat4$3e$__["mat4"].translate(m, m, [
            1,
            -1,
            0
        ]);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$mat4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__mat4$3e$__["mat4"].multiply(m, m, vpm);
        const mInverse = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$mat4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__mat4$3e$__["mat4"].invert((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["createMat4"])(), m);
        if (!mInverse) {
            throw new Error('Pixel project matrix not invertible');
        }
        this.pixelProjectionMatrix = m;
        this.pixelUnprojectionMatrix = mInverse;
    }
    /**
     * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
     * Performs the nonlinear part of the web mercator projection.
     * Remaining projection is done with 4x4 matrices which also handles
     * perspective.
     *
     * @param lngLat - [lng, lat] coordinates
     *   Specifies a point on the sphere to project onto the map.
     * @return [x,y] coordinates.
     */ projectFlat(lngLat) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["lngLatToWorld"])(lngLat);
    }
    /**
     * Unproject world point [x,y] on map onto {lat, lon} on sphere
     *
     * @param xy - array with [x,y] members
     *  representing point on projected map plane
     * @return - array with [lat,lon] of point on sphere.
     *   Has toArray method if you need a GeoJSON Array.
     *   Per cartographic tradition, lat and lon are specified as degrees.
     */ unprojectFlat(xy) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["worldToLngLat"])(xy);
    }
    /**
     * Get the map center that place a given [lng, lat] coordinate at screen point [x, y]
     * @param opt
     * @param opt.lngLat - [lng,lat] coordinates
     *   Specifies a point on the sphere.
     * @param opt.pos - [x,y] coordinates
     *   Specifies a point on the screen.
     * @return [lng,lat] new map center.
     */ getMapCenterByLngLatPosition({ lngLat, pos }) {
        const fromLocation = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["pixelsToWorld"])(pos, this.pixelUnprojectionMatrix);
        const toLocation = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["lngLatToWorld"])(lngLat);
        const translate = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec2$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec2$3e$__["vec2"].add([], toLocation, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec2$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec2$3e$__["vec2"].negate([], fromLocation));
        const newCenter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec2$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec2$3e$__["vec2"].add([], this.center, translate);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["worldToLngLat"])(newCenter);
    }
    /**
     * Returns a new viewport that fit around the given rectangle.
     * Only supports non-perspective mode.
     * @param bounds - [[lon, lat], [lon, lat]]
     * @param [options]
     * @param [options.padding] - The amount of padding in pixels to add to the given bounds.
     * @param [options.offset] - The center of the given bounds relative to the map's center,
     *    [x, y] measured in pixels.
     * @returns {WebMercatorViewport}
     */ fitBounds(bounds, options = {}) {
        const { width, height } = this;
        const { longitude, latitude, zoom } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$fit$2d$bounds$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fitBounds"])(Object.assign({
            width,
            height,
            bounds
        }, options));
        return new WebMercatorViewport({
            width,
            height,
            longitude,
            latitude,
            zoom
        });
    }
    /**
     * Returns the bounding box of the viewport.
     * @param [options]
     * @param [options.z] - The altitude at which the bounds should be calculated.
     * @returns {Array} bounds - [[lon, lat], [lon, lat]]
     */ getBounds(options) {
        const corners = this.getBoundingRegion(options);
        const west = Math.min(...corners.map((p)=>p[0]));
        const east = Math.max(...corners.map((p)=>p[0]));
        const south = Math.min(...corners.map((p)=>p[1]));
        const north = Math.max(...corners.map((p)=>p[1]));
        return [
            [
                west,
                south
            ],
            [
                east,
                north
            ]
        ];
    }
    /**
     * Returns the bounding box of the viewport.
     * @param [options]
     * @param [options.z] - The altitude at which the bounds should be calculated.
     * @returns {Array} an array of 4 points that define the visible region
     */ getBoundingRegion(options = {}) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$get$2d$bounds$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getBounds"])(this, options.z || 0);
    }
    // DEPRECATED
    /** @deprecated Legacy method name */ getLocationAtPoint({ lngLat, pos }) {
        return this.getMapCenterByLngLatPosition({
            lngLat,
            pos
        });
    }
} //# sourceMappingURL=web-mercator-viewport.js.map
}}),
"[project]/node_modules/@math.gl/web-mercator/dist/normalize-viewport-props.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "normalizeViewportProps": (()=>normalizeViewportProps)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/web-mercator-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/math-utils.js [client] (ecmascript)");
;
;
// defined by mapbox-gl
const TILE_SIZE = 512;
function normalizeViewportProps(props) {
    const { width, height, pitch = 0 } = props;
    let { longitude, latitude, zoom, bearing = 0 } = props;
    // Normalize degrees
    if (longitude < -180 || longitude > 180) {
        longitude = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["mod"])(longitude + 180, 360) - 180;
    }
    if (bearing < -180 || bearing > 180) {
        bearing = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["mod"])(bearing + 180, 360) - 180;
    }
    // Constrain zoom and shift center at low zoom levels
    const minZoom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["log2"])(height / TILE_SIZE);
    if (zoom <= minZoom) {
        zoom = minZoom;
        latitude = 0;
    } else {
        // Eliminate white space above and below the map
        const halfHeightPixels = height / 2 / Math.pow(2, zoom);
        const minLatitude = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["worldToLngLat"])([
            0,
            halfHeightPixels
        ])[1];
        if (latitude < minLatitude) {
            latitude = minLatitude;
        } else {
            const maxLatitude = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["worldToLngLat"])([
                0,
                TILE_SIZE - halfHeightPixels
            ])[1];
            if (latitude > maxLatitude) {
                latitude = maxLatitude;
            }
        }
    }
    return {
        width,
        height,
        longitude,
        latitude,
        zoom,
        pitch,
        bearing
    };
} //# sourceMappingURL=normalize-viewport-props.js.map
}}),
"[project]/node_modules/@math.gl/web-mercator/dist/fly-to-viewport.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "flyToViewport": (()=>flyToViewport),
    "getFlyToDuration": (()=>getFlyToDuration)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/math-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/web-mercator-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec2$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec2$3e$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/gl-matrix/vec2.js [client] (ecmascript) <export * as vec2>");
;
;
;
const EPSILON = 0.01;
const VIEWPORT_TRANSITION_PROPS = [
    'longitude',
    'latitude',
    'zoom'
];
const DEFAULT_OPTS = {
    curve: 1.414,
    speed: 1.2
};
function flyToViewport(startProps, endProps, t, options) {
    // Equations from above paper are referred where needed.
    const { startZoom, startCenterXY, uDelta, w0, u1, S, rho, rho2, r0 } = getFlyToTransitionParams(startProps, endProps, options);
    // If change in center is too small, do linear interpolaiton.
    if (u1 < EPSILON) {
        const viewport = {};
        for (const key of VIEWPORT_TRANSITION_PROPS){
            const startValue = startProps[key];
            const endValue = endProps[key];
            // @ts-ignore-error properties are populated dynamically
            viewport[key] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["lerp"])(startValue, endValue, t);
        }
        // @ts-expect-error properties are populated dynamically
        return viewport;
    }
    const s = t * S;
    const w = Math.cosh(r0) / Math.cosh(r0 + rho * s);
    const u = w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s) - Math.sinh(r0)) / rho2) / u1;
    const scaleIncrement = 1 / w; // Using w method for scaling.
    const newZoom = startZoom + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["scaleToZoom"])(scaleIncrement);
    const newCenterWorld = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec2$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec2$3e$__["vec2"].scale([], uDelta, u);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec2$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec2$3e$__["vec2"].add(newCenterWorld, newCenterWorld, startCenterXY);
    const newCenter = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["worldToLngLat"])(newCenterWorld);
    return {
        longitude: newCenter[0],
        latitude: newCenter[1],
        zoom: newZoom
    };
}
function getFlyToDuration(startProps, endProps, options) {
    const opts = {
        ...DEFAULT_OPTS,
        ...options
    };
    const { screenSpeed, speed, maxDuration } = opts;
    const { S, rho } = getFlyToTransitionParams(startProps, endProps, opts);
    const length = 1000 * S;
    let duration;
    if (Number.isFinite(screenSpeed)) {
        duration = length / (screenSpeed / rho);
    } else {
        duration = length / speed;
    }
    return Number.isFinite(maxDuration) && duration > maxDuration ? 0 : duration;
}
// Private Methods
// Calculate all parameters that are static for given startProps and endProps
function getFlyToTransitionParams(startProps, endProps, opts) {
    opts = Object.assign({}, DEFAULT_OPTS, opts);
    const rho = opts.curve;
    const startZoom = startProps.zoom;
    const startCenter = [
        startProps.longitude,
        startProps.latitude
    ];
    const startScale = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["zoomToScale"])(startZoom);
    const endZoom = endProps.zoom;
    const endCenter = [
        endProps.longitude,
        endProps.latitude
    ];
    const scale = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["zoomToScale"])(endZoom - startZoom);
    const startCenterXY = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["lngLatToWorld"])(startCenter);
    const endCenterXY = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["lngLatToWorld"])(endCenter);
    const uDelta = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec2$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec2$3e$__["vec2"].sub([], endCenterXY, startCenterXY);
    const w0 = Math.max(startProps.width, startProps.height);
    const w1 = w0 / scale;
    const u1 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$vec2$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__vec2$3e$__["vec2"].length(uDelta) * startScale;
    // u0 is treated as '0' in Eq (9).
    // If u1 is too small, will generate invalid number
    const _u1 = Math.max(u1, EPSILON);
    // Implement Equation (9) from above algorithm.
    const rho2 = rho * rho;
    const b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * _u1 * _u1) / (2 * w0 * rho2 * _u1);
    const b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * _u1 * _u1) / (2 * w1 * rho2 * _u1);
    const r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);
    const r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
    const S = (r1 - r0) / rho;
    return {
        startZoom,
        startCenterXY,
        uDelta,
        w0,
        u1,
        S,
        rho,
        rho2,
        r0,
        r1
    };
} //# sourceMappingURL=fly-to-viewport.js.map
}}),
"[project]/node_modules/@math.gl/web-mercator/dist/index.js [client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Classic web-mercator-project
__turbopack_context__.s({});
;
;
;
;
;
;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@math.gl/web-mercator/dist/index.js [client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$viewport$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/web-mercator-viewport.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$get$2d$bounds$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/get-bounds.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$fit$2d$bounds$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/fit-bounds.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$normalize$2d$viewport$2d$props$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/normalize-viewport-props.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$fly$2d$to$2d$viewport$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/fly-to-viewport.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/web-mercator-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/index.js [client] (ecmascript) <locals>");
}}),
"[project]/node_modules/@loaders.gl/images/dist/lib/utils/version.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Version constant cannot be imported, it needs to correspond to the build version of **this** module.
// __VERSION__ is injected by babel-plugin-version-inline
// @ts-ignore TS2304: Cannot find name '__VERSION__'.
__turbopack_context__.s({
    "VERSION": (()=>VERSION)
});
const VERSION = typeof "4.3.2" !== 'undefined' ? "4.3.2" : 'latest';
}}),
"[project]/node_modules/@loaders.gl/images/dist/lib/category-api/image-type.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "getDefaultImageType": (()=>getDefaultImageType),
    "isImageTypeSupported": (()=>isImageTypeSupported)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/globals.js [client] (ecmascript)");
;
// @ts-ignore TS2339: Property does not exist on type
const parseImageNode = globalThis.loaders?.parseImageNode;
const IMAGE_SUPPORTED = typeof Image !== 'undefined'; // NOTE: "false" positives if jsdom is installed
const IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== 'undefined';
const NODE_IMAGE_SUPPORTED = Boolean(parseImageNode);
const DATA_SUPPORTED = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBrowser"] ? true : NODE_IMAGE_SUPPORTED;
function isImageTypeSupported(type) {
    switch(type){
        case 'auto':
            // Should only ever be false in Node.js, if polyfills have not been installed...
            return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED;
        case 'imagebitmap':
            return IMAGE_BITMAP_SUPPORTED;
        case 'image':
            return IMAGE_SUPPORTED;
        case 'data':
            return DATA_SUPPORTED;
        default:
            throw new Error(`@loaders.gl/images: image ${type} not supported in this environment`);
    }
}
function getDefaultImageType() {
    if (IMAGE_BITMAP_SUPPORTED) {
        return 'imagebitmap';
    }
    if (IMAGE_SUPPORTED) {
        return 'image';
    }
    if (DATA_SUPPORTED) {
        return 'data';
    }
    // This should only happen in Node.js
    throw new Error('Install \'@loaders.gl/polyfills\' to parse images under Node.js');
}
}}),
"[project]/node_modules/@loaders.gl/images/dist/lib/category-api/parsed-image-api.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "deleteImage": (()=>deleteImage),
    "getImageData": (()=>getImageData),
    "getImageSize": (()=>getImageSize),
    "getImageType": (()=>getImageType),
    "isImage": (()=>isImage)
});
function isImage(image) {
    return Boolean(getImageTypeOrNull(image));
}
function deleteImage(image) {
    switch(getImageType(image)){
        case 'imagebitmap':
            image.close();
            break;
        default:
    }
}
function getImageType(image) {
    const format = getImageTypeOrNull(image);
    if (!format) {
        throw new Error('Not an image');
    }
    return format;
}
function getImageSize(image) {
    return getImageData(image);
}
function getImageData(image) {
    switch(getImageType(image)){
        case 'data':
            return image;
        case 'image':
        case 'imagebitmap':
            // Extract the image data from the image via a canvas
            const canvas = document.createElement('canvas');
            // TODO - reuse the canvas?
            const context = canvas.getContext('2d');
            if (!context) {
                throw new Error('getImageData');
            }
            // @ts-ignore
            canvas.width = image.width;
            // @ts-ignore
            canvas.height = image.height;
            // @ts-ignore
            context.drawImage(image, 0, 0);
            // @ts-ignore
            return context.getImageData(0, 0, image.width, image.height);
        default:
            throw new Error('getImageData');
    }
}
// PRIVATE
// eslint-disable-next-line complexity
function getImageTypeOrNull(image) {
    if (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
        return 'imagebitmap';
    }
    if (typeof Image !== 'undefined' && image instanceof Image) {
        return 'image';
    }
    if (image && typeof image === 'object' && image.data && image.width && image.height) {
        return 'data';
    }
    return null;
}
}}),
"[project]/node_modules/@loaders.gl/images/dist/lib/parsers/svg-utils.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// SVG parsing has limitations, e.g:
// https://bugs.chromium.org/p/chromium/issues/detail?id=606319
__turbopack_context__.s({
    "getBlob": (()=>getBlob),
    "getBlobOrSVGDataUrl": (()=>getBlobOrSVGDataUrl),
    "isSVG": (()=>isSVG)
});
const SVG_DATA_URL_PATTERN = /^data:image\/svg\+xml/;
const SVG_URL_PATTERN = /\.svg((\?|#).*)?$/;
function isSVG(url) {
    return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));
}
function getBlobOrSVGDataUrl(arrayBuffer, url) {
    if (isSVG(url)) {
        // Prepare a properly tagged data URL, and load using normal mechanism
        const textDecoder = new TextDecoder();
        let xmlText = textDecoder.decode(arrayBuffer);
        // TODO Escape in browser to support e.g. Chinese characters
        try {
            if (typeof unescape === 'function' && typeof encodeURIComponent === 'function') {
                xmlText = unescape(encodeURIComponent(xmlText));
            }
        } catch (error) {
            throw new Error(error.message);
        }
        // base64 encoding is safer. utf-8 fails in some browsers
        const src = `data:image/svg+xml;base64,${btoa(xmlText)}`;
        return src;
    }
    return getBlob(arrayBuffer, url);
}
function getBlob(arrayBuffer, url) {
    if (isSVG(url)) {
        // https://bugs.chromium.org/p/chromium/issues/detail?id=606319
        // return new Blob([new Uint8Array(arrayBuffer)], {type: 'image/svg+xml'});
        throw new Error('SVG cannot be parsed directly to imagebitmap');
    }
    // TODO - how to determine mime type? Param? Sniff here?
    return new Blob([
        new Uint8Array(arrayBuffer)
    ]); // MIME type not needed?
}
}}),
"[project]/node_modules/@loaders.gl/images/dist/lib/parsers/parse-to-image.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "loadToImage": (()=>loadToImage),
    "parseToImage": (()=>parseToImage)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$parsers$2f$svg$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/images/dist/lib/parsers/svg-utils.js [client] (ecmascript)");
;
async function parseToImage(arrayBuffer, options, url) {
    // Note: image parsing requires conversion to Blob (for createObjectURL).
    // Potentially inefficient for not using `response.blob()` (and for File / Blob inputs)...
    // But presumably not worth adding 'blob' flag to loader objects?
    const blobOrDataUrl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$parsers$2f$svg$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getBlobOrSVGDataUrl"])(arrayBuffer, url);
    const URL = self.URL || self.webkitURL;
    const objectUrl = typeof blobOrDataUrl !== 'string' && URL.createObjectURL(blobOrDataUrl);
    try {
        return await loadToImage(objectUrl || blobOrDataUrl, options);
    } finally{
        if (objectUrl) {
            URL.revokeObjectURL(objectUrl);
        }
    }
}
async function loadToImage(url, options) {
    const image = new Image();
    image.src = url;
    // The `image.onload()` callback does not guarantee that the image has been decoded
    // so a main thread "freeze" can be incurred when using the image for the first time.
    // `Image.decode()` returns a promise that completes when image is decoded.
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/decode
    // Note: When calling `img.decode()`, we do not need to wait for `img.onload()`
    // Note: `HTMLImageElement.decode()` is not available in Edge and IE11
    if (options.image && options.image.decode && image.decode) {
        await image.decode();
        return image;
    }
    // Create a promise that tracks onload/onerror callbacks
    return await new Promise((resolve, reject)=>{
        try {
            image.onload = ()=>resolve(image);
            image.onerror = (error)=>{
                const message = error instanceof Error ? error.message : 'error';
                reject(new Error(message));
            };
        } catch (error) {
            reject(error);
        }
    });
}
}}),
"[project]/node_modules/@loaders.gl/images/dist/lib/parsers/parse-to-image-bitmap.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "parseToImageBitmap": (()=>parseToImageBitmap)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$parsers$2f$svg$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/images/dist/lib/parsers/svg-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$parsers$2f$parse$2d$to$2d$image$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/images/dist/lib/parsers/parse-to-image.js [client] (ecmascript)");
;
;
const EMPTY_OBJECT = {};
let imagebitmapOptionsSupported = true;
async function parseToImageBitmap(arrayBuffer, options, url) {
    let blob;
    // Cannot parse SVG directly to ImageBitmap, parse to Image first
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$parsers$2f$svg$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isSVG"])(url)) {
        // Note: this only works on main thread
        const image = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$parsers$2f$parse$2d$to$2d$image$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseToImage"])(arrayBuffer, options, url);
        blob = image;
    } else {
        // Create blob from the array buffer
        blob = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$parsers$2f$svg$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getBlob"])(arrayBuffer, url);
    }
    const imagebitmapOptions = options && options.imagebitmap;
    return await safeCreateImageBitmap(blob, imagebitmapOptions);
}
/**
 * Safely creates an imageBitmap with options
 * *
 * Firefox crashes if imagebitmapOptions is supplied
 * Avoid supplying if not provided or supported, remember if not supported
 */ async function safeCreateImageBitmap(blob, imagebitmapOptions = null) {
    if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) {
        imagebitmapOptions = null;
    }
    if (imagebitmapOptions) {
        try {
            // @ts-ignore Options
            return await createImageBitmap(blob, imagebitmapOptions);
        } catch (error) {
            console.warn(error); // eslint-disable-line
            imagebitmapOptionsSupported = false;
        }
    }
    return await createImageBitmap(blob);
}
function isEmptyObject(object) {
    // @ts-ignore
    for(const key in object || EMPTY_OBJECT){
        return false;
    }
    return true;
}
}}),
"[project]/node_modules/@loaders.gl/images/dist/lib/category-api/parse-isobmff-binary.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// code adapted from https://github.com/sindresorhus/file-type under MIT license
/**
 * Tests if a buffer is in ISO base media file format (ISOBMFF) @see https://en.wikipedia.org/wiki/ISO_base_media_file_format
 * (ISOBMFF is a media container standard based on the Apple QuickTime container format)
 */ __turbopack_context__.s({
    "decodeMajorBrand": (()=>decodeMajorBrand),
    "getISOBMFFMediaType": (()=>getISOBMFFMediaType)
});
function getISOBMFFMediaType(buffer) {
    // Almost all ISO base media files start with `ftyp` box. (It's not required to be first, but it's recommended to be.)
    if (!checkString(buffer, 'ftyp', 4)) {
        return null;
    }
    // Extra check: test for 8859-1 printable characters (for simplicity, it's a mask which also catches one non-printable character).
    if ((buffer[8] & 0x60) === 0x00) {
        return null;
    }
    // `ftyp` box must contain a brand major identifier, which must consist of ISO 8859-1 printable characters.
    return decodeMajorBrand(buffer);
}
function decodeMajorBrand(buffer) {
    const brandMajor = getUTF8String(buffer, 8, 12).replace('\0', ' ').trim();
    switch(brandMajor){
        case 'avif':
        case 'avis':
            return {
                extension: 'avif',
                mimeType: 'image/avif'
            };
        default:
            return null;
    }
// We don't need these now, but they are easy to add
// case 'mif1':
//   return {extension: 'heic', mimeType: 'image/heif'};
// case 'msf1':
//   return {extension: 'heic', mimeType: 'image/heif-sequence'};
// case 'heic':
// case 'heix':
//   return {extension: 'heic', mimeType: 'image/heic'};
// case 'hevc':
// case 'hevx':
//   return {extension: 'heic', mimeType: 'image/heic-sequence'};
// case 'qt':
//   return {ext: 'mov', mime: 'video/quicktime'};
// case 'M4V':
// case 'M4VH':
// case 'M4VP':
//   return {ext: 'm4v', mime: 'video/x-m4v'};
// case 'M4P':
//   return {ext: 'm4p', mime: 'video/mp4'};
// case 'M4B':
//   return {ext: 'm4b', mime: 'audio/mp4'};
// case 'M4A':
//   return {ext: 'm4a', mime: 'audio/x-m4a'};
// case 'F4V':
//   return {ext: 'f4v', mime: 'video/mp4'};
// case 'F4P':
//   return {ext: 'f4p', mime: 'video/mp4'};
// case 'F4A':
//   return {ext: 'f4a', mime: 'audio/mp4'};
// case 'F4B':
//   return {ext: 'f4b', mime: 'audio/mp4'};
// case 'crx':
//   return {ext: 'cr3', mime: 'image/x-canon-cr3'};
// default:
// if (brandMajor.startsWith('3g')) {
//   if (brandMajor.startsWith('3g2')) {
//     return {ext: '3g2', mime: 'video/3gpp2'};
//   }
//   return {ext: '3gp', mime: 'video/3gpp'};
// }
// return {ext: 'mp4', mime: 'video/mp4'};
}
/** Interpret a chunk of bytes as a UTF8 string */ function getUTF8String(array, start, end) {
    return String.fromCharCode(...array.slice(start, end));
}
function stringToBytes(string) {
    return [
        ...string
    ].map((character)=>character.charCodeAt(0));
}
function checkString(buffer, header, offset = 0) {
    const headerBytes = stringToBytes(header);
    for(let i = 0; i < headerBytes.length; ++i){
        if (headerBytes[i] !== buffer[i + offset]) {
            return false;
        }
    }
    return true;
}
}}),
"[project]/node_modules/@loaders.gl/images/dist/lib/category-api/binary-image-api.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Attributions
// * Based on binary-gltf-utils under MIT license: Copyright (c) 2016-17 Karl Cheng
__turbopack_context__.s({
    "getBinaryImageMetadata": (()=>getBinaryImageMetadata),
    "getBmpMetadata": (()=>getBmpMetadata)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$category$2d$api$2f$parse$2d$isobmff$2d$binary$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/images/dist/lib/category-api/parse-isobmff-binary.js [client] (ecmascript)");
;
const BIG_ENDIAN = false;
const LITTLE_ENDIAN = true;
function getBinaryImageMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    return getPngMetadata(dataView) || getJpegMetadata(dataView) || getGifMetadata(dataView) || getBmpMetadata(dataView) || getISOBMFFMetadata(dataView);
}
// ISOBMFF
function getISOBMFFMetadata(binaryData) {
    const buffer = new Uint8Array(binaryData instanceof DataView ? binaryData.buffer : binaryData);
    const mediaType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$category$2d$api$2f$parse$2d$isobmff$2d$binary$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getISOBMFFMediaType"])(buffer);
    if (!mediaType) {
        return null;
    }
    return {
        mimeType: mediaType.mimeType,
        // TODO - decode width and height
        width: 0,
        height: 0
    };
}
// PNG
function getPngMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    // Check file contains the first 4 bytes of the PNG signature.
    const isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 0x89504e47;
    if (!isPng) {
        return null;
    }
    // Extract size from a binary PNG file
    return {
        mimeType: 'image/png',
        width: dataView.getUint32(16, BIG_ENDIAN),
        height: dataView.getUint32(20, BIG_ENDIAN)
    };
}
// GIF
// Extract size from a binary GIF file
// TODO: GIF is not this simple
function getGifMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    // Check first 4 bytes of the GIF signature ("GIF8").
    const isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 0x47494638;
    if (!isGif) {
        return null;
    }
    // GIF is little endian.
    return {
        mimeType: 'image/gif',
        width: dataView.getUint16(6, LITTLE_ENDIAN),
        height: dataView.getUint16(8, LITTLE_ENDIAN)
    };
}
function getBmpMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    // Check magic number is valid (first 2 characters should be "BM").
    // The mandatory bitmap file header is 14 bytes long.
    const isBmp = dataView.byteLength >= 14 && dataView.getUint16(0, BIG_ENDIAN) === 0x424d && dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;
    if (!isBmp) {
        return null;
    }
    // BMP is little endian.
    return {
        mimeType: 'image/bmp',
        width: dataView.getUint32(18, LITTLE_ENDIAN),
        height: dataView.getUint32(22, LITTLE_ENDIAN)
    };
}
// JPEG
// Extract width and height from a binary JPEG file
function getJpegMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    // Check file contains the JPEG "start of image" (SOI) marker
    // followed by another marker.
    const isJpeg = dataView.byteLength >= 3 && dataView.getUint16(0, BIG_ENDIAN) === 0xffd8 && dataView.getUint8(2) === 0xff;
    if (!isJpeg) {
        return null;
    }
    const { tableMarkers, sofMarkers } = getJpegMarkers();
    // Exclude the two byte SOI marker.
    let i = 2;
    while(i + 9 < dataView.byteLength){
        const marker = dataView.getUint16(i, BIG_ENDIAN);
        // The frame that contains the width and height of the JPEG image.
        if (sofMarkers.has(marker)) {
            return {
                mimeType: 'image/jpeg',
                height: dataView.getUint16(i + 5, BIG_ENDIAN),
                width: dataView.getUint16(i + 7, BIG_ENDIAN) // Number of pixels per line
            };
        }
        // Miscellaneous tables/data preceding the frame header.
        if (!tableMarkers.has(marker)) {
            return null;
        }
        // Length includes size of length parameter but not the two byte header.
        i += 2;
        i += dataView.getUint16(i, BIG_ENDIAN);
    }
    return null;
}
function getJpegMarkers() {
    // Tables/misc header markers.
    // DQT, DHT, DAC, DRI, COM, APP_n
    const tableMarkers = new Set([
        0xffdb,
        0xffc4,
        0xffcc,
        0xffdd,
        0xfffe
    ]);
    for(let i = 0xffe0; i < 0xfff0; ++i){
        tableMarkers.add(i);
    }
    // SOF markers and DHP marker.
    // These markers are after tables/misc data.
    const sofMarkers = new Set([
        0xffc0,
        0xffc1,
        0xffc2,
        0xffc3,
        0xffc5,
        0xffc6,
        0xffc7,
        0xffc9,
        0xffca,
        0xffcb,
        0xffcd,
        0xffce,
        0xffcf,
        0xffde
    ]);
    return {
        tableMarkers,
        sofMarkers
    };
}
// TODO - move into image module?
function toDataView(data) {
    if (data instanceof DataView) {
        return data;
    }
    if (ArrayBuffer.isView(data)) {
        return new DataView(data.buffer);
    }
    // TODO: make these functions work for Node.js buffers?
    // if (bufferToArrayBuffer) {
    //   data = bufferToArrayBuffer(data);
    // }
    // Careful - Node Buffers will look like ArrayBuffers (keep after isBuffer)
    if (data instanceof ArrayBuffer) {
        return new DataView(data);
    }
    throw new Error('toDataView');
}
}}),
"[project]/node_modules/@loaders.gl/images/dist/lib/parsers/parse-to-node-image.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "parseToNodeImage": (()=>parseToNodeImage)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/assert.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$category$2d$api$2f$binary$2d$image$2d$api$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/images/dist/lib/category-api/binary-image-api.js [client] (ecmascript)");
;
;
async function parseToNodeImage(arrayBuffer, options) {
    const { mimeType } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$category$2d$api$2f$binary$2d$image$2d$api$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getBinaryImageMetadata"])(arrayBuffer) || {};
    // @ts-ignore
    const parseImageNode = globalThis.loaders?.parseImageNode;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(parseImageNode); // '@loaders.gl/polyfills not installed'
    // @ts-expect-error TODO should we throw error in this case?
    return await parseImageNode(arrayBuffer, mimeType);
}
}}),
"[project]/node_modules/@loaders.gl/images/dist/lib/parsers/parse-image.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "parseImage": (()=>parseImage)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/assert.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$category$2d$api$2f$image$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/images/dist/lib/category-api/image-type.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$category$2d$api$2f$parsed$2d$image$2d$api$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/images/dist/lib/category-api/parsed-image-api.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$parsers$2f$parse$2d$to$2d$image$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/images/dist/lib/parsers/parse-to-image.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$parsers$2f$parse$2d$to$2d$image$2d$bitmap$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/images/dist/lib/parsers/parse-to-image-bitmap.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$parsers$2f$parse$2d$to$2d$node$2d$image$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/images/dist/lib/parsers/parse-to-node-image.js [client] (ecmascript)");
;
;
;
;
;
;
async function parseImage(arrayBuffer, options, context) {
    options = options || {};
    const imageOptions = options.image || {};
    // The user can request a specific output format via `options.image.type`
    const imageType = imageOptions.type || 'auto';
    const { url } = context || {};
    // Note: For options.image.type === `data`, we may still need to load as `image` or `imagebitmap`
    const loadType = getLoadableImageType(imageType);
    let image;
    switch(loadType){
        case 'imagebitmap':
            image = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$parsers$2f$parse$2d$to$2d$image$2d$bitmap$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseToImageBitmap"])(arrayBuffer, options, url);
            break;
        case 'image':
            image = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$parsers$2f$parse$2d$to$2d$image$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseToImage"])(arrayBuffer, options, url);
            break;
        case 'data':
            // Node.js loads imagedata directly
            image = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$parsers$2f$parse$2d$to$2d$node$2d$image$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseToNodeImage"])(arrayBuffer, options);
            break;
        default:
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$env$2d$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(false);
    }
    // Browser: if options.image.type === 'data', we can now extract data from the loaded image
    if (imageType === 'data') {
        image = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$category$2d$api$2f$parsed$2d$image$2d$api$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getImageData"])(image);
    }
    return image;
}
// Get a loadable image type from image type
function getLoadableImageType(type) {
    switch(type){
        case 'auto':
        case 'data':
            // Browser: For image data we need still need to load using an image format
            // Node: the default image type is `data`.
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$category$2d$api$2f$image$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getDefaultImageType"])();
        default:
            // Throw an error if not supported
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$category$2d$api$2f$image$2d$type$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isImageTypeSupported"])(type);
            return type;
    }
}
}}),
"[project]/node_modules/@loaders.gl/images/dist/image-loader.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// import type { ImageType } from '@loaders.gl/schema';
__turbopack_context__.s({
    "ImageLoader": (()=>ImageLoader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$utils$2f$version$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/images/dist/lib/utils/version.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$parsers$2f$parse$2d$image$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/images/dist/lib/parsers/parse-image.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$category$2d$api$2f$binary$2d$image$2d$api$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/images/dist/lib/category-api/binary-image-api.js [client] (ecmascript)");
;
;
;
const EXTENSIONS = [
    'png',
    'jpg',
    'jpeg',
    'gif',
    'webp',
    'bmp',
    'ico',
    'svg',
    'avif'
];
const MIME_TYPES = [
    'image/png',
    'image/jpeg',
    'image/gif',
    'image/webp',
    'image/avif',
    'image/bmp',
    'image/vnd.microsoft.icon',
    'image/svg+xml'
];
const DEFAULT_IMAGE_LOADER_OPTIONS = {
    image: {
        type: 'auto',
        decode: true // if format is HTML
    }
};
const ImageLoader = {
    dataType: null,
    batchType: null,
    id: 'image',
    module: 'images',
    name: 'Images',
    version: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$utils$2f$version$2e$js__$5b$client$5d$__$28$ecmascript$29$__["VERSION"],
    mimeTypes: MIME_TYPES,
    extensions: EXTENSIONS,
    parse: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$parsers$2f$parse$2d$image$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseImage"],
    // TODO: byteOffset, byteLength;
    tests: [
        (arrayBuffer)=>Boolean((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$images$2f$dist$2f$lib$2f$category$2d$api$2f$binary$2d$image$2d$api$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getBinaryImageMetadata"])(new DataView(arrayBuffer)))
    ],
    options: DEFAULT_IMAGE_LOADER_OPTIONS
};
}}),
"[project]/node_modules/@luma.gl/constants/dist/webgl-constants.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/* eslint-disable key-spacing, max-len, no-inline-comments, camelcase */ /**
 * Standard WebGL, WebGL2 and extension constants (OpenGL constants)
 * @note (Most) of these constants are also defined on the WebGLRenderingContext interface.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants
 * @privateRemarks Locally called `GLEnum` instead of `GL`, because `babel-plugin-inline-webl-constants`
 *  both depends on and processes this module, but shouldn't replace these declarations.
 */ // eslint-disable-next-line no-shadow
__turbopack_context__.s({
    "GL": (()=>GLEnum)
});
var GLEnum;
(function(GLEnum) {
    // Clearing buffers
    // Constants passed to clear() to clear buffer masks.
    /** Passed to clear to clear the current depth buffer. */ GLEnum[GLEnum["DEPTH_BUFFER_BIT"] = 256] = "DEPTH_BUFFER_BIT";
    /** Passed to clear to clear the current stencil buffer. */ GLEnum[GLEnum["STENCIL_BUFFER_BIT"] = 1024] = "STENCIL_BUFFER_BIT";
    /** Passed to clear to clear the current color buffer. */ GLEnum[GLEnum["COLOR_BUFFER_BIT"] = 16384] = "COLOR_BUFFER_BIT";
    // Rendering primitives
    // Constants passed to drawElements() or drawArrays() to specify what kind of primitive to render.
    /** Passed to drawElements or drawArrays to draw single points. */ GLEnum[GLEnum["POINTS"] = 0] = "POINTS";
    /** Passed to drawElements or drawArrays to draw lines. Each vertex connects to the one after it. */ GLEnum[GLEnum["LINES"] = 1] = "LINES";
    /** Passed to drawElements or drawArrays to draw lines. Each set of two vertices is treated as a separate line segment. */ GLEnum[GLEnum["LINE_LOOP"] = 2] = "LINE_LOOP";
    /** Passed to drawElements or drawArrays to draw a connected group of line segments from the first vertex to the last. */ GLEnum[GLEnum["LINE_STRIP"] = 3] = "LINE_STRIP";
    /** Passed to drawElements or drawArrays to draw triangles. Each set of three vertices creates a separate triangle. */ GLEnum[GLEnum["TRIANGLES"] = 4] = "TRIANGLES";
    /** Passed to drawElements or drawArrays to draw a connected group of triangles. */ GLEnum[GLEnum["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
    /** Passed to drawElements or drawArrays to draw a connected group of triangles. Each vertex connects to the previous and the first vertex in the fan. */ GLEnum[GLEnum["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
    // Blending modes
    // Constants passed to blendFunc() or blendFuncSeparate() to specify the blending mode (for both, RBG and alpha, or separately).
    /** Passed to blendFunc or blendFuncSeparate to turn off a component. */ GLEnum[GLEnum["ZERO"] = 0] = "ZERO";
    /** Passed to blendFunc or blendFuncSeparate to turn on a component. */ GLEnum[GLEnum["ONE"] = 1] = "ONE";
    /** Passed to blendFunc or blendFuncSeparate to multiply a component by the source elements color. */ GLEnum[GLEnum["SRC_COLOR"] = 768] = "SRC_COLOR";
    /** Passed to blendFunc or blendFuncSeparate to multiply a component by one minus the source elements color. */ GLEnum[GLEnum["ONE_MINUS_SRC_COLOR"] = 769] = "ONE_MINUS_SRC_COLOR";
    /** Passed to blendFunc or blendFuncSeparate to multiply a component by the source's alpha. */ GLEnum[GLEnum["SRC_ALPHA"] = 770] = "SRC_ALPHA";
    /** Passed to blendFunc or blendFuncSeparate to multiply a component by one minus the source's alpha. */ GLEnum[GLEnum["ONE_MINUS_SRC_ALPHA"] = 771] = "ONE_MINUS_SRC_ALPHA";
    /** Passed to blendFunc or blendFuncSeparate to multiply a component by the destination's alpha. */ GLEnum[GLEnum["DST_ALPHA"] = 772] = "DST_ALPHA";
    /** Passed to blendFunc or blendFuncSeparate to multiply a component by one minus the destination's alpha. */ GLEnum[GLEnum["ONE_MINUS_DST_ALPHA"] = 773] = "ONE_MINUS_DST_ALPHA";
    /** Passed to blendFunc or blendFuncSeparate to multiply a component by the destination's color. */ GLEnum[GLEnum["DST_COLOR"] = 774] = "DST_COLOR";
    /** Passed to blendFunc or blendFuncSeparate to multiply a component by one minus the destination's color. */ GLEnum[GLEnum["ONE_MINUS_DST_COLOR"] = 775] = "ONE_MINUS_DST_COLOR";
    /** Passed to blendFunc or blendFuncSeparate to multiply a component by the minimum of source's alpha or one minus the destination's alpha. */ GLEnum[GLEnum["SRC_ALPHA_SATURATE"] = 776] = "SRC_ALPHA_SATURATE";
    /** Passed to blendFunc or blendFuncSeparate to specify a constant color blend function. */ GLEnum[GLEnum["CONSTANT_COLOR"] = 32769] = "CONSTANT_COLOR";
    /** Passed to blendFunc or blendFuncSeparate to specify one minus a constant color blend function. */ GLEnum[GLEnum["ONE_MINUS_CONSTANT_COLOR"] = 32770] = "ONE_MINUS_CONSTANT_COLOR";
    /** Passed to blendFunc or blendFuncSeparate to specify a constant alpha blend function. */ GLEnum[GLEnum["CONSTANT_ALPHA"] = 32771] = "CONSTANT_ALPHA";
    /** Passed to blendFunc or blendFuncSeparate to specify one minus a constant alpha blend function. */ GLEnum[GLEnum["ONE_MINUS_CONSTANT_ALPHA"] = 32772] = "ONE_MINUS_CONSTANT_ALPHA";
    // Blending equations
    // Constants passed to blendEquation() or blendEquationSeparate() to control
    // how the blending is calculated (for both, RBG and alpha, or separately).
    /** Passed to blendEquation or blendEquationSeparate to set an addition blend function. */ /** Passed to blendEquation or blendEquationSeparate to specify a subtraction blend function (source - destination). */ /** Passed to blendEquation or blendEquationSeparate to specify a reverse subtraction blend function (destination - source). */ GLEnum[GLEnum["FUNC_ADD"] = 32774] = "FUNC_ADD";
    GLEnum[GLEnum["FUNC_SUBTRACT"] = 32778] = "FUNC_SUBTRACT";
    GLEnum[GLEnum["FUNC_REVERSE_SUBTRACT"] = 32779] = "FUNC_REVERSE_SUBTRACT";
    // Getting GL parameter information
    // Constants passed to getParameter() to specify what information to return.
    /** Passed to getParameter to get the current RGB blend function. */ GLEnum[GLEnum["BLEND_EQUATION"] = 32777] = "BLEND_EQUATION";
    /** Passed to getParameter to get the current RGB blend function. Same as BLEND_EQUATION */ GLEnum[GLEnum["BLEND_EQUATION_RGB"] = 32777] = "BLEND_EQUATION_RGB";
    /** Passed to getParameter to get the current alpha blend function. Same as BLEND_EQUATION */ GLEnum[GLEnum["BLEND_EQUATION_ALPHA"] = 34877] = "BLEND_EQUATION_ALPHA";
    /** Passed to getParameter to get the current destination RGB blend function. */ GLEnum[GLEnum["BLEND_DST_RGB"] = 32968] = "BLEND_DST_RGB";
    /** Passed to getParameter to get the current destination RGB blend function. */ GLEnum[GLEnum["BLEND_SRC_RGB"] = 32969] = "BLEND_SRC_RGB";
    /** Passed to getParameter to get the current destination alpha blend function. */ GLEnum[GLEnum["BLEND_DST_ALPHA"] = 32970] = "BLEND_DST_ALPHA";
    /** Passed to getParameter to get the current source alpha blend function. */ GLEnum[GLEnum["BLEND_SRC_ALPHA"] = 32971] = "BLEND_SRC_ALPHA";
    /** Passed to getParameter to return a the current blend color. */ GLEnum[GLEnum["BLEND_COLOR"] = 32773] = "BLEND_COLOR";
    /** Passed to getParameter to get the array buffer binding. */ GLEnum[GLEnum["ARRAY_BUFFER_BINDING"] = 34964] = "ARRAY_BUFFER_BINDING";
    /** Passed to getParameter to get the current element array buffer. */ GLEnum[GLEnum["ELEMENT_ARRAY_BUFFER_BINDING"] = 34965] = "ELEMENT_ARRAY_BUFFER_BINDING";
    /** Passed to getParameter to get the current lineWidth (set by the lineWidth method). */ GLEnum[GLEnum["LINE_WIDTH"] = 2849] = "LINE_WIDTH";
    /** Passed to getParameter to get the current size of a point drawn with gl.POINTS */ GLEnum[GLEnum["ALIASED_POINT_SIZE_RANGE"] = 33901] = "ALIASED_POINT_SIZE_RANGE";
    /** Passed to getParameter to get the range of available widths for a line. Returns a length-2 array with the lo value at 0, and hight at 1. */ GLEnum[GLEnum["ALIASED_LINE_WIDTH_RANGE"] = 33902] = "ALIASED_LINE_WIDTH_RANGE";
    /** Passed to getParameter to get the current value of cullFace. Should return FRONT, BACK, or FRONT_AND_BACK */ GLEnum[GLEnum["CULL_FACE_MODE"] = 2885] = "CULL_FACE_MODE";
    /** Passed to getParameter to determine the current value of frontFace. Should return CW or CCW. */ GLEnum[GLEnum["FRONT_FACE"] = 2886] = "FRONT_FACE";
    /** Passed to getParameter to return a length-2 array of floats giving the current depth range. */ GLEnum[GLEnum["DEPTH_RANGE"] = 2928] = "DEPTH_RANGE";
    /** Passed to getParameter to determine if the depth write mask is enabled. */ GLEnum[GLEnum["DEPTH_WRITEMASK"] = 2930] = "DEPTH_WRITEMASK";
    /** Passed to getParameter to determine the current depth clear value. */ GLEnum[GLEnum["DEPTH_CLEAR_VALUE"] = 2931] = "DEPTH_CLEAR_VALUE";
    /** Passed to getParameter to get the current depth function. Returns NEVER, ALWAYS, LESS, EQUAL, LEQUAL, GREATER, GEQUAL, or NOTEQUAL. */ GLEnum[GLEnum["DEPTH_FUNC"] = 2932] = "DEPTH_FUNC";
    /** Passed to getParameter to get the value the stencil will be cleared to. */ GLEnum[GLEnum["STENCIL_CLEAR_VALUE"] = 2961] = "STENCIL_CLEAR_VALUE";
    /** Passed to getParameter to get the current stencil function. Returns NEVER, ALWAYS, LESS, EQUAL, LEQUAL, GREATER, GEQUAL, or NOTEQUAL. */ GLEnum[GLEnum["STENCIL_FUNC"] = 2962] = "STENCIL_FUNC";
    /** Passed to getParameter to get the current stencil fail function. Should return KEEP, REPLACE, INCR, DECR, INVERT, INCR_WRAP, or DECR_WRAP. */ GLEnum[GLEnum["STENCIL_FAIL"] = 2964] = "STENCIL_FAIL";
    /** Passed to getParameter to get the current stencil fail function should the depth buffer test fail. Should return KEEP, REPLACE, INCR, DECR, INVERT, INCR_WRAP, or DECR_WRAP. */ GLEnum[GLEnum["STENCIL_PASS_DEPTH_FAIL"] = 2965] = "STENCIL_PASS_DEPTH_FAIL";
    /** Passed to getParameter to get the current stencil fail function should the depth buffer test pass. Should return KEEP, REPLACE, INCR, DECR, INVERT, INCR_WRAP, or DECR_WRAP. */ GLEnum[GLEnum["STENCIL_PASS_DEPTH_PASS"] = 2966] = "STENCIL_PASS_DEPTH_PASS";
    /** Passed to getParameter to get the reference value used for stencil tests. */ GLEnum[GLEnum["STENCIL_REF"] = 2967] = "STENCIL_REF";
    GLEnum[GLEnum["STENCIL_VALUE_MASK"] = 2963] = "STENCIL_VALUE_MASK";
    GLEnum[GLEnum["STENCIL_WRITEMASK"] = 2968] = "STENCIL_WRITEMASK";
    GLEnum[GLEnum["STENCIL_BACK_FUNC"] = 34816] = "STENCIL_BACK_FUNC";
    GLEnum[GLEnum["STENCIL_BACK_FAIL"] = 34817] = "STENCIL_BACK_FAIL";
    GLEnum[GLEnum["STENCIL_BACK_PASS_DEPTH_FAIL"] = 34818] = "STENCIL_BACK_PASS_DEPTH_FAIL";
    GLEnum[GLEnum["STENCIL_BACK_PASS_DEPTH_PASS"] = 34819] = "STENCIL_BACK_PASS_DEPTH_PASS";
    GLEnum[GLEnum["STENCIL_BACK_REF"] = 36003] = "STENCIL_BACK_REF";
    GLEnum[GLEnum["STENCIL_BACK_VALUE_MASK"] = 36004] = "STENCIL_BACK_VALUE_MASK";
    GLEnum[GLEnum["STENCIL_BACK_WRITEMASK"] = 36005] = "STENCIL_BACK_WRITEMASK";
    /** An Int32Array with four elements for the current viewport dimensions. */ GLEnum[GLEnum["VIEWPORT"] = 2978] = "VIEWPORT";
    /** An Int32Array with four elements for the current scissor box dimensions. */ GLEnum[GLEnum["SCISSOR_BOX"] = 3088] = "SCISSOR_BOX";
    GLEnum[GLEnum["COLOR_CLEAR_VALUE"] = 3106] = "COLOR_CLEAR_VALUE";
    GLEnum[GLEnum["COLOR_WRITEMASK"] = 3107] = "COLOR_WRITEMASK";
    GLEnum[GLEnum["UNPACK_ALIGNMENT"] = 3317] = "UNPACK_ALIGNMENT";
    GLEnum[GLEnum["PACK_ALIGNMENT"] = 3333] = "PACK_ALIGNMENT";
    GLEnum[GLEnum["MAX_TEXTURE_SIZE"] = 3379] = "MAX_TEXTURE_SIZE";
    GLEnum[GLEnum["MAX_VIEWPORT_DIMS"] = 3386] = "MAX_VIEWPORT_DIMS";
    GLEnum[GLEnum["SUBPIXEL_BITS"] = 3408] = "SUBPIXEL_BITS";
    GLEnum[GLEnum["RED_BITS"] = 3410] = "RED_BITS";
    GLEnum[GLEnum["GREEN_BITS"] = 3411] = "GREEN_BITS";
    GLEnum[GLEnum["BLUE_BITS"] = 3412] = "BLUE_BITS";
    GLEnum[GLEnum["ALPHA_BITS"] = 3413] = "ALPHA_BITS";
    GLEnum[GLEnum["DEPTH_BITS"] = 3414] = "DEPTH_BITS";
    GLEnum[GLEnum["STENCIL_BITS"] = 3415] = "STENCIL_BITS";
    GLEnum[GLEnum["POLYGON_OFFSET_UNITS"] = 10752] = "POLYGON_OFFSET_UNITS";
    GLEnum[GLEnum["POLYGON_OFFSET_FACTOR"] = 32824] = "POLYGON_OFFSET_FACTOR";
    GLEnum[GLEnum["TEXTURE_BINDING_2D"] = 32873] = "TEXTURE_BINDING_2D";
    GLEnum[GLEnum["SAMPLE_BUFFERS"] = 32936] = "SAMPLE_BUFFERS";
    GLEnum[GLEnum["SAMPLES"] = 32937] = "SAMPLES";
    GLEnum[GLEnum["SAMPLE_COVERAGE_VALUE"] = 32938] = "SAMPLE_COVERAGE_VALUE";
    GLEnum[GLEnum["SAMPLE_COVERAGE_INVERT"] = 32939] = "SAMPLE_COVERAGE_INVERT";
    GLEnum[GLEnum["COMPRESSED_TEXTURE_FORMATS"] = 34467] = "COMPRESSED_TEXTURE_FORMATS";
    GLEnum[GLEnum["VENDOR"] = 7936] = "VENDOR";
    GLEnum[GLEnum["RENDERER"] = 7937] = "RENDERER";
    GLEnum[GLEnum["VERSION"] = 7938] = "VERSION";
    GLEnum[GLEnum["IMPLEMENTATION_COLOR_READ_TYPE"] = 35738] = "IMPLEMENTATION_COLOR_READ_TYPE";
    GLEnum[GLEnum["IMPLEMENTATION_COLOR_READ_FORMAT"] = 35739] = "IMPLEMENTATION_COLOR_READ_FORMAT";
    GLEnum[GLEnum["BROWSER_DEFAULT_WEBGL"] = 37444] = "BROWSER_DEFAULT_WEBGL";
    // Buffers
    // Constants passed to bufferData(), bufferSubData(), bindBuffer(), or
    // getBufferParameter().
    /** Passed to bufferData as a hint about whether the contents of the buffer are likely to be used often and not change often. */ GLEnum[GLEnum["STATIC_DRAW"] = 35044] = "STATIC_DRAW";
    /** Passed to bufferData as a hint about whether the contents of the buffer are likely to not be used often. */ GLEnum[GLEnum["STREAM_DRAW"] = 35040] = "STREAM_DRAW";
    /** Passed to bufferData as a hint about whether the contents of the buffer are likely to be used often and change often. */ GLEnum[GLEnum["DYNAMIC_DRAW"] = 35048] = "DYNAMIC_DRAW";
    /** Passed to bindBuffer or bufferData to specify the type of buffer being used. */ GLEnum[GLEnum["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
    /** Passed to bindBuffer or bufferData to specify the type of buffer being used. */ GLEnum[GLEnum["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
    /** Passed to getBufferParameter to get a buffer's size. */ GLEnum[GLEnum["BUFFER_SIZE"] = 34660] = "BUFFER_SIZE";
    /** Passed to getBufferParameter to get the hint for the buffer passed in when it was created. */ GLEnum[GLEnum["BUFFER_USAGE"] = 34661] = "BUFFER_USAGE";
    // Vertex attributes
    // Constants passed to getVertexAttrib().
    /** Passed to getVertexAttrib to read back the current vertex attribute. */ GLEnum[GLEnum["CURRENT_VERTEX_ATTRIB"] = 34342] = "CURRENT_VERTEX_ATTRIB";
    GLEnum[GLEnum["VERTEX_ATTRIB_ARRAY_ENABLED"] = 34338] = "VERTEX_ATTRIB_ARRAY_ENABLED";
    GLEnum[GLEnum["VERTEX_ATTRIB_ARRAY_SIZE"] = 34339] = "VERTEX_ATTRIB_ARRAY_SIZE";
    GLEnum[GLEnum["VERTEX_ATTRIB_ARRAY_STRIDE"] = 34340] = "VERTEX_ATTRIB_ARRAY_STRIDE";
    GLEnum[GLEnum["VERTEX_ATTRIB_ARRAY_TYPE"] = 34341] = "VERTEX_ATTRIB_ARRAY_TYPE";
    GLEnum[GLEnum["VERTEX_ATTRIB_ARRAY_NORMALIZED"] = 34922] = "VERTEX_ATTRIB_ARRAY_NORMALIZED";
    GLEnum[GLEnum["VERTEX_ATTRIB_ARRAY_POINTER"] = 34373] = "VERTEX_ATTRIB_ARRAY_POINTER";
    GLEnum[GLEnum["VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"] = 34975] = "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING";
    // Culling
    // Constants passed to cullFace().
    /** Passed to enable/disable to turn on/off culling. Can also be used with getParameter to find the current culling method. */ GLEnum[GLEnum["CULL_FACE"] = 2884] = "CULL_FACE";
    /** Passed to cullFace to specify that only front faces should be culled. */ GLEnum[GLEnum["FRONT"] = 1028] = "FRONT";
    /** Passed to cullFace to specify that only back faces should be culled. */ GLEnum[GLEnum["BACK"] = 1029] = "BACK";
    /** Passed to cullFace to specify that front and back faces should be culled. */ GLEnum[GLEnum["FRONT_AND_BACK"] = 1032] = "FRONT_AND_BACK";
    // Enabling and disabling
    // Constants passed to enable() or disable().
    /** Passed to enable/disable to turn on/off blending. Can also be used with getParameter to find the current blending method. */ GLEnum[GLEnum["BLEND"] = 3042] = "BLEND";
    /** Passed to enable/disable to turn on/off the depth test. Can also be used with getParameter to query the depth test. */ GLEnum[GLEnum["DEPTH_TEST"] = 2929] = "DEPTH_TEST";
    /** Passed to enable/disable to turn on/off dithering. Can also be used with getParameter to find the current dithering method. */ GLEnum[GLEnum["DITHER"] = 3024] = "DITHER";
    /** Passed to enable/disable to turn on/off the polygon offset. Useful for rendering hidden-line images, decals, and or solids with highlighted edges. Can also be used with getParameter to query the scissor test. */ GLEnum[GLEnum["POLYGON_OFFSET_FILL"] = 32823] = "POLYGON_OFFSET_FILL";
    /** Passed to enable/disable to turn on/off the alpha to coverage. Used in multi-sampling alpha channels. */ GLEnum[GLEnum["SAMPLE_ALPHA_TO_COVERAGE"] = 32926] = "SAMPLE_ALPHA_TO_COVERAGE";
    /** Passed to enable/disable to turn on/off the sample coverage. Used in multi-sampling. */ GLEnum[GLEnum["SAMPLE_COVERAGE"] = 32928] = "SAMPLE_COVERAGE";
    /** Passed to enable/disable to turn on/off the scissor test. Can also be used with getParameter to query the scissor test. */ GLEnum[GLEnum["SCISSOR_TEST"] = 3089] = "SCISSOR_TEST";
    /** Passed to enable/disable to turn on/off the stencil test. Can also be used with getParameter to query the stencil test. */ GLEnum[GLEnum["STENCIL_TEST"] = 2960] = "STENCIL_TEST";
    // Errors
    // Constants returned from getError().
    /** Returned from getError(). */ GLEnum[GLEnum["NO_ERROR"] = 0] = "NO_ERROR";
    /** Returned from getError(). */ GLEnum[GLEnum["INVALID_ENUM"] = 1280] = "INVALID_ENUM";
    /** Returned from getError(). */ GLEnum[GLEnum["INVALID_VALUE"] = 1281] = "INVALID_VALUE";
    /** Returned from getError(). */ GLEnum[GLEnum["INVALID_OPERATION"] = 1282] = "INVALID_OPERATION";
    /** Returned from getError(). */ GLEnum[GLEnum["OUT_OF_MEMORY"] = 1285] = "OUT_OF_MEMORY";
    /** Returned from getError(). */ GLEnum[GLEnum["CONTEXT_LOST_WEBGL"] = 37442] = "CONTEXT_LOST_WEBGL";
    // Front face directions
    // Constants passed to frontFace().
    /** Passed to frontFace to specify the front face of a polygon is drawn in the clockwise direction */ GLEnum[GLEnum["CW"] = 2304] = "CW";
    /** Passed to frontFace to specify the front face of a polygon is drawn in the counter clockwise direction */ GLEnum[GLEnum["CCW"] = 2305] = "CCW";
    // Hints
    // Constants passed to hint()
    /** There is no preference for this behavior. */ GLEnum[GLEnum["DONT_CARE"] = 4352] = "DONT_CARE";
    /** The most efficient behavior should be used. */ GLEnum[GLEnum["FASTEST"] = 4353] = "FASTEST";
    /** The most correct or the highest quality option should be used. */ GLEnum[GLEnum["NICEST"] = 4354] = "NICEST";
    /** Hint for the quality of filtering when generating mipmap images with WebGLRenderingContext.generateMipmap(). */ GLEnum[GLEnum["GENERATE_MIPMAP_HINT"] = 33170] = "GENERATE_MIPMAP_HINT";
    // Data types
    GLEnum[GLEnum["BYTE"] = 5120] = "BYTE";
    GLEnum[GLEnum["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
    GLEnum[GLEnum["SHORT"] = 5122] = "SHORT";
    GLEnum[GLEnum["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
    GLEnum[GLEnum["INT"] = 5124] = "INT";
    GLEnum[GLEnum["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
    GLEnum[GLEnum["FLOAT"] = 5126] = "FLOAT";
    GLEnum[GLEnum["DOUBLE"] = 5130] = "DOUBLE";
    // Pixel formats
    GLEnum[GLEnum["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
    GLEnum[GLEnum["ALPHA"] = 6406] = "ALPHA";
    GLEnum[GLEnum["RGB"] = 6407] = "RGB";
    GLEnum[GLEnum["RGBA"] = 6408] = "RGBA";
    GLEnum[GLEnum["LUMINANCE"] = 6409] = "LUMINANCE";
    GLEnum[GLEnum["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
    // Pixel types
    // UNSIGNED_BYTE = 0x1401,
    GLEnum[GLEnum["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
    GLEnum[GLEnum["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
    GLEnum[GLEnum["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
    // Shaders
    // Constants passed to createShader() or getShaderParameter()
    /** Passed to createShader to define a fragment shader. */ GLEnum[GLEnum["FRAGMENT_SHADER"] = 35632] = "FRAGMENT_SHADER";
    /** Passed to createShader to define a vertex shader */ GLEnum[GLEnum["VERTEX_SHADER"] = 35633] = "VERTEX_SHADER";
    /** Passed to getShaderParameter to get the status of the compilation. Returns false if the shader was not compiled. You can then query getShaderInfoLog to find the exact error */ GLEnum[GLEnum["COMPILE_STATUS"] = 35713] = "COMPILE_STATUS";
    /** Passed to getShaderParameter to determine if a shader was deleted via deleteShader. Returns true if it was, false otherwise. */ GLEnum[GLEnum["DELETE_STATUS"] = 35712] = "DELETE_STATUS";
    /** Passed to getProgramParameter after calling linkProgram to determine if a program was linked correctly. Returns false if there were errors. Use getProgramInfoLog to find the exact error. */ GLEnum[GLEnum["LINK_STATUS"] = 35714] = "LINK_STATUS";
    /** Passed to getProgramParameter after calling validateProgram to determine if it is valid. Returns false if errors were found. */ GLEnum[GLEnum["VALIDATE_STATUS"] = 35715] = "VALIDATE_STATUS";
    /** Passed to getProgramParameter after calling attachShader to determine if the shader was attached correctly. Returns false if errors occurred. */ GLEnum[GLEnum["ATTACHED_SHADERS"] = 35717] = "ATTACHED_SHADERS";
    /** Passed to getProgramParameter to get the number of attributes active in a program. */ GLEnum[GLEnum["ACTIVE_ATTRIBUTES"] = 35721] = "ACTIVE_ATTRIBUTES";
    /** Passed to getProgramParameter to get the number of uniforms active in a program. */ GLEnum[GLEnum["ACTIVE_UNIFORMS"] = 35718] = "ACTIVE_UNIFORMS";
    /** The maximum number of entries possible in the vertex attribute list. */ GLEnum[GLEnum["MAX_VERTEX_ATTRIBS"] = 34921] = "MAX_VERTEX_ATTRIBS";
    GLEnum[GLEnum["MAX_VERTEX_UNIFORM_VECTORS"] = 36347] = "MAX_VERTEX_UNIFORM_VECTORS";
    GLEnum[GLEnum["MAX_VARYING_VECTORS"] = 36348] = "MAX_VARYING_VECTORS";
    GLEnum[GLEnum["MAX_COMBINED_TEXTURE_IMAGE_UNITS"] = 35661] = "MAX_COMBINED_TEXTURE_IMAGE_UNITS";
    GLEnum[GLEnum["MAX_VERTEX_TEXTURE_IMAGE_UNITS"] = 35660] = "MAX_VERTEX_TEXTURE_IMAGE_UNITS";
    /** Implementation dependent number of maximum texture units. At least 8. */ GLEnum[GLEnum["MAX_TEXTURE_IMAGE_UNITS"] = 34930] = "MAX_TEXTURE_IMAGE_UNITS";
    GLEnum[GLEnum["MAX_FRAGMENT_UNIFORM_VECTORS"] = 36349] = "MAX_FRAGMENT_UNIFORM_VECTORS";
    GLEnum[GLEnum["SHADER_TYPE"] = 35663] = "SHADER_TYPE";
    GLEnum[GLEnum["SHADING_LANGUAGE_VERSION"] = 35724] = "SHADING_LANGUAGE_VERSION";
    GLEnum[GLEnum["CURRENT_PROGRAM"] = 35725] = "CURRENT_PROGRAM";
    // Depth or stencil tests
    // Constants passed to depthFunc() or stencilFunc().
    /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will never pass, i.e., nothing will be drawn. */ GLEnum[GLEnum["NEVER"] = 512] = "NEVER";
    /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is less than the stored value. */ GLEnum[GLEnum["LESS"] = 513] = "LESS";
    /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is equals to the stored value. */ GLEnum[GLEnum["EQUAL"] = 514] = "EQUAL";
    /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is less than or equal to the stored value. */ GLEnum[GLEnum["LEQUAL"] = 515] = "LEQUAL";
    /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is greater than the stored value. */ GLEnum[GLEnum["GREATER"] = 516] = "GREATER";
    /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is not equal to the stored value. */ GLEnum[GLEnum["NOTEQUAL"] = 517] = "NOTEQUAL";
    /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is greater than or equal to the stored value. */ GLEnum[GLEnum["GEQUAL"] = 518] = "GEQUAL";
    /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will always pass, i.e., pixels will be drawn in the order they are drawn. */ GLEnum[GLEnum["ALWAYS"] = 519] = "ALWAYS";
    // Stencil actions
    // Constants passed to stencilOp().
    GLEnum[GLEnum["KEEP"] = 7680] = "KEEP";
    GLEnum[GLEnum["REPLACE"] = 7681] = "REPLACE";
    GLEnum[GLEnum["INCR"] = 7682] = "INCR";
    GLEnum[GLEnum["DECR"] = 7683] = "DECR";
    GLEnum[GLEnum["INVERT"] = 5386] = "INVERT";
    GLEnum[GLEnum["INCR_WRAP"] = 34055] = "INCR_WRAP";
    GLEnum[GLEnum["DECR_WRAP"] = 34056] = "DECR_WRAP";
    // Textures
    // Constants passed to texParameteri(),
    // texParameterf(), bindTexture(), texImage2D(), and others.
    GLEnum[GLEnum["NEAREST"] = 9728] = "NEAREST";
    GLEnum[GLEnum["LINEAR"] = 9729] = "LINEAR";
    GLEnum[GLEnum["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
    GLEnum[GLEnum["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
    GLEnum[GLEnum["NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
    GLEnum[GLEnum["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
    /** The texture magnification function is used when the pixel being textured maps to an area less than or equal to one texture element. It sets the texture magnification function to either GL_NEAREST or GL_LINEAR (see below). GL_NEAREST is generally faster than GL_LINEAR, but it can produce textured images with sharper edges because the transition between texture elements is not as smooth. Default: GL_LINEAR.  */ GLEnum[GLEnum["TEXTURE_MAG_FILTER"] = 10240] = "TEXTURE_MAG_FILTER";
    /** The texture minifying function is used whenever the pixel being textured maps to an area greater than one texture element. There are six defined minifying functions. Two of them use the nearest one or nearest four texture elements to compute the texture value. The other four use mipmaps. Default: GL_NEAREST_MIPMAP_LINEAR */ GLEnum[GLEnum["TEXTURE_MIN_FILTER"] = 10241] = "TEXTURE_MIN_FILTER";
    /** Sets the wrap parameter for texture coordinate  to either GL_CLAMP_TO_EDGE, GL_MIRRORED_REPEAT, or GL_REPEAT. G */ GLEnum[GLEnum["TEXTURE_WRAP_S"] = 10242] = "TEXTURE_WRAP_S";
    /** Sets the wrap parameter for texture coordinate  to either GL_CLAMP_TO_EDGE, GL_MIRRORED_REPEAT, or GL_REPEAT. G */ GLEnum[GLEnum["TEXTURE_WRAP_T"] = 10243] = "TEXTURE_WRAP_T";
    GLEnum[GLEnum["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
    GLEnum[GLEnum["TEXTURE"] = 5890] = "TEXTURE";
    GLEnum[GLEnum["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
    GLEnum[GLEnum["TEXTURE_BINDING_CUBE_MAP"] = 34068] = "TEXTURE_BINDING_CUBE_MAP";
    GLEnum[GLEnum["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
    GLEnum[GLEnum["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
    GLEnum[GLEnum["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
    GLEnum[GLEnum["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
    GLEnum[GLEnum["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
    GLEnum[GLEnum["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
    GLEnum[GLEnum["MAX_CUBE_MAP_TEXTURE_SIZE"] = 34076] = "MAX_CUBE_MAP_TEXTURE_SIZE";
    // TEXTURE0 - 31 0x84C0 - 0x84DF A texture unit.
    GLEnum[GLEnum["TEXTURE0"] = 33984] = "TEXTURE0";
    GLEnum[GLEnum["ACTIVE_TEXTURE"] = 34016] = "ACTIVE_TEXTURE";
    GLEnum[GLEnum["REPEAT"] = 10497] = "REPEAT";
    GLEnum[GLEnum["CLAMP_TO_EDGE"] = 33071] = "CLAMP_TO_EDGE";
    GLEnum[GLEnum["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
    // Emulation
    GLEnum[GLEnum["TEXTURE_WIDTH"] = 4096] = "TEXTURE_WIDTH";
    GLEnum[GLEnum["TEXTURE_HEIGHT"] = 4097] = "TEXTURE_HEIGHT";
    // Uniform types
    GLEnum[GLEnum["FLOAT_VEC2"] = 35664] = "FLOAT_VEC2";
    GLEnum[GLEnum["FLOAT_VEC3"] = 35665] = "FLOAT_VEC3";
    GLEnum[GLEnum["FLOAT_VEC4"] = 35666] = "FLOAT_VEC4";
    GLEnum[GLEnum["INT_VEC2"] = 35667] = "INT_VEC2";
    GLEnum[GLEnum["INT_VEC3"] = 35668] = "INT_VEC3";
    GLEnum[GLEnum["INT_VEC4"] = 35669] = "INT_VEC4";
    GLEnum[GLEnum["BOOL"] = 35670] = "BOOL";
    GLEnum[GLEnum["BOOL_VEC2"] = 35671] = "BOOL_VEC2";
    GLEnum[GLEnum["BOOL_VEC3"] = 35672] = "BOOL_VEC3";
    GLEnum[GLEnum["BOOL_VEC4"] = 35673] = "BOOL_VEC4";
    GLEnum[GLEnum["FLOAT_MAT2"] = 35674] = "FLOAT_MAT2";
    GLEnum[GLEnum["FLOAT_MAT3"] = 35675] = "FLOAT_MAT3";
    GLEnum[GLEnum["FLOAT_MAT4"] = 35676] = "FLOAT_MAT4";
    GLEnum[GLEnum["SAMPLER_2D"] = 35678] = "SAMPLER_2D";
    GLEnum[GLEnum["SAMPLER_CUBE"] = 35680] = "SAMPLER_CUBE";
    // Shader precision-specified types
    GLEnum[GLEnum["LOW_FLOAT"] = 36336] = "LOW_FLOAT";
    GLEnum[GLEnum["MEDIUM_FLOAT"] = 36337] = "MEDIUM_FLOAT";
    GLEnum[GLEnum["HIGH_FLOAT"] = 36338] = "HIGH_FLOAT";
    GLEnum[GLEnum["LOW_INT"] = 36339] = "LOW_INT";
    GLEnum[GLEnum["MEDIUM_INT"] = 36340] = "MEDIUM_INT";
    GLEnum[GLEnum["HIGH_INT"] = 36341] = "HIGH_INT";
    // Framebuffers and renderbuffers
    GLEnum[GLEnum["FRAMEBUFFER"] = 36160] = "FRAMEBUFFER";
    GLEnum[GLEnum["RENDERBUFFER"] = 36161] = "RENDERBUFFER";
    GLEnum[GLEnum["RGBA4"] = 32854] = "RGBA4";
    GLEnum[GLEnum["RGB5_A1"] = 32855] = "RGB5_A1";
    GLEnum[GLEnum["RGB565"] = 36194] = "RGB565";
    GLEnum[GLEnum["DEPTH_COMPONENT16"] = 33189] = "DEPTH_COMPONENT16";
    GLEnum[GLEnum["STENCIL_INDEX"] = 6401] = "STENCIL_INDEX";
    GLEnum[GLEnum["STENCIL_INDEX8"] = 36168] = "STENCIL_INDEX8";
    GLEnum[GLEnum["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
    GLEnum[GLEnum["RENDERBUFFER_WIDTH"] = 36162] = "RENDERBUFFER_WIDTH";
    GLEnum[GLEnum["RENDERBUFFER_HEIGHT"] = 36163] = "RENDERBUFFER_HEIGHT";
    GLEnum[GLEnum["RENDERBUFFER_INTERNAL_FORMAT"] = 36164] = "RENDERBUFFER_INTERNAL_FORMAT";
    GLEnum[GLEnum["RENDERBUFFER_RED_SIZE"] = 36176] = "RENDERBUFFER_RED_SIZE";
    GLEnum[GLEnum["RENDERBUFFER_GREEN_SIZE"] = 36177] = "RENDERBUFFER_GREEN_SIZE";
    GLEnum[GLEnum["RENDERBUFFER_BLUE_SIZE"] = 36178] = "RENDERBUFFER_BLUE_SIZE";
    GLEnum[GLEnum["RENDERBUFFER_ALPHA_SIZE"] = 36179] = "RENDERBUFFER_ALPHA_SIZE";
    GLEnum[GLEnum["RENDERBUFFER_DEPTH_SIZE"] = 36180] = "RENDERBUFFER_DEPTH_SIZE";
    GLEnum[GLEnum["RENDERBUFFER_STENCIL_SIZE"] = 36181] = "RENDERBUFFER_STENCIL_SIZE";
    GLEnum[GLEnum["FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE"] = 36048] = "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE";
    GLEnum[GLEnum["FRAMEBUFFER_ATTACHMENT_OBJECT_NAME"] = 36049] = "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME";
    GLEnum[GLEnum["FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL"] = 36050] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL";
    GLEnum[GLEnum["FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE"] = 36051] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE";
    GLEnum[GLEnum["COLOR_ATTACHMENT0"] = 36064] = "COLOR_ATTACHMENT0";
    GLEnum[GLEnum["DEPTH_ATTACHMENT"] = 36096] = "DEPTH_ATTACHMENT";
    GLEnum[GLEnum["STENCIL_ATTACHMENT"] = 36128] = "STENCIL_ATTACHMENT";
    GLEnum[GLEnum["DEPTH_STENCIL_ATTACHMENT"] = 33306] = "DEPTH_STENCIL_ATTACHMENT";
    GLEnum[GLEnum["NONE"] = 0] = "NONE";
    GLEnum[GLEnum["FRAMEBUFFER_COMPLETE"] = 36053] = "FRAMEBUFFER_COMPLETE";
    GLEnum[GLEnum["FRAMEBUFFER_INCOMPLETE_ATTACHMENT"] = 36054] = "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
    GLEnum[GLEnum["FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"] = 36055] = "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
    GLEnum[GLEnum["FRAMEBUFFER_INCOMPLETE_DIMENSIONS"] = 36057] = "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
    GLEnum[GLEnum["FRAMEBUFFER_UNSUPPORTED"] = 36061] = "FRAMEBUFFER_UNSUPPORTED";
    GLEnum[GLEnum["FRAMEBUFFER_BINDING"] = 36006] = "FRAMEBUFFER_BINDING";
    GLEnum[GLEnum["RENDERBUFFER_BINDING"] = 36007] = "RENDERBUFFER_BINDING";
    GLEnum[GLEnum["READ_FRAMEBUFFER"] = 36008] = "READ_FRAMEBUFFER";
    GLEnum[GLEnum["DRAW_FRAMEBUFFER"] = 36009] = "DRAW_FRAMEBUFFER";
    GLEnum[GLEnum["MAX_RENDERBUFFER_SIZE"] = 34024] = "MAX_RENDERBUFFER_SIZE";
    GLEnum[GLEnum["INVALID_FRAMEBUFFER_OPERATION"] = 1286] = "INVALID_FRAMEBUFFER_OPERATION";
    // Pixel storage modes
    // Constants passed to pixelStorei().
    GLEnum[GLEnum["UNPACK_FLIP_Y_WEBGL"] = 37440] = "UNPACK_FLIP_Y_WEBGL";
    GLEnum[GLEnum["UNPACK_PREMULTIPLY_ALPHA_WEBGL"] = 37441] = "UNPACK_PREMULTIPLY_ALPHA_WEBGL";
    GLEnum[GLEnum["UNPACK_COLORSPACE_CONVERSION_WEBGL"] = 37443] = "UNPACK_COLORSPACE_CONVERSION_WEBGL";
    // Additional constants defined WebGL 2
    // These constants are defined on the WebGL2RenderingContext interface.
    // All WebGL 1 constants are also available in a WebGL 2 context.
    // Getting GL parameter information
    // Constants passed to getParameter()
    // to specify what information to return.
    GLEnum[GLEnum["READ_BUFFER"] = 3074] = "READ_BUFFER";
    GLEnum[GLEnum["UNPACK_ROW_LENGTH"] = 3314] = "UNPACK_ROW_LENGTH";
    GLEnum[GLEnum["UNPACK_SKIP_ROWS"] = 3315] = "UNPACK_SKIP_ROWS";
    GLEnum[GLEnum["UNPACK_SKIP_PIXELS"] = 3316] = "UNPACK_SKIP_PIXELS";
    GLEnum[GLEnum["PACK_ROW_LENGTH"] = 3330] = "PACK_ROW_LENGTH";
    GLEnum[GLEnum["PACK_SKIP_ROWS"] = 3331] = "PACK_SKIP_ROWS";
    GLEnum[GLEnum["PACK_SKIP_PIXELS"] = 3332] = "PACK_SKIP_PIXELS";
    GLEnum[GLEnum["TEXTURE_BINDING_3D"] = 32874] = "TEXTURE_BINDING_3D";
    GLEnum[GLEnum["UNPACK_SKIP_IMAGES"] = 32877] = "UNPACK_SKIP_IMAGES";
    GLEnum[GLEnum["UNPACK_IMAGE_HEIGHT"] = 32878] = "UNPACK_IMAGE_HEIGHT";
    GLEnum[GLEnum["MAX_3D_TEXTURE_SIZE"] = 32883] = "MAX_3D_TEXTURE_SIZE";
    GLEnum[GLEnum["MAX_ELEMENTS_VERTICES"] = 33000] = "MAX_ELEMENTS_VERTICES";
    GLEnum[GLEnum["MAX_ELEMENTS_INDICES"] = 33001] = "MAX_ELEMENTS_INDICES";
    GLEnum[GLEnum["MAX_TEXTURE_LOD_BIAS"] = 34045] = "MAX_TEXTURE_LOD_BIAS";
    GLEnum[GLEnum["MAX_FRAGMENT_UNIFORM_COMPONENTS"] = 35657] = "MAX_FRAGMENT_UNIFORM_COMPONENTS";
    GLEnum[GLEnum["MAX_VERTEX_UNIFORM_COMPONENTS"] = 35658] = "MAX_VERTEX_UNIFORM_COMPONENTS";
    GLEnum[GLEnum["MAX_ARRAY_TEXTURE_LAYERS"] = 35071] = "MAX_ARRAY_TEXTURE_LAYERS";
    GLEnum[GLEnum["MIN_PROGRAM_TEXEL_OFFSET"] = 35076] = "MIN_PROGRAM_TEXEL_OFFSET";
    GLEnum[GLEnum["MAX_PROGRAM_TEXEL_OFFSET"] = 35077] = "MAX_PROGRAM_TEXEL_OFFSET";
    GLEnum[GLEnum["MAX_VARYING_COMPONENTS"] = 35659] = "MAX_VARYING_COMPONENTS";
    GLEnum[GLEnum["FRAGMENT_SHADER_DERIVATIVE_HINT"] = 35723] = "FRAGMENT_SHADER_DERIVATIVE_HINT";
    GLEnum[GLEnum["RASTERIZER_DISCARD"] = 35977] = "RASTERIZER_DISCARD";
    GLEnum[GLEnum["VERTEX_ARRAY_BINDING"] = 34229] = "VERTEX_ARRAY_BINDING";
    GLEnum[GLEnum["MAX_VERTEX_OUTPUT_COMPONENTS"] = 37154] = "MAX_VERTEX_OUTPUT_COMPONENTS";
    GLEnum[GLEnum["MAX_FRAGMENT_INPUT_COMPONENTS"] = 37157] = "MAX_FRAGMENT_INPUT_COMPONENTS";
    GLEnum[GLEnum["MAX_SERVER_WAIT_TIMEOUT"] = 37137] = "MAX_SERVER_WAIT_TIMEOUT";
    GLEnum[GLEnum["MAX_ELEMENT_INDEX"] = 36203] = "MAX_ELEMENT_INDEX";
    // Textures
    // Constants passed to texParameteri(),
    // texParameterf(), bindTexture(), texImage2D(), and others.
    GLEnum[GLEnum["RED"] = 6403] = "RED";
    GLEnum[GLEnum["RGB8"] = 32849] = "RGB8";
    GLEnum[GLEnum["RGBA8"] = 32856] = "RGBA8";
    GLEnum[GLEnum["RGB10_A2"] = 32857] = "RGB10_A2";
    GLEnum[GLEnum["TEXTURE_3D"] = 32879] = "TEXTURE_3D";
    /** Sets the wrap parameter for texture coordinate  to either GL_CLAMP_TO_EDGE, GL_MIRRORED_REPEAT, or GL_REPEAT. G */ GLEnum[GLEnum["TEXTURE_WRAP_R"] = 32882] = "TEXTURE_WRAP_R";
    GLEnum[GLEnum["TEXTURE_MIN_LOD"] = 33082] = "TEXTURE_MIN_LOD";
    GLEnum[GLEnum["TEXTURE_MAX_LOD"] = 33083] = "TEXTURE_MAX_LOD";
    GLEnum[GLEnum["TEXTURE_BASE_LEVEL"] = 33084] = "TEXTURE_BASE_LEVEL";
    GLEnum[GLEnum["TEXTURE_MAX_LEVEL"] = 33085] = "TEXTURE_MAX_LEVEL";
    GLEnum[GLEnum["TEXTURE_COMPARE_MODE"] = 34892] = "TEXTURE_COMPARE_MODE";
    GLEnum[GLEnum["TEXTURE_COMPARE_FUNC"] = 34893] = "TEXTURE_COMPARE_FUNC";
    GLEnum[GLEnum["SRGB"] = 35904] = "SRGB";
    GLEnum[GLEnum["SRGB8"] = 35905] = "SRGB8";
    GLEnum[GLEnum["SRGB8_ALPHA8"] = 35907] = "SRGB8_ALPHA8";
    GLEnum[GLEnum["COMPARE_REF_TO_TEXTURE"] = 34894] = "COMPARE_REF_TO_TEXTURE";
    GLEnum[GLEnum["RGBA32F"] = 34836] = "RGBA32F";
    GLEnum[GLEnum["RGB32F"] = 34837] = "RGB32F";
    GLEnum[GLEnum["RGBA16F"] = 34842] = "RGBA16F";
    GLEnum[GLEnum["RGB16F"] = 34843] = "RGB16F";
    GLEnum[GLEnum["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
    GLEnum[GLEnum["TEXTURE_BINDING_2D_ARRAY"] = 35869] = "TEXTURE_BINDING_2D_ARRAY";
    GLEnum[GLEnum["R11F_G11F_B10F"] = 35898] = "R11F_G11F_B10F";
    GLEnum[GLEnum["RGB9_E5"] = 35901] = "RGB9_E5";
    GLEnum[GLEnum["RGBA32UI"] = 36208] = "RGBA32UI";
    GLEnum[GLEnum["RGB32UI"] = 36209] = "RGB32UI";
    GLEnum[GLEnum["RGBA16UI"] = 36214] = "RGBA16UI";
    GLEnum[GLEnum["RGB16UI"] = 36215] = "RGB16UI";
    GLEnum[GLEnum["RGBA8UI"] = 36220] = "RGBA8UI";
    GLEnum[GLEnum["RGB8UI"] = 36221] = "RGB8UI";
    GLEnum[GLEnum["RGBA32I"] = 36226] = "RGBA32I";
    GLEnum[GLEnum["RGB32I"] = 36227] = "RGB32I";
    GLEnum[GLEnum["RGBA16I"] = 36232] = "RGBA16I";
    GLEnum[GLEnum["RGB16I"] = 36233] = "RGB16I";
    GLEnum[GLEnum["RGBA8I"] = 36238] = "RGBA8I";
    GLEnum[GLEnum["RGB8I"] = 36239] = "RGB8I";
    GLEnum[GLEnum["RED_INTEGER"] = 36244] = "RED_INTEGER";
    GLEnum[GLEnum["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
    GLEnum[GLEnum["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
    GLEnum[GLEnum["R8"] = 33321] = "R8";
    GLEnum[GLEnum["RG8"] = 33323] = "RG8";
    GLEnum[GLEnum["R16F"] = 33325] = "R16F";
    GLEnum[GLEnum["R32F"] = 33326] = "R32F";
    GLEnum[GLEnum["RG16F"] = 33327] = "RG16F";
    GLEnum[GLEnum["RG32F"] = 33328] = "RG32F";
    GLEnum[GLEnum["R8I"] = 33329] = "R8I";
    GLEnum[GLEnum["R8UI"] = 33330] = "R8UI";
    GLEnum[GLEnum["R16I"] = 33331] = "R16I";
    GLEnum[GLEnum["R16UI"] = 33332] = "R16UI";
    GLEnum[GLEnum["R32I"] = 33333] = "R32I";
    GLEnum[GLEnum["R32UI"] = 33334] = "R32UI";
    GLEnum[GLEnum["RG8I"] = 33335] = "RG8I";
    GLEnum[GLEnum["RG8UI"] = 33336] = "RG8UI";
    GLEnum[GLEnum["RG16I"] = 33337] = "RG16I";
    GLEnum[GLEnum["RG16UI"] = 33338] = "RG16UI";
    GLEnum[GLEnum["RG32I"] = 33339] = "RG32I";
    GLEnum[GLEnum["RG32UI"] = 33340] = "RG32UI";
    GLEnum[GLEnum["R8_SNORM"] = 36756] = "R8_SNORM";
    GLEnum[GLEnum["RG8_SNORM"] = 36757] = "RG8_SNORM";
    GLEnum[GLEnum["RGB8_SNORM"] = 36758] = "RGB8_SNORM";
    GLEnum[GLEnum["RGBA8_SNORM"] = 36759] = "RGBA8_SNORM";
    GLEnum[GLEnum["RGB10_A2UI"] = 36975] = "RGB10_A2UI";
    /* covered by extension
    COMPRESSED_R11_EAC  = 0x9270,
    COMPRESSED_SIGNED_R11_EAC = 0x9271,
    COMPRESSED_RG11_EAC = 0x9272,
    COMPRESSED_SIGNED_RG11_EAC  = 0x9273,
    COMPRESSED_RGB8_ETC2  = 0x9274,
    COMPRESSED_SRGB8_ETC2 = 0x9275,
    COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2  = 0x9276,
    COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC  = 0x9277,
    COMPRESSED_RGBA8_ETC2_EAC = 0x9278,
    COMPRESSED_SRGB8_ALPHA8_ETC2_EAC  = 0x9279,
    */ GLEnum[GLEnum["TEXTURE_IMMUTABLE_FORMAT"] = 37167] = "TEXTURE_IMMUTABLE_FORMAT";
    GLEnum[GLEnum["TEXTURE_IMMUTABLE_LEVELS"] = 33503] = "TEXTURE_IMMUTABLE_LEVELS";
    // Pixel types
    GLEnum[GLEnum["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
    GLEnum[GLEnum["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
    GLEnum[GLEnum["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
    GLEnum[GLEnum["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
    GLEnum[GLEnum["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
    GLEnum[GLEnum["HALF_FLOAT"] = 5131] = "HALF_FLOAT";
    GLEnum[GLEnum["RG"] = 33319] = "RG";
    GLEnum[GLEnum["RG_INTEGER"] = 33320] = "RG_INTEGER";
    GLEnum[GLEnum["INT_2_10_10_10_REV"] = 36255] = "INT_2_10_10_10_REV";
    // Queries
    GLEnum[GLEnum["CURRENT_QUERY"] = 34917] = "CURRENT_QUERY";
    /** Returns a GLuint containing the query result. */ GLEnum[GLEnum["QUERY_RESULT"] = 34918] = "QUERY_RESULT";
    /** Whether query result is available. */ GLEnum[GLEnum["QUERY_RESULT_AVAILABLE"] = 34919] = "QUERY_RESULT_AVAILABLE";
    /** Occlusion query (if drawing passed depth test)  */ GLEnum[GLEnum["ANY_SAMPLES_PASSED"] = 35887] = "ANY_SAMPLES_PASSED";
    /** Occlusion query less accurate/faster version */ GLEnum[GLEnum["ANY_SAMPLES_PASSED_CONSERVATIVE"] = 36202] = "ANY_SAMPLES_PASSED_CONSERVATIVE";
    // Draw buffers
    GLEnum[GLEnum["MAX_DRAW_BUFFERS"] = 34852] = "MAX_DRAW_BUFFERS";
    GLEnum[GLEnum["DRAW_BUFFER0"] = 34853] = "DRAW_BUFFER0";
    GLEnum[GLEnum["DRAW_BUFFER1"] = 34854] = "DRAW_BUFFER1";
    GLEnum[GLEnum["DRAW_BUFFER2"] = 34855] = "DRAW_BUFFER2";
    GLEnum[GLEnum["DRAW_BUFFER3"] = 34856] = "DRAW_BUFFER3";
    GLEnum[GLEnum["DRAW_BUFFER4"] = 34857] = "DRAW_BUFFER4";
    GLEnum[GLEnum["DRAW_BUFFER5"] = 34858] = "DRAW_BUFFER5";
    GLEnum[GLEnum["DRAW_BUFFER6"] = 34859] = "DRAW_BUFFER6";
    GLEnum[GLEnum["DRAW_BUFFER7"] = 34860] = "DRAW_BUFFER7";
    GLEnum[GLEnum["DRAW_BUFFER8"] = 34861] = "DRAW_BUFFER8";
    GLEnum[GLEnum["DRAW_BUFFER9"] = 34862] = "DRAW_BUFFER9";
    GLEnum[GLEnum["DRAW_BUFFER10"] = 34863] = "DRAW_BUFFER10";
    GLEnum[GLEnum["DRAW_BUFFER11"] = 34864] = "DRAW_BUFFER11";
    GLEnum[GLEnum["DRAW_BUFFER12"] = 34865] = "DRAW_BUFFER12";
    GLEnum[GLEnum["DRAW_BUFFER13"] = 34866] = "DRAW_BUFFER13";
    GLEnum[GLEnum["DRAW_BUFFER14"] = 34867] = "DRAW_BUFFER14";
    GLEnum[GLEnum["DRAW_BUFFER15"] = 34868] = "DRAW_BUFFER15";
    GLEnum[GLEnum["MAX_COLOR_ATTACHMENTS"] = 36063] = "MAX_COLOR_ATTACHMENTS";
    GLEnum[GLEnum["COLOR_ATTACHMENT1"] = 36065] = "COLOR_ATTACHMENT1";
    GLEnum[GLEnum["COLOR_ATTACHMENT2"] = 36066] = "COLOR_ATTACHMENT2";
    GLEnum[GLEnum["COLOR_ATTACHMENT3"] = 36067] = "COLOR_ATTACHMENT3";
    GLEnum[GLEnum["COLOR_ATTACHMENT4"] = 36068] = "COLOR_ATTACHMENT4";
    GLEnum[GLEnum["COLOR_ATTACHMENT5"] = 36069] = "COLOR_ATTACHMENT5";
    GLEnum[GLEnum["COLOR_ATTACHMENT6"] = 36070] = "COLOR_ATTACHMENT6";
    GLEnum[GLEnum["COLOR_ATTACHMENT7"] = 36071] = "COLOR_ATTACHMENT7";
    GLEnum[GLEnum["COLOR_ATTACHMENT8"] = 36072] = "COLOR_ATTACHMENT8";
    GLEnum[GLEnum["COLOR_ATTACHMENT9"] = 36073] = "COLOR_ATTACHMENT9";
    GLEnum[GLEnum["COLOR_ATTACHMENT10"] = 36074] = "COLOR_ATTACHMENT10";
    GLEnum[GLEnum["COLOR_ATTACHMENT11"] = 36075] = "COLOR_ATTACHMENT11";
    GLEnum[GLEnum["COLOR_ATTACHMENT12"] = 36076] = "COLOR_ATTACHMENT12";
    GLEnum[GLEnum["COLOR_ATTACHMENT13"] = 36077] = "COLOR_ATTACHMENT13";
    GLEnum[GLEnum["COLOR_ATTACHMENT14"] = 36078] = "COLOR_ATTACHMENT14";
    GLEnum[GLEnum["COLOR_ATTACHMENT15"] = 36079] = "COLOR_ATTACHMENT15";
    // Samplers
    GLEnum[GLEnum["SAMPLER_3D"] = 35679] = "SAMPLER_3D";
    GLEnum[GLEnum["SAMPLER_2D_SHADOW"] = 35682] = "SAMPLER_2D_SHADOW";
    GLEnum[GLEnum["SAMPLER_2D_ARRAY"] = 36289] = "SAMPLER_2D_ARRAY";
    GLEnum[GLEnum["SAMPLER_2D_ARRAY_SHADOW"] = 36292] = "SAMPLER_2D_ARRAY_SHADOW";
    GLEnum[GLEnum["SAMPLER_CUBE_SHADOW"] = 36293] = "SAMPLER_CUBE_SHADOW";
    GLEnum[GLEnum["INT_SAMPLER_2D"] = 36298] = "INT_SAMPLER_2D";
    GLEnum[GLEnum["INT_SAMPLER_3D"] = 36299] = "INT_SAMPLER_3D";
    GLEnum[GLEnum["INT_SAMPLER_CUBE"] = 36300] = "INT_SAMPLER_CUBE";
    GLEnum[GLEnum["INT_SAMPLER_2D_ARRAY"] = 36303] = "INT_SAMPLER_2D_ARRAY";
    GLEnum[GLEnum["UNSIGNED_INT_SAMPLER_2D"] = 36306] = "UNSIGNED_INT_SAMPLER_2D";
    GLEnum[GLEnum["UNSIGNED_INT_SAMPLER_3D"] = 36307] = "UNSIGNED_INT_SAMPLER_3D";
    GLEnum[GLEnum["UNSIGNED_INT_SAMPLER_CUBE"] = 36308] = "UNSIGNED_INT_SAMPLER_CUBE";
    GLEnum[GLEnum["UNSIGNED_INT_SAMPLER_2D_ARRAY"] = 36311] = "UNSIGNED_INT_SAMPLER_2D_ARRAY";
    GLEnum[GLEnum["MAX_SAMPLES"] = 36183] = "MAX_SAMPLES";
    GLEnum[GLEnum["SAMPLER_BINDING"] = 35097] = "SAMPLER_BINDING";
    // Buffers
    GLEnum[GLEnum["PIXEL_PACK_BUFFER"] = 35051] = "PIXEL_PACK_BUFFER";
    GLEnum[GLEnum["PIXEL_UNPACK_BUFFER"] = 35052] = "PIXEL_UNPACK_BUFFER";
    GLEnum[GLEnum["PIXEL_PACK_BUFFER_BINDING"] = 35053] = "PIXEL_PACK_BUFFER_BINDING";
    GLEnum[GLEnum["PIXEL_UNPACK_BUFFER_BINDING"] = 35055] = "PIXEL_UNPACK_BUFFER_BINDING";
    GLEnum[GLEnum["COPY_READ_BUFFER"] = 36662] = "COPY_READ_BUFFER";
    GLEnum[GLEnum["COPY_WRITE_BUFFER"] = 36663] = "COPY_WRITE_BUFFER";
    GLEnum[GLEnum["COPY_READ_BUFFER_BINDING"] = 36662] = "COPY_READ_BUFFER_BINDING";
    GLEnum[GLEnum["COPY_WRITE_BUFFER_BINDING"] = 36663] = "COPY_WRITE_BUFFER_BINDING";
    // Data types
    GLEnum[GLEnum["FLOAT_MAT2x3"] = 35685] = "FLOAT_MAT2x3";
    GLEnum[GLEnum["FLOAT_MAT2x4"] = 35686] = "FLOAT_MAT2x4";
    GLEnum[GLEnum["FLOAT_MAT3x2"] = 35687] = "FLOAT_MAT3x2";
    GLEnum[GLEnum["FLOAT_MAT3x4"] = 35688] = "FLOAT_MAT3x4";
    GLEnum[GLEnum["FLOAT_MAT4x2"] = 35689] = "FLOAT_MAT4x2";
    GLEnum[GLEnum["FLOAT_MAT4x3"] = 35690] = "FLOAT_MAT4x3";
    GLEnum[GLEnum["UNSIGNED_INT_VEC2"] = 36294] = "UNSIGNED_INT_VEC2";
    GLEnum[GLEnum["UNSIGNED_INT_VEC3"] = 36295] = "UNSIGNED_INT_VEC3";
    GLEnum[GLEnum["UNSIGNED_INT_VEC4"] = 36296] = "UNSIGNED_INT_VEC4";
    GLEnum[GLEnum["UNSIGNED_NORMALIZED"] = 35863] = "UNSIGNED_NORMALIZED";
    GLEnum[GLEnum["SIGNED_NORMALIZED"] = 36764] = "SIGNED_NORMALIZED";
    // Vertex attributes
    GLEnum[GLEnum["VERTEX_ATTRIB_ARRAY_INTEGER"] = 35069] = "VERTEX_ATTRIB_ARRAY_INTEGER";
    GLEnum[GLEnum["VERTEX_ATTRIB_ARRAY_DIVISOR"] = 35070] = "VERTEX_ATTRIB_ARRAY_DIVISOR";
    // Transform feedback
    GLEnum[GLEnum["TRANSFORM_FEEDBACK_BUFFER_MODE"] = 35967] = "TRANSFORM_FEEDBACK_BUFFER_MODE";
    GLEnum[GLEnum["MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS"] = 35968] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS";
    GLEnum[GLEnum["TRANSFORM_FEEDBACK_VARYINGS"] = 35971] = "TRANSFORM_FEEDBACK_VARYINGS";
    GLEnum[GLEnum["TRANSFORM_FEEDBACK_BUFFER_START"] = 35972] = "TRANSFORM_FEEDBACK_BUFFER_START";
    GLEnum[GLEnum["TRANSFORM_FEEDBACK_BUFFER_SIZE"] = 35973] = "TRANSFORM_FEEDBACK_BUFFER_SIZE";
    GLEnum[GLEnum["TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN"] = 35976] = "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN";
    GLEnum[GLEnum["MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS"] = 35978] = "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS";
    GLEnum[GLEnum["MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS"] = 35979] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS";
    GLEnum[GLEnum["INTERLEAVED_ATTRIBS"] = 35980] = "INTERLEAVED_ATTRIBS";
    GLEnum[GLEnum["SEPARATE_ATTRIBS"] = 35981] = "SEPARATE_ATTRIBS";
    GLEnum[GLEnum["TRANSFORM_FEEDBACK_BUFFER"] = 35982] = "TRANSFORM_FEEDBACK_BUFFER";
    GLEnum[GLEnum["TRANSFORM_FEEDBACK_BUFFER_BINDING"] = 35983] = "TRANSFORM_FEEDBACK_BUFFER_BINDING";
    GLEnum[GLEnum["TRANSFORM_FEEDBACK"] = 36386] = "TRANSFORM_FEEDBACK";
    GLEnum[GLEnum["TRANSFORM_FEEDBACK_PAUSED"] = 36387] = "TRANSFORM_FEEDBACK_PAUSED";
    GLEnum[GLEnum["TRANSFORM_FEEDBACK_ACTIVE"] = 36388] = "TRANSFORM_FEEDBACK_ACTIVE";
    GLEnum[GLEnum["TRANSFORM_FEEDBACK_BINDING"] = 36389] = "TRANSFORM_FEEDBACK_BINDING";
    // Framebuffers and renderbuffers
    GLEnum[GLEnum["FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING"] = 33296] = "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING";
    GLEnum[GLEnum["FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE"] = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE";
    GLEnum[GLEnum["FRAMEBUFFER_ATTACHMENT_RED_SIZE"] = 33298] = "FRAMEBUFFER_ATTACHMENT_RED_SIZE";
    GLEnum[GLEnum["FRAMEBUFFER_ATTACHMENT_GREEN_SIZE"] = 33299] = "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE";
    GLEnum[GLEnum["FRAMEBUFFER_ATTACHMENT_BLUE_SIZE"] = 33300] = "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE";
    GLEnum[GLEnum["FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE"] = 33301] = "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE";
    GLEnum[GLEnum["FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE"] = 33302] = "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE";
    GLEnum[GLEnum["FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE"] = 33303] = "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE";
    GLEnum[GLEnum["FRAMEBUFFER_DEFAULT"] = 33304] = "FRAMEBUFFER_DEFAULT";
    // DEPTH_STENCIL_ATTACHMENT  = 0x821A,
    // DEPTH_STENCIL = 0x84F9,
    GLEnum[GLEnum["DEPTH24_STENCIL8"] = 35056] = "DEPTH24_STENCIL8";
    GLEnum[GLEnum["DRAW_FRAMEBUFFER_BINDING"] = 36006] = "DRAW_FRAMEBUFFER_BINDING";
    GLEnum[GLEnum["READ_FRAMEBUFFER_BINDING"] = 36010] = "READ_FRAMEBUFFER_BINDING";
    GLEnum[GLEnum["RENDERBUFFER_SAMPLES"] = 36011] = "RENDERBUFFER_SAMPLES";
    GLEnum[GLEnum["FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER"] = 36052] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER";
    GLEnum[GLEnum["FRAMEBUFFER_INCOMPLETE_MULTISAMPLE"] = 36182] = "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE";
    // Uniforms
    GLEnum[GLEnum["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
    GLEnum[GLEnum["UNIFORM_BUFFER_BINDING"] = 35368] = "UNIFORM_BUFFER_BINDING";
    GLEnum[GLEnum["UNIFORM_BUFFER_START"] = 35369] = "UNIFORM_BUFFER_START";
    GLEnum[GLEnum["UNIFORM_BUFFER_SIZE"] = 35370] = "UNIFORM_BUFFER_SIZE";
    GLEnum[GLEnum["MAX_VERTEX_UNIFORM_BLOCKS"] = 35371] = "MAX_VERTEX_UNIFORM_BLOCKS";
    GLEnum[GLEnum["MAX_FRAGMENT_UNIFORM_BLOCKS"] = 35373] = "MAX_FRAGMENT_UNIFORM_BLOCKS";
    GLEnum[GLEnum["MAX_COMBINED_UNIFORM_BLOCKS"] = 35374] = "MAX_COMBINED_UNIFORM_BLOCKS";
    GLEnum[GLEnum["MAX_UNIFORM_BUFFER_BINDINGS"] = 35375] = "MAX_UNIFORM_BUFFER_BINDINGS";
    GLEnum[GLEnum["MAX_UNIFORM_BLOCK_SIZE"] = 35376] = "MAX_UNIFORM_BLOCK_SIZE";
    GLEnum[GLEnum["MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS"] = 35377] = "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS";
    GLEnum[GLEnum["MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS"] = 35379] = "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS";
    GLEnum[GLEnum["UNIFORM_BUFFER_OFFSET_ALIGNMENT"] = 35380] = "UNIFORM_BUFFER_OFFSET_ALIGNMENT";
    GLEnum[GLEnum["ACTIVE_UNIFORM_BLOCKS"] = 35382] = "ACTIVE_UNIFORM_BLOCKS";
    GLEnum[GLEnum["UNIFORM_TYPE"] = 35383] = "UNIFORM_TYPE";
    GLEnum[GLEnum["UNIFORM_SIZE"] = 35384] = "UNIFORM_SIZE";
    GLEnum[GLEnum["UNIFORM_BLOCK_INDEX"] = 35386] = "UNIFORM_BLOCK_INDEX";
    GLEnum[GLEnum["UNIFORM_OFFSET"] = 35387] = "UNIFORM_OFFSET";
    GLEnum[GLEnum["UNIFORM_ARRAY_STRIDE"] = 35388] = "UNIFORM_ARRAY_STRIDE";
    GLEnum[GLEnum["UNIFORM_MATRIX_STRIDE"] = 35389] = "UNIFORM_MATRIX_STRIDE";
    GLEnum[GLEnum["UNIFORM_IS_ROW_MAJOR"] = 35390] = "UNIFORM_IS_ROW_MAJOR";
    GLEnum[GLEnum["UNIFORM_BLOCK_BINDING"] = 35391] = "UNIFORM_BLOCK_BINDING";
    GLEnum[GLEnum["UNIFORM_BLOCK_DATA_SIZE"] = 35392] = "UNIFORM_BLOCK_DATA_SIZE";
    GLEnum[GLEnum["UNIFORM_BLOCK_ACTIVE_UNIFORMS"] = 35394] = "UNIFORM_BLOCK_ACTIVE_UNIFORMS";
    GLEnum[GLEnum["UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES"] = 35395] = "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES";
    GLEnum[GLEnum["UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER"] = 35396] = "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER";
    GLEnum[GLEnum["UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER"] = 35398] = "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER";
    // Sync objects
    GLEnum[GLEnum["OBJECT_TYPE"] = 37138] = "OBJECT_TYPE";
    GLEnum[GLEnum["SYNC_CONDITION"] = 37139] = "SYNC_CONDITION";
    GLEnum[GLEnum["SYNC_STATUS"] = 37140] = "SYNC_STATUS";
    GLEnum[GLEnum["SYNC_FLAGS"] = 37141] = "SYNC_FLAGS";
    GLEnum[GLEnum["SYNC_FENCE"] = 37142] = "SYNC_FENCE";
    GLEnum[GLEnum["SYNC_GPU_COMMANDS_COMPLETE"] = 37143] = "SYNC_GPU_COMMANDS_COMPLETE";
    GLEnum[GLEnum["UNSIGNALED"] = 37144] = "UNSIGNALED";
    GLEnum[GLEnum["SIGNALED"] = 37145] = "SIGNALED";
    GLEnum[GLEnum["ALREADY_SIGNALED"] = 37146] = "ALREADY_SIGNALED";
    GLEnum[GLEnum["TIMEOUT_EXPIRED"] = 37147] = "TIMEOUT_EXPIRED";
    GLEnum[GLEnum["CONDITION_SATISFIED"] = 37148] = "CONDITION_SATISFIED";
    GLEnum[GLEnum["WAIT_FAILED"] = 37149] = "WAIT_FAILED";
    GLEnum[GLEnum["SYNC_FLUSH_COMMANDS_BIT"] = 1] = "SYNC_FLUSH_COMMANDS_BIT";
    // Miscellaneous constants
    GLEnum[GLEnum["COLOR"] = 6144] = "COLOR";
    GLEnum[GLEnum["DEPTH"] = 6145] = "DEPTH";
    GLEnum[GLEnum["STENCIL"] = 6146] = "STENCIL";
    GLEnum[GLEnum["MIN"] = 32775] = "MIN";
    GLEnum[GLEnum["MAX"] = 32776] = "MAX";
    GLEnum[GLEnum["DEPTH_COMPONENT24"] = 33190] = "DEPTH_COMPONENT24";
    GLEnum[GLEnum["STREAM_READ"] = 35041] = "STREAM_READ";
    GLEnum[GLEnum["STREAM_COPY"] = 35042] = "STREAM_COPY";
    GLEnum[GLEnum["STATIC_READ"] = 35045] = "STATIC_READ";
    GLEnum[GLEnum["STATIC_COPY"] = 35046] = "STATIC_COPY";
    GLEnum[GLEnum["DYNAMIC_READ"] = 35049] = "DYNAMIC_READ";
    GLEnum[GLEnum["DYNAMIC_COPY"] = 35050] = "DYNAMIC_COPY";
    GLEnum[GLEnum["DEPTH_COMPONENT32F"] = 36012] = "DEPTH_COMPONENT32F";
    GLEnum[GLEnum["DEPTH32F_STENCIL8"] = 36013] = "DEPTH32F_STENCIL8";
    GLEnum[GLEnum["INVALID_INDEX"] = 4294967295] = "INVALID_INDEX";
    GLEnum[GLEnum["TIMEOUT_IGNORED"] = -1] = "TIMEOUT_IGNORED";
    GLEnum[GLEnum["MAX_CLIENT_WAIT_TIMEOUT_WEBGL"] = 37447] = "MAX_CLIENT_WAIT_TIMEOUT_WEBGL";
    // Constants defined in WebGL extensions
    // WEBGL_debug_renderer_info
    /** Passed to getParameter to get the vendor string of the graphics driver. */ GLEnum[GLEnum["UNMASKED_VENDOR_WEBGL"] = 37445] = "UNMASKED_VENDOR_WEBGL";
    /** Passed to getParameter to get the renderer string of the graphics driver. */ GLEnum[GLEnum["UNMASKED_RENDERER_WEBGL"] = 37446] = "UNMASKED_RENDERER_WEBGL";
    // EXT_texture_filter_anisotropic
    /** Returns the maximum available anisotropy. */ GLEnum[GLEnum["MAX_TEXTURE_MAX_ANISOTROPY_EXT"] = 34047] = "MAX_TEXTURE_MAX_ANISOTROPY_EXT";
    /** Passed to texParameter to set the desired maximum anisotropy for a texture. */ GLEnum[GLEnum["TEXTURE_MAX_ANISOTROPY_EXT"] = 34046] = "TEXTURE_MAX_ANISOTROPY_EXT";
    // EXT_texture_norm16 - https://khronos.org/registry/webgl/extensions/EXT_texture_norm16/
    GLEnum[GLEnum["R16_EXT"] = 33322] = "R16_EXT";
    GLEnum[GLEnum["RG16_EXT"] = 33324] = "RG16_EXT";
    GLEnum[GLEnum["RGB16_EXT"] = 32852] = "RGB16_EXT";
    GLEnum[GLEnum["RGBA16_EXT"] = 32859] = "RGBA16_EXT";
    GLEnum[GLEnum["R16_SNORM_EXT"] = 36760] = "R16_SNORM_EXT";
    GLEnum[GLEnum["RG16_SNORM_EXT"] = 36761] = "RG16_SNORM_EXT";
    GLEnum[GLEnum["RGB16_SNORM_EXT"] = 36762] = "RGB16_SNORM_EXT";
    GLEnum[GLEnum["RGBA16_SNORM_EXT"] = 36763] = "RGBA16_SNORM_EXT";
    // WEBGL_compressed_texture_s3tc (BC1, BC2, BC3)
    /** A DXT1-compressed image in an RGB image format. */ GLEnum[GLEnum["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
    /** A DXT1-compressed image in an RGB image format with a simple on/off alpha value. */ GLEnum[GLEnum["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
    /** A DXT3-compressed image in an RGBA image format. Compared to a 32-bit RGBA texture, it offers 4:1 compression. */ GLEnum[GLEnum["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
    /** A DXT5-compressed image in an RGBA image format. It also provides a 4:1 compression, but differs to the DXT3 compression in how the alpha compression is done. */ GLEnum[GLEnum["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
    // WEBGL_compressed_texture_s3tc_srgb (BC1, BC2, BC3 -  SRGB)
    GLEnum[GLEnum["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
    GLEnum[GLEnum["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
    GLEnum[GLEnum["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
    GLEnum[GLEnum["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
    // WEBGL_compressed_texture_rgtc (BC4, BC5)
    GLEnum[GLEnum["COMPRESSED_RED_RGTC1_EXT"] = 36283] = "COMPRESSED_RED_RGTC1_EXT";
    GLEnum[GLEnum["COMPRESSED_SIGNED_RED_RGTC1_EXT"] = 36284] = "COMPRESSED_SIGNED_RED_RGTC1_EXT";
    GLEnum[GLEnum["COMPRESSED_RED_GREEN_RGTC2_EXT"] = 36285] = "COMPRESSED_RED_GREEN_RGTC2_EXT";
    GLEnum[GLEnum["COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT"] = 36286] = "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT";
    // WEBGL_compressed_texture_bptc (BC6, BC7)
    GLEnum[GLEnum["COMPRESSED_RGBA_BPTC_UNORM_EXT"] = 36492] = "COMPRESSED_RGBA_BPTC_UNORM_EXT";
    GLEnum[GLEnum["COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT"] = 36493] = "COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT";
    GLEnum[GLEnum["COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT"] = 36494] = "COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT";
    GLEnum[GLEnum["COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT"] = 36495] = "COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT";
    // WEBGL_compressed_texture_es3
    /** One-channel (red) unsigned format compression. */ GLEnum[GLEnum["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
    /** One-channel (red) signed format compression. */ GLEnum[GLEnum["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
    /** Two-channel (red and green) unsigned format compression. */ GLEnum[GLEnum["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
    /** Two-channel (red and green) signed format compression. */ GLEnum[GLEnum["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
    /** Compresses RGB8 data with no alpha channel. */ GLEnum[GLEnum["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
    /** Compresses RGBA8 data. The RGB part is encoded the same as RGB_ETC2, but the alpha part is encoded separately. */ GLEnum[GLEnum["COMPRESSED_RGBA8_ETC2_EAC"] = 37493] = "COMPRESSED_RGBA8_ETC2_EAC";
    /** Compresses sRGB8 data with no alpha channel. */ GLEnum[GLEnum["COMPRESSED_SRGB8_ETC2"] = 37494] = "COMPRESSED_SRGB8_ETC2";
    /** Compresses sRGBA8 data. The sRGB part is encoded the same as SRGB_ETC2, but the alpha part is encoded separately. */ GLEnum[GLEnum["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37495] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
    /** Similar to RGB8_ETC, but with ability to punch through the alpha channel, which means to make it completely opaque or transparent. */ GLEnum[GLEnum["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37496] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
    /** Similar to SRGB8_ETC, but with ability to punch through the alpha channel, which means to make it completely opaque or transparent. */ GLEnum[GLEnum["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37497] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
    // WEBGL_compressed_texture_pvrtc
    /** RGB compression in 4-bit mode. One block for each 4×4 pixels. */ GLEnum[GLEnum["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
    /** RGBA compression in 4-bit mode. One block for each 4×4 pixels. */ GLEnum[GLEnum["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
    /** RGB compression in 2-bit mode. One block for each 8×4 pixels. */ GLEnum[GLEnum["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG";
    /** RGBA compression in 2-bit mode. One block for each 8×4 pixels. */ GLEnum[GLEnum["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";
    // WEBGL_compressed_texture_etc1
    /** Compresses 24-bit RGB data with no alpha channel. */ GLEnum[GLEnum["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";
    // WEBGL_compressed_texture_atc
    GLEnum[GLEnum["COMPRESSED_RGB_ATC_WEBGL"] = 35986] = "COMPRESSED_RGB_ATC_WEBGL";
    GLEnum[GLEnum["COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL"] = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL";
    GLEnum[GLEnum["COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL"] = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL";
    // WEBGL_compressed_texture_astc
    GLEnum[GLEnum["COMPRESSED_RGBA_ASTC_4x4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
    GLEnum[GLEnum["COMPRESSED_RGBA_ASTC_5x4_KHR"] = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR";
    GLEnum[GLEnum["COMPRESSED_RGBA_ASTC_5x5_KHR"] = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR";
    GLEnum[GLEnum["COMPRESSED_RGBA_ASTC_6x5_KHR"] = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR";
    GLEnum[GLEnum["COMPRESSED_RGBA_ASTC_6x6_KHR"] = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR";
    GLEnum[GLEnum["COMPRESSED_RGBA_ASTC_8x5_KHR"] = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR";
    GLEnum[GLEnum["COMPRESSED_RGBA_ASTC_8x6_KHR"] = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR";
    GLEnum[GLEnum["COMPRESSED_RGBA_ASTC_8x8_KHR"] = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR";
    GLEnum[GLEnum["COMPRESSED_RGBA_ASTC_10x5_KHR"] = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR";
    GLEnum[GLEnum["COMPRESSED_RGBA_ASTC_10x6_KHR"] = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR";
    GLEnum[GLEnum["COMPRESSED_RGBA_ASTC_10x8_KHR"] = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR";
    GLEnum[GLEnum["COMPRESSED_RGBA_ASTC_10x10_KHR"] = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR";
    GLEnum[GLEnum["COMPRESSED_RGBA_ASTC_12x10_KHR"] = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR";
    GLEnum[GLEnum["COMPRESSED_RGBA_ASTC_12x12_KHR"] = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR";
    GLEnum[GLEnum["COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR"] = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR";
    GLEnum[GLEnum["COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR"] = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR";
    GLEnum[GLEnum["COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR"] = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR";
    GLEnum[GLEnum["COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR"] = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR";
    GLEnum[GLEnum["COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR"] = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR";
    GLEnum[GLEnum["COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR"] = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR";
    GLEnum[GLEnum["COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR"] = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR";
    GLEnum[GLEnum["COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR"] = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR";
    GLEnum[GLEnum["COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR"] = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR";
    GLEnum[GLEnum["COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR"] = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR";
    GLEnum[GLEnum["COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR"] = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR";
    GLEnum[GLEnum["COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR"] = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR";
    GLEnum[GLEnum["COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR"] = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR";
    GLEnum[GLEnum["COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR"] = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR";
    // EXT_disjoint_timer_query
    /** The number of bits used to hold the query result for the given target. */ GLEnum[GLEnum["QUERY_COUNTER_BITS_EXT"] = 34916] = "QUERY_COUNTER_BITS_EXT";
    /** The currently active query. */ GLEnum[GLEnum["CURRENT_QUERY_EXT"] = 34917] = "CURRENT_QUERY_EXT";
    /** The query result. */ GLEnum[GLEnum["QUERY_RESULT_EXT"] = 34918] = "QUERY_RESULT_EXT";
    /** A Boolean indicating whether or not a query result is available. */ GLEnum[GLEnum["QUERY_RESULT_AVAILABLE_EXT"] = 34919] = "QUERY_RESULT_AVAILABLE_EXT";
    /** Elapsed time (in nanoseconds). */ GLEnum[GLEnum["TIME_ELAPSED_EXT"] = 35007] = "TIME_ELAPSED_EXT";
    /** The current time. */ GLEnum[GLEnum["TIMESTAMP_EXT"] = 36392] = "TIMESTAMP_EXT";
    /** A Boolean indicating whether or not the GPU performed any disjoint operation (lost context) */ GLEnum[GLEnum["GPU_DISJOINT_EXT"] = 36795] = "GPU_DISJOINT_EXT";
    // KHR_parallel_shader_compile https://registry.khronos.org/webgl/extensions/KHR_parallel_shader_compile
    /** a non-blocking poll operation, so that compile/link status availability can be queried without potentially incurring stalls */ GLEnum[GLEnum["COMPLETION_STATUS_KHR"] = 37297] = "COMPLETION_STATUS_KHR";
    // EXT_depth_clamp https://registry.khronos.org/webgl/extensions/EXT_depth_clamp/
    /** Disables depth clipping */ GLEnum[GLEnum["DEPTH_CLAMP_EXT"] = 34383] = "DEPTH_CLAMP_EXT";
    // WEBGL_provoking_vertex https://registry.khronos.org/webgl/extensions/WEBGL_provoking_vertex/
    /** Values of first vertex in primitive are used for flat shading */ GLEnum[GLEnum["FIRST_VERTEX_CONVENTION_WEBGL"] = 36429] = "FIRST_VERTEX_CONVENTION_WEBGL";
    /** Values of first vertex in primitive are used for flat shading */ GLEnum[GLEnum["LAST_VERTEX_CONVENTION_WEBGL"] = 36430] = "LAST_VERTEX_CONVENTION_WEBGL";
    /** Controls which vertex in primitive is used for flat shading */ GLEnum[GLEnum["PROVOKING_VERTEX_WEBL"] = 36431] = "PROVOKING_VERTEX_WEBL";
    // WEBGL_polygon_mode https://registry.khronos.org/webgl/extensions/WEBGL_polygon_mode/
    GLEnum[GLEnum["POLYGON_MODE_WEBGL"] = 2880] = "POLYGON_MODE_WEBGL";
    GLEnum[GLEnum["POLYGON_OFFSET_LINE_WEBGL"] = 10754] = "POLYGON_OFFSET_LINE_WEBGL";
    GLEnum[GLEnum["LINE_WEBGL"] = 6913] = "LINE_WEBGL";
    GLEnum[GLEnum["FILL_WEBGL"] = 6914] = "FILL_WEBGL";
    // WEBGL_clip_cull_distance https://registry.khronos.org/webgl/extensions/WEBGL_clip_cull_distance/
    /** Max clip distances */ GLEnum[GLEnum["MAX_CLIP_DISTANCES_WEBGL"] = 3378] = "MAX_CLIP_DISTANCES_WEBGL";
    /** Max cull distances */ GLEnum[GLEnum["MAX_CULL_DISTANCES_WEBGL"] = 33529] = "MAX_CULL_DISTANCES_WEBGL";
    /** Max clip and cull distances */ GLEnum[GLEnum["MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL"] = 33530] = "MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL";
    /** Enable gl_ClipDistance[0] and gl_CullDistance[0] */ GLEnum[GLEnum["CLIP_DISTANCE0_WEBGL"] = 12288] = "CLIP_DISTANCE0_WEBGL";
    /** Enable gl_ClipDistance[1] and gl_CullDistance[1] */ GLEnum[GLEnum["CLIP_DISTANCE1_WEBGL"] = 12289] = "CLIP_DISTANCE1_WEBGL";
    /** Enable gl_ClipDistance[2] and gl_CullDistance[2] */ GLEnum[GLEnum["CLIP_DISTANCE2_WEBGL"] = 12290] = "CLIP_DISTANCE2_WEBGL";
    /** Enable gl_ClipDistance[3] and gl_CullDistance[3] */ GLEnum[GLEnum["CLIP_DISTANCE3_WEBGL"] = 12291] = "CLIP_DISTANCE3_WEBGL";
    /** Enable gl_ClipDistance[4] and gl_CullDistance[4] */ GLEnum[GLEnum["CLIP_DISTANCE4_WEBGL"] = 12292] = "CLIP_DISTANCE4_WEBGL";
    /** Enable gl_ClipDistance[5] and gl_CullDistance[5] */ GLEnum[GLEnum["CLIP_DISTANCE5_WEBGL"] = 12293] = "CLIP_DISTANCE5_WEBGL";
    /** Enable gl_ClipDistance[6] and gl_CullDistance[6] */ GLEnum[GLEnum["CLIP_DISTANCE6_WEBGL"] = 12294] = "CLIP_DISTANCE6_WEBGL";
    /** Enable gl_ClipDistance[7] and gl_CullDistance[7] */ GLEnum[GLEnum["CLIP_DISTANCE7_WEBGL"] = 12295] = "CLIP_DISTANCE7_WEBGL";
    /** EXT_polygon_offset_clamp https://registry.khronos.org/webgl/extensions/EXT_polygon_offset_clamp/ */ GLEnum[GLEnum["POLYGON_OFFSET_CLAMP_EXT"] = 36379] = "POLYGON_OFFSET_CLAMP_EXT";
    /** EXT_clip_control https://registry.khronos.org/webgl/extensions/EXT_clip_control/ */ GLEnum[GLEnum["LOWER_LEFT_EXT"] = 36001] = "LOWER_LEFT_EXT";
    GLEnum[GLEnum["UPPER_LEFT_EXT"] = 36002] = "UPPER_LEFT_EXT";
    GLEnum[GLEnum["NEGATIVE_ONE_TO_ONE_EXT"] = 37726] = "NEGATIVE_ONE_TO_ONE_EXT";
    GLEnum[GLEnum["ZERO_TO_ONE_EXT"] = 37727] = "ZERO_TO_ONE_EXT";
    GLEnum[GLEnum["CLIP_ORIGIN_EXT"] = 37724] = "CLIP_ORIGIN_EXT";
    GLEnum[GLEnum["CLIP_DEPTH_MODE_EXT"] = 37725] = "CLIP_DEPTH_MODE_EXT";
    /** WEBGL_blend_func_extended https://registry.khronos.org/webgl/extensions/WEBGL_blend_func_extended/ */ GLEnum[GLEnum["SRC1_COLOR_WEBGL"] = 35065] = "SRC1_COLOR_WEBGL";
    GLEnum[GLEnum["SRC1_ALPHA_WEBGL"] = 34185] = "SRC1_ALPHA_WEBGL";
    GLEnum[GLEnum["ONE_MINUS_SRC1_COLOR_WEBGL"] = 35066] = "ONE_MINUS_SRC1_COLOR_WEBGL";
    GLEnum[GLEnum["ONE_MINUS_SRC1_ALPHA_WEBGL"] = 35067] = "ONE_MINUS_SRC1_ALPHA_WEBGL";
    GLEnum[GLEnum["MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL"] = 35068] = "MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL";
    /** EXT_texture_mirror_clamp_to_edge https://registry.khronos.org/webgl/extensions/EXT_texture_mirror_clamp_to_edge/ */ GLEnum[GLEnum["MIRROR_CLAMP_TO_EDGE_EXT"] = 34627] = "MIRROR_CLAMP_TO_EDGE_EXT";
})(GLEnum || (GLEnum = {}));
;
 //# sourceMappingURL=webgl-constants.js.map
}}),
"[project]/node_modules/@math.gl/types/dist/is-array.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/**
 * Check is an array is a typed array
 * @param value value to be tested
 * @returns input with type narrowed to TypedArray, or null
 */ __turbopack_context__.s({
    "isNumberArray": (()=>isNumberArray),
    "isNumericArray": (()=>isNumericArray),
    "isTypedArray": (()=>isTypedArray)
});
function isTypedArray(value) {
    return ArrayBuffer.isView(value) && !(value instanceof DataView);
}
function isNumberArray(value) {
    if (Array.isArray(value)) {
        return value.length === 0 || typeof value[0] === 'number';
    }
    return false;
}
function isNumericArray(value) {
    return isTypedArray(value) || isNumberArray(value);
} //# sourceMappingURL=is-array.js.map
}}),
"[project]/node_modules/@deck.gl/react/dist/utils/use-isomorphic-layout-effect.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// From https://github.com/streamich/react-use/blob/master/src/useIsomorphicLayoutEffect.ts
// useLayoutEffect but does not trigger warning in server-side rendering
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react/index.js [client] (ecmascript)");
;
const useIsomorphicLayoutEffect = typeof window !== 'undefined' ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useLayoutEffect"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useEffect"];
const __TURBOPACK__default__export__ = useIsomorphicLayoutEffect;
 //# sourceMappingURL=use-isomorphic-layout-effect.js.map
}}),
"[project]/node_modules/@deck.gl/react/dist/utils/inherits-from.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// Check if one JavaScript class inherits from another
__turbopack_context__.s({
    "inheritsFrom": (()=>inheritsFrom)
});
function inheritsFrom(Type, ParentType) {
    while(Type){
        if (Type === ParentType) {
            return true;
        }
        Type = Object.getPrototypeOf(Type);
    }
    return false;
} //# sourceMappingURL=inherits-from.js.map
}}),
"[project]/node_modules/@deck.gl/react/dist/utils/evaluate-children.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "default": (()=>evaluateChildren),
    "isComponent": (()=>isComponent)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react/index.js [client] (ecmascript)");
;
const MAP_STYLE = {
    position: 'absolute',
    zIndex: -1
};
function evaluateChildren(children, childProps) {
    if (typeof children === 'function') {
        return children(childProps);
    }
    if (Array.isArray(children)) {
        return children.map((child)=>evaluateChildren(child, childProps));
    }
    if (isComponent(children)) {
        // Special treatment for react-map-gl's Map component
        // to support shorthand use case <DeckGL><StaticMap /></DeckGL>
        if (isReactMap(children)) {
            // Place map under the canvas
            childProps.style = MAP_STYLE;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["cloneElement"])(children, childProps);
        }
        if (needsDeckGLViewProps(children)) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["cloneElement"])(children, childProps);
        }
    }
    return children;
}
function isComponent(child) {
    return child && typeof child === 'object' && 'type' in child || false;
}
function isReactMap(child) {
    return child.props?.mapStyle;
}
function needsDeckGLViewProps(child) {
    const componentClass = child.type;
    // @ts-expect-error deckGLViewProps is a custom hack defined on the constructor (nebula.gl)
    return componentClass && componentClass.deckGLViewProps;
} //# sourceMappingURL=evaluate-children.js.map
}}),
"[project]/node_modules/@deck.gl/react/dist/utils/extract-jsx-layers.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "default": (()=>extractJSXLayers)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$inherits$2d$from$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/react/dist/utils/inherits-from.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$layer$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Layer$3e$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/core/dist/lib/layer.js [client] (ecmascript) <export default as Layer>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$views$2f$view$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__View$3e$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/core/dist/views/view.js [client] (ecmascript) <export default as View>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$evaluate$2d$children$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/react/dist/utils/evaluate-children.js [client] (ecmascript)");
;
;
;
;
;
// recursively wrap render callbacks in `View`
function wrapInView(node) {
    if (typeof node === 'function') {
        // React.Children does not traverse functions.
        // All render callbacks must be protected under a <View>
        // @ts-expect-error View is not a ReactJSXElement constructor. Only used as a temporary wrapper and will be removed in extractJSXLayers
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["createElement"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$views$2f$view$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__View$3e$__["View"], {}, node);
    }
    if (Array.isArray(node)) {
        return node.map(wrapInView);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$evaluate$2d$children$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isComponent"])(node)) {
        if (node.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Fragment"]) {
            return wrapInView(node.props.children);
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$inherits$2d$from$2e$js__$5b$client$5d$__$28$ecmascript$29$__["inheritsFrom"])(node.type, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$views$2f$view$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__View$3e$__["View"])) {
            return node;
        }
    }
    return node;
}
function extractJSXLayers({ children, layers = [], views = null }) {
    const reactChildren = []; // extract real react elements (i.e. not deck.gl layers)
    const jsxLayers = []; // extracted layer from react children, will add to deck.gl layer array
    const jsxViews = {};
    // React.children
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Children"].forEach(wrapInView(children), (reactElement)=>{
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$evaluate$2d$children$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isComponent"])(reactElement)) {
            // For some reason Children.forEach doesn't filter out `null`s
            const ElementType = reactElement.type;
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$inherits$2d$from$2e$js__$5b$client$5d$__$28$ecmascript$29$__["inheritsFrom"])(ElementType, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$layer$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Layer$3e$__["Layer"])) {
                const layer = createLayer(ElementType, reactElement.props);
                jsxLayers.push(layer);
            } else {
                reactChildren.push(reactElement);
            }
            // empty id => default view
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$inherits$2d$from$2e$js__$5b$client$5d$__$28$ecmascript$29$__["inheritsFrom"])(ElementType, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$views$2f$view$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__View$3e$__["View"]) && ElementType !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$views$2f$view$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__View$3e$__["View"] && reactElement.props.id) {
                // @ts-ignore Cannot instantiate an abstract class (View)
                const view = new ElementType(reactElement.props);
                jsxViews[view.id] = view;
            }
        } else if (reactElement) {
            reactChildren.push(reactElement);
        }
    });
    // Avoid modifying views if no JSX views were found
    if (Object.keys(jsxViews).length > 0) {
        // If a view is specified in both views prop and JSX, use the one in views
        if (Array.isArray(views)) {
            views.forEach((view)=>{
                jsxViews[view.id] = view;
            });
        } else if (views) {
            jsxViews[views.id] = views;
        }
        views = Object.values(jsxViews);
    }
    // Avoid modifying layers array if no JSX layers were found
    layers = jsxLayers.length > 0 ? [
        ...jsxLayers,
        ...layers
    ] : layers;
    return {
        layers,
        children: reactChildren,
        views
    };
}
function createLayer(LayerType, reactProps) {
    const props = {};
    // Layer.defaultProps is treated as ReactElement.defaultProps and merged into react props
    // Remove them
    const defaultProps = LayerType.defaultProps || {};
    for(const key in reactProps){
        if (defaultProps[key] !== reactProps[key]) {
            props[key] = reactProps[key];
        }
    }
    // @ts-ignore Cannot instantiate an abstract class (Layer)
    return new LayerType(props);
} //# sourceMappingURL=extract-jsx-layers.js.map
}}),
"[project]/node_modules/@deck.gl/react/dist/utils/deckgl-context.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "DeckGlContext": (()=>DeckGlContext)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react/index.js [client] (ecmascript)");
;
const DeckGlContext = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["createContext"])(); //# sourceMappingURL=deckgl-context.js.map
}}),
"[project]/node_modules/@deck.gl/react/dist/utils/position-children-under-views.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "default": (()=>positionChildrenUnderViews)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$views$2f$view$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__View$3e$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/core/dist/views/view.js [client] (ecmascript) <export default as View>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$inherits$2d$from$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/react/dist/utils/inherits-from.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$evaluate$2d$children$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/react/dist/utils/evaluate-children.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$deckgl$2d$context$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/react/dist/utils/deckgl-context.js [client] (ecmascript)");
;
;
;
;
;
function positionChildrenUnderViews({ children, deck, ContextProvider = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$deckgl$2d$context$2e$js__$5b$client$5d$__$28$ecmascript$29$__["DeckGlContext"].Provider }) {
    // @ts-expect-error accessing protected property
    const { viewManager } = deck || {};
    if (!viewManager || !viewManager.views.length) {
        return [];
    }
    const views = {};
    const defaultViewId = viewManager.views[0].id;
    // Sort children by view id
    for (const child of children){
        // Unless child is a View, position / render as part of the default view
        let viewId = defaultViewId;
        let viewChildren = child;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$evaluate$2d$children$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isComponent"])(child) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$inherits$2d$from$2e$js__$5b$client$5d$__$28$ecmascript$29$__["inheritsFrom"])(child.type, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$views$2f$view$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__View$3e$__["View"])) {
            viewId = child.props.id || defaultViewId;
            viewChildren = child.props.children;
        }
        const viewport = viewManager.getViewport(viewId);
        const viewState = viewManager.getViewState(viewId);
        // Drop (auto-hide) elements with viewId that are not matched by any current view
        if (viewport) {
            viewState.padding = viewport.padding;
            const { x, y, width, height } = viewport;
            // Resolve potentially relative dimensions using the deck.gl container size
            viewChildren = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$evaluate$2d$children$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(viewChildren, {
                x,
                y,
                width,
                height,
                viewport,
                viewState
            });
            if (!views[viewId]) {
                views[viewId] = {
                    viewport,
                    children: []
                };
            }
            views[viewId].children.push(viewChildren);
        }
    }
    // Render views
    return Object.keys(views).map((viewId)=>{
        const { viewport, children: viewChildren } = views[viewId];
        const { x, y, width, height } = viewport;
        const style = {
            position: 'absolute',
            left: x,
            top: y,
            width,
            height
        };
        const key = `view-${viewId}`;
        // If children is passed as an array, React will throw the "each element in a list needs
        // a key" warning. Sending each child as separate arguments removes this requirement.
        const viewElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["createElement"])('div', {
            key,
            id: key,
            style
        }, ...viewChildren);
        const contextValue = {
            deck,
            viewport,
            // @ts-expect-error accessing protected property
            container: deck.canvas.offsetParent,
            // @ts-expect-error accessing protected property
            eventManager: deck.eventManager,
            onViewStateChange: (params)=>{
                params.viewId = viewId;
                // @ts-expect-error accessing protected method
                deck._onViewStateChange(params);
            },
            widgets: []
        };
        const providerKey = `view-${viewId}-context`;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["createElement"])(ContextProvider, {
            key: providerKey,
            value: contextValue
        }, viewElement);
    });
} //# sourceMappingURL=position-children-under-views.js.map
}}),
"[project]/node_modules/@deck.gl/react/dist/utils/extract-styles.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "default": (()=>extractStyles)
});
const CANVAS_ONLY_STYLES = {
    mixBlendMode: null
};
function extractStyles({ width, height, style }) {
    // This styling is enforced for correct positioning with children
    const containerStyle = {
        position: 'absolute',
        zIndex: 0,
        left: 0,
        top: 0,
        width,
        height
    };
    // Fill the container
    const canvasStyle = {
        left: 0,
        top: 0
    };
    if (style) {
        for(const key in style){
            if (key in CANVAS_ONLY_STYLES) {
                // apply style to the canvas, but not deck's children, e.g. mix-blend-mode
                canvasStyle[key] = style[key];
            } else {
                // apply style to the container, e.g. position/flow settings
                containerStyle[key] = style[key];
            }
        }
    }
    return {
        containerStyle,
        canvasStyle
    };
} //# sourceMappingURL=extract-styles.js.map
}}),
"[project]/node_modules/@deck.gl/react/dist/deckgl.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$deck$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Deck$3e$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/core/dist/lib/deck.js [client] (ecmascript) <export default as Deck>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$use$2d$isomorphic$2d$layout$2d$effect$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/react/dist/utils/use-isomorphic-layout-effect.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$extract$2d$jsx$2d$layers$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/react/dist/utils/extract-jsx-layers.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$position$2d$children$2d$under$2d$views$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/react/dist/utils/position-children-under-views.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$extract$2d$styles$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/react/dist/utils/extract-styles.js [client] (ecmascript)");
;
;
;
;
;
;
;
function getRefHandles(thisRef) {
    return {
        get deck () {
            return thisRef.deck;
        },
        // The following method can only be called after ref is available, by which point deck is defined in useEffect
        pickObject: (opts)=>thisRef.deck.pickObject(opts),
        pickMultipleObjects: (opts)=>thisRef.deck.pickMultipleObjects(opts),
        pickObjects: (opts)=>thisRef.deck.pickObjects(opts)
    };
}
function redrawDeck(thisRef) {
    if (thisRef.redrawReason) {
        // Only redraw if we have received a dirty flag
        // @ts-expect-error accessing protected method
        thisRef.deck._drawLayers(thisRef.redrawReason);
        thisRef.redrawReason = null;
    }
}
function createDeckInstance(thisRef, DeckClass, props) {
    const deck = new DeckClass({
        ...props,
        // The Deck's animation loop is independent from React's render cycle, causing potential
        // synchronization issues. We provide this custom render function to make sure that React
        // and Deck update on the same schedule.
        // TODO(ibgreen) - Hack to enable WebGPU as it needs to render quickly to avoid CanvasContext texture from going stale
        _customRender: props.deviceProps?.adapters?.[0]?.type === 'webgpu' ? undefined : (redrawReason)=>{
            // Save the dirty flag for later
            thisRef.redrawReason = redrawReason;
            // Viewport/view state is passed to child components as props.
            // If they have changed, we need to trigger a React rerender to update children props.
            const viewports = deck.getViewports();
            if (thisRef.lastRenderedViewports !== viewports) {
                // Viewports have changed, update children props first.
                // This will delay the Deck canvas redraw till after React update (in useLayoutEffect)
                // so that the canvas does not get rendered before the child components update.
                thisRef.forceUpdate();
            } else {
                redrawDeck(thisRef);
            }
        }
    });
    return deck;
}
function DeckGLWithRef(props, ref) {
    // A mechanism to force redraw
    const [version, setVersion] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useState"])(0);
    // A reference to persistent states
    const _thisRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useRef"])({
        control: null,
        version,
        forceUpdate: {
            "DeckGLWithRef.useRef[_thisRef]": ()=>setVersion({
                    "DeckGLWithRef.useRef[_thisRef]": (v)=>v + 1
                }["DeckGLWithRef.useRef[_thisRef]"])
        }["DeckGLWithRef.useRef[_thisRef]"]
    });
    const thisRef = _thisRef.current;
    // DOM refs
    const containerRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useRef"])(null);
    const canvasRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useRef"])(null);
    // extract any deck.gl layers masquerading as react elements from props.children
    const jsxProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "DeckGLWithRef.useMemo[jsxProps]": ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$extract$2d$jsx$2d$layers$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(props)
    }["DeckGLWithRef.useMemo[jsxProps]"], [
        props.layers,
        props.views,
        props.children
    ]);
    // Callbacks
    let inRender = true;
    const handleViewStateChange = (params)=>{
        if (inRender && props.viewState) {
            // Callback may invoke a state update. Defer callback to after render() to avoid React error
            // In React StrictMode, render is executed twice and useEffect/useLayoutEffect is executed once
            // Store deferred parameters in ref so that we can access it in another render
            thisRef.viewStateUpdateRequested = params;
            return null;
        }
        thisRef.viewStateUpdateRequested = null;
        return props.onViewStateChange?.(params);
    };
    const handleInteractionStateChange = (params)=>{
        if (inRender) {
            // Callback may invoke a state update. Defer callback to after render() to avoid React error
            // In React StrictMode, render is executed twice and useEffect/useLayoutEffect is executed once
            // Store deferred parameters in ref so that we can access it in another render
            thisRef.interactionStateUpdateRequested = params;
        } else {
            thisRef.interactionStateUpdateRequested = null;
            props.onInteractionStateChange?.(params);
        }
    };
    // Update Deck's props. If Deck needs redraw, this will trigger a call to `_customRender` in
    // the next animation frame.
    // Needs to be called both from initial mount, and when new props are received
    const deckProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "DeckGLWithRef.useMemo[deckProps]": ()=>{
            const forwardProps = {
                widgets: [],
                ...props,
                // Override user styling props. We will set the canvas style in render()
                style: null,
                width: '100%',
                height: '100%',
                parent: containerRef.current,
                canvas: canvasRef.current,
                layers: jsxProps.layers,
                views: jsxProps.views,
                onViewStateChange: handleViewStateChange,
                onInteractionStateChange: handleInteractionStateChange
            };
            // The defaultValue for _customRender is null, which would overwrite the definition
            // of _customRender. Remove to avoid frequently redeclaring the method here.
            delete forwardProps._customRender;
            if (thisRef.deck) {
                thisRef.deck.setProps(forwardProps);
            }
            return forwardProps;
        }
    }["DeckGLWithRef.useMemo[deckProps]"], [
        props
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "DeckGLWithRef.useEffect": ()=>{
            const DeckClass = props.Deck || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$deck$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Deck$3e$__["Deck"];
            thisRef.deck = createDeckInstance(thisRef, DeckClass, {
                ...deckProps,
                parent: containerRef.current,
                canvas: canvasRef.current
            });
            return ({
                "DeckGLWithRef.useEffect": ()=>thisRef.deck?.finalize()
            })["DeckGLWithRef.useEffect"];
        }
    }["DeckGLWithRef.useEffect"], []);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$use$2d$isomorphic$2d$layout$2d$effect$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])({
        "DeckGLWithRef.useIsomorphicLayoutEffect": ()=>{
            // render has just been called. The children are positioned based on the current view state.
            // Redraw Deck canvas immediately, if necessary, using the current view state, so that it
            // matches the child components.
            redrawDeck(thisRef);
            // Execute deferred callbacks
            const { viewStateUpdateRequested, interactionStateUpdateRequested } = thisRef;
            if (viewStateUpdateRequested) {
                handleViewStateChange(viewStateUpdateRequested);
            }
            if (interactionStateUpdateRequested) {
                handleInteractionStateChange(interactionStateUpdateRequested);
            }
        }
    }["DeckGLWithRef.useIsomorphicLayoutEffect"]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useImperativeHandle"])(ref, {
        "DeckGLWithRef.useImperativeHandle": ()=>getRefHandles(thisRef)
    }["DeckGLWithRef.useImperativeHandle"], []);
    const currentViewports = thisRef.deck && thisRef.deck.isInitialized ? thisRef.deck.getViewports() : undefined;
    const { ContextProvider, width = '100%', height = '100%', id, style } = props;
    const { containerStyle, canvasStyle } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "DeckGLWithRef.useMemo": ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$extract$2d$styles$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])({
                width,
                height,
                style
            })
    }["DeckGLWithRef.useMemo"], [
        width,
        height,
        style
    ]);
    // Props changes may lead to 3 types of updates:
    // 1. Only the WebGL canvas - updated in Deck's render cycle (next animation frame)
    // 2. Only the DOM - updated in React's lifecycle (now)
    // 3. Both the WebGL canvas and the DOM - defer React rerender to next animation frame just
    //    before Deck redraw to ensure perfect synchronization & avoid excessive redraw
    //    This is because multiple changes may happen to Deck between two frames e.g. transition
    if (!thisRef.viewStateUpdateRequested && thisRef.lastRenderedViewports === currentViewports || // case 2
    thisRef.version !== version // case 3 just before deck redraws
    ) {
        thisRef.lastRenderedViewports = currentViewports;
        thisRef.version = version;
        // Render the background elements (typically react-map-gl instances)
        // using the view descriptors
        const childrenUnderViews = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$react$2f$dist$2f$utils$2f$position$2d$children$2d$under$2d$views$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])({
            children: jsxProps.children,
            deck: thisRef.deck,
            ContextProvider
        });
        const canvas = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["createElement"])('canvas', {
            key: 'canvas',
            id: id || 'deckgl-overlay',
            ref: canvasRef,
            style: canvasStyle
        });
        // Render deck.gl as the last child
        thisRef.control = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["createElement"])('div', {
            id: `${id || 'deckgl'}-wrapper`,
            ref: containerRef,
            style: containerStyle
        }, [
            canvas,
            childrenUnderViews
        ]);
    }
    inRender = false;
    return thisRef.control;
}
const DeckGL = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["forwardRef"])(DeckGLWithRef);
const __TURBOPACK__default__export__ = DeckGL;
 //# sourceMappingURL=deckgl.js.map
}}),
"[project]/node_modules/@mapbox/tiny-sdf/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>TinySDF)
});
const INF = 1e20;
class TinySDF {
    constructor({ fontSize = 24, buffer = 3, radius = 8, cutoff = 0.25, fontFamily = 'sans-serif', fontWeight = 'normal', fontStyle = 'normal' } = {}){
        this.buffer = buffer;
        this.cutoff = cutoff;
        this.radius = radius;
        // make the canvas size big enough to both have the specified buffer around the glyph
        // for "halo", and account for some glyphs possibly being larger than their font size
        const size = this.size = fontSize + buffer * 4;
        const canvas = this._createCanvas(size);
        const ctx = this.ctx = canvas.getContext('2d', {
            willReadFrequently: true
        });
        ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;
        ctx.textBaseline = 'alphabetic';
        ctx.textAlign = 'left'; // Necessary so that RTL text doesn't have different alignment
        ctx.fillStyle = 'black';
        // temporary arrays for the distance transform
        this.gridOuter = new Float64Array(size * size);
        this.gridInner = new Float64Array(size * size);
        this.f = new Float64Array(size);
        this.z = new Float64Array(size + 1);
        this.v = new Uint16Array(size);
    }
    _createCanvas(size) {
        const canvas = document.createElement('canvas');
        canvas.width = canvas.height = size;
        return canvas;
    }
    draw(char) {
        const { width: glyphAdvance, actualBoundingBoxAscent, actualBoundingBoxDescent, actualBoundingBoxLeft, actualBoundingBoxRight } = this.ctx.measureText(char);
        // The integer/pixel part of the top alignment is encoded in metrics.glyphTop
        // The remainder is implicitly encoded in the rasterization
        const glyphTop = Math.ceil(actualBoundingBoxAscent);
        const glyphLeft = 0;
        // If the glyph overflows the canvas size, it will be clipped at the bottom/right
        const glyphWidth = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(actualBoundingBoxRight - actualBoundingBoxLeft)));
        const glyphHeight = Math.min(this.size - this.buffer, glyphTop + Math.ceil(actualBoundingBoxDescent));
        const width = glyphWidth + 2 * this.buffer;
        const height = glyphHeight + 2 * this.buffer;
        const len = Math.max(width * height, 0);
        const data = new Uint8ClampedArray(len);
        const glyph = {
            data,
            width,
            height,
            glyphWidth,
            glyphHeight,
            glyphTop,
            glyphLeft,
            glyphAdvance
        };
        if (glyphWidth === 0 || glyphHeight === 0) return glyph;
        const { ctx, buffer, gridInner, gridOuter } = this;
        ctx.clearRect(buffer, buffer, glyphWidth, glyphHeight);
        ctx.fillText(char, buffer, buffer + glyphTop);
        const imgData = ctx.getImageData(buffer, buffer, glyphWidth, glyphHeight);
        // Initialize grids outside the glyph range to alpha 0
        gridOuter.fill(INF, 0, len);
        gridInner.fill(0, 0, len);
        for(let y = 0; y < glyphHeight; y++){
            for(let x = 0; x < glyphWidth; x++){
                const a = imgData.data[4 * (y * glyphWidth + x) + 3] / 255; // alpha value
                if (a === 0) continue; // empty pixels
                const j = (y + buffer) * width + x + buffer;
                if (a === 1) {
                    gridOuter[j] = 0;
                    gridInner[j] = INF;
                } else {
                    const d = 0.5 - a;
                    gridOuter[j] = d > 0 ? d * d : 0;
                    gridInner[j] = d < 0 ? d * d : 0;
                }
            }
        }
        edt(gridOuter, 0, 0, width, height, width, this.f, this.v, this.z);
        edt(gridInner, buffer, buffer, glyphWidth, glyphHeight, width, this.f, this.v, this.z);
        for(let i = 0; i < len; i++){
            const d = Math.sqrt(gridOuter[i]) - Math.sqrt(gridInner[i]);
            data[i] = Math.round(255 - 255 * (d / this.radius + this.cutoff));
        }
        return glyph;
    }
}
// 2D Euclidean squared distance transform by Felzenszwalb & Huttenlocher https://cs.brown.edu/~pff/papers/dt-final.pdf
function edt(data, x0, y0, width, height, gridSize, f, v, z) {
    for(let x = x0; x < x0 + width; x++)edt1d(data, y0 * gridSize + x, gridSize, height, f, v, z);
    for(let y = y0; y < y0 + height; y++)edt1d(data, y * gridSize + x0, 1, width, f, v, z);
}
// 1D squared distance transform
function edt1d(grid, offset, stride, length, f, v, z) {
    v[0] = 0;
    z[0] = -INF;
    z[1] = INF;
    f[0] = grid[offset];
    for(let q = 1, k = 0, s = 0; q < length; q++){
        f[q] = grid[offset + q * stride];
        const q2 = q * q;
        do {
            const r = v[k];
            s = (f[q] - f[r] + q2 - r * r) / (q - r) / 2;
        }while (s <= z[k] && --k > -1)
        k++;
        v[k] = q;
        z[k] = s;
        z[k + 1] = INF;
    }
    for(let q = 0, k = 0; q < length; q++){
        while(z[k + 1] < q)k++;
        const r = v[k];
        const qr = q - r;
        grid[offset + q * stride] = f[r] + qr * qr;
    }
}
}}),
"[project]/node_modules/@math.gl/polygon/dist/polygon-utils.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT and ISC
// Copyright (c) vis.gl contributors
/* eslint-disable max-statements, max-depth, complexity, no-unused-expressions */ __turbopack_context__.s({
    "DimIndex": (()=>DimIndex),
    "WINDING": (()=>WINDING),
    "forEachSegmentInPolygon": (()=>forEachSegmentInPolygon),
    "forEachSegmentInPolygonPoints": (()=>forEachSegmentInPolygonPoints),
    "getPolygonSignedArea": (()=>getPolygonSignedArea),
    "getPolygonSignedAreaPoints": (()=>getPolygonSignedAreaPoints),
    "getPolygonWindingDirection": (()=>getPolygonWindingDirection),
    "getPolygonWindingDirectionPoints": (()=>getPolygonWindingDirectionPoints),
    "modifyPolygonWindingDirection": (()=>modifyPolygonWindingDirection),
    "modifyPolygonWindingDirectionPoints": (()=>modifyPolygonWindingDirectionPoints)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$common$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/lib/common.js [client] (ecmascript)");
;
const WINDING = {
    CLOCKWISE: 1,
    COUNTER_CLOCKWISE: -1
};
function modifyPolygonWindingDirection(points, direction, options = {}) {
    const windingDirection = getPolygonWindingDirection(points, options);
    if (windingDirection !== direction) {
        reversePolygon(points, options);
        return true;
    }
    return false;
}
function getPolygonWindingDirection(points, options = {}) {
    return Math.sign(getPolygonSignedArea(points, options));
}
const DimIndex = {
    x: 0,
    y: 1,
    z: 2
};
function getPolygonSignedArea(points, options = {}) {
    const { start = 0, end = points.length, plane = 'xy' } = options;
    const dim = options.size || 2;
    let area = 0;
    const i0 = DimIndex[plane[0]];
    const i1 = DimIndex[plane[1]];
    for(let i = start, j = end - dim; i < end; i += dim){
        area += (points[i + i0] - points[j + i0]) * (points[i + i1] + points[j + i1]);
        j = i;
    }
    return area / 2;
}
function forEachSegmentInPolygon(points, visitor, options = {}) {
    const { start = 0, end = points.length, size = 2, isClosed } = options;
    const numPoints = (end - start) / size;
    for(let i = 0; i < numPoints - 1; ++i){
        visitor(points[start + i * size], points[start + i * size + 1], points[start + (i + 1) * size], points[start + (i + 1) * size + 1], i, i + 1);
    }
    const endPointIndex = start + (numPoints - 1) * size;
    const isClosedEx = isClosed || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$common$2e$js__$5b$client$5d$__$28$ecmascript$29$__["equals"])(points[start], points[endPointIndex]) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$common$2e$js__$5b$client$5d$__$28$ecmascript$29$__["equals"])(points[start + 1], points[endPointIndex + 1]);
    if (!isClosedEx) {
        visitor(points[endPointIndex], points[endPointIndex + 1], points[start], points[start + 1], numPoints - 1, 0);
    }
}
function reversePolygon(points, options) {
    const { start = 0, end = points.length, size = 2 } = options;
    const numPoints = (end - start) / size;
    const numSwaps = Math.floor(numPoints / 2);
    for(let i = 0; i < numSwaps; ++i){
        const b1 = start + i * size;
        const b2 = start + (numPoints - 1 - i) * size;
        for(let j = 0; j < size; ++j){
            const tmp = points[b1 + j];
            points[b1 + j] = points[b2 + j];
            points[b2 + j] = tmp;
        }
    }
}
function modifyPolygonWindingDirectionPoints(points, direction, options = {}) {
    const currentDirection = getPolygonWindingDirectionPoints(points, options);
    if (currentDirection !== direction) {
        points.reverse();
        return true;
    }
    return false;
}
function getPolygonWindingDirectionPoints(points, options = {}) {
    return Math.sign(getPolygonSignedAreaPoints(points, options));
}
function getPolygonSignedAreaPoints(points, options = {}) {
    // https://en.wikipedia.org/wiki/Shoelace_formula
    const { start = 0, end = points.length, plane = 'xy' } = options;
    let area = 0;
    const i0 = DimIndex[plane[0]];
    const i1 = DimIndex[plane[1]];
    for(let i = start, j = end - 1; i < end; ++i){
        area += (points[i][i0] - points[j][i0]) * (points[i][i1] + points[j][i1]);
        j = i;
    }
    return area / 2;
}
function forEachSegmentInPolygonPoints(points, visitor, options = {}) {
    const { start = 0, end = points.length, isClosed } = options;
    for(let i = start; i < end - 1; ++i){
        visitor(points[i], points[i + 1], i, i + 1);
    }
    const isClosedEx = isClosed || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$common$2e$js__$5b$client$5d$__$28$ecmascript$29$__["equals"])(points[end - 1], points[0]);
    if (!isClosedEx) {
        visitor(points[end - 1], points[0], end - 1, 0);
    }
} //# sourceMappingURL=polygon-utils.js.map
}}),
"[project]/node_modules/@math.gl/polygon/dist/polygon.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/* eslint-disable no-undef, no-console */ __turbopack_context__.s({
    "Polygon": (()=>Polygon)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$common$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/lib/common.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$polygon$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/polygon/dist/polygon-utils.js [client] (ecmascript)");
;
;
class Polygon {
    constructor(points, options = {}){
        this.points = points;
        this.isFlatArray = !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$common$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isArray"])(points[0]);
        this.options = {
            start: options.start || 0,
            end: options.end || points.length,
            size: options.size || 2,
            isClosed: options.isClosed
        };
        Object.freeze(this);
    }
    /**
     * Returns signed area of the polygon.
     * @returns Signed area of the polygon.
     */ getSignedArea() {
        if (this.isFlatArray) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$polygon$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getPolygonSignedArea"])(this.points, this.options);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$polygon$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getPolygonSignedAreaPoints"])(this.points, this.options);
    }
    /**
     * Returns absolute area of the polygon.
     * @returns Absolute area of the polygon.
     */ getArea() {
        return Math.abs(this.getSignedArea());
    }
    /**
     * Returns winding direction of the polygon.
     * @returns Winding direction of the polygon. 1 is for clockwise, -1 for counterclockwise winding direction.
     */ getWindingDirection() {
        return Math.sign(this.getSignedArea());
    }
    /**
     * Calls the visitor callback for each segment in the polygon.
     * @param visitor A callback to call for each segment.
     */ forEachSegment(visitor) {
        if (this.isFlatArray) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$polygon$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["forEachSegmentInPolygon"])(this.points, // eslint-disable-next-line max-params
            (x1, y1, x2, y2, i1, i2)=>{
                // TODO @igorDykhta original visitor uses arrays for each point, but with flat arrays performance degrades if we allocate points for each segment
                visitor([
                    x1,
                    y1
                ], [
                    x2,
                    y2
                ], i1, i2);
            }, this.options);
        } else {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$polygon$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["forEachSegmentInPolygonPoints"])(this.points, visitor, this.options);
        }
    }
    /**
     * Checks winding direction of the polygon and reverses the polygon in case of opposite winding direction.
     * @param direction Requested winding direction. 1 is for clockwise, -1 for counterclockwise winding direction.
     * @return Returns true if the winding direction was changed.
     */ modifyWindingDirection(direction) {
        if (this.isFlatArray) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$polygon$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["modifyPolygonWindingDirection"])(this.points, direction, this.options);
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$polygon$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["modifyPolygonWindingDirectionPoints"])(this.points, direction, this.options);
    }
} //# sourceMappingURL=polygon.js.map
}}),
"[project]/node_modules/@math.gl/polygon/dist/earcut.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT and ISC
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "earcut": (()=>earcut)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$polygon$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/polygon/dist/polygon-utils.js [client] (ecmascript)");
;
function earcut(positions, holeIndices, dim = 2, areas, plane = 'xy') {
    const hasHoles = holeIndices && holeIndices.length;
    const outerLen = hasHoles ? holeIndices[0] * dim : positions.length;
    let outerNode = linkedList(positions, 0, outerLen, dim, true, areas && areas[0], plane);
    const triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev) return triangles;
    let invSize;
    let maxX;
    let maxY;
    let minX;
    let minY;
    let x;
    let y;
    if (hasHoles) outerNode = eliminateHoles(positions, holeIndices, outerNode, dim, areas, plane);
    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (positions.length > 80 * dim) {
        minX = maxX = positions[0];
        minY = maxY = positions[1];
        for(let i = dim; i < outerLen; i += dim){
            x = positions[i];
            y = positions[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }
        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
    return triangles;
}
// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise, area, plane) {
    let i;
    let last;
    if (area === undefined) {
        area = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$polygon$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getPolygonSignedArea"])(data, {
            start,
            end,
            size: dim,
            plane
        });
    }
    let i0 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$polygon$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["DimIndex"][plane[0]];
    let i1 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$polygon$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["DimIndex"][plane[1]];
    // Note that the signed area calculation in math.gl
    // has the opposite sign to that which was originally
    // present in earcut, thus the `< 0` is reversed
    if (clockwise === area < 0) {
        for(i = start; i < end; i += dim)last = insertNode(i, data[i + i0], data[i + i1], last);
    } else {
        for(i = end - dim; i >= start; i -= dim)last = insertNode(i, data[i + i0], data[i + i1], last);
    }
    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }
    return last;
}
// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;
    let p = start;
    let again;
    do {
        again = false;
        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;
        } else {
            p = p.next;
        }
    }while (again || p !== end)
    return end;
}
// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;
    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
    let stop = ear;
    let prev;
    let next;
    // iterate through ears, slicing them one by one
    while(ear.prev !== ear.next){
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim | 0);
            triangles.push(ear.i / dim | 0);
            triangles.push(next.i / dim | 0);
            removeNode(ear);
            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;
            continue;
        }
        ear = next;
        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }
            break;
        }
    }
}
// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    const a = ear.prev;
    const b = ear;
    const c = ear.next;
    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
    // now make sure we don't have other points inside the potential ear
    const ax = a.x;
    const bx = b.x;
    const cx = c.x;
    const ay = a.y;
    const by = b.y;
    const cy = c.y;
    // triangle bbox; min & max are calculated like this for speed
    const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx;
    const y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy;
    const x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx;
    const y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
    let p = c.next;
    while(p !== a){
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }
    return true;
}
function isEarHashed(ear, minX, minY, invSize) {
    const a = ear.prev;
    const b = ear;
    const c = ear.next;
    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
    const ax = a.x;
    const bx = b.x;
    const cx = c.x;
    const ay = a.y;
    const by = b.y;
    const cy = c.y;
    // triangle bbox; min & max are calculated like this for speed
    const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx;
    const y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy;
    const x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx;
    const y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
    // z-order range for the current triangle bbox;
    const minZ = zOrder(x0, y0, minX, minY, invSize);
    const maxZ = zOrder(x1, y1, minX, minY, invSize);
    let p = ear.prevZ;
    let n = ear.nextZ;
    // look for points inside the triangle in both directions
    while(p && p.z >= minZ && n && n.z <= maxZ){
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }
    // look for remaining points in decreasing z-order
    while(p && p.z >= minZ){
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }
    // look for remaining points in increasing z-order
    while(n && n.z <= maxZ){
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }
    return true;
}
// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    let p = start;
    do {
        const a = p.prev;
        const b = p.next.next;
        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
            triangles.push(a.i / dim | 0);
            triangles.push(p.i / dim | 0);
            triangles.push(b.i / dim | 0);
            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);
            p = start = b;
        }
        p = p.next;
    }while (p !== start)
    return filterPoints(p);
}
// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    let a = start;
    do {
        let b = a.next.next;
        while(b !== a.prev){
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                let c = splitPolygon(a, b);
                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);
                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
                return;
            }
            b = b.next;
        }
        a = a.next;
    }while (a !== start)
}
// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim, areas, plane) {
    const queue = [];
    let i;
    let len;
    let start;
    let end;
    let list;
    for(i = 0, len = holeIndices.length; i < len; i++){
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false, areas && areas[i + 1], plane);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }
    queue.sort(compareX);
    // process holes from left to right
    for(i = 0; i < queue.length; i++){
        outerNode = eliminateHole(queue[i], outerNode);
    }
    return outerNode;
}
function compareX(a, b) {
    return a.x - b.x;
}
// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    const bridge = findHoleBridge(hole, outerNode);
    if (!bridge) {
        return outerNode;
    }
    const bridgeReverse = splitPolygon(bridge, hole);
    // filter collinear points around the cuts
    filterPoints(bridgeReverse, bridgeReverse.next);
    return filterPoints(bridge, bridge.next);
}
// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    let p = outerNode;
    const hx = hole.x;
    const hy = hole.y;
    let qx = -Infinity;
    let m;
    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                m = p.x < p.next.x ? p : p.next;
                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint
            }
        }
        p = p.next;
    }while (p !== outerNode)
    if (!m) return null;
    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point
    const stop = m;
    const mx = m.x;
    const my = m.y;
    let tanMin = Infinity;
    let tan;
    p = m;
    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential
            if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
                m = p;
                tanMin = tan;
            }
        }
        p = p.next;
    }while (p !== stop)
    return m;
}
// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}
// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    let p = start;
    do {
        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    }while (p !== start)
    p.prevZ.nextZ = null;
    p.prevZ = null;
    sortLinked(p);
}
// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    let e;
    let i;
    let inSize = 1;
    let numMerges;
    let p;
    let pSize;
    let q;
    let qSize;
    let tail;
    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;
        while(p){
            numMerges++;
            q = p;
            pSize = 0;
            for(i = 0; i < inSize; i++){
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;
            while(pSize > 0 || qSize > 0 && q){
                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }
                if (tail) tail.nextZ = e;
                else list = e;
                e.prevZ = tail;
                tail = e;
            }
            p = q;
        }
        tail.nextZ = null;
        inSize *= 2;
    }while (numMerges > 1)
    return list;
}
// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = (x - minX) * invSize | 0;
    y = (y - minY) * invSize | 0;
    x = (x | x << 8) & 0x00ff00ff;
    x = (x | x << 4) & 0x0f0f0f0f;
    x = (x | x << 2) & 0x33333333;
    x = (x | x << 1) & 0x55555555;
    y = (y | y << 8) & 0x00ff00ff;
    y = (y | y << 4) & 0x0f0f0f0f;
    y = (y | y << 2) & 0x33333333;
    y = (y | y << 1) & 0x55555555;
    return x | y << 1;
}
// find the leftmost node of a polygon ring
function getLeftmost(start) {
    let p = start;
    let leftmost = start;
    do {
        if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
        p = p.next;
    }while (p !== start)
    return leftmost;
}
// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
}
// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
    (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
    (area(a.prev, a, b.prev) || area(a, b.prev, b)) || equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}
// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}
// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}
// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    const o1 = sign(area(p1, q1, p2));
    const o2 = sign(area(p1, q1, q2));
    const o3 = sign(area(p2, q2, p1));
    const o4 = sign(area(p2, q2, q1));
    if (o1 !== o2 && o3 !== o4) return true; // general case
    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2
    return false;
}
// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}
function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}
// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    let p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
        p = p.next;
    }while (p !== a)
    return false;
}
// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}
// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    let p = a;
    let inside = false;
    const px = (a.x + b.x) / 2;
    const py = (a.y + b.y) / 2;
    do {
        if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
        p = p.next;
    }while (p !== a)
    return inside;
}
// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    const a2 = new Vertex(a.i, a.x, a.y);
    const b2 = new Vertex(b.i, b.x, b.y);
    const an = a.next;
    const bp = b.prev;
    a.next = b;
    b.prev = a;
    a2.next = an;
    an.prev = a2;
    b2.next = a2;
    a2.prev = b2;
    bp.next = b2;
    b2.prev = bp;
    return b2;
}
// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    const p = new Vertex(i, x, y);
    if (!last) {
        p.prev = p;
        p.next = p;
    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}
function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;
    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}
class Vertex {
    constructor(i, x, y){
        // previous and next vertex nodes in a polygon ring
        this.prev = null;
        this.next = null;
        // z-order curve value
        this.z = 0;
        // previous and next nodes in z-order
        this.prevZ = null;
        this.nextZ = null;
        // indicates whether this is a steiner point
        this.steiner = false;
        this.i = i;
        this.x = x;
        this.y = y;
    }
} //# sourceMappingURL=earcut.js.map
}}),
"[project]/node_modules/@math.gl/polygon/dist/utils.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "copy": (()=>copy),
    "getPointAtIndex": (()=>getPointAtIndex),
    "push": (()=>push)
});
function push(target, source) {
    const size = source.length;
    const startIndex = target.length;
    // dedupe, if source is the same point as the last vertex
    if (startIndex > 0) {
        let isDuplicate = true;
        for(let i = 0; i < size; i++){
            if (target[startIndex - size + i] !== source[i]) {
                isDuplicate = false;
                break;
            }
        }
        if (isDuplicate) {
            return false;
        }
    }
    for(let i = 0; i < size; i++){
        target[startIndex + i] = source[i];
    }
    return true;
}
function copy(target, source) {
    const size = source.length;
    for(let i = 0; i < size; i++){
        target[i] = source[i];
    }
}
function getPointAtIndex(positions, index, size, offset, out = []) {
    const startI = offset + index * size;
    for(let i = 0; i < size; i++){
        out[i] = positions[startI + i];
    }
    return out;
} //# sourceMappingURL=utils.js.map
}}),
"[project]/node_modules/@math.gl/polygon/dist/lineclip.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT and ISC
// Copyright (c) vis.gl contributors
/*
  Adapted from https://github.com/mapbox/lineclip to work with flat arrays
  and 3d positions

  ISC License

  Copyright (c) 2015, Mapbox

  Permission to use, copy, modify, and/or distribute this software for any purpose
  with or without fee is hereby granted, provided that the above copyright notice
  and this permission notice appear in all copies.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
  FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
  OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
  THIS SOFTWARE.

 */ /* eslint-disable max-statements, max-depth, complexity */ __turbopack_context__.s({
    "bitCode": (()=>bitCode),
    "clipPolygon": (()=>clipPolygon),
    "clipPolyline": (()=>clipPolyline),
    "intersect": (()=>intersect)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/polygon/dist/utils.js [client] (ecmascript)");
;
function clipPolyline(positions, bbox, options) {
    const { size = 2, startIndex = 0, endIndex = positions.length } = options || {};
    const numPoints = (endIndex - startIndex) / size;
    const result = [];
    let part = [];
    let a;
    let b;
    let codeA = -1;
    let codeB;
    let lastCode;
    for(let i = 1; i < numPoints; i++){
        a = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getPointAtIndex"])(positions, i - 1, size, startIndex, a);
        b = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getPointAtIndex"])(positions, i, size, startIndex, b);
        if (codeA < 0) {
            codeA = bitCode(a, bbox);
        }
        codeB = lastCode = bitCode(b, bbox);
        // eslint-disable-next-line no-constant-condition
        while(true){
            if (!(codeA | codeB)) {
                // accept
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["push"])(part, a);
                if (codeB !== lastCode) {
                    // segment went outside
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["push"])(part, b);
                    if (i < numPoints - 1) {
                        // start a new line
                        result.push(part);
                        part = [];
                    }
                } else if (i === numPoints - 1) {
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["push"])(part, b);
                }
                break;
            } else if (codeA & codeB) {
                break;
            } else if (codeA) {
                // a outside, intersect with clip edge
                intersect(a, b, codeA, bbox, a);
                codeA = bitCode(a, bbox);
            } else {
                // b outside
                intersect(a, b, codeB, bbox, b);
                codeB = bitCode(b, bbox);
            }
        }
        codeA = lastCode;
    }
    if (part.length) result.push(part);
    return result;
}
function clipPolygon(positions, bbox, options) {
    const { size = 2, endIndex = positions.length } = options || {};
    let { startIndex = 0 } = options || {};
    let numPoints = (endIndex - startIndex) / size;
    let result;
    let p;
    let prev;
    let inside;
    let prevInside;
    // clip against each side of the clip rectangle
    for(let edge = 1; edge <= 8; edge *= 2){
        result = [];
        prev = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getPointAtIndex"])(positions, numPoints - 1, size, startIndex, prev);
        prevInside = !(bitCode(prev, bbox) & edge);
        for(let i = 0; i < numPoints; i++){
            p = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getPointAtIndex"])(positions, i, size, startIndex, p);
            inside = !(bitCode(p, bbox) & edge);
            // if segment goes through the clip window, add an intersection
            if (inside !== prevInside) (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["push"])(result, intersect(prev, p, edge, bbox));
            if (inside) (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["push"])(result, p); // add a point if it's inside
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["copy"])(prev, p);
            prevInside = inside;
        }
        // close loop
        positions = result;
        startIndex = 0;
        numPoints = result.length / size;
        if (!numPoints) break;
    }
    return result;
}
function intersect(a, b, edge, bbox, out = []) {
    let t;
    // Forces out[snapI] to be on the bbox edge
    // Interpolation introduces precision issue which may cause lineclip to be
    // stuck in an infinite loop
    let snap;
    if (edge & 8) {
        // top
        t = (bbox[3] - a[1]) / (b[1] - a[1]);
        snap = 3;
    } else if (edge & 4) {
        // bottom
        t = (bbox[1] - a[1]) / (b[1] - a[1]);
        snap = 1;
    } else if (edge & 2) {
        // right
        t = (bbox[2] - a[0]) / (b[0] - a[0]);
        snap = 2;
    } else if (edge & 1) {
        // left
        t = (bbox[0] - a[0]) / (b[0] - a[0]);
        snap = 0;
    } else {
        return null;
    }
    for(let i = 0; i < a.length; i++){
        out[i] = (snap & 1) === i ? bbox[snap] : t * (b[i] - a[i]) + a[i];
    }
    return out;
}
function bitCode(p, bbox) {
    let code = 0;
    if (p[0] < bbox[0]) code |= 1;
    else if (p[0] > bbox[2]) code |= 2; // right
    if (p[1] < bbox[1]) code |= 4;
    else if (p[1] > bbox[3]) code |= 8; // top
    return code;
} //# sourceMappingURL=lineclip.js.map
}}),
"[project]/node_modules/@math.gl/polygon/dist/cut-by-grid.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/* eslint-disable max-statements, max-depth, complexity, no-unused-expressions */ __turbopack_context__.s({
    "cutPolygonByGrid": (()=>cutPolygonByGrid),
    "cutPolylineByGrid": (()=>cutPolylineByGrid)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$lineclip$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/polygon/dist/lineclip.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/polygon/dist/utils.js [client] (ecmascript)");
;
;
function cutPolylineByGrid(positions, options) {
    const { size = 2, broken = false, gridResolution = 10, gridOffset = [
        0,
        0
    ], startIndex = 0, endIndex = positions.length } = options || {};
    const numPoints = (endIndex - startIndex) / size;
    let part = [];
    const result = [
        part
    ];
    const a = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getPointAtIndex"])(positions, 0, size, startIndex);
    let b;
    let codeB;
    const cell = getGridCell(a, gridResolution, gridOffset, []);
    const scratchPoint = [];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["push"])(part, a);
    for(let i = 1; i < numPoints; i++){
        b = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getPointAtIndex"])(positions, i, size, startIndex, b);
        codeB = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$lineclip$2e$js__$5b$client$5d$__$28$ecmascript$29$__["bitCode"])(b, cell);
        while(codeB){
            // find the intersection with the current cell
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$lineclip$2e$js__$5b$client$5d$__$28$ecmascript$29$__["intersect"])(a, b, codeB, cell, scratchPoint);
            const codeAlt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$lineclip$2e$js__$5b$client$5d$__$28$ecmascript$29$__["bitCode"])(scratchPoint, cell);
            if (codeAlt) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$lineclip$2e$js__$5b$client$5d$__$28$ecmascript$29$__["intersect"])(a, scratchPoint, codeAlt, cell, scratchPoint);
                codeB = codeAlt;
            }
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["push"])(part, scratchPoint);
            // move to the next cell
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["copy"])(a, scratchPoint);
            moveToNeighborCell(cell, gridResolution, codeB);
            if (broken && part.length > size) {
                part = [];
                result.push(part);
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["push"])(part, a);
            }
            codeB = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$lineclip$2e$js__$5b$client$5d$__$28$ecmascript$29$__["bitCode"])(b, cell);
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["push"])(part, b);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["copy"])(a, b);
    }
    return broken ? result : result[0];
}
const TYPE_INSIDE = 0;
const TYPE_BORDER = 1;
function cutPolygonByGrid(positions, holeIndices = null, options) {
    if (!positions.length) {
        // input is empty
        return [];
    }
    const { size = 2, gridResolution = 10, gridOffset = [
        0,
        0
    ], edgeTypes = false } = options || {};
    const result = [];
    const queue = [
        {
            pos: positions,
            types: edgeTypes ? new Array(positions.length / size).fill(TYPE_BORDER) : null,
            holes: holeIndices || []
        }
    ];
    const bbox = [
        [],
        []
    ];
    // @ts-ignore
    let cell = [];
    // Recursively bisect polygon until every part fit in a single grid cell
    while(queue.length){
        const { pos, types, holes } = queue.shift();
        // Get the bounding box of the outer polygon
        getBoundingBox(pos, size, holes[0] || pos.length, bbox);
        cell = getGridCell(bbox[0], gridResolution, gridOffset, cell);
        const code = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$lineclip$2e$js__$5b$client$5d$__$28$ecmascript$29$__["bitCode"])(bbox[1], cell);
        if (code) {
            // Split the outer ring at the boundary
            let parts = bisectPolygon(pos, types, size, 0, holes[0] || pos.length, cell, code);
            const polygonLow = {
                pos: parts[0].pos,
                types: parts[0].types,
                holes: []
            };
            const polygonHigh = {
                pos: parts[1].pos,
                types: parts[1].types,
                holes: []
            };
            queue.push(polygonLow, polygonHigh);
            // Split each hole at the boundary
            for(let i = 0; i < holes.length; i++){
                parts = bisectPolygon(pos, types, size, holes[i], holes[i + 1] || pos.length, cell, code);
                if (parts[0]) {
                    polygonLow.holes.push(polygonLow.pos.length);
                    polygonLow.pos = concatInPlace(polygonLow.pos, parts[0].pos);
                    if (edgeTypes) {
                        polygonLow.types = concatInPlace(polygonLow.types, parts[0].types);
                    }
                }
                if (parts[1]) {
                    polygonHigh.holes.push(polygonHigh.pos.length);
                    polygonHigh.pos = concatInPlace(polygonHigh.pos, parts[1].pos);
                    if (edgeTypes) {
                        polygonHigh.types = concatInPlace(polygonHigh.types, parts[1].types);
                    }
                }
            }
        } else {
            // Polygon fits in a single cell, no more processing required
            const polygon = {
                positions: pos
            };
            if (edgeTypes) {
                polygon.edgeTypes = types;
            }
            if (holes.length) {
                polygon.holeIndices = holes;
            }
            result.push(polygon);
        }
    }
    return result;
}
// edgeTypes:
// TYPE_BORDER - edge from the original polygon
// TYPE_INSIDE - inside the original polygon
// eslint-disable-next-line max-params
function bisectPolygon(positions, edgeTypes, size, startIndex, endIndex, bbox, edge) {
    const numPoints = (endIndex - startIndex) / size;
    const resultLow = [];
    const resultHigh = [];
    const typesLow = [];
    const typesHigh = [];
    const scratchPoint = [];
    let p;
    let side;
    let type;
    const prev = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getPointAtIndex"])(positions, numPoints - 1, size, startIndex);
    let prevSide = Math.sign(edge & 8 ? prev[1] - bbox[3] : prev[0] - bbox[2]);
    let prevType = edgeTypes && edgeTypes[numPoints - 1];
    let lowPointCount = 0;
    let highPointCount = 0;
    for(let i = 0; i < numPoints; i++){
        p = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getPointAtIndex"])(positions, i, size, startIndex, p);
        side = Math.sign(edge & 8 ? p[1] - bbox[3] : p[0] - bbox[2]);
        type = edgeTypes && edgeTypes[startIndex / size + i];
        // if segment goes through the boundary, add an intersection
        if (side && prevSide && prevSide !== side) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$lineclip$2e$js__$5b$client$5d$__$28$ecmascript$29$__["intersect"])(prev, p, edge, bbox, scratchPoint);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["push"])(resultLow, scratchPoint) && typesLow.push(prevType);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["push"])(resultHigh, scratchPoint) && typesHigh.push(prevType);
        }
        if (side <= 0) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["push"])(resultLow, p) && typesLow.push(type);
            lowPointCount -= side;
        } else if (typesLow.length) {
            typesLow[typesLow.length - 1] = TYPE_INSIDE;
        }
        if (side >= 0) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["push"])(resultHigh, p) && typesHigh.push(type);
            highPointCount += side;
        } else if (typesHigh.length) {
            typesHigh[typesHigh.length - 1] = TYPE_INSIDE;
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["copy"])(prev, p);
        prevSide = side;
        prevType = type;
    }
    return [
        lowPointCount ? {
            pos: resultLow,
            types: edgeTypes && typesLow
        } : null,
        highPointCount ? {
            pos: resultHigh,
            types: edgeTypes && typesHigh
        } : null
    ];
}
function getGridCell(p, gridResolution, gridOffset, out) {
    const left = Math.floor((p[0] - gridOffset[0]) / gridResolution) * gridResolution + gridOffset[0];
    const bottom = Math.floor((p[1] - gridOffset[1]) / gridResolution) * gridResolution + gridOffset[1];
    out[0] = left;
    out[1] = bottom;
    out[2] = left + gridResolution;
    out[3] = bottom + gridResolution;
    return out;
}
function moveToNeighborCell(cell, gridResolution, edge) {
    if (edge & 8) {
        // top
        cell[1] += gridResolution;
        cell[3] += gridResolution;
    } else if (edge & 4) {
        // bottom
        cell[1] -= gridResolution;
        cell[3] -= gridResolution;
    } else if (edge & 2) {
        // right
        cell[0] += gridResolution;
        cell[2] += gridResolution;
    } else if (edge & 1) {
        // left
        cell[0] -= gridResolution;
        cell[2] -= gridResolution;
    }
}
function getBoundingBox(positions, size, endIndex, out) {
    let minX = Infinity;
    let maxX = -Infinity;
    let minY = Infinity;
    let maxY = -Infinity;
    for(let i = 0; i < endIndex; i += size){
        const x = positions[i];
        const y = positions[i + 1];
        minX = x < minX ? x : minX;
        maxX = x > maxX ? x : maxX;
        minY = y < minY ? y : minY;
        maxY = y > maxY ? y : maxY;
    }
    out[0][0] = minX;
    out[0][1] = minY;
    out[1][0] = maxX;
    out[1][1] = maxY;
    return out;
}
function concatInPlace(arr1, arr2) {
    for(let i = 0; i < arr2.length; i++){
        arr1.push(arr2[i]);
    }
    return arr1;
} //# sourceMappingURL=cut-by-grid.js.map
}}),
"[project]/node_modules/@math.gl/polygon/dist/cut-by-mercator-bounds.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "cutPolygonByMercatorBounds": (()=>cutPolygonByMercatorBounds),
    "cutPolylineByMercatorBounds": (()=>cutPolylineByMercatorBounds)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$cut$2d$by$2d$grid$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/polygon/dist/cut-by-grid.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/polygon/dist/utils.js [client] (ecmascript)");
;
;
// https://en.wikipedia.org/wiki/Web_Mercator_projection
const DEFAULT_MAX_LATITUDE = 85.051129;
function cutPolylineByMercatorBounds(positions, options) {
    const { size = 2, startIndex = 0, endIndex = positions.length, normalize = true } = options || {};
    // Remap longitudes so that each segment takes the shorter path
    const newPositions = positions.slice(startIndex, endIndex);
    wrapLongitudesForShortestPath(newPositions, size, 0, endIndex - startIndex);
    const parts = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$cut$2d$by$2d$grid$2e$js__$5b$client$5d$__$28$ecmascript$29$__["cutPolylineByGrid"])(newPositions, {
        size,
        broken: true,
        gridResolution: 360,
        gridOffset: [
            -180,
            -180
        ]
    });
    if (normalize) {
        // Each part is guaranteed to be in a single copy of the world
        // Map longitudes back to [-180, 180]
        for (const part of parts){
            shiftLongitudesIntoRange(part, size);
        }
    }
    return parts;
}
function cutPolygonByMercatorBounds(positions, holeIndices = null, options) {
    const { size = 2, normalize = true, edgeTypes = false } = options || {};
    holeIndices = holeIndices || [];
    const newPositions = [];
    const newHoleIndices = [];
    let srcStartIndex = 0;
    let targetIndex = 0;
    for(let ringIndex = 0; ringIndex <= holeIndices.length; ringIndex++){
        // srcStartIndex/srcEndIndex define the ring in the original positions
        const srcEndIndex = holeIndices[ringIndex] || positions.length;
        // targetStartIndex/targetIndex define the ring in newPositions
        const targetStartIndex = targetIndex;
        // In case the ring contains a pole (e.g. Antarctica), we'll have to insert vertices
        // The insertion point is defined by the vertex closest to the pole
        // Split the the ring by the insertion point when copying to newPositions
        const splitIndex = findSplitIndex(positions, size, srcStartIndex, srcEndIndex);
        for(let i = splitIndex; i < srcEndIndex; i++){
            newPositions[targetIndex++] = positions[i];
        }
        for(let i = srcStartIndex; i < splitIndex; i++){
            newPositions[targetIndex++] = positions[i];
        }
        // Remap longitudes so that each segment takes the shorter path
        wrapLongitudesForShortestPath(newPositions, size, targetStartIndex, targetIndex);
        // Handle the case when the ring contains a pole
        insertPoleVertices(newPositions, size, targetStartIndex, targetIndex, options?.maxLatitude);
        srcStartIndex = srcEndIndex;
        newHoleIndices[ringIndex] = targetIndex;
    }
    newHoleIndices.pop();
    const parts = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$cut$2d$by$2d$grid$2e$js__$5b$client$5d$__$28$ecmascript$29$__["cutPolygonByGrid"])(newPositions, newHoleIndices, {
        size,
        gridResolution: 360,
        gridOffset: [
            -180,
            -180
        ],
        edgeTypes
    });
    if (normalize) {
        // Each part is guaranteed to be in a single copy of the world
        // Map longitudes back to [-180, 180]
        for (const part of parts){
            // @ts-expect-error (mutates readonly array) May mutate newPositions, which is created by us
            shiftLongitudesIntoRange(part.positions, size);
        }
    }
    return parts;
}
/* Helpers */ // See comments for insertPoleVertices
function findSplitIndex(positions, size, startIndex, endIndex) {
    let maxLat = -1;
    let pointIndex = -1;
    for(let i = startIndex + 1; i < endIndex; i += size){
        const lat = Math.abs(positions[i]);
        if (lat > maxLat) {
            maxLat = lat;
            pointIndex = i - 1;
        }
    }
    return pointIndex;
}
// https://user-images.githubusercontent.com/2059298/78857483-5987e400-79de-11ea-98fc-0631287a8431.png
//
// If the polygon contains a pole, to tesselate it correctly, we need to insert the edge
// of map into the polygon. This requires adding two vertices that represent the pole, by
// drawing a perpendicular line to the Mercator map edge from a selected vertex on the ring.
//
// We select the insertion position carefully so that the inserted line segments do not
// intersect with the ring itself. This is ensured by findSplitIndex, which returns the
// vertex closest to the pole.
function insertPoleVertices(positions, size, startIndex, endIndex, maxLatitude = DEFAULT_MAX_LATITUDE) {
    // Check if the ring contains a pole
    const firstLng = positions[startIndex];
    const lastLng = positions[endIndex - size];
    if (Math.abs(firstLng - lastLng) > 180) {
        // The ring does not make a round trip
        // Add the nearest pole to the vertices so that the polygon tesselates correctly
        const p = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getPointAtIndex"])(positions, 0, size, startIndex);
        // Copy the first vertex to the world of the last vertex
        p[0] += Math.round((lastLng - firstLng) / 360) * 360;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["push"])(positions, p);
        // Project the copied vertex to the edge of the map
        p[1] = Math.sign(p[1]) * maxLatitude;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["push"])(positions, p);
        // Project the first vertex to the edge of the map
        p[0] = firstLng;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["push"])(positions, p);
    }
}
function wrapLongitudesForShortestPath(positions, size, startIndex, endIndex) {
    let prevLng = positions[0];
    let lng;
    for(let i = startIndex; i < endIndex; i += size){
        lng = positions[i];
        const delta = lng - prevLng;
        if (delta > 180 || delta < -180) {
            lng -= Math.round(delta / 360) * 360;
        }
        positions[i] = prevLng = lng;
    }
}
function shiftLongitudesIntoRange(positions, size) {
    let refLng;
    const pointCount = positions.length / size;
    // Find a longitude that is not on the edge of a world
    // Which we will use to determine which world copy it is
    for(let i = 0; i < pointCount; i++){
        refLng = positions[i * size];
        if ((refLng + 180) % 360 !== 0) {
            break;
        }
    }
    const delta = -Math.round(refLng / 360) * 360;
    if (delta === 0) {
        return;
    }
    for(let i = 0; i < pointCount; i++){
        positions[i * size] += delta;
    }
} //# sourceMappingURL=cut-by-mercator-bounds.js.map
}}),
"[project]/node_modules/@math.gl/polygon/dist/index.js [client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({});
;
;
;
;
;
;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@math.gl/polygon/dist/index.js [client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$polygon$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/polygon/dist/polygon.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$polygon$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/polygon/dist/polygon-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$earcut$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/polygon/dist/earcut.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$lineclip$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/polygon/dist/lineclip.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$cut$2d$by$2d$grid$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/polygon/dist/cut-by-grid.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$cut$2d$by$2d$mercator$2d$bounds$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/polygon/dist/cut-by-mercator-bounds.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$polygon$2f$dist$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/polygon/dist/index.js [client] (ecmascript) <locals>");
}}),
"[project]/node_modules/earcut/src/earcut.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
module.exports = earcut;
module.exports.default = earcut;
function earcut(data, holeIndices, dim) {
    dim = dim || 2;
    var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev) return triangles;
    var minX, minY, maxX, maxY, x, y, invSize;
    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for(var i = dim; i < outerLen; i += dim){
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }
        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
    return triangles;
}
// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;
    if (clockwise === signedArea(data, start, end, dim) > 0) {
        for(i = start; i < end; i += dim)last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for(i = end - dim; i >= start; i -= dim)last = insertNode(i, data[i], data[i + 1], last);
    }
    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }
    return last;
}
// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;
    var p = start, again;
    do {
        again = false;
        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;
        } else {
            p = p.next;
        }
    }while (again || p !== end)
    return end;
}
// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;
    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
    var stop = ear, prev, next;
    // iterate through ears, slicing them one by one
    while(ear.prev !== ear.next){
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim | 0);
            triangles.push(ear.i / dim | 0);
            triangles.push(next.i / dim | 0);
            removeNode(ear);
            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;
            continue;
        }
        ear = next;
        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }
            break;
        }
    }
}
// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
    // now make sure we don't have other points inside the potential ear
    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
    var p = c.next;
    while(p !== a){
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }
    return true;
}
function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
    // z-order range for the current triangle bbox;
    var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
    var p = ear.prevZ, n = ear.nextZ;
    // look for points inside the triangle in both directions
    while(p && p.z >= minZ && n && n.z <= maxZ){
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }
    // look for remaining points in decreasing z-order
    while(p && p.z >= minZ){
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }
    // look for remaining points in increasing z-order
    while(n && n.z <= maxZ){
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }
    return true;
}
// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev, b = p.next.next;
        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
            triangles.push(a.i / dim | 0);
            triangles.push(p.i / dim | 0);
            triangles.push(b.i / dim | 0);
            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);
            p = start = b;
        }
        p = p.next;
    }while (p !== start)
    return filterPoints(p);
}
// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while(b !== a.prev){
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);
                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);
                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
                return;
            }
            b = b.next;
        }
        a = a.next;
    }while (a !== start)
}
// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [], i, len, start, end, list;
    for(i = 0, len = holeIndices.length; i < len; i++){
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }
    queue.sort(compareX);
    // process holes from left to right
    for(i = 0; i < queue.length; i++){
        outerNode = eliminateHole(queue[i], outerNode);
    }
    return outerNode;
}
function compareX(a, b) {
    return a.x - b.x;
}
// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    var bridge = findHoleBridge(hole, outerNode);
    if (!bridge) {
        return outerNode;
    }
    var bridgeReverse = splitPolygon(bridge, hole);
    // filter collinear points around the cuts
    filterPoints(bridgeReverse, bridgeReverse.next);
    return filterPoints(bridge, bridge.next);
}
// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                m = p.x < p.next.x ? p : p.next;
                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint
            }
        }
        p = p.next;
    }while (p !== outerNode)
    if (!m) return null;
    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point
    var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
    p = m;
    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential
            if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
                m = p;
                tanMin = tan;
            }
        }
        p = p.next;
    }while (p !== stop)
    return m;
}
// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}
// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    }while (p !== start)
    p.prevZ.nextZ = null;
    p.prevZ = null;
    sortLinked(p);
}
// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;
        while(p){
            numMerges++;
            q = p;
            pSize = 0;
            for(i = 0; i < inSize; i++){
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;
            while(pSize > 0 || qSize > 0 && q){
                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }
                if (tail) tail.nextZ = e;
                else list = e;
                e.prevZ = tail;
                tail = e;
            }
            p = q;
        }
        tail.nextZ = null;
        inSize *= 2;
    }while (numMerges > 1)
    return list;
}
// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = (x - minX) * invSize | 0;
    y = (y - minY) * invSize | 0;
    x = (x | x << 8) & 0x00FF00FF;
    x = (x | x << 4) & 0x0F0F0F0F;
    x = (x | x << 2) & 0x33333333;
    x = (x | x << 1) & 0x55555555;
    y = (y | y << 8) & 0x00FF00FF;
    y = (y | y << 4) & 0x0F0F0F0F;
    y = (y | y << 2) & 0x33333333;
    y = (y | y << 1) & 0x55555555;
    return x | y << 1;
}
// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start, leftmost = start;
    do {
        if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
        p = p.next;
    }while (p !== start)
    return leftmost;
}
// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
}
// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
    (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
    (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
    equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}
// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}
// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}
// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    var o1 = sign(area(p1, q1, p2));
    var o2 = sign(area(p1, q1, q2));
    var o3 = sign(area(p2, q2, p1));
    var o4 = sign(area(p2, q2, q1));
    if (o1 !== o2 && o3 !== o4) return true; // general case
    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2
    return false;
}
// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}
function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}
// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
        p = p.next;
    }while (p !== a)
    return false;
}
// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}
// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
    do {
        if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
        p = p.next;
    }while (p !== a)
    return inside;
}
// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
    a.next = b;
    b.prev = a;
    a2.next = an;
    an.prev = a2;
    b2.next = a2;
    a2.prev = b2;
    bp.next = b2;
    b2.prev = bp;
    return b2;
}
// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);
    if (!last) {
        p.prev = p;
        p.next = p;
    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}
function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;
    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}
function Node(i, x, y) {
    // vertex index in coordinates array
    this.i = i;
    // vertex coordinates
    this.x = x;
    this.y = y;
    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;
    // z-order curve value
    this.z = 0;
    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;
    // indicates whether this is a steiner point
    this.steiner = false;
}
// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function(data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for(var i = 0, len = holeIndices.length; i < len; i++){
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }
    var trianglesArea = 0;
    for(i = 0; i < triangles.length; i += 3){
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }
    return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
};
function signedArea(data, start, end, dim) {
    var sum = 0;
    for(var i = start, j = end - dim; i < end; i += dim){
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}
// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function(data) {
    var dim = data[0][0].length, result = {
        vertices: [],
        holes: [],
        dimensions: dim
    }, holeIndex = 0;
    for(var i = 0; i < data.length; i++){
        for(var j = 0; j < data[i].length; j++){
            for(var d = 0; d < dim; d++)result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};
}}),
"[project]/node_modules/@deck.gl/geo-layers/dist/tileset-2d/tile-2d-header.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "Tile2DHeader": (()=>Tile2DHeader)
});
class Tile2DHeader {
    constructor(index){
        this.index = index;
        this.isVisible = false;
        this.isSelected = false;
        this.parent = null;
        this.children = [];
        this.content = null;
        this._loader = undefined;
        this._abortController = null;
        this._loaderId = 0;
        this._isLoaded = false;
        this._isCancelled = false;
        this._needsReload = false;
    }
    /** @deprecated use `boundingBox` instead */ get bbox() {
        return this._bbox;
    }
    // TODO - remove in v9
    set bbox(value) {
        // Only set once from `Tileset2D.getTileMetadata`
        if (this._bbox) return;
        this._bbox = value;
        if ('west' in value) {
            this.boundingBox = [
                [
                    value.west,
                    value.south
                ],
                [
                    value.east,
                    value.north
                ]
            ];
        } else {
            this.boundingBox = [
                [
                    value.left,
                    value.top
                ],
                [
                    value.right,
                    value.bottom
                ]
            ];
        }
    }
    get data() {
        return this.isLoading && this._loader ? this._loader.then(()=>this.data) : this.content;
    }
    get isLoaded() {
        return this._isLoaded && !this._needsReload;
    }
    get isLoading() {
        return Boolean(this._loader) && !this._isCancelled;
    }
    get needsReload() {
        return this._needsReload || this._isCancelled;
    }
    get byteLength() {
        const result = this.content ? this.content.byteLength : 0;
        if (!Number.isFinite(result)) {
            // eslint-disable-next-line no-console
            console.error('byteLength not defined in tile data');
        }
        return result;
    }
    /* eslint-disable max-statements */ async _loadData({ getData, requestScheduler, onLoad, onError }) {
        const { index, id, bbox, userData, zoom } = this;
        const loaderId = this._loaderId;
        this._abortController = new AbortController();
        const { signal } = this._abortController;
        // @ts-expect-error (2345) Argument of type '(tile: any) => 1 | -1' is not assignable ...
        const requestToken = await requestScheduler.scheduleRequest(this, (tile)=>{
            return tile.isSelected ? 1 : -1;
        });
        if (!requestToken) {
            this._isCancelled = true;
            return;
        }
        // A tile can be cancelled while being scheduled
        if (this._isCancelled) {
            requestToken.done();
            return;
        }
        let tileData = null;
        let error;
        try {
            tileData = await getData({
                index,
                id,
                bbox,
                userData,
                zoom,
                signal
            });
        } catch (err) {
            error = err || true;
        } finally{
            requestToken.done();
        }
        // If loadData has been called with a newer version, discard the result from this operation
        if (loaderId !== this._loaderId) {
            return;
        }
        // Clear the `isLoading` flag
        this._loader = undefined;
        // Rewrite tile content with the result of getTileData if successful, or `null` in case of
        // error or cancellation
        this.content = tileData;
        // If cancelled, do not invoke the callbacks
        // Consider it loaded if we tried to cancel but `getTileData` still returned data
        if (this._isCancelled && !tileData) {
            this._isLoaded = false;
            return;
        }
        this._isLoaded = true;
        this._isCancelled = false;
        if (error) {
            onError(error, this);
        } else {
            onLoad(this);
        }
    }
    loadData(opts) {
        this._isLoaded = false;
        this._isCancelled = false;
        this._needsReload = false;
        this._loaderId++;
        this._loader = this._loadData(opts);
        return this._loader;
    }
    setNeedsReload() {
        if (this.isLoading) {
            this.abort();
            this._loader = undefined;
        }
        this._needsReload = true;
    }
    abort() {
        if (this.isLoaded) {
            return;
        }
        this._isCancelled = true;
        this._abortController?.abort();
    }
} //# sourceMappingURL=tile-2d-header.js.map
}}),
"[project]/node_modules/@deck.gl/geo-layers/dist/tileset-2d/tile-2d-traversal.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "getOSMTileIndices": (()=>getOSMTileIndices)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$viewports$2f$web$2d$mercator$2d$viewport$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__WebMercatorViewport$3e$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/core/dist/viewports/web-mercator-viewport.js [client] (ecmascript) <export default as WebMercatorViewport>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$viewports$2f$globe$2d$viewport$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__$5f$GlobeViewport$3e$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/core/dist/viewports/globe-viewport.js [client] (ecmascript) <export default as _GlobeViewport>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/index.js [client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$culling$2d$volume$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/culling-volume.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$plane$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/plane.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$bounding$2d$volumes$2f$axis$2d$aligned$2d$bounding$2d$box$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/bounding-volumes/axis-aligned-bounding-box.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$algorithms$2f$bounding$2d$box$2d$from$2d$points$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/algorithms/bounding-box-from-points.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/index.js [client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/web-mercator-utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/geo-layers/dist/tileset-2d/utils.js [client] (ecmascript)");
;
;
;
;
const TILE_SIZE = 512;
// number of world copies to check
const MAX_MAPS = 3;
// for calculating bounding volume of a tile in a non-web-mercator viewport
const REF_POINTS_5 = [
    [
        0.5,
        0.5
    ],
    [
        0,
        0
    ],
    [
        0,
        1
    ],
    [
        1,
        0
    ],
    [
        1,
        1
    ]
]; // 4 corners and center
const REF_POINTS_9 = REF_POINTS_5.concat([
    [
        0,
        0.5
    ],
    [
        0.5,
        0
    ],
    [
        1,
        0.5
    ],
    [
        0.5,
        1
    ]
]); // 4 corners, center and 4 mid points
const REF_POINTS_11 = REF_POINTS_9.concat([
    [
        0.25,
        0.5
    ],
    [
        0.75,
        0.5
    ]
]); // 2 additional points on equator for top tile
class OSMNode {
    constructor(x, y, z){
        this.x = x;
        this.y = y;
        this.z = z;
    }
    get children() {
        if (!this._children) {
            const x = this.x * 2;
            const y = this.y * 2;
            const z = this.z + 1;
            this._children = [
                new OSMNode(x, y, z),
                new OSMNode(x, y + 1, z),
                new OSMNode(x + 1, y, z),
                new OSMNode(x + 1, y + 1, z)
            ];
        }
        return this._children;
    }
    // eslint-disable-next-line complexity
    update(params) {
        const { viewport, cullingVolume, elevationBounds, minZ, maxZ, bounds, offset, project } = params;
        const boundingVolume = this.getBoundingVolume(elevationBounds, offset, project);
        // First, check if this tile is visible
        if (bounds && !this.insideBounds(bounds)) {
            return false;
        }
        const isInside = cullingVolume.computeVisibility(boundingVolume);
        if (isInside < 0) {
            return false;
        }
        // Avoid loading overlapping tiles - if a descendant is requested, do not request the ancester
        if (!this.childVisible) {
            let { z } = this;
            if (z < maxZ && z >= minZ) {
                // Adjust LOD
                // If the tile is far enough from the camera, accept a lower zoom level
                const distance = boundingVolume.distanceTo(viewport.cameraPosition) * viewport.scale / viewport.height;
                z += Math.floor(Math.log2(distance));
            }
            if (z >= maxZ) {
                // LOD is acceptable
                this.selected = true;
                return true;
            }
        }
        // LOD is not enough, recursively test child tiles
        this.selected = false;
        this.childVisible = true;
        for (const child of this.children){
            child.update(params);
        }
        return true;
    }
    getSelected(result = []) {
        if (this.selected) {
            result.push(this);
        }
        if (this._children) {
            for (const node of this._children){
                node.getSelected(result);
            }
        }
        return result;
    }
    insideBounds([minX, minY, maxX, maxY]) {
        const scale = Math.pow(2, this.z);
        const extent = TILE_SIZE / scale;
        return this.x * extent < maxX && this.y * extent < maxY && (this.x + 1) * extent > minX && (this.y + 1) * extent > minY;
    }
    getBoundingVolume(zRange, worldOffset, project) {
        if (project) {
            // Custom projection
            // Estimate bounding box from sample points
            // At low zoom level we need more samples to calculate the bounding volume correctly
            const refPoints = this.z < 1 ? REF_POINTS_11 : this.z < 2 ? REF_POINTS_9 : REF_POINTS_5;
            // Convert from tile-relative coordinates to common space
            const refPointPositions = [];
            for (const p of refPoints){
                const lngLat = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["osmTile2lngLat"])(this.x + p[0], this.y + p[1], this.z);
                lngLat[2] = zRange[0];
                refPointPositions.push(project(lngLat));
                if (zRange[0] !== zRange[1]) {
                    // Account for the elevation volume
                    lngLat[2] = zRange[1];
                    refPointPositions.push(project(lngLat));
                }
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$algorithms$2f$bounding$2d$box$2d$from$2d$points$2e$js__$5b$client$5d$__$28$ecmascript$29$__["makeOrientedBoundingBoxFromPoints"])(refPointPositions);
        }
        // Use WebMercator projection
        const scale = Math.pow(2, this.z);
        const extent = TILE_SIZE / scale;
        const originX = this.x * extent + worldOffset * TILE_SIZE;
        // deck's common space is y-flipped
        const originY = TILE_SIZE - (this.y + 1) * extent;
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$bounding$2d$volumes$2f$axis$2d$aligned$2d$bounding$2d$box$2e$js__$5b$client$5d$__$28$ecmascript$29$__["AxisAlignedBoundingBox"]([
            originX,
            originY,
            zRange[0]
        ], [
            originX + extent,
            originY + extent,
            zRange[1]
        ]);
    }
}
function getOSMTileIndices(viewport, maxZ, zRange, bounds) {
    const project = viewport instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$viewports$2f$globe$2d$viewport$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__$5f$GlobeViewport$3e$__["_GlobeViewport"] && viewport.resolution ? viewport.projectPosition : null;
    // Get the culling volume of the current camera
    const planes = Object.values(viewport.getFrustumPlanes()).map(({ normal, distance })=>new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$plane$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Plane"](normal.clone().negate(), distance));
    const cullingVolume = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$culling$2d$volume$2e$js__$5b$client$5d$__$28$ecmascript$29$__["CullingVolume"](planes);
    // Project zRange from meters to common space
    const unitsPerMeter = viewport.distanceScales.unitsPerMeter[2];
    const elevationMin = zRange && zRange[0] * unitsPerMeter || 0;
    const elevationMax = zRange && zRange[1] * unitsPerMeter || 0;
    // Always load at the current zoom level if pitch is small
    const minZ = viewport instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$viewports$2f$web$2d$mercator$2d$viewport$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__WebMercatorViewport$3e$__["WebMercatorViewport"] && viewport.pitch <= 60 ? maxZ : 0;
    // Map extent to OSM position
    if (bounds) {
        const [minLng, minLat, maxLng, maxLat] = bounds;
        const topLeft = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["lngLatToWorld"])([
            minLng,
            maxLat
        ]);
        const bottomRight = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["lngLatToWorld"])([
            maxLng,
            minLat
        ]);
        bounds = [
            topLeft[0],
            TILE_SIZE - topLeft[1],
            bottomRight[0],
            TILE_SIZE - bottomRight[1]
        ];
    }
    const root = new OSMNode(0, 0, 0);
    const traversalParams = {
        viewport,
        project,
        cullingVolume,
        elevationBounds: [
            elevationMin,
            elevationMax
        ],
        minZ,
        maxZ,
        bounds,
        // num. of worlds from the center. For repeated maps
        offset: 0
    };
    root.update(traversalParams);
    if (viewport instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$viewports$2f$web$2d$mercator$2d$viewport$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__WebMercatorViewport$3e$__["WebMercatorViewport"] && viewport.subViewports && viewport.subViewports.length > 1) {
        // Check worlds in repeated maps
        traversalParams.offset = -1;
        while(root.update(traversalParams)){
            if (--traversalParams.offset < -MAX_MAPS) {
                break;
            }
        }
        traversalParams.offset = 1;
        while(root.update(traversalParams)){
            if (++traversalParams.offset > MAX_MAPS) {
                break;
            }
        }
    }
    return root.getSelected();
} //# sourceMappingURL=tile-2d-traversal.js.map
}}),
"[project]/node_modules/@deck.gl/geo-layers/dist/tileset-2d/utils.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "getCullBounds": (()=>getCullBounds),
    "getTileIndices": (()=>getTileIndices),
    "getURLFromTemplate": (()=>getURLFromTemplate),
    "isGeoBoundingBox": (()=>isGeoBoundingBox),
    "isURLTemplate": (()=>isURLTemplate),
    "osmTile2lngLat": (()=>osmTile2lngLat),
    "tileToBoundingBox": (()=>tileToBoundingBox),
    "urlType": (()=>urlType)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$tile$2d$2d$2d$traversal$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/geo-layers/dist/tileset-2d/tile-2d-traversal.js [client] (ecmascript)");
;
const TILE_SIZE = 512;
const DEFAULT_EXTENT = [
    -Infinity,
    -Infinity,
    Infinity,
    Infinity
];
const urlType = {
    type: 'object',
    value: null,
    validate: (value, propType)=>propType.optional && value === null || typeof value === 'string' || Array.isArray(value) && value.every((url)=>typeof url === 'string'),
    equal: (value1, value2)=>{
        if (value1 === value2) {
            return true;
        }
        if (!Array.isArray(value1) || !Array.isArray(value2)) {
            return false;
        }
        const len = value1.length;
        if (len !== value2.length) {
            return false;
        }
        for(let i = 0; i < len; i++){
            if (value1[i] !== value2[i]) {
                return false;
            }
        }
        return true;
    }
};
function transformBox(bbox, modelMatrix) {
    const transformedCoords = [
        // top-left
        modelMatrix.transformAsPoint([
            bbox[0],
            bbox[1]
        ]),
        // top-right
        modelMatrix.transformAsPoint([
            bbox[2],
            bbox[1]
        ]),
        // bottom-left
        modelMatrix.transformAsPoint([
            bbox[0],
            bbox[3]
        ]),
        // bottom-right
        modelMatrix.transformAsPoint([
            bbox[2],
            bbox[3]
        ])
    ];
    const transformedBox = [
        // Minimum x coord
        Math.min(...transformedCoords.map((i)=>i[0])),
        // Minimum y coord
        Math.min(...transformedCoords.map((i)=>i[1])),
        // Max x coord
        Math.max(...transformedCoords.map((i)=>i[0])),
        // Max y coord
        Math.max(...transformedCoords.map((i)=>i[1]))
    ];
    return transformedBox;
}
function stringHash(s) {
    return Math.abs(s.split('').reduce((a, b)=>(a << 5) - a + b.charCodeAt(0) | 0, 0));
}
function getURLFromTemplate(template, tile) {
    if (!template || !template.length) {
        return null;
    }
    const { index, id } = tile;
    if (Array.isArray(template)) {
        const i = stringHash(id) % template.length;
        template = template[i];
    }
    let url = template;
    for (const key of Object.keys(index)){
        const regex = new RegExp(`{${key}}`, 'g');
        url = url.replace(regex, String(index[key]));
    }
    // Back-compatible support for {-y}
    if (Number.isInteger(index.y) && Number.isInteger(index.z)) {
        url = url.replace(/\{-y\}/g, String(Math.pow(2, index.z) - index.y - 1));
    }
    return url;
}
/**
 * gets the bounding box of a viewport
 */ function getBoundingBox(viewport, zRange, extent) {
    let bounds;
    if (zRange && zRange.length === 2) {
        const [minZ, maxZ] = zRange;
        const bounds0 = viewport.getBounds({
            z: minZ
        });
        const bounds1 = viewport.getBounds({
            z: maxZ
        });
        bounds = [
            Math.min(bounds0[0], bounds1[0]),
            Math.min(bounds0[1], bounds1[1]),
            Math.max(bounds0[2], bounds1[2]),
            Math.max(bounds0[3], bounds1[3])
        ];
    } else {
        bounds = viewport.getBounds();
    }
    if (!viewport.isGeospatial) {
        return [
            // Top corner should not be more then bottom corner in either direction
            Math.max(Math.min(bounds[0], extent[2]), extent[0]),
            Math.max(Math.min(bounds[1], extent[3]), extent[1]),
            // Bottom corner should not be less then top corner in either direction
            Math.min(Math.max(bounds[2], extent[0]), extent[2]),
            Math.min(Math.max(bounds[3], extent[1]), extent[3])
        ];
    }
    return [
        Math.max(bounds[0], extent[0]),
        Math.max(bounds[1], extent[1]),
        Math.min(bounds[2], extent[2]),
        Math.min(bounds[3], extent[3])
    ];
}
function getCullBounds({ viewport, z, cullRect }) {
    const subViewports = viewport.subViewports || [
        viewport
    ];
    return subViewports.map((v)=>getCullBoundsInViewport(v, z || 0, cullRect));
}
function getCullBoundsInViewport(/** Current viewport */ viewport, /** At altitude */ z, /** Culling rectangle in screen space */ cullRect) {
    if (!Array.isArray(z)) {
        const x = cullRect.x - viewport.x;
        const y = cullRect.y - viewport.y;
        const { width, height } = cullRect;
        const unprojectOption = {
            targetZ: z
        };
        const topLeft = viewport.unproject([
            x,
            y
        ], unprojectOption);
        const topRight = viewport.unproject([
            x + width,
            y
        ], unprojectOption);
        const bottomLeft = viewport.unproject([
            x,
            y + height
        ], unprojectOption);
        const bottomRight = viewport.unproject([
            x + width,
            y + height
        ], unprojectOption);
        return [
            Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),
            Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]),
            Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),
            Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])
        ];
    }
    const bounds0 = getCullBoundsInViewport(viewport, z[0], cullRect);
    const bounds1 = getCullBoundsInViewport(viewport, z[1], cullRect);
    return [
        Math.min(bounds0[0], bounds1[0]),
        Math.min(bounds0[1], bounds1[1]),
        Math.max(bounds0[2], bounds1[2]),
        Math.max(bounds0[3], bounds1[3])
    ];
}
function getIndexingCoords(bbox, scale, modelMatrixInverse) {
    if (modelMatrixInverse) {
        const transformedTileIndex = transformBox(bbox, modelMatrixInverse).map((i)=>i * scale / TILE_SIZE);
        return transformedTileIndex;
    }
    return bbox.map((i)=>i * scale / TILE_SIZE);
}
function getScale(z, tileSize) {
    return Math.pow(2, z) * TILE_SIZE / tileSize;
}
function osmTile2lngLat(x, y, z) {
    const scale = getScale(z, TILE_SIZE);
    const lng = x / scale * 360 - 180;
    const n = Math.PI - 2 * Math.PI * y / scale;
    const lat = 180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
    return [
        lng,
        lat
    ];
}
function tile2XY(x, y, z, tileSize) {
    const scale = getScale(z, tileSize);
    return [
        x / scale * TILE_SIZE,
        y / scale * TILE_SIZE
    ];
}
function tileToBoundingBox(viewport, x, y, z, tileSize = TILE_SIZE) {
    if (viewport.isGeospatial) {
        const [west, north] = osmTile2lngLat(x, y, z);
        const [east, south] = osmTile2lngLat(x + 1, y + 1, z);
        return {
            west,
            north,
            east,
            south
        };
    }
    const [left, top] = tile2XY(x, y, z, tileSize);
    const [right, bottom] = tile2XY(x + 1, y + 1, z, tileSize);
    return {
        left,
        top,
        right,
        bottom
    };
}
function getIdentityTileIndices(viewport, z, tileSize, extent, modelMatrixInverse) {
    const bbox = getBoundingBox(viewport, null, extent);
    const scale = getScale(z, tileSize);
    const [minX, minY, maxX, maxY] = getIndexingCoords(bbox, scale, modelMatrixInverse);
    const indices = [];
    /*
        |  TILE  |  TILE  |  TILE  |
          |(minX)            |(maxX)
     */ for(let x = Math.floor(minX); x < maxX; x++){
        for(let y = Math.floor(minY); y < maxY; y++){
            indices.push({
                x,
                y,
                z
            });
        }
    }
    return indices;
}
function getTileIndices({ viewport, maxZoom, minZoom, zRange, extent, tileSize = TILE_SIZE, modelMatrix, modelMatrixInverse, zoomOffset = 0 }) {
    let z = viewport.isGeospatial ? Math.round(viewport.zoom + Math.log2(TILE_SIZE / tileSize)) + zoomOffset : Math.ceil(viewport.zoom) + zoomOffset;
    if (typeof minZoom === 'number' && Number.isFinite(minZoom) && z < minZoom) {
        if (!extent) {
            return [];
        }
        z = minZoom;
    }
    if (typeof maxZoom === 'number' && Number.isFinite(maxZoom) && z > maxZoom) {
        z = maxZoom;
    }
    let transformedExtent = extent;
    if (modelMatrix && modelMatrixInverse && extent && !viewport.isGeospatial) {
        transformedExtent = transformBox(extent, modelMatrix);
    }
    return viewport.isGeospatial ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$tile$2d$2d$2d$traversal$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getOSMTileIndices"])(viewport, z, zRange, extent) : getIdentityTileIndices(viewport, z, tileSize, transformedExtent || DEFAULT_EXTENT, modelMatrixInverse);
}
function isURLTemplate(s) {
    return /(?=.*{z})(?=.*{x})(?=.*({y}|{-y}))/.test(s);
}
function isGeoBoundingBox(v) {
    return Number.isFinite(v.west) && Number.isFinite(v.north) && Number.isFinite(v.east) && Number.isFinite(v.south);
} //# sourceMappingURL=utils.js.map
}}),
"[project]/node_modules/@deck.gl/geo-layers/dist/tileset-2d/memoize.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
// deck.gl, MIT license
// @note - this is a duplicate of the deck.gl core export (because Tileset2D should be deck.gl independent)
/**
 * Speed up consecutive function calls by caching the result of calls with identical input
 * https://en.wikipedia.org/wiki/Memoization
 * @param compute - the function to be memoized
 */ __turbopack_context__.s({
    "memoize": (()=>memoize)
});
function memoize(compute) {
    let cachedArgs = {};
    let cachedResult;
    return (args)=>{
        for(const key in args){
            if (!isEqual(args[key], cachedArgs[key])) {
                cachedResult = compute(args);
                cachedArgs = args;
                break;
            }
        }
        return cachedResult;
    };
}
function isEqual(a, b) {
    if (a === b) {
        return true;
    }
    if (Array.isArray(a)) {
        // Special treatment for arrays: compare 1-level deep
        // This is to support equality of matrix/coordinate props
        const len = a.length;
        if (!b || b.length !== len) {
            return false;
        }
        for(let i = 0; i < len; i++){
            if (a[i] !== b[i]) {
                return false;
            }
        }
        return true;
    }
    return false;
} //# sourceMappingURL=memoize.js.map
}}),
"[project]/node_modules/@deck.gl/geo-layers/dist/tileset-2d/tileset-2d.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "DEFAULT_TILESET2D_PROPS": (()=>DEFAULT_TILESET2D_PROPS),
    "STRATEGY_DEFAULT": (()=>STRATEGY_DEFAULT),
    "STRATEGY_NEVER": (()=>STRATEGY_NEVER),
    "STRATEGY_REPLACE": (()=>STRATEGY_REPLACE),
    "Tileset2D": (()=>Tileset2D)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$request$2d$utils$2f$request$2d$scheduler$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__RequestScheduler$3e$__ = __turbopack_context__.i("[project]/node_modules/@loaders.gl/loader-utils/dist/lib/request-utils/request-scheduler.js [client] (ecmascript) <export default as RequestScheduler>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix4$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/classes/matrix4.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$common$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/lib/common.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$tile$2d$2d$2d$header$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/geo-layers/dist/tileset-2d/tile-2d-header.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/geo-layers/dist/tileset-2d/utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$memoize$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/geo-layers/dist/tileset-2d/memoize.js [client] (ecmascript)");
;
;
;
;
;
// bit masks
const TILE_STATE_VISITED = 1;
const TILE_STATE_VISIBLE = 2;
const STRATEGY_NEVER = 'never';
const STRATEGY_REPLACE = 'no-overlap';
const STRATEGY_DEFAULT = 'best-available';
const DEFAULT_CACHE_SCALE = 5;
const STRATEGIES = {
    [STRATEGY_DEFAULT]: updateTileStateDefault,
    [STRATEGY_REPLACE]: updateTileStateReplace,
    [STRATEGY_NEVER]: ()=>{}
};
const DEFAULT_TILESET2D_PROPS = {
    extent: null,
    tileSize: 512,
    maxZoom: null,
    minZoom: null,
    maxCacheSize: null,
    maxCacheByteSize: null,
    refinementStrategy: 'best-available',
    zRange: null,
    maxRequests: 6,
    debounceTime: 0,
    zoomOffset: 0,
    // onTileLoad: (tile: Tile2DHeader) => void,  // onTileUnload: (tile: Tile2DHeader) => void,  // onTileError: (error: any, tile: Tile2DHeader) => void,  /** Called when all tiles in the current viewport are loaded. */
    // onViewportLoad: ((tiles: Tile2DHeader<DataT>[]) => void) | null,
    onTileLoad: ()=>{},
    onTileUnload: ()=>{},
    onTileError: ()=>{}
};
class Tileset2D {
    /**
     * Takes in a function that returns tile data, a cache size, and a max and a min zoom level.
     * Cache size defaults to 5 * number of tiles in the current viewport
     */ constructor(opts){
        /* Private methods */ this._getCullBounds = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$memoize$2e$js__$5b$client$5d$__$28$ecmascript$29$__["memoize"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getCullBounds"]);
        this.opts = {
            ...DEFAULT_TILESET2D_PROPS,
            ...opts
        };
        this.setOptions(this.opts);
        this.onTileLoad = (tile)=>{
            this.opts.onTileLoad?.(tile);
            if (this.opts.maxCacheByteSize !== null) {
                this._cacheByteSize += tile.byteLength;
                this._resizeCache();
            }
        };
        this._requestScheduler = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$loaders$2e$gl$2f$loader$2d$utils$2f$dist$2f$lib$2f$request$2d$utils$2f$request$2d$scheduler$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__RequestScheduler$3e$__["RequestScheduler"]({
            throttleRequests: this.opts.maxRequests > 0 || this.opts.debounceTime > 0,
            maxRequests: this.opts.maxRequests,
            debounceTime: this.opts.debounceTime
        });
        // Maps tile id in string {z}-{x}-{y} to a Tile object
        this._cache = new Map();
        this._tiles = [];
        this._dirty = false;
        this._cacheByteSize = 0;
        // Cache the last processed viewport
        this._viewport = null;
        this._zRange = null;
        this._selectedTiles = null;
        this._frameNumber = 0;
        this._modelMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix4$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix4"]();
        this._modelMatrixInverse = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix4$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix4"]();
    }
    /* Public API */ get tiles() {
        return this._tiles;
    }
    get selectedTiles() {
        return this._selectedTiles;
    }
    get isLoaded() {
        return this._selectedTiles !== null && this._selectedTiles.every((tile)=>tile.isLoaded);
    }
    get needsReload() {
        return this._selectedTiles !== null && this._selectedTiles.some((tile)=>tile.needsReload);
    }
    setOptions(opts) {
        Object.assign(this.opts, opts);
        if (Number.isFinite(opts.maxZoom)) {
            this._maxZoom = Math.floor(opts.maxZoom);
        }
        if (Number.isFinite(opts.minZoom)) {
            this._minZoom = Math.ceil(opts.minZoom);
        }
    }
    // Clean up any outstanding tile requests.
    finalize() {
        for (const tile of this._cache.values()){
            if (tile.isLoading) {
                tile.abort();
            }
        }
        this._cache.clear();
        this._tiles = [];
        this._selectedTiles = null;
    }
    reloadAll() {
        for (const id of this._cache.keys()){
            const tile = this._cache.get(id);
            if (!this._selectedTiles || !this._selectedTiles.includes(tile)) {
                this._cache.delete(id);
            } else {
                tile.setNeedsReload();
            }
        }
    }
    /**
     * Update the cache with the given viewport and model matrix and triggers callback onUpdate.
     */ update(viewport, { zRange, modelMatrix } = {
        zRange: null,
        modelMatrix: null
    }) {
        const modelMatrixAsMatrix4 = modelMatrix ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix4$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix4"](modelMatrix) : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix4$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix4"]();
        const isModelMatrixNew = !modelMatrixAsMatrix4.equals(this._modelMatrix);
        if (!this._viewport || !viewport.equals(this._viewport) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$common$2e$js__$5b$client$5d$__$28$ecmascript$29$__["equals"])(this._zRange, zRange) || isModelMatrixNew) {
            if (isModelMatrixNew) {
                this._modelMatrixInverse = modelMatrixAsMatrix4.clone().invert();
                this._modelMatrix = modelMatrixAsMatrix4;
            }
            this._viewport = viewport;
            this._zRange = zRange;
            const tileIndices = this.getTileIndices({
                viewport,
                maxZoom: this._maxZoom,
                minZoom: this._minZoom,
                zRange,
                modelMatrix: this._modelMatrix,
                modelMatrixInverse: this._modelMatrixInverse
            });
            this._selectedTiles = tileIndices.map((index)=>this._getTile(index, true));
            if (this._dirty) {
                // Some new tiles are added
                this._rebuildTree();
            }
        // Check for needed reloads explicitly even if the view/matrix has not changed.
        } else if (this.needsReload) {
            this._selectedTiles = this._selectedTiles.map((tile)=>this._getTile(tile.index, true));
        }
        // Update tile states
        const changed = this.updateTileStates();
        this._pruneRequests();
        if (this._dirty) {
            // cache size is either the user defined maxSize or 5 * number of current tiles in the viewport.
            this._resizeCache();
        }
        if (changed) {
            this._frameNumber++;
        }
        return this._frameNumber;
    }
    // eslint-disable-next-line complexity
    isTileVisible(tile, cullRect) {
        if (!tile.isVisible) {
            return false;
        }
        if (cullRect && this._viewport) {
            const boundsArr = this._getCullBounds({
                viewport: this._viewport,
                z: this._zRange,
                cullRect
            });
            const { bbox } = tile;
            for (const [minX, minY, maxX, maxY] of boundsArr){
                let overlaps;
                if ('west' in bbox) {
                    overlaps = bbox.west < maxX && bbox.east > minX && bbox.south < maxY && bbox.north > minY;
                } else {
                    // top/bottom could be swapped depending on the indexing system
                    const y0 = Math.min(bbox.top, bbox.bottom);
                    const y1 = Math.max(bbox.top, bbox.bottom);
                    overlaps = bbox.left < maxX && bbox.right > minX && y0 < maxY && y1 > minY;
                }
                if (overlaps) {
                    return true;
                }
            }
            return false;
        }
        return true;
    }
    /* Public interface for subclassing */ /** Returns array of tile indices in the current viewport */ getTileIndices({ viewport, maxZoom, minZoom, zRange, modelMatrix, modelMatrixInverse }) {
        const { tileSize, extent, zoomOffset } = this.opts;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getTileIndices"])({
            viewport,
            maxZoom,
            minZoom,
            zRange,
            tileSize,
            extent: extent,
            modelMatrix,
            modelMatrixInverse,
            zoomOffset
        });
    }
    /** Returns unique string key for a tile index */ getTileId(index) {
        return `${index.x}-${index.y}-${index.z}`;
    }
    /** Returns a zoom level for a tile index */ getTileZoom(index) {
        return index.z;
    }
    /** Returns additional metadata to add to tile, bbox by default */ getTileMetadata(index) {
        const { tileSize } = this.opts;
        return {
            bbox: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["tileToBoundingBox"])(this._viewport, index.x, index.y, index.z, tileSize)
        };
    }
    /** Returns index of the parent tile */ getParentIndex(index) {
        const x = Math.floor(index.x / 2);
        const y = Math.floor(index.y / 2);
        const z = index.z - 1;
        return {
            x,
            y,
            z
        };
    }
    // Returns true if any tile's visibility changed
    updateTileStates() {
        const refinementStrategy = this.opts.refinementStrategy || STRATEGY_DEFAULT;
        const visibilities = new Array(this._cache.size);
        let i = 0;
        // Reset state
        for (const tile of this._cache.values()){
            // save previous state
            visibilities[i++] = tile.isVisible;
            tile.isSelected = false;
            tile.isVisible = false;
        }
        // @ts-expect-error called only when _selectedTiles is already defined
        for (const tile of this._selectedTiles){
            tile.isSelected = true;
            tile.isVisible = true;
        }
        // Strategy-specific state logic
        (typeof refinementStrategy === 'function' ? refinementStrategy : STRATEGIES[refinementStrategy])(Array.from(this._cache.values()));
        i = 0;
        // Check if any visibility has changed
        for (const tile of this._cache.values()){
            if (visibilities[i++] !== tile.isVisible) {
                return true;
            }
        }
        return false;
    }
    _pruneRequests() {
        const { maxRequests = 0 } = this.opts;
        const abortCandidates = [];
        let ongoingRequestCount = 0;
        for (const tile of this._cache.values()){
            // Keep track of all the ongoing requests
            if (tile.isLoading) {
                ongoingRequestCount++;
                if (!tile.isSelected && !tile.isVisible) {
                    abortCandidates.push(tile);
                }
            }
        }
        while(maxRequests > 0 && ongoingRequestCount > maxRequests && abortCandidates.length > 0){
            // There are too many ongoing requests, so abort some that are unselected
            const tile = abortCandidates.shift();
            tile.abort();
            ongoingRequestCount--;
        }
    }
    // This needs to be called every time some tiles have been added/removed from cache
    _rebuildTree() {
        const { _cache } = this;
        // Reset states
        for (const tile of _cache.values()){
            tile.parent = null;
            if (tile.children) {
                tile.children.length = 0;
            }
        }
        // Rebuild tree
        for (const tile of _cache.values()){
            const parent = this._getNearestAncestor(tile);
            tile.parent = parent;
            if (parent?.children) {
                parent.children.push(tile);
            }
        }
    }
    /**
     * Clear tiles that are not visible when the cache is full
     */ /* eslint-disable complexity */ _resizeCache() {
        const { _cache, opts } = this;
        const maxCacheSize = opts.maxCacheSize ?? // @ts-expect-error called only when selectedTiles is initialized
        (opts.maxCacheByteSize !== null ? Infinity : DEFAULT_CACHE_SCALE * this.selectedTiles.length);
        const maxCacheByteSize = opts.maxCacheByteSize ?? Infinity;
        const overflown = _cache.size > maxCacheSize || this._cacheByteSize > maxCacheByteSize;
        if (overflown) {
            for (const [id, tile] of _cache){
                if (!tile.isVisible && !tile.isSelected) {
                    // delete tile
                    this._cacheByteSize -= opts.maxCacheByteSize !== null ? tile.byteLength : 0;
                    _cache.delete(id);
                    this.opts.onTileUnload?.(tile);
                }
                if (_cache.size <= maxCacheSize && this._cacheByteSize <= maxCacheByteSize) {
                    break;
                }
            }
            this._rebuildTree();
            this._dirty = true;
        }
        if (this._dirty) {
            // sort by zoom level so that smaller tiles are displayed on top
            this._tiles = Array.from(this._cache.values()).sort((t1, t2)=>t1.zoom - t2.zoom);
            this._dirty = false;
        }
    }
    _getTile(index, create) {
        const id = this.getTileId(index);
        let tile = this._cache.get(id);
        let needsReload = false;
        if (!tile && create) {
            tile = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$tile$2d$2d$2d$header$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Tile2DHeader"](index);
            Object.assign(tile, this.getTileMetadata(tile.index));
            Object.assign(tile, {
                id,
                zoom: this.getTileZoom(tile.index)
            });
            needsReload = true;
            this._cache.set(id, tile);
            this._dirty = true;
        } else if (tile && tile.needsReload) {
            needsReload = true;
        }
        if (tile && needsReload) {
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            tile.loadData({
                getData: this.opts.getTileData,
                requestScheduler: this._requestScheduler,
                onLoad: this.onTileLoad,
                onError: this.opts.onTileError
            });
        }
        return tile;
    }
    _getNearestAncestor(tile) {
        const { _minZoom = 0 } = this;
        let index = tile.index;
        while(this.getTileZoom(index) > _minZoom){
            index = this.getParentIndex(index);
            const parent = this._getTile(index);
            if (parent) {
                return parent;
            }
        }
        return null;
    }
}
/* -- Refinement strategies --*/ /* eslint-disable max-depth */ // For all the selected && pending tiles:
// - pick the closest ancestor as placeholder
// - if no ancestor is visible, pick the closest children as placeholder
function updateTileStateDefault(allTiles) {
    for (const tile of allTiles){
        tile.state = 0;
    }
    for (const tile of allTiles){
        if (tile.isSelected && !getPlaceholderInAncestors(tile)) {
            getPlaceholderInChildren(tile);
        }
    }
    for (const tile of allTiles){
        tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);
    }
}
// Until a selected tile and all its selected siblings are loaded, use the closest ancestor as placeholder
function updateTileStateReplace(allTiles) {
    for (const tile of allTiles){
        tile.state = 0;
    }
    for (const tile of allTiles){
        if (tile.isSelected) {
            getPlaceholderInAncestors(tile);
        }
    }
    // Always process parents first
    const sortedTiles = Array.from(allTiles).sort((t1, t2)=>t1.zoom - t2.zoom);
    for (const tile of sortedTiles){
        tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);
        if (tile.children && (tile.isVisible || tile.state & TILE_STATE_VISITED)) {
            // If the tile is rendered, or if the tile has been explicitly hidden, hide all of its children
            for (const child of tile.children){
                child.state = TILE_STATE_VISITED;
            }
        } else if (tile.isSelected) {
            getPlaceholderInChildren(tile);
        }
    }
}
// Walk up the tree until we find one ancestor that is loaded. Returns true if successful.
function getPlaceholderInAncestors(startTile) {
    let tile = startTile;
    while(tile){
        if (tile.isLoaded || tile.content) {
            tile.state |= TILE_STATE_VISIBLE;
            return true;
        }
        tile = tile.parent;
    }
    return false;
}
// Recursively set children as placeholder
function getPlaceholderInChildren(tile) {
    for (const child of tile.children){
        if (child.isLoaded || child.content) {
            child.state |= TILE_STATE_VISIBLE;
        } else {
            getPlaceholderInChildren(child);
        }
    }
} //# sourceMappingURL=tileset-2d.js.map
}}),
"[project]/node_modules/@deck.gl/geo-layers/dist/tile-layer/tile-layer.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$composite$2d$layer$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__CompositeLayer$3e$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/core/dist/lib/composite-layer.js [client] (ecmascript) <export default as CompositeLayer>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$utils$2f$flatten$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__flatten__as__$5f$flatten$3e$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/core/dist/utils/flatten.js [client] (ecmascript) <export flatten as _flatten>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$layers$2f$dist$2f$geojson$2d$layer$2f$geojson$2d$layer$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__GeoJsonLayer$3e$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/layers/dist/geojson-layer/geojson-layer.js [client] (ecmascript) <export default as GeoJsonLayer>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$tileset$2d$2d$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/geo-layers/dist/tileset-2d/tileset-2d.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/geo-layers/dist/tileset-2d/utils.js [client] (ecmascript)");
;
;
;
;
const defaultProps = {
    TilesetClass: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$tileset$2d$2d$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Tileset2D"],
    data: {
        type: 'data',
        value: []
    },
    dataComparator: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["urlType"].equal,
    renderSubLayers: {
        type: 'function',
        value: (props)=>new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$layers$2f$dist$2f$geojson$2d$layer$2f$geojson$2d$layer$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__GeoJsonLayer$3e$__["GeoJsonLayer"](props)
    },
    getTileData: {
        type: 'function',
        optional: true,
        value: null
    },
    // TODO - change to onViewportLoad to align with Tile3DLayer
    onViewportLoad: {
        type: 'function',
        optional: true,
        value: null
    },
    onTileLoad: {
        type: 'function',
        value: (tile)=>{}
    },
    onTileUnload: {
        type: 'function',
        value: (tile)=>{}
    },
    // eslint-disable-next-line
    onTileError: {
        type: 'function',
        value: (err)=>console.error(err)
    },
    extent: {
        type: 'array',
        optional: true,
        value: null,
        compare: true
    },
    tileSize: 512,
    maxZoom: null,
    minZoom: 0,
    maxCacheSize: null,
    maxCacheByteSize: null,
    refinementStrategy: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$tileset$2d$2d$2e$js__$5b$client$5d$__$28$ecmascript$29$__["STRATEGY_DEFAULT"],
    zRange: null,
    maxRequests: 6,
    debounceTime: 0,
    zoomOffset: 0
};
/**
 * The TileLayer is a composite layer that makes it possible to visualize very large datasets.
 *
 * Instead of fetching the entire dataset, it only loads and renders what's visible in the current viewport.
 */ class TileLayer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$lib$2f$composite$2d$layer$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__CompositeLayer$3e$__["CompositeLayer"] {
    initializeState() {
        this.state = {
            tileset: null,
            isLoaded: false
        };
    }
    finalizeState() {
        this.state?.tileset?.finalize();
    }
    get isLoaded() {
        return Boolean(this.state?.tileset?.selectedTiles?.every((tile)=>tile.isLoaded && tile.layers && tile.layers.every((layer)=>layer.isLoaded)));
    }
    shouldUpdateState({ changeFlags }) {
        return changeFlags.somethingChanged;
    }
    updateState({ changeFlags }) {
        let { tileset } = this.state;
        const propsChanged = changeFlags.propsOrDataChanged || changeFlags.updateTriggersChanged;
        const dataChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getTileData);
        if (!tileset) {
            tileset = new this.props.TilesetClass(this._getTilesetOptions());
            this.setState({
                tileset
            });
        } else if (propsChanged) {
            tileset.setOptions(this._getTilesetOptions());
            if (dataChanged) {
                // reload all tiles
                // use cached layers until new content is loaded
                tileset.reloadAll();
            } else {
                // some render options changed, regenerate sub layers now
                tileset.tiles.forEach((tile)=>{
                    tile.layers = null;
                });
            }
        }
        this._updateTileset();
    }
    _getTilesetOptions() {
        const { tileSize, maxCacheSize, maxCacheByteSize, refinementStrategy, extent, maxZoom, minZoom, maxRequests, debounceTime, zoomOffset } = this.props;
        return {
            maxCacheSize,
            maxCacheByteSize,
            maxZoom,
            minZoom,
            tileSize,
            refinementStrategy,
            extent,
            maxRequests,
            debounceTime,
            zoomOffset,
            getTileData: this.getTileData.bind(this),
            onTileLoad: this._onTileLoad.bind(this),
            onTileError: this._onTileError.bind(this),
            onTileUnload: this._onTileUnload.bind(this)
        };
    }
    _updateTileset() {
        const tileset = this.state.tileset;
        const { zRange, modelMatrix } = this.props;
        const frameNumber = tileset.update(this.context.viewport, {
            zRange,
            modelMatrix
        });
        const { isLoaded } = tileset;
        const loadingStateChanged = this.state.isLoaded !== isLoaded;
        const tilesetChanged = this.state.frameNumber !== frameNumber;
        if (isLoaded && (loadingStateChanged || tilesetChanged)) {
            this._onViewportLoad();
        }
        if (tilesetChanged) {
            // Save the tileset frame number - trigger a rerender
            this.setState({
                frameNumber
            });
        }
        // Save the loaded state - should not trigger a rerender
        this.state.isLoaded = isLoaded;
    }
    _onViewportLoad() {
        const { tileset } = this.state;
        const { onViewportLoad } = this.props;
        if (onViewportLoad) {
            // This method can only be called when tileset is defined and updated
            onViewportLoad(tileset.selectedTiles);
        }
    }
    _onTileLoad(tile) {
        this.props.onTileLoad(tile);
        tile.layers = null;
        this.setNeedsUpdate();
    }
    _onTileError(error, tile) {
        this.props.onTileError(error);
        tile.layers = null;
        this.setNeedsUpdate();
    }
    _onTileUnload(tile) {
        this.props.onTileUnload(tile);
    }
    // Methods for subclass to override
    getTileData(tile) {
        const { data, getTileData, fetch } = this.props;
        const { signal } = tile;
        tile.url = typeof data === 'string' || Array.isArray(data) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tileset$2d$2d$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getURLFromTemplate"])(data, tile) : null;
        if (getTileData) {
            return getTileData(tile);
        }
        if (fetch && tile.url) {
            return fetch(tile.url, {
                propName: 'data',
                layer: this,
                signal
            });
        }
        return null;
    }
    renderSubLayers(props) {
        return this.props.renderSubLayers(props);
    }
    getSubLayerPropsByTile(tile) {
        return null;
    }
    getPickingInfo(params) {
        // TileLayer does not directly render anything, sourceLayer cannot be null
        const sourceLayer = params.sourceLayer;
        const sourceTile = sourceLayer.props.tile;
        const info = params.info;
        if (info.picked) {
            info.tile = sourceTile;
        }
        info.sourceTile = sourceTile;
        info.sourceTileSubLayer = sourceLayer;
        return info;
    }
    _updateAutoHighlight(info) {
        info.sourceTileSubLayer.updateAutoHighlight(info);
    }
    renderLayers() {
        return this.state.tileset.tiles.map((tile)=>{
            const subLayerProps = this.getSubLayerPropsByTile(tile);
            // cache the rendered layer in the tile
            if (!tile.isLoaded && !tile.content) {
            // nothing to show
            } else if (!tile.layers) {
                const layers = this.renderSubLayers({
                    ...this.props,
                    ...this.getSubLayerProps({
                        id: tile.id,
                        updateTriggers: this.props.updateTriggers
                    }),
                    data: tile.content,
                    _offset: 0,
                    tile
                });
                tile.layers = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$core$2f$dist$2f$utils$2f$flatten$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__flatten__as__$5f$flatten$3e$__["_flatten"])(layers, Boolean).map((layer)=>layer.clone({
                        tile,
                        ...subLayerProps
                    }));
            } else if (subLayerProps && tile.layers[0] && Object.keys(subLayerProps).some((propName)=>tile.layers[0].props[propName] !== subLayerProps[propName])) {
                tile.layers = tile.layers.map((layer)=>layer.clone(subLayerProps));
            }
            return tile.layers;
        });
    }
    filterSubLayer({ layer, cullRect }) {
        const { tile } = layer.props;
        return this.state.tileset.isTileVisible(tile, cullRect);
    }
}
TileLayer.defaultProps = defaultProps;
TileLayer.layerName = 'TileLayer';
const __TURBOPACK__default__export__ = TileLayer;
 //# sourceMappingURL=tile-layer.js.map
}}),
"[project]/node_modules/@deck.gl/geo-layers/dist/tile-layer/tile-layer.js [client] (ecmascript) <export default as TileLayer>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "TileLayer": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tile$2d$layer$2f$tile$2d$layer$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$deck$2e$gl$2f$geo$2d$layers$2f$dist$2f$tile$2d$layer$2f$tile$2d$layer$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@deck.gl/geo-layers/dist/tile-layer/tile-layer.js [client] (ecmascript)");
}}),
"[project]/node_modules/@math.gl/culling/dist/constants.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "INTERSECTION": (()=>INTERSECTION)
});
const INTERSECTION = {
    OUTSIDE: -1,
    INTERSECTING: 0,
    INSIDE: 1 // Represents that an object is fully within the frustum.
}; //# sourceMappingURL=constants.js.map
}}),
"[project]/node_modules/@math.gl/culling/dist/lib/bounding-volumes/axis-aligned-bounding-box.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT and Apache-2.0
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "AxisAlignedBoundingBox": (()=>AxisAlignedBoundingBox)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/classes/vector3.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/constants.js [client] (ecmascript)");
;
;
const scratchVector = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const scratchNormal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
class AxisAlignedBoundingBox {
    /**
     * Creates an instance of an AxisAlignedBoundingBox from the minimum and maximum points along the x, y, and z axes.
     * @param minimum=[0, 0, 0] The minimum point along the x, y, and z axes.
     * @param maximum=[0, 0, 0] The maximum point along the x, y, and z axes.
     * @param center The center of the box; automatically computed if not supplied.
     */ constructor(minimum = [
        0,
        0,
        0
    ], maximum = [
        0,
        0,
        0
    ], center){
        // If center was not defined, compute it.
        center = center || scratchVector.copy(minimum).add(maximum).scale(0.5);
        this.center = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"](center);
        this.halfDiagonal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"](maximum).subtract(this.center);
        /**
         * The minimum point defining the bounding box.
         * @type {Vector3}
         * @default {@link 0, 0, 0}
         */ this.minimum = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"](minimum);
        /**
         * The maximum point defining the bounding box.
         * @type {Vector3}
         * @default {@link 0, 0, 0}
         */ this.maximum = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"](maximum);
    }
    /**
     * Duplicates a AxisAlignedBoundingBox instance.
     *
     * @returns {AxisAlignedBoundingBox} A new AxisAlignedBoundingBox instance.
     */ clone() {
        return new AxisAlignedBoundingBox(this.minimum, this.maximum, this.center);
    }
    /**
     * Compares the provided AxisAlignedBoundingBox componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     *
     * @param {AxisAlignedBoundingBox} [right] The second AxisAlignedBoundingBox to compare with.
     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */ equals(right) {
        return this === right || Boolean(right) && this.minimum.equals(right.minimum) && this.maximum.equals(right.maximum);
    }
    /**
     * Applies a 4x4 affine transformation matrix to a bounding sphere.
     * @param transform The transformation matrix to apply to the bounding sphere.
     * @returns itself, i.e. the modified BoundingVolume.
     */ transform(transform) {
        this.center.transformAsPoint(transform);
        // TODO - this.halfDiagonal.transformAsVector(transform);
        this.halfDiagonal.transform(transform);
        this.minimum.transform(transform);
        this.maximum.transform(transform);
        return this;
    }
    /**
     * Determines which side of a plane a box is located.
     */ intersectPlane(plane) {
        const { halfDiagonal } = this;
        const normal = scratchNormal.from(plane.normal);
        const e = halfDiagonal.x * Math.abs(normal.x) + halfDiagonal.y * Math.abs(normal.y) + halfDiagonal.z * Math.abs(normal.z);
        const s = this.center.dot(normal) + plane.distance; // signed distance from center
        if (s - e > 0) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["INTERSECTION"].INSIDE;
        }
        if (s + e < 0) {
            // Not in front because normals point inward
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["INTERSECTION"].OUTSIDE;
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["INTERSECTION"].INTERSECTING;
    }
    /** Computes the estimated distance from the closest point on a bounding box to a point. */ distanceTo(point) {
        return Math.sqrt(this.distanceSquaredTo(point));
    }
    /** Computes the estimated distance squared from the closest point on a bounding box to a point. */ distanceSquaredTo(point) {
        const offset = scratchVector.from(point).subtract(this.center);
        const { halfDiagonal } = this;
        let distanceSquared = 0.0;
        let d;
        d = Math.abs(offset.x) - halfDiagonal.x;
        if (d > 0) {
            distanceSquared += d * d;
        }
        d = Math.abs(offset.y) - halfDiagonal.y;
        if (d > 0) {
            distanceSquared += d * d;
        }
        d = Math.abs(offset.z) - halfDiagonal.z;
        if (d > 0) {
            distanceSquared += d * d;
        }
        return distanceSquared;
    }
} //# sourceMappingURL=axis-aligned-bounding-box.js.map
}}),
"[project]/node_modules/@math.gl/culling/dist/lib/bounding-volumes/bounding-sphere.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT and Apache-2.0
// Copyright (c) vis.gl contributors
// This file is derived from the Cesium math library under Apache 2 license
// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md
__turbopack_context__.s({
    "BoundingSphere": (()=>BoundingSphere)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/classes/vector3.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$mat4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__mat4$3e$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/gl-matrix/mat4.js [client] (ecmascript) <export * as mat4>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/constants.js [client] (ecmascript)");
;
;
const scratchVector = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const scratchVector2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
class BoundingSphere {
    /** Creates a bounding sphere */ constructor(center = [
        0,
        0,
        0
    ], radius = 0.0){
        this.radius = -0;
        this.center = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
        this.fromCenterRadius(center, radius);
    }
    /** Sets the bounding sphere from `center` and `radius`. */ fromCenterRadius(center, radius) {
        this.center.from(center);
        this.radius = radius;
        return this;
    }
    /**
     * Computes a bounding sphere from the corner points of an axis-aligned bounding box.  The sphere
     * tightly and fully encompasses the box.
     */ fromCornerPoints(corner, oppositeCorner) {
        oppositeCorner = scratchVector.from(oppositeCorner);
        this.center = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]().from(corner).add(oppositeCorner).scale(0.5);
        this.radius = this.center.distance(oppositeCorner);
        return this;
    }
    /** Compares the provided BoundingSphere component wise */ equals(right) {
        return this === right || Boolean(right) && this.center.equals(right.center) && this.radius === right.radius;
    }
    /** Duplicates a BoundingSphere instance. */ clone() {
        return new BoundingSphere(this.center, this.radius);
    }
    /** Computes a bounding sphere that contains both the left and right bounding spheres. */ union(boundingSphere) {
        const leftCenter = this.center;
        const leftRadius = this.radius;
        const rightCenter = boundingSphere.center;
        const rightRadius = boundingSphere.radius;
        const toRightCenter = scratchVector.copy(rightCenter).subtract(leftCenter);
        const centerSeparation = toRightCenter.magnitude();
        if (leftRadius >= centerSeparation + rightRadius) {
            // Left sphere wins.
            return this.clone();
        }
        if (rightRadius >= centerSeparation + leftRadius) {
            // Right sphere wins.
            return boundingSphere.clone();
        }
        // There are two tangent points, one on far side of each sphere.
        const halfDistanceBetweenTangentPoints = (leftRadius + centerSeparation + rightRadius) * 0.5;
        // Compute the center point halfway between the two tangent points.
        scratchVector2.copy(toRightCenter).scale((-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation).add(leftCenter);
        this.center.copy(scratchVector2);
        this.radius = halfDistanceBetweenTangentPoints;
        return this;
    }
    /** Computes a bounding sphere by enlarging the provided sphere to contain the provided point. */ expand(point) {
        const scratchPoint = scratchVector.from(point);
        const radius = scratchPoint.subtract(this.center).magnitude();
        if (radius > this.radius) {
            this.radius = radius;
        }
        return this;
    }
    // BoundingVolume interface
    /**
     * Applies a 4x4 affine transformation matrix to a bounding sphere.
     * @param sphere The bounding sphere to apply the transformation to.
     * @param transform The transformation matrix to apply to the bounding sphere.
     * @returns self.
     */ transform(transform) {
        this.center.transform(transform);
        const scale = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$gl$2d$matrix$2f$mat4$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__mat4$3e$__["mat4"].getScaling(scratchVector, transform);
        this.radius = Math.max(scale[0], Math.max(scale[1], scale[2])) * this.radius;
        return this;
    }
    /** Computes the estimated distance squared from the closest point on a bounding sphere to a point. */ distanceSquaredTo(point) {
        const d = this.distanceTo(point);
        return d * d;
    }
    /** Computes the estimated distance from the closest point on a bounding sphere to a point. */ distanceTo(point) {
        const scratchPoint = scratchVector.from(point);
        const delta = scratchPoint.subtract(this.center);
        return Math.max(0, delta.len() - this.radius);
    }
    /** Determines which side of a plane a sphere is located. */ intersectPlane(plane) {
        const center = this.center;
        const radius = this.radius;
        const normal = plane.normal;
        const distanceToPlane = normal.dot(center) + plane.distance;
        // The center point is negative side of the plane normal
        if (distanceToPlane < -radius) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["INTERSECTION"].OUTSIDE;
        }
        // The center point is positive side of the plane, but radius extends beyond it; partial overlap
        if (distanceToPlane < radius) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["INTERSECTION"].INTERSECTING;
        }
        // The center point and radius is positive side of the plane
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["INTERSECTION"].INSIDE;
    }
} //# sourceMappingURL=bounding-sphere.js.map
}}),
"[project]/node_modules/@math.gl/culling/dist/lib/bounding-volumes/oriented-bounding-box.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT and Apache-2.0
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "OrientedBoundingBox": (()=>OrientedBoundingBox)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/classes/vector3.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix3$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/classes/matrix3.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$quaternion$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/classes/quaternion.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$bounding$2d$volumes$2f$bounding$2d$sphere$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/bounding-volumes/bounding-sphere.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/constants.js [client] (ecmascript)");
;
;
;
const scratchVector3 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const scratchOffset = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const scratchVectorU = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const scratchVectorV = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const scratchVectorW = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const scratchCorner = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const scratchToCenter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const MATRIX3 = {
    COLUMN0ROW0: 0,
    COLUMN0ROW1: 1,
    COLUMN0ROW2: 2,
    COLUMN1ROW0: 3,
    COLUMN1ROW1: 4,
    COLUMN1ROW2: 5,
    COLUMN2ROW0: 6,
    COLUMN2ROW1: 7,
    COLUMN2ROW2: 8
};
class OrientedBoundingBox {
    constructor(center = [
        0,
        0,
        0
    ], halfAxes = [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
    ]){
        this.center = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]().from(center);
        this.halfAxes = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix3"](halfAxes);
    }
    /** Returns an array with three halfSizes for the bounding box */ get halfSize() {
        const xAxis = this.halfAxes.getColumn(0);
        const yAxis = this.halfAxes.getColumn(1);
        const zAxis = this.halfAxes.getColumn(2);
        return [
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"](xAxis).len(),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"](yAxis).len(),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"](zAxis).len()
        ];
    }
    /** Returns a quaternion describing the orientation of the bounding box */ get quaternion() {
        const xAxis = this.halfAxes.getColumn(0);
        const yAxis = this.halfAxes.getColumn(1);
        const zAxis = this.halfAxes.getColumn(2);
        const normXAxis = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"](xAxis).normalize();
        const normYAxis = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"](yAxis).normalize();
        const normZAxis = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"](zAxis).normalize();
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$quaternion$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Quaternion"]().fromMatrix3(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix3"]([
            ...normXAxis,
            ...normYAxis,
            ...normZAxis
        ]));
    }
    /**
     * Create OrientedBoundingBox from quaternion based OBB,
     */ fromCenterHalfSizeQuaternion(center, halfSize, quaternion) {
        const quaternionObject = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$quaternion$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Quaternion"](quaternion);
        const directionsMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix3"]().fromQuaternion(quaternionObject);
        directionsMatrix[0] = directionsMatrix[0] * halfSize[0];
        directionsMatrix[1] = directionsMatrix[1] * halfSize[0];
        directionsMatrix[2] = directionsMatrix[2] * halfSize[0];
        directionsMatrix[3] = directionsMatrix[3] * halfSize[1];
        directionsMatrix[4] = directionsMatrix[4] * halfSize[1];
        directionsMatrix[5] = directionsMatrix[5] * halfSize[1];
        directionsMatrix[6] = directionsMatrix[6] * halfSize[2];
        directionsMatrix[7] = directionsMatrix[7] * halfSize[2];
        directionsMatrix[8] = directionsMatrix[8] * halfSize[2];
        this.center = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]().from(center);
        this.halfAxes = directionsMatrix;
        return this;
    }
    /** Duplicates a OrientedBoundingBox instance. */ clone() {
        return new OrientedBoundingBox(this.center, this.halfAxes);
    }
    /** Compares the provided OrientedBoundingBox component wise and returns */ equals(right) {
        return this === right || Boolean(right) && this.center.equals(right.center) && this.halfAxes.equals(right.halfAxes);
    }
    /** Computes a tight-fitting bounding sphere enclosing the provided oriented bounding box. */ getBoundingSphere(result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$bounding$2d$volumes$2f$bounding$2d$sphere$2e$js__$5b$client$5d$__$28$ecmascript$29$__["BoundingSphere"]()) {
        const halfAxes = this.halfAxes;
        const u = halfAxes.getColumn(0, scratchVectorU);
        const v = halfAxes.getColumn(1, scratchVectorV);
        const w = halfAxes.getColumn(2, scratchVectorW);
        // Calculate "corner" vector
        const cornerVector = scratchVector3.copy(u).add(v).add(w);
        result.center.copy(this.center);
        result.radius = cornerVector.magnitude();
        return result;
    }
    /** Determines which side of a plane the oriented bounding box is located. */ intersectPlane(plane) {
        const center = this.center;
        const normal = plane.normal;
        const halfAxes = this.halfAxes;
        const normalX = normal.x;
        const normalY = normal.y;
        const normalZ = normal.z;
        // Plane is used as if it is its normal; the first three components are assumed to be normalized
        const radEffective = Math.abs(normalX * halfAxes[MATRIX3.COLUMN0ROW0] + normalY * halfAxes[MATRIX3.COLUMN0ROW1] + normalZ * halfAxes[MATRIX3.COLUMN0ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN1ROW0] + normalY * halfAxes[MATRIX3.COLUMN1ROW1] + normalZ * halfAxes[MATRIX3.COLUMN1ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN2ROW0] + normalY * halfAxes[MATRIX3.COLUMN2ROW1] + normalZ * halfAxes[MATRIX3.COLUMN2ROW2]);
        const distanceToPlane = normal.dot(center) + plane.distance;
        if (distanceToPlane <= -radEffective) {
            // The entire box is on the negative side of the plane normal
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["INTERSECTION"].OUTSIDE;
        } else if (distanceToPlane >= radEffective) {
            // The entire box is on the positive side of the plane normal
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["INTERSECTION"].INSIDE;
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["INTERSECTION"].INTERSECTING;
    }
    /** Computes the estimated distance from the closest point on a bounding box to a point. */ distanceTo(point) {
        return Math.sqrt(this.distanceSquaredTo(point));
    }
    /**
     * Computes the estimated distance squared from the closest point
     * on a bounding box to a point.
     * See Geometric Tools for Computer Graphics 10.4.2
     */ distanceSquaredTo(point) {
        // Computes the estimated distance squared from the
        // closest point on a bounding box to a point.
        // See Geometric Tools for Computer Graphics 10.4.2
        const offset = scratchOffset.from(point).subtract(this.center);
        const halfAxes = this.halfAxes;
        const u = halfAxes.getColumn(0, scratchVectorU);
        const v = halfAxes.getColumn(1, scratchVectorV);
        const w = halfAxes.getColumn(2, scratchVectorW);
        const uHalf = u.magnitude();
        const vHalf = v.magnitude();
        const wHalf = w.magnitude();
        u.normalize();
        v.normalize();
        w.normalize();
        let distanceSquared = 0.0;
        let d;
        d = Math.abs(offset.dot(u)) - uHalf;
        if (d > 0) {
            distanceSquared += d * d;
        }
        d = Math.abs(offset.dot(v)) - vHalf;
        if (d > 0) {
            distanceSquared += d * d;
        }
        d = Math.abs(offset.dot(w)) - wHalf;
        if (d > 0) {
            distanceSquared += d * d;
        }
        return distanceSquared;
    }
    /**
     * The distances calculated by the vector from the center of the bounding box
     * to position projected onto direction.
     *
     * - If you imagine the infinite number of planes with normal direction,
     *   this computes the smallest distance to the closest and farthest planes
     *   from `position` that intersect the bounding box.
     *
     * @param position The position to calculate the distance from.
     * @param direction The direction from position.
     * @param result An Interval (array of length 2) to store the nearest and farthest distances.
     * @returns Interval (array of length 2) with nearest and farthest distances
     *   on the bounding box from position in direction.
     */ // eslint-disable-next-line max-statements
    computePlaneDistances(position, direction, result = [
        -0,
        -0
    ]) {
        let minDist = Number.POSITIVE_INFINITY;
        let maxDist = Number.NEGATIVE_INFINITY;
        const center = this.center;
        const halfAxes = this.halfAxes;
        const u = halfAxes.getColumn(0, scratchVectorU);
        const v = halfAxes.getColumn(1, scratchVectorV);
        const w = halfAxes.getColumn(2, scratchVectorW);
        // project first corner
        const corner = scratchCorner.copy(u).add(v).add(w).add(center);
        const toCenter = scratchToCenter.copy(corner).subtract(position);
        let mag = direction.dot(toCenter);
        minDist = Math.min(mag, minDist);
        maxDist = Math.max(mag, maxDist);
        // project second corner
        corner.copy(center).add(u).add(v).subtract(w);
        toCenter.copy(corner).subtract(position);
        mag = direction.dot(toCenter);
        minDist = Math.min(mag, minDist);
        maxDist = Math.max(mag, maxDist);
        // project third corner
        corner.copy(center).add(u).subtract(v).add(w);
        toCenter.copy(corner).subtract(position);
        mag = direction.dot(toCenter);
        minDist = Math.min(mag, minDist);
        maxDist = Math.max(mag, maxDist);
        // project fourth corner
        corner.copy(center).add(u).subtract(v).subtract(w);
        toCenter.copy(corner).subtract(position);
        mag = direction.dot(toCenter);
        minDist = Math.min(mag, minDist);
        maxDist = Math.max(mag, maxDist);
        // project fifth corner
        center.copy(corner).subtract(u).add(v).add(w);
        toCenter.copy(corner).subtract(position);
        mag = direction.dot(toCenter);
        minDist = Math.min(mag, minDist);
        maxDist = Math.max(mag, maxDist);
        // project sixth corner
        center.copy(corner).subtract(u).add(v).subtract(w);
        toCenter.copy(corner).subtract(position);
        mag = direction.dot(toCenter);
        minDist = Math.min(mag, minDist);
        maxDist = Math.max(mag, maxDist);
        // project seventh corner
        center.copy(corner).subtract(u).subtract(v).add(w);
        toCenter.copy(corner).subtract(position);
        mag = direction.dot(toCenter);
        minDist = Math.min(mag, minDist);
        maxDist = Math.max(mag, maxDist);
        // project eighth corner
        center.copy(corner).subtract(u).subtract(v).subtract(w);
        toCenter.copy(corner).subtract(position);
        mag = direction.dot(toCenter);
        minDist = Math.min(mag, minDist);
        maxDist = Math.max(mag, maxDist);
        result[0] = minDist;
        result[1] = maxDist;
        return result;
    }
    /**
     * Applies a 4x4 affine transformation matrix to a bounding sphere.
     * @param transform The transformation matrix to apply to the bounding sphere.
     * @returns itself, i.e. the modified BoundingVolume.
     */ transform(transformation) {
        this.center.transformAsPoint(transformation);
        const xAxis = this.halfAxes.getColumn(0, scratchVectorU);
        xAxis.transformAsPoint(transformation);
        const yAxis = this.halfAxes.getColumn(1, scratchVectorV);
        yAxis.transformAsPoint(transformation);
        const zAxis = this.halfAxes.getColumn(2, scratchVectorW);
        zAxis.transformAsPoint(transformation);
        this.halfAxes = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix3"]([
            ...xAxis,
            ...yAxis,
            ...zAxis
        ]);
        return this;
    }
    getTransform() {
        // const modelMatrix = Matrix4.fromRotationTranslation(this.boundingVolume.halfAxes, this.boundingVolume.center);
        // return modelMatrix;
        throw new Error('not implemented');
    }
} //# sourceMappingURL=oriented-bounding-box.js.map
}}),
"[project]/node_modules/@math.gl/culling/dist/lib/plane.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT and Apache-2.0
// Copyright (c) vis.gl contributors
// This file is derived from the Cesium math library under Apache 2 license
// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md
/* eslint-disable */ __turbopack_context__.s({
    "Plane": (()=>Plane)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/classes/vector3.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$common$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/lib/common.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/lib/assert.js [client] (ecmascript)");
;
const scratchPosition = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const scratchNormal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
class Plane {
    constructor(normal = [
        0,
        0,
        1
    ], distance = 0){
        this.normal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
        this.distance = -0;
        this.fromNormalDistance(normal, distance);
    }
    /** Creates a plane from a normal and a distance from the origin. */ fromNormalDistance(normal, distance) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(Number.isFinite(distance));
        this.normal.from(normal).normalize();
        this.distance = distance;
        return this;
    }
    /** Creates a plane from a normal and a point on the plane. */ fromPointNormal(point, normal) {
        point = scratchPosition.from(point);
        this.normal.from(normal).normalize();
        const distance = -this.normal.dot(point);
        this.distance = distance;
        return this;
    }
    /** Creates a plane from the general equation */ fromCoefficients(a, b, c, d) {
        this.normal.set(a, b, c);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$common$2e$js__$5b$client$5d$__$28$ecmascript$29$__["equals"])(this.normal.len(), 1));
        this.distance = d;
        return this;
    }
    /** Duplicates a Plane instance. */ clone() {
        return new Plane(this.normal, this.distance);
    }
    /** Compares the provided Planes by normal and distance */ equals(right) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$common$2e$js__$5b$client$5d$__$28$ecmascript$29$__["equals"])(this.distance, right.distance) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$common$2e$js__$5b$client$5d$__$28$ecmascript$29$__["equals"])(this.normal, right.normal);
    }
    /** Computes the signed shortest distance of a point to a plane.
     * The sign of the distance determines which side of the plane the point is on.
     */ getPointDistance(point) {
        return this.normal.dot(point) + this.distance;
    }
    /** Transforms the plane by the given transformation matrix. */ transform(matrix4) {
        const normal = scratchNormal.copy(this.normal).transformAsVector(matrix4).normalize();
        const point = this.normal.scale(-this.distance).transform(matrix4);
        return this.fromPointNormal(point, normal);
    }
    projectPointOntoPlane(point, result = [
        0,
        0,
        0
    ]) {
        const scratchPoint = scratchPosition.from(point);
        // projectedPoint = point - (normal.point + scale) * normal
        const pointDistance = this.getPointDistance(scratchPoint);
        const scaledNormal = scratchNormal.copy(this.normal).scale(pointDistance);
        return scratchPoint.subtract(scaledNormal).to(result);
    }
} //# sourceMappingURL=plane.js.map
}}),
"[project]/node_modules/@math.gl/culling/dist/lib/culling-volume.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT and Apache-2.0
// Copyright (c) vis.gl contributors
// This file is derived from the Cesium math library under Apache 2 license
// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md
/* eslint-disable */ __turbopack_context__.s({
    "CullingVolume": (()=>CullingVolume)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/classes/vector3.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/lib/assert.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/constants.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$plane$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/plane.js [client] (ecmascript)");
;
;
;
// X, Y, Z Unit vectors
const faces = [
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]([
        1,
        0,
        0
    ]),
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]([
        0,
        1,
        0
    ]),
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]([
        0,
        0,
        1
    ])
];
const scratchPlaneCenter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const scratchPlaneNormal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
class CullingVolume {
    /**
     * Create a new `CullingVolume` bounded by an array of clipping planed
     * @param planes Array of clipping planes.
     * */ constructor(planes = []){
        this.planes = planes;
    }
    /**
     * Constructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere.
     * The planes are aligned to the x, y, and z axes in world coordinates.
     */ fromBoundingSphere(boundingSphere) {
        this.planes.length = 2 * faces.length;
        const center = boundingSphere.center;
        const radius = boundingSphere.radius;
        let planeIndex = 0;
        for (const faceNormal of faces){
            let plane0 = this.planes[planeIndex];
            let plane1 = this.planes[planeIndex + 1];
            if (!plane0) {
                plane0 = this.planes[planeIndex] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$plane$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Plane"]();
            }
            if (!plane1) {
                plane1 = this.planes[planeIndex + 1] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$plane$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Plane"]();
            }
            const plane0Center = scratchPlaneCenter.copy(faceNormal).scale(-radius).add(center);
            // const plane0Distance = -faceNormal.dot(plane0Center);
            plane0.fromPointNormal(plane0Center, faceNormal);
            const plane1Center = scratchPlaneCenter.copy(faceNormal).scale(radius).add(center);
            const negatedFaceNormal = scratchPlaneNormal.copy(faceNormal).negate();
            // const plane1Distance = -negatedFaceNormal.dot(plane1Center);
            plane1.fromPointNormal(plane1Center, negatedFaceNormal);
            planeIndex += 2;
        }
        return this;
    }
    /** Determines whether a bounding volume intersects the culling volume. */ computeVisibility(boundingVolume) {
        // const planes = this.planes;
        let intersect = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["INTERSECTION"].INSIDE;
        for (const plane of this.planes){
            const result = boundingVolume.intersectPlane(plane);
            switch(result){
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["INTERSECTION"].OUTSIDE:
                    // We are done
                    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["INTERSECTION"].OUTSIDE;
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["INTERSECTION"].INTERSECTING:
                    // If no other intersection is outside, return INTERSECTING
                    intersect = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["INTERSECTION"].INTERSECTING;
                    break;
                default:
            }
        }
        return intersect;
    }
    /**
     * Determines whether a bounding volume intersects the culling volume.
     *
     * @param parentPlaneMask A bit mask from the boundingVolume's parent's check against the same culling
     *   volume, such that if (planeMask & (1 << planeIndex) === 0), for k < 31, then
     *   the parent (and therefore this) volume is completely inside plane[planeIndex]
     *   and that plane check can be skipped.
     */ computeVisibilityWithPlaneMask(boundingVolume, parentPlaneMask) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(Number.isFinite(parentPlaneMask), 'parentPlaneMask is required.');
        if (parentPlaneMask === CullingVolume.MASK_OUTSIDE || parentPlaneMask === CullingVolume.MASK_INSIDE) {
            // parent is completely outside or completely inside, so this child is as well.
            return parentPlaneMask;
        }
        // Start with MASK_INSIDE (all zeros) so that after the loop, the return value can be compared with MASK_INSIDE.
        // (Because if there are fewer than 31 planes, the upper bits wont be changed.)
        let mask = CullingVolume.MASK_INSIDE;
        const planes = this.planes;
        for(let k = 0; k < this.planes.length; ++k){
            // For k greater than 31 (since 31 is the maximum number of INSIDE/INTERSECTING bits we can store), skip the optimization.
            const flag = k < 31 ? 1 << k : 0;
            if (k < 31 && (parentPlaneMask & flag) === 0) {
                continue;
            }
            const plane = planes[k];
            const result = boundingVolume.intersectPlane(plane);
            if (result === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["INTERSECTION"].OUTSIDE) {
                return CullingVolume.MASK_OUTSIDE;
            } else if (result === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["INTERSECTION"].INTERSECTING) {
                mask |= flag;
            }
        }
        return mask;
    }
}
/**
 * For plane masks (as used in {@link CullingVolume#computeVisibilityWithPlaneMask}), this special value
 * represents the case where the object bounding volume is entirely outside the culling volume.
 */ CullingVolume.MASK_OUTSIDE = 0xffffffff;
/**
 * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value
 * represents the case where the object bounding volume is entirely inside the culling volume.
 */ CullingVolume.MASK_INSIDE = 0x00000000;
/**
 * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value
 * represents the case where the object bounding volume (may) intersect all planes of the culling volume.
 */ CullingVolume.MASK_INDETERMINATE = 0x7fffffff; //# sourceMappingURL=culling-volume.js.map
}}),
"[project]/node_modules/@math.gl/culling/dist/lib/perspective-off-center-frustum.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT and Apache-2.0
// Copyright (c) vis.gl contributors
// This file is derived from the Cesium math library under Apache 2 license
// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md
// Note: This class is still an experimental export, mainly used by other test cases
// - It has not been fully adapted to math.gl conventions
// - Documentation has not been ported
__turbopack_context__.s({
    "PerspectiveOffCenterFrustum": (()=>PerspectiveOffCenterFrustum)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/classes/vector3.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix4$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/classes/matrix4.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/lib/assert.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$culling$2d$volume$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/culling-volume.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$plane$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/plane.js [client] (ecmascript)");
;
;
;
const scratchPlaneUpVector = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const scratchPlaneRightVector = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const scratchPlaneNearCenter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const scratchPlaneFarCenter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const scratchPlaneNormal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
class PerspectiveOffCenterFrustum {
    /**
     * The viewing frustum is defined by 6 planes.
     * Each plane is represented by a {@link Vector4} object, where the x, y, and z components
     * define the unit vector normal to the plane, and the w component is the distance of the
     * plane from the origin/camera position.
     *
     * @alias PerspectiveOffCenterFrustum
     *
     * @example
     * const frustum = new PerspectiveOffCenterFrustum({
     *     left : -1.0,
     *     right : 1.0,
     *     top : 1.0,
     *     bottom : -1.0,
     *     near : 1.0,
     *     far : 100.0
     * });
     *
     * @see PerspectiveFrustum
     */ constructor(options = {}){
        this._cullingVolume = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$culling$2d$volume$2e$js__$5b$client$5d$__$28$ecmascript$29$__["CullingVolume"]([
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$plane$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Plane"](),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$plane$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Plane"](),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$plane$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Plane"](),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$plane$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Plane"](),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$plane$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Plane"](),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$plane$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Plane"]()
        ]);
        this._perspectiveMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix4$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix4"]();
        this._infinitePerspective = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix4$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix4"]();
        const { near = 1.0, far = 500000000.0 } = options;
        this.left = options.left;
        this._left = undefined;
        this.right = options.right;
        this._right = undefined;
        this.top = options.top;
        this._top = undefined;
        this.bottom = options.bottom;
        this._bottom = undefined;
        this.near = near;
        this._near = near;
        this.far = far;
        this._far = far;
    }
    /**
     * Returns a duplicate of a PerspectiveOffCenterFrustum instance.
     * @returns {PerspectiveOffCenterFrustum} A new PerspectiveFrustum instance.
     * */ clone() {
        return new PerspectiveOffCenterFrustum({
            right: this.right,
            left: this.left,
            top: this.top,
            bottom: this.bottom,
            near: this.near,
            far: this.far
        });
    }
    /**
     * Compares the provided PerspectiveOffCenterFrustum componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     *
     * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
     */ equals(other) {
        return other && other instanceof PerspectiveOffCenterFrustum && this.right === other.right && this.left === other.left && this.top === other.top && this.bottom === other.bottom && this.near === other.near && this.far === other.far;
    }
    /**
     * Gets the perspective projection matrix computed from the view frustum.
     * @memberof PerspectiveOffCenterFrustum.prototype
     * @type {Matrix4}
     *
     * @see PerspectiveOffCenterFrustum#infiniteProjectionMatrix
     */ get projectionMatrix() {
        this._update();
        return this._perspectiveMatrix;
    }
    /**
     * Gets the perspective projection matrix computed from the view frustum with an infinite far plane.
     * @memberof PerspectiveOffCenterFrustum.prototype
     * @type {Matrix4}
     *
     * @see PerspectiveOffCenterFrustum#projectionMatrix
     */ get infiniteProjectionMatrix() {
        this._update();
        return this._infinitePerspective;
    }
    /**
     * Creates a culling volume for this frustum.
     * @returns {CullingVolume} A culling volume at the given position and orientation.
     *
     * @example
     * // Check if a bounding volume intersects the frustum.
     * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);
     * const intersect = cullingVolume.computeVisibility(boundingVolume);
     */ // eslint-disable-next-line complexity, max-statements
    computeCullingVolume(/** A Vector3 defines the eye position. */ position, /** A Vector3 defines the view direction. */ direction, /** A Vector3 defines the up direction. */ up) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(position, 'position is required.');
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(direction, 'direction is required.');
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(up, 'up is required.');
        const planes = this._cullingVolume.planes;
        up = scratchPlaneUpVector.copy(up).normalize();
        const right = scratchPlaneRightVector.copy(direction).cross(up).normalize();
        const nearCenter = scratchPlaneNearCenter.copy(direction).multiplyByScalar(this.near).add(position);
        const farCenter = scratchPlaneFarCenter.copy(direction).multiplyByScalar(this.far).add(position);
        let normal = scratchPlaneNormal;
        // Left plane computation
        normal.copy(right).multiplyByScalar(this.left).add(nearCenter).subtract(position).cross(up);
        planes[0].fromPointNormal(position, normal);
        // Right plane computation
        normal.copy(right).multiplyByScalar(this.right).add(nearCenter).subtract(position).cross(up).negate();
        planes[1].fromPointNormal(position, normal);
        // Bottom plane computation
        normal.copy(up).multiplyByScalar(this.bottom).add(nearCenter).subtract(position).cross(right).negate();
        planes[2].fromPointNormal(position, normal);
        // Top plane computation
        normal.copy(up).multiplyByScalar(this.top).add(nearCenter).subtract(position).cross(right);
        planes[3].fromPointNormal(position, normal);
        normal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]().copy(direction);
        // Near plane computation
        planes[4].fromPointNormal(nearCenter, normal);
        // Far plane computation
        normal.negate();
        planes[5].fromPointNormal(farCenter, normal);
        return this._cullingVolume;
    }
    /**
     * Returns the pixel's width and height in meters.
     *
     * @returns {Vector2} The modified result parameter or a new instance of {@link Vector2} with the pixel's width and height in the x and y properties, respectively.
     *
     * @exception {DeveloperError} drawingBufferWidth must be greater than zero.
     * @exception {DeveloperError} drawingBufferHeight must be greater than zero.
     *
     * @example
     * // Example 1
     * // Get the width and height of a pixel.
     * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, new Vector2());
     *
     * @example
     * // Example 2
     * // Get the width and height of a pixel if the near plane was set to 'distance'.
     * // For example, get the size of a pixel of an image on a billboard.
     * const position = camera.position;
     * const direction = camera.direction;
     * const toCenter = Vector3.subtract(primitive.boundingVolume.center, position, new Vector3());      // vector from camera to a primitive
     * const toCenterProj = Vector3.multiplyByScalar(direction, Vector3.dot(direction, toCenter), new Vector3()); // project vector onto camera direction vector
     * const distance = Vector3.magnitude(toCenterProj);
     * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distance, new Vector2());
     */ getPixelDimensions(/** The width of the drawing buffer. */ drawingBufferWidth, /** The height of the drawing buffer. */ drawingBufferHeight, /** The distance to the near plane in meters. */ distance, /** The object onto which to store the result. */ result) {
        this._update();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(Number.isFinite(drawingBufferWidth) && Number.isFinite(drawingBufferHeight));
        // 'Both drawingBufferWidth and drawingBufferHeight are required.'
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(drawingBufferWidth > 0);
        // 'drawingBufferWidth must be greater than zero.'
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(drawingBufferHeight > 0);
        // 'drawingBufferHeight must be greater than zero.'
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(distance > 0);
        // 'distance is required.');
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(result);
        // 'A result object is required.');
        const inverseNear = 1.0 / this.near;
        let tanTheta = this.top * inverseNear;
        const pixelHeight = 2.0 * distance * tanTheta / drawingBufferHeight;
        tanTheta = this.right * inverseNear;
        const pixelWidth = 2.0 * distance * tanTheta / drawingBufferWidth;
        result.x = pixelWidth;
        result.y = pixelHeight;
        return result;
    }
    // eslint-disable-next-line complexity, max-statements
    _update() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(Number.isFinite(this.right) && Number.isFinite(this.left) && Number.isFinite(this.top) && Number.isFinite(this.bottom) && Number.isFinite(this.near) && Number.isFinite(this.far));
        // throw new DeveloperError('right, left, top, bottom, near, or far parameters are not set.');
        const { top, bottom, right, left, near, far } = this;
        if (top !== this._top || bottom !== this._bottom || left !== this._left || right !== this._right || near !== this._near || far !== this._far) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(this.near > 0 && this.near < this.far, 'near must be greater than zero and less than far.');
            this._left = left;
            this._right = right;
            this._top = top;
            this._bottom = bottom;
            this._near = near;
            this._far = far;
            this._perspectiveMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix4$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix4"]().frustum({
                left,
                right,
                bottom,
                top,
                near,
                far
            });
            this._infinitePerspective = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix4$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix4"]().frustum({
                left,
                right,
                bottom,
                top,
                near,
                far: Infinity
            });
        }
    }
} //# sourceMappingURL=perspective-off-center-frustum.js.map
}}),
"[project]/node_modules/@math.gl/culling/dist/lib/perspective-frustum.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT and Apache-2.0
// Copyright (c) vis.gl contributors
__turbopack_context__.s({
    "PerspectiveFrustum": (()=>PerspectiveFrustum)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/lib/assert.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector2$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/classes/vector2.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$perspective$2d$off$2d$center$2d$frustum$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/perspective-off-center-frustum.js [client] (ecmascript)");
;
;
const defined = (val)=>val !== null && typeof val !== 'undefined';
class PerspectiveFrustum {
    constructor(options = {}){
        this._offCenterFrustum = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$perspective$2d$off$2d$center$2d$frustum$2e$js__$5b$client$5d$__$28$ecmascript$29$__["PerspectiveOffCenterFrustum"]();
        const { fov, aspectRatio, near = 1.0, far = 500000000.0, xOffset = 0.0, yOffset = 0.0 } = options;
        this.fov = fov;
        this.aspectRatio = aspectRatio;
        this.near = near;
        this.far = far;
        this.xOffset = xOffset;
        this.yOffset = yOffset;
    }
    /**
     * Returns a duplicate of a PerspectiveFrustum instance.
     */ clone() {
        return new PerspectiveFrustum({
            aspectRatio: this.aspectRatio,
            fov: this.fov,
            near: this.near,
            far: this.far
        });
    }
    /**
     * Compares the provided PerspectiveFrustum componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     */ equals(other) {
        if (!defined(other) || !(other instanceof PerspectiveFrustum)) {
            return false;
        }
        this._update();
        other._update();
        return this.fov === other.fov && this.aspectRatio === other.aspectRatio && this.near === other.near && this.far === other.far && this._offCenterFrustum.equals(other._offCenterFrustum);
    }
    /**
     * Gets the perspective projection matrix computed from the view this.
     */ get projectionMatrix() {
        this._update();
        return this._offCenterFrustum.projectionMatrix;
    }
    /**
     * The perspective projection matrix computed from the view frustum with an infinite far plane.
     */ get infiniteProjectionMatrix() {
        this._update();
        return this._offCenterFrustum.infiniteProjectionMatrix;
    }
    /**
     * Gets the angle of the vertical field of view, in radians.
     */ get fovy() {
        this._update();
        return this._fovy;
    }
    /**
     * @private
     */ get sseDenominator() {
        this._update();
        return this._sseDenominator;
    }
    /**
     * Creates a culling volume for this this.ion.
     * @returns {CullingVolume} A culling volume at the given position and orientation.
     *
     * @example
     * // Check if a bounding volume intersects the this.
     * var cullingVolume = this.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);
     * var intersect = cullingVolume.computeVisibility(boundingVolume);
     */ computeCullingVolume(/** A Vector3 defines the eye position. */ position, /** A Vector3 defines the view direction. */ direction, /** A Vector3 defines the up direction. */ up) {
        this._update();
        return this._offCenterFrustum.computeCullingVolume(position, direction, up);
    }
    /**
     * Returns the pixel's width and height in meters.
     * @returns {Vector2} The modified result parameter or a new instance of {@link Vector2} with the pixel's width and height in the x and y properties, respectively.
     *
     * @exception {DeveloperError} drawingBufferWidth must be greater than zero.
     * @exception {DeveloperError} drawingBufferHeight must be greater than zero.
     *
     * @example
     * // Example 1
     * // Get the width and height of a pixel.
     * var pixelSize = camera.this.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, new Vector2());
     *
     * @example
     * // Example 2
     * // Get the width and height of a pixel if the near plane was set to 'distance'.
     * // For example, get the size of a pixel of an image on a billboard.
     * var position = camera.position;
     * var direction = camera.direction;
     * var toCenter = Vector3.subtract(primitive.boundingVolume.center, position, new Vector3());      // vector from camera to a primitive
     * var toCenterProj = Vector3.multiplyByScalar(direction, Vector3.dot(direction, toCenter), new Vector3()); // project vector onto camera direction vector
     * var distance = Vector3.magnitude(toCenterProj);
     * var pixelSize = camera.this.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distance, new Vector2());
     */ getPixelDimensions(/** The width of the drawing buffer. */ drawingBufferWidth, /** The height of the drawing buffer. */ drawingBufferHeight, /** The distance to the near plane in meters. */ distance, /** The object onto which to store the result. */ result) {
        this._update();
        return this._offCenterFrustum.getPixelDimensions(drawingBufferWidth, drawingBufferHeight, distance, result || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector2$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector2"]());
    }
    // eslint-disable-next-line complexity, max-statements
    _update() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(Number.isFinite(this.fov) && Number.isFinite(this.aspectRatio) && Number.isFinite(this.near) && Number.isFinite(this.far));
        // 'fov, aspectRatio, near, or far parameters are not set.'
        const f = this._offCenterFrustum;
        if (this.fov !== this._fov || this.aspectRatio !== this._aspectRatio || this.near !== this._near || this.far !== this._far || this.xOffset !== this._xOffset || this.yOffset !== this._yOffset) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(this.fov >= 0 && this.fov < Math.PI);
            // throw new DeveloperError('fov must be in the range [0, PI).');
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(this.aspectRatio > 0);
            // throw new DeveloperError('aspectRatio must be positive.');
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["assert"])(this.near >= 0 && this.near < this.far);
            // throw new DeveloperError('near must be greater than zero and less than far.');
            this._aspectRatio = this.aspectRatio;
            this._fov = this.fov;
            this._fovy = this.aspectRatio <= 1 ? this.fov : Math.atan(Math.tan(this.fov * 0.5) / this.aspectRatio) * 2.0;
            this._near = this.near;
            this._far = this.far;
            this._sseDenominator = 2.0 * Math.tan(0.5 * this._fovy);
            this._xOffset = this.xOffset;
            this._yOffset = this.yOffset;
            f.top = this.near * Math.tan(0.5 * this._fovy);
            f.bottom = -f.top;
            f.right = this.aspectRatio * f.top;
            f.left = -f.right;
            f.near = this.near;
            f.far = this.far;
            f.right += this.xOffset;
            f.left += this.xOffset;
            f.top += this.yOffset;
            f.bottom += this.yOffset;
        }
    }
} //# sourceMappingURL=perspective-frustum.js.map
}}),
"[project]/node_modules/@math.gl/culling/dist/lib/algorithms/bounding-sphere-from-points.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT and Apache-2.0
// Copyright (c) vis.gl contributors
// This file is derived from the Cesium math library under Apache 2 license
// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md
__turbopack_context__.s({
    "makeBoundingSphereFromPoints": (()=>makeBoundingSphereFromPoints)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/classes/vector3.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$bounding$2d$volumes$2f$bounding$2d$sphere$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/bounding-volumes/bounding-sphere.js [client] (ecmascript)");
;
;
/* eslint-disable */ const fromPointsXMin = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const fromPointsYMin = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const fromPointsZMin = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const fromPointsXMax = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const fromPointsYMax = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const fromPointsZMax = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const fromPointsCurrentPos = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const fromPointsScratch = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const fromPointsRitterCenter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const fromPointsMinBoxPt = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const fromPointsMaxBoxPt = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const fromPointsNaiveCenterScratch = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
function makeBoundingSphereFromPoints(positions, result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$bounding$2d$volumes$2f$bounding$2d$sphere$2e$js__$5b$client$5d$__$28$ecmascript$29$__["BoundingSphere"]()) {
    if (!positions || positions.length === 0) {
        return result.fromCenterRadius([
            0,
            0,
            0
        ], 0);
    }
    const currentPos = fromPointsCurrentPos.copy(positions[0]);
    const xMin = fromPointsXMin.copy(currentPos);
    const yMin = fromPointsYMin.copy(currentPos);
    const zMin = fromPointsZMin.copy(currentPos);
    const xMax = fromPointsXMax.copy(currentPos);
    const yMax = fromPointsYMax.copy(currentPos);
    const zMax = fromPointsZMax.copy(currentPos);
    for (const position of positions){
        currentPos.copy(position);
        const x = currentPos.x;
        const y = currentPos.y;
        const z = currentPos.z;
        // Store points containing the the smallest and largest components
        if (x < xMin.x) {
            xMin.copy(currentPos);
        }
        if (x > xMax.x) {
            xMax.copy(currentPos);
        }
        if (y < yMin.y) {
            yMin.copy(currentPos);
        }
        if (y > yMax.y) {
            yMax.copy(currentPos);
        }
        if (z < zMin.z) {
            zMin.copy(currentPos);
        }
        if (z > zMax.z) {
            zMax.copy(currentPos);
        }
    }
    // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).
    const xSpan = fromPointsScratch.copy(xMax).subtract(xMin).magnitudeSquared();
    const ySpan = fromPointsScratch.copy(yMax).subtract(yMin).magnitudeSquared();
    const zSpan = fromPointsScratch.copy(zMax).subtract(zMin).magnitudeSquared();
    // Set the diameter endpoints to the largest span.
    let diameter1 = xMin;
    let diameter2 = xMax;
    let maxSpan = xSpan;
    if (ySpan > maxSpan) {
        maxSpan = ySpan;
        diameter1 = yMin;
        diameter2 = yMax;
    }
    if (zSpan > maxSpan) {
        maxSpan = zSpan;
        diameter1 = zMin;
        diameter2 = zMax;
    }
    // Calculate the center of the initial sphere found by Ritter's algorithm
    const ritterCenter = fromPointsRitterCenter;
    ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;
    ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;
    ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;
    // Calculate the radius of the initial sphere found by Ritter's algorithm
    let radiusSquared = fromPointsScratch.copy(diameter2).subtract(ritterCenter).magnitudeSquared();
    let ritterRadius = Math.sqrt(radiusSquared);
    // Find the center of the sphere found using the Naive method.
    const minBoxPt = fromPointsMinBoxPt;
    minBoxPt.x = xMin.x;
    minBoxPt.y = yMin.y;
    minBoxPt.z = zMin.z;
    const maxBoxPt = fromPointsMaxBoxPt;
    maxBoxPt.x = xMax.x;
    maxBoxPt.y = yMax.y;
    maxBoxPt.z = zMax.z;
    const naiveCenter = fromPointsNaiveCenterScratch.copy(minBoxPt).add(maxBoxPt).multiplyByScalar(0.5);
    // Begin 2nd pass to find naive radius and modify the ritter sphere.
    let naiveRadius = 0;
    for (const position of positions){
        currentPos.copy(position);
        // Find the furthest point from the naive center to calculate the naive radius.
        const r = fromPointsScratch.copy(currentPos).subtract(naiveCenter).magnitude();
        if (r > naiveRadius) {
            naiveRadius = r;
        }
        // Make adjustments to the Ritter Sphere to include all points.
        const oldCenterToPointSquared = fromPointsScratch.copy(currentPos).subtract(ritterCenter).magnitudeSquared();
        if (oldCenterToPointSquared > radiusSquared) {
            const oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);
            // Calculate new radius to include the point that lies outside
            ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;
            radiusSquared = ritterRadius * ritterRadius;
            // Calculate center of new Ritter sphere
            const oldToNew = oldCenterToPoint - ritterRadius;
            ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;
            ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;
            ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;
        }
    }
    if (ritterRadius < naiveRadius) {
        ritterCenter.to(result.center);
        result.radius = ritterRadius;
    } else {
        naiveCenter.to(result.center);
        result.radius = naiveRadius;
    }
    return result;
} //# sourceMappingURL=bounding-sphere-from-points.js.map
}}),
"[project]/node_modules/@math.gl/culling/dist/lib/algorithms/compute-eigen-decomposition.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT and Apache-2.0
// Copyright (c) vis.gl contributors
// This file is derived from the Cesium math library under Apache 2 license
// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md
__turbopack_context__.s({
    "computeEigenDecomposition": (()=>computeEigenDecomposition)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix3$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/classes/matrix3.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__$5f$MathUtils$3e$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/lib/math-utils.js [client] (ecmascript) <export * as _MathUtils>");
;
const scratchMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix3"]();
const scratchUnitary = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix3"]();
const scratchDiagonal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix3"]();
const jMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix3"]();
const jMatrixTranspose = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix3"]();
function computeEigenDecomposition(matrix, // @ts-expect-error accept empty object type
result = {}) {
    const EIGEN_TOLERANCE = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__$5f$MathUtils$3e$__["_MathUtils"].EPSILON20;
    const EIGEN_MAX_SWEEPS = 10;
    let count = 0;
    let sweep = 0;
    const unitaryMatrix = scratchUnitary;
    const diagonalMatrix = scratchDiagonal;
    unitaryMatrix.identity();
    diagonalMatrix.copy(matrix);
    const epsilon = EIGEN_TOLERANCE * computeFrobeniusNorm(diagonalMatrix);
    while(sweep < EIGEN_MAX_SWEEPS && offDiagonalFrobeniusNorm(diagonalMatrix) > epsilon){
        shurDecomposition(diagonalMatrix, jMatrix);
        jMatrixTranspose.copy(jMatrix).transpose();
        diagonalMatrix.multiplyRight(jMatrix);
        diagonalMatrix.multiplyLeft(jMatrixTranspose);
        unitaryMatrix.multiplyRight(jMatrix);
        if (++count > 2) {
            ++sweep;
            count = 0;
        }
    }
    result.unitary = unitaryMatrix.toTarget(result.unitary);
    result.diagonal = diagonalMatrix.toTarget(result.diagonal);
    return result;
}
function computeFrobeniusNorm(matrix) {
    let norm = 0.0;
    for(let i = 0; i < 9; ++i){
        const temp = matrix[i];
        norm += temp * temp;
    }
    return Math.sqrt(norm);
}
const rowVal = [
    1,
    0,
    0
];
const colVal = [
    2,
    2,
    1
];
// Computes the "off-diagonal" Frobenius norm.
// Assumes matrix is symmetric.
function offDiagonalFrobeniusNorm(matrix) {
    let norm = 0.0;
    for(let i = 0; i < 3; ++i){
        const temp = matrix[scratchMatrix.getElementIndex(colVal[i], rowVal[i])];
        norm += 2.0 * temp * temp;
    }
    return Math.sqrt(norm);
}
// The routine takes a matrix, which is assumed to be symmetric, and
// finds the largest off-diagonal term, and then creates
// a matrix (result) which can be used to help reduce it
//
// This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,
// section 8.4.2 The 2by2 Symmetric Schur Decomposition.
//
// eslint-disable-next-line max-statements
function shurDecomposition(matrix, result) {
    const tolerance = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$lib$2f$math$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__$5f$MathUtils$3e$__["_MathUtils"].EPSILON15;
    let maxDiagonal = 0.0;
    let rotAxis = 1;
    // find pivot (rotAxis) based on max diagonal of matrix
    for(let i = 0; i < 3; ++i){
        const temp = Math.abs(matrix[scratchMatrix.getElementIndex(colVal[i], rowVal[i])]);
        if (temp > maxDiagonal) {
            rotAxis = i;
            maxDiagonal = temp;
        }
    }
    const p = rowVal[rotAxis];
    const q = colVal[rotAxis];
    let c = 1.0;
    let s = 0.0;
    if (Math.abs(matrix[scratchMatrix.getElementIndex(q, p)]) > tolerance) {
        const qq = matrix[scratchMatrix.getElementIndex(q, q)];
        const pp = matrix[scratchMatrix.getElementIndex(p, p)];
        const qp = matrix[scratchMatrix.getElementIndex(q, p)];
        const tau = (qq - pp) / 2.0 / qp;
        let t;
        if (tau < 0.0) {
            t = -1.0 / (-tau + Math.sqrt(1.0 + tau * tau));
        } else {
            t = 1.0 / (tau + Math.sqrt(1.0 + tau * tau));
        }
        c = 1.0 / Math.sqrt(1.0 + t * t);
        s = t * c;
    }
    // Copy into result
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix3"].IDENTITY.to(result);
    result[scratchMatrix.getElementIndex(p, p)] = result[scratchMatrix.getElementIndex(q, q)] = c;
    result[scratchMatrix.getElementIndex(q, p)] = s;
    result[scratchMatrix.getElementIndex(p, q)] = -s;
    return result;
} //# sourceMappingURL=compute-eigen-decomposition.js.map
}}),
"[project]/node_modules/@math.gl/culling/dist/lib/algorithms/bounding-box-from-points.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT and Apache-2.0
// Copyright (c) vis.gl contributors
// This file is derived from the Cesium math library under Apache 2 license
// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md
__turbopack_context__.s({
    "makeAxisAlignedBoundingBoxFromPoints": (()=>makeAxisAlignedBoundingBoxFromPoints),
    "makeOrientedBoundingBoxFromPoints": (()=>makeOrientedBoundingBoxFromPoints)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/classes/vector3.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix3$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/core/dist/classes/matrix3.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$algorithms$2f$compute$2d$eigen$2d$decomposition$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/algorithms/compute-eigen-decomposition.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$bounding$2d$volumes$2f$oriented$2d$bounding$2d$box$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/bounding-volumes/oriented-bounding-box.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$bounding$2d$volumes$2f$axis$2d$aligned$2d$bounding$2d$box$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/bounding-volumes/axis-aligned-bounding-box.js [client] (ecmascript)");
;
;
;
;
const scratchVector2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const scratchVector3 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const scratchVector4 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const scratchVector5 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const scratchVector6 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
const scratchCovarianceResult = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix3"]();
const scratchEigenResult = {
    diagonal: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix3"](),
    unitary: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix3"]()
};
function makeOrientedBoundingBoxFromPoints(positions, result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$bounding$2d$volumes$2f$oriented$2d$bounding$2d$box$2e$js__$5b$client$5d$__$28$ecmascript$29$__["OrientedBoundingBox"]()) {
    if (!positions || positions.length === 0) {
        result.halfAxes = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix3"]([
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]);
        result.center = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"]();
        return result;
    }
    const length = positions.length;
    const meanPoint = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$vector3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Vector3"](0, 0, 0);
    for (const position of positions){
        meanPoint.add(position);
    }
    const invLength = 1.0 / length;
    meanPoint.multiplyByScalar(invLength);
    let exx = 0.0;
    let exy = 0.0;
    let exz = 0.0;
    let eyy = 0.0;
    let eyz = 0.0;
    let ezz = 0.0;
    for (const position of positions){
        const p = scratchVector2.copy(position).subtract(meanPoint);
        exx += p.x * p.x;
        exy += p.x * p.y;
        exz += p.x * p.z;
        eyy += p.y * p.y;
        eyz += p.y * p.z;
        ezz += p.z * p.z;
    }
    exx *= invLength;
    exy *= invLength;
    exz *= invLength;
    eyy *= invLength;
    eyz *= invLength;
    ezz *= invLength;
    const covarianceMatrix = scratchCovarianceResult;
    covarianceMatrix[0] = exx;
    covarianceMatrix[1] = exy;
    covarianceMatrix[2] = exz;
    covarianceMatrix[3] = exy;
    covarianceMatrix[4] = eyy;
    covarianceMatrix[5] = eyz;
    covarianceMatrix[6] = exz;
    covarianceMatrix[7] = eyz;
    covarianceMatrix[8] = ezz;
    const { unitary } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$algorithms$2f$compute$2d$eigen$2d$decomposition$2e$js__$5b$client$5d$__$28$ecmascript$29$__["computeEigenDecomposition"])(covarianceMatrix, scratchEigenResult);
    const rotation = result.halfAxes.copy(unitary);
    let v1 = rotation.getColumn(0, scratchVector4);
    let v2 = rotation.getColumn(1, scratchVector5);
    let v3 = rotation.getColumn(2, scratchVector6);
    let u1 = -Number.MAX_VALUE;
    let u2 = -Number.MAX_VALUE;
    let u3 = -Number.MAX_VALUE;
    let l1 = Number.MAX_VALUE;
    let l2 = Number.MAX_VALUE;
    let l3 = Number.MAX_VALUE;
    for (const position of positions){
        scratchVector2.copy(position);
        u1 = Math.max(scratchVector2.dot(v1), u1);
        u2 = Math.max(scratchVector2.dot(v2), u2);
        u3 = Math.max(scratchVector2.dot(v3), u3);
        l1 = Math.min(scratchVector2.dot(v1), l1);
        l2 = Math.min(scratchVector2.dot(v2), l2);
        l3 = Math.min(scratchVector2.dot(v3), l3);
    }
    v1 = v1.multiplyByScalar(0.5 * (l1 + u1));
    v2 = v2.multiplyByScalar(0.5 * (l2 + u2));
    v3 = v3.multiplyByScalar(0.5 * (l3 + u3));
    result.center.copy(v1).add(v2).add(v3);
    const scale = scratchVector3.set(u1 - l1, u2 - l2, u3 - l3).multiplyByScalar(0.5);
    const scaleMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$core$2f$dist$2f$classes$2f$matrix3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Matrix3"]([
        scale[0],
        0,
        0,
        0,
        scale[1],
        0,
        0,
        0,
        scale[2]
    ]);
    result.halfAxes.multiplyRight(scaleMatrix);
    return result;
}
function makeAxisAlignedBoundingBoxFromPoints(positions, result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$bounding$2d$volumes$2f$axis$2d$aligned$2d$bounding$2d$box$2e$js__$5b$client$5d$__$28$ecmascript$29$__["AxisAlignedBoundingBox"]()) {
    if (!positions || positions.length === 0) {
        result.minimum.set(0, 0, 0);
        result.maximum.set(0, 0, 0);
        result.center.set(0, 0, 0);
        result.halfDiagonal.set(0, 0, 0);
        return result;
    }
    let minimumX = positions[0][0];
    let minimumY = positions[0][1];
    let minimumZ = positions[0][2];
    let maximumX = positions[0][0];
    let maximumY = positions[0][1];
    let maximumZ = positions[0][2];
    for (const p of positions){
        const x = p[0];
        const y = p[1];
        const z = p[2];
        minimumX = Math.min(x, minimumX);
        maximumX = Math.max(x, maximumX);
        minimumY = Math.min(y, minimumY);
        maximumY = Math.max(y, maximumY);
        minimumZ = Math.min(z, minimumZ);
        maximumZ = Math.max(z, maximumZ);
    }
    result.minimum.set(minimumX, minimumY, minimumZ);
    result.maximum.set(maximumX, maximumY, maximumZ);
    result.center.copy(result.minimum).add(result.maximum).scale(0.5);
    result.halfDiagonal.copy(result.maximum).subtract(result.center);
    return result;
} //# sourceMappingURL=bounding-box-from-points.js.map
}}),
"[project]/node_modules/@math.gl/culling/dist/index.js [client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// math.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
__turbopack_context__.s({});
;
;
;
;
;
;
;
;
;
;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@math.gl/culling/dist/index.js [client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/constants.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$bounding$2d$volumes$2f$axis$2d$aligned$2d$bounding$2d$box$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/bounding-volumes/axis-aligned-bounding-box.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$bounding$2d$volumes$2f$bounding$2d$sphere$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/bounding-volumes/bounding-sphere.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$bounding$2d$volumes$2f$oriented$2d$bounding$2d$box$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/bounding-volumes/oriented-bounding-box.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$culling$2d$volume$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/culling-volume.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$plane$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/plane.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$perspective$2d$off$2d$center$2d$frustum$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/perspective-off-center-frustum.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$perspective$2d$frustum$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/perspective-frustum.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$algorithms$2f$bounding$2d$sphere$2d$from$2d$points$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/algorithms/bounding-sphere-from-points.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$algorithms$2f$bounding$2d$box$2d$from$2d$points$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/algorithms/bounding-box-from-points.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$lib$2f$algorithms$2f$compute$2d$eigen$2d$decomposition$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/lib/algorithms/compute-eigen-decomposition.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$culling$2f$dist$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/culling/dist/index.js [client] (ecmascript) <locals>");
}}),
}]);

//# sourceMappingURL=node_modules_d7aa4dd8._.js.map