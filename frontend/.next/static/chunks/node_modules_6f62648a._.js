(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_6f62648a._.js", {

"[project]/node_modules/@probe.gl/env/dist/index.js [client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Extract injected version from package.json (injected by babel plugin)
// @ts-expect-error
__turbopack_context__.s({
    "VERSION": (()=>VERSION)
});
const VERSION = typeof "4.1.0" !== 'undefined' ? "4.1.0" : 'untranspiled source';
;
;
;
;
;
 // TODO - wish we could just export a constant
 // export const isBrowser = checkIfBrowser();
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@probe.gl/env/dist/lib/is-electron.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// based on https://github.com/cheton/is-electron
// https://github.com/electron/electron/issues/2288
/* eslint-disable complexity */ __turbopack_context__.s({
    "isElectron": (()=>isElectron)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
function isElectron(mockUserAgent) {
    // Renderer process
    // @ts-expect-error
    if (typeof window !== 'undefined' && window.process?.type === 'renderer') {
        return true;
    }
    // Main process
    // eslint-disable-next-line
    if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"] !== 'undefined' && Boolean(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].versions?.['electron'])) {
        return true;
    }
    // Detect the user agent when the `nodeIntegration` option is set to true
    const realUserAgent = typeof navigator !== 'undefined' && navigator.userAgent;
    const userAgent = mockUserAgent || realUserAgent;
    return Boolean(userAgent && userAgent.indexOf('Electron') >= 0);
} //# sourceMappingURL=is-electron.js.map
}}),
"[project]/node_modules/@probe.gl/env/dist/lib/is-browser.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// This function is needed in initialization stages,
// make sure it can be imported in isolation
__turbopack_context__.s({
    "isBrowser": (()=>isBrowser)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$is$2d$electron$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/env/dist/lib/is-electron.js [client] (ecmascript)");
;
function isBrowser() {
    const isNode = // @ts-expect-error
    typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"] === 'object' && String(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"]) === '[object process]' && !("TURBOPACK compile-time value", true);
    return !isNode || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$is$2d$electron$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isElectron"])();
} //# sourceMappingURL=is-browser.js.map
}}),
"[project]/node_modules/@probe.gl/env/dist/lib/globals.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Do not name these variables the same as the global objects - will break bundling
__turbopack_context__.s({
    "console": (()=>console_),
    "document": (()=>document_),
    "global": (()=>global_),
    "navigator": (()=>navigator_),
    "process": (()=>process_),
    "self": (()=>global_),
    "window": (()=>window_)
});
const global_ = globalThis;
const window_ = globalThis;
const document_ = globalThis.document || {};
const process_ = globalThis.process || {};
const console_ = globalThis.console;
const navigator_ = globalThis.navigator || {};
;
 //# sourceMappingURL=globals.js.map
}}),
"[project]/node_modules/@probe.gl/env/dist/lib/get-browser.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
// This function is needed in initialization stages,
// make sure it can be imported in isolation
__turbopack_context__.s({
    "getBrowser": (()=>getBrowser),
    "isMobile": (()=>isMobile)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$is$2d$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/env/dist/lib/is-browser.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$is$2d$electron$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/env/dist/lib/is-electron.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/env/dist/lib/globals.js [client] (ecmascript)");
;
;
;
function isMobile() {
    return typeof globalThis.orientation !== 'undefined';
}
function getBrowser(mockUserAgent) {
    if (!mockUserAgent && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$is$2d$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBrowser"])()) {
        return 'Node';
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$is$2d$electron$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isElectron"])(mockUserAgent)) {
        return 'Electron';
    }
    const userAgent = mockUserAgent || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__["navigator"].userAgent || '';
    // NOTE: Order of tests matter, as many agents list Chrome etc.
    if (userAgent.indexOf('Edge') > -1) {
        return 'Edge';
    }
    if (globalThis.chrome) {
        return 'Chrome';
    }
    if (globalThis.safari) {
        return 'Safari';
    }
    if (globalThis.mozInnerScreenX) {
        return 'Firefox';
    }
    return 'Unknown';
} //# sourceMappingURL=get-browser.js.map
}}),
"[project]/node_modules/@probe.gl/log/dist/utils/local-storage.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// probe.gl, MIT license
__turbopack_context__.s({
    "LocalStorage": (()=>LocalStorage)
});
function getStorage(type) {
    try {
        const storage = window[type];
        const x = '__storage_test__';
        storage.setItem(x, x);
        storage.removeItem(x);
        return storage;
    } catch (e) {
        return null;
    }
}
class LocalStorage {
    constructor(id, defaultConfig, type = 'sessionStorage'){
        this.storage = getStorage(type);
        this.id = id;
        this.config = defaultConfig;
        this._loadConfiguration();
    }
    getConfiguration() {
        return this.config;
    }
    setConfiguration(configuration) {
        Object.assign(this.config, configuration);
        if (this.storage) {
            const serialized = JSON.stringify(this.config);
            this.storage.setItem(this.id, serialized);
        }
    }
    // Get config from persistent store, if available
    _loadConfiguration() {
        let configuration = {};
        if (this.storage) {
            const serializedConfiguration = this.storage.getItem(this.id);
            configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
        }
        Object.assign(this.config, configuration);
        return this;
    }
} //# sourceMappingURL=local-storage.js.map
}}),
"[project]/node_modules/@probe.gl/log/dist/utils/formatters.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// probe.gl, MIT license
/**
 * Format time
 */ __turbopack_context__.s({
    "formatTime": (()=>formatTime),
    "formatValue": (()=>formatValue),
    "leftPad": (()=>leftPad),
    "rightPad": (()=>rightPad)
});
function formatTime(ms) {
    let formatted;
    if (ms < 10) {
        formatted = `${ms.toFixed(2)}ms`;
    } else if (ms < 100) {
        formatted = `${ms.toFixed(1)}ms`;
    } else if (ms < 1000) {
        formatted = `${ms.toFixed(0)}ms`;
    } else {
        formatted = `${(ms / 1000).toFixed(2)}s`;
    }
    return formatted;
}
function leftPad(string, length = 8) {
    const padLength = Math.max(length - string.length, 0);
    return `${' '.repeat(padLength)}${string}`;
}
function rightPad(string, length = 8) {
    const padLength = Math.max(length - string.length, 0);
    return `${string}${' '.repeat(padLength)}`;
}
function formatValue(v, options = {}) {
    const EPSILON = 1e-16;
    const { isInteger = false } = options;
    if (Array.isArray(v) || ArrayBuffer.isView(v)) {
        return formatArrayValue(v, options);
    }
    if (!Number.isFinite(v)) {
        return String(v);
    }
    // @ts-expect-error
    if (Math.abs(v) < EPSILON) {
        return isInteger ? '0' : '0.';
    }
    if (isInteger) {
        // @ts-expect-error
        return v.toFixed(0);
    }
    // @ts-expect-error
    if (Math.abs(v) > 100 && Math.abs(v) < 10000) {
        // @ts-expect-error
        return v.toFixed(0);
    }
    // @ts-expect-error
    const string = v.toPrecision(2);
    const decimal = string.indexOf('.0');
    return decimal === string.length - 2 ? string.slice(0, -1) : string;
}
/** Helper to formatValue */ function formatArrayValue(v, options) {
    const { maxElts = 16, size = 1 } = options;
    let string = '[';
    for(let i = 0; i < v.length && i < maxElts; ++i){
        if (i > 0) {
            string += `,${i % size === 0 ? ' ' : ''}`;
        }
        string += formatValue(v[i], options);
    }
    const terminator = v.length > maxElts ? '...' : ']';
    return `${string}${terminator}`;
} //# sourceMappingURL=formatters.js.map
}}),
"[project]/node_modules/@probe.gl/log/dist/utils/color.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "COLOR": (()=>COLOR),
    "addColor": (()=>addColor)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$is$2d$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/env/dist/lib/is-browser.js [client] (ecmascript)");
;
var COLOR;
(function(COLOR) {
    COLOR[COLOR["BLACK"] = 30] = "BLACK";
    COLOR[COLOR["RED"] = 31] = "RED";
    COLOR[COLOR["GREEN"] = 32] = "GREEN";
    COLOR[COLOR["YELLOW"] = 33] = "YELLOW";
    COLOR[COLOR["BLUE"] = 34] = "BLUE";
    COLOR[COLOR["MAGENTA"] = 35] = "MAGENTA";
    COLOR[COLOR["CYAN"] = 36] = "CYAN";
    COLOR[COLOR["WHITE"] = 37] = "WHITE";
    COLOR[COLOR["BRIGHT_BLACK"] = 90] = "BRIGHT_BLACK";
    COLOR[COLOR["BRIGHT_RED"] = 91] = "BRIGHT_RED";
    COLOR[COLOR["BRIGHT_GREEN"] = 92] = "BRIGHT_GREEN";
    COLOR[COLOR["BRIGHT_YELLOW"] = 93] = "BRIGHT_YELLOW";
    COLOR[COLOR["BRIGHT_BLUE"] = 94] = "BRIGHT_BLUE";
    COLOR[COLOR["BRIGHT_MAGENTA"] = 95] = "BRIGHT_MAGENTA";
    COLOR[COLOR["BRIGHT_CYAN"] = 96] = "BRIGHT_CYAN";
    COLOR[COLOR["BRIGHT_WHITE"] = 97] = "BRIGHT_WHITE";
})(COLOR || (COLOR = {}));
const BACKGROUND_INCREMENT = 10;
function getColor(color) {
    if (typeof color !== 'string') {
        return color;
    }
    color = color.toUpperCase();
    return COLOR[color] || COLOR.WHITE;
}
function addColor(string, color, background) {
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$is$2d$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBrowser"] && typeof string === 'string') {
        if (color) {
            const colorCode = getColor(color);
            string = `\u001b[${colorCode}m${string}\u001b[39m`;
        }
        if (background) {
            // background colors values are +10
            const colorCode = getColor(background);
            string = `\u001b[${colorCode + BACKGROUND_INCREMENT}m${string}\u001b[49m`;
        }
    }
    return string;
} //# sourceMappingURL=color.js.map
}}),
"[project]/node_modules/@probe.gl/log/dist/utils/autobind.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
/**
 * Binds the "this" argument of all functions on a class instance to the instance
 * @param obj - class instance (typically a react component)
 */ __turbopack_context__.s({
    "autobind": (()=>autobind)
});
function autobind(obj, predefined = [
    'constructor'
]) {
    const proto = Object.getPrototypeOf(obj);
    const propNames = Object.getOwnPropertyNames(proto);
    const object = obj;
    for (const key of propNames){
        const value = object[key];
        if (typeof value === 'function') {
            if (!predefined.find((name)=>key === name)) {
                object[key] = value.bind(obj);
            }
        }
    }
} //# sourceMappingURL=autobind.js.map
}}),
"[project]/node_modules/@probe.gl/log/dist/utils/assert.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>assert)
});
function assert(condition, message) {
    if (!condition) {
        throw new Error(message || 'Assertion failed');
    }
} //# sourceMappingURL=assert.js.map
}}),
"[project]/node_modules/@probe.gl/log/dist/utils/hi-res-timestamp.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// probe.gl, MIT license
__turbopack_context__.s({
    "getHiResTimestamp": (()=>getHiResTimestamp)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/env/dist/lib/globals.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$is$2d$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/env/dist/lib/is-browser.js [client] (ecmascript)");
;
function getHiResTimestamp() {
    let timestamp;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$is$2d$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBrowser"])() && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__["window"].performance) {
        timestamp = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__["window"]?.performance?.now?.();
    } else if ('hrtime' in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__["process"]) {
        // @ts-ignore
        const timeParts = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$globals$2e$js__$5b$client$5d$__$28$ecmascript$29$__["process"]?.hrtime?.();
        timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;
    } else {
        timestamp = Date.now();
    }
    return timestamp;
} //# sourceMappingURL=hi-res-timestamp.js.map
}}),
"[project]/node_modules/@probe.gl/log/dist/log.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// probe.gl, MIT license
/* eslint-disable no-console,prefer-rest-params */ __turbopack_context__.s({
    "Log": (()=>Log),
    "normalizeArguments": (()=>normalizeArguments)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/env/dist/index.js [client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$is$2d$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/env/dist/lib/is-browser.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$utils$2f$local$2d$storage$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/log/dist/utils/local-storage.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$utils$2f$formatters$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/log/dist/utils/formatters.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$utils$2f$color$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/log/dist/utils/color.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$utils$2f$autobind$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/log/dist/utils/autobind.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/log/dist/utils/assert.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$utils$2f$hi$2d$res$2d$timestamp$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/log/dist/utils/hi-res-timestamp.js [client] (ecmascript)");
;
;
;
;
;
;
;
// Instrumentation in other packages may override console methods, so preserve them here
const originalConsole = {
    debug: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$lib$2f$is$2d$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBrowser"])() ? console.debug || console.log : console.log,
    log: console.log,
    info: console.info,
    warn: console.warn,
    error: console.error
};
const DEFAULT_LOG_CONFIGURATION = {
    enabled: true,
    level: 0
};
function noop() {} // eslint-disable-line @typescript-eslint/no-empty-function
const cache = {};
const ONCE = {
    once: true
};
class Log {
    constructor({ id } = {
        id: ''
    }){
        this.VERSION = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["VERSION"];
        this._startTs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$utils$2f$hi$2d$res$2d$timestamp$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getHiResTimestamp"])();
        this._deltaTs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$utils$2f$hi$2d$res$2d$timestamp$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getHiResTimestamp"])();
        this.userData = {};
        // TODO - fix support from throttling groups
        this.LOG_THROTTLE_TIMEOUT = 0; // Time before throttled messages are logged again
        this.id = id;
        this.userData = {};
        this._storage = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$utils$2f$local$2d$storage$2e$js__$5b$client$5d$__$28$ecmascript$29$__["LocalStorage"](`__probe-${this.id}__`, DEFAULT_LOG_CONFIGURATION);
        this.timeStamp(`${this.id} started`);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$utils$2f$autobind$2e$js__$5b$client$5d$__$28$ecmascript$29$__["autobind"])(this);
        Object.seal(this);
    }
    set level(newLevel) {
        this.setLevel(newLevel);
    }
    get level() {
        return this.getLevel();
    }
    isEnabled() {
        return this._storage.config.enabled;
    }
    getLevel() {
        return this._storage.config.level;
    }
    /** @return milliseconds, with fractions */ getTotal() {
        return Number(((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$utils$2f$hi$2d$res$2d$timestamp$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getHiResTimestamp"])() - this._startTs).toPrecision(10));
    }
    /** @return milliseconds, with fractions */ getDelta() {
        return Number(((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$utils$2f$hi$2d$res$2d$timestamp$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getHiResTimestamp"])() - this._deltaTs).toPrecision(10));
    }
    /** @deprecated use logLevel */ set priority(newPriority) {
        this.level = newPriority;
    }
    /** @deprecated use logLevel */ get priority() {
        return this.level;
    }
    /** @deprecated use logLevel */ getPriority() {
        return this.level;
    }
    // Configure
    enable(enabled = true) {
        this._storage.setConfiguration({
            enabled
        });
        return this;
    }
    setLevel(level) {
        this._storage.setConfiguration({
            level
        });
        return this;
    }
    /** return the current status of the setting */ get(setting) {
        return this._storage.config[setting];
    }
    // update the status of the setting
    set(setting, value) {
        this._storage.setConfiguration({
            [setting]: value
        });
    }
    /** Logs the current settings as a table */ settings() {
        if (console.table) {
            console.table(this._storage.config);
        } else {
            console.log(this._storage.config);
        }
    }
    // Unconditional logging
    assert(condition, message) {
        if (!condition) {
            throw new Error(message || 'Assertion failed');
        }
    }
    warn(message) {
        return this._getLogFunction(0, message, originalConsole.warn, arguments, ONCE);
    }
    error(message) {
        return this._getLogFunction(0, message, originalConsole.error, arguments);
    }
    /** Print a deprecation warning */ deprecated(oldUsage, newUsage) {
        return this.warn(`\`${oldUsage}\` is deprecated and will be removed \
in a later version. Use \`${newUsage}\` instead`);
    }
    /** Print a removal warning */ removed(oldUsage, newUsage) {
        return this.error(`\`${oldUsage}\` has been removed. Use \`${newUsage}\` instead`);
    }
    probe(logLevel, message) {
        return this._getLogFunction(logLevel, message, originalConsole.log, arguments, {
            time: true,
            once: true
        });
    }
    log(logLevel, message) {
        return this._getLogFunction(logLevel, message, originalConsole.debug, arguments);
    }
    info(logLevel, message) {
        return this._getLogFunction(logLevel, message, console.info, arguments);
    }
    once(logLevel, message) {
        return this._getLogFunction(logLevel, message, originalConsole.debug || originalConsole.info, arguments, ONCE);
    }
    /** Logs an object as a table */ table(logLevel, table, columns) {
        if (table) {
            return this._getLogFunction(logLevel, table, console.table || noop, columns && [
                columns
            ], {
                tag: getTableHeader(table)
            });
        }
        return noop;
    }
    time(logLevel, message) {
        return this._getLogFunction(logLevel, message, console.time ? console.time : console.info);
    }
    timeEnd(logLevel, message) {
        return this._getLogFunction(logLevel, message, console.timeEnd ? console.timeEnd : console.info);
    }
    timeStamp(logLevel, message) {
        return this._getLogFunction(logLevel, message, console.timeStamp || noop);
    }
    group(logLevel, message, opts = {
        collapsed: false
    }) {
        const options = normalizeArguments({
            logLevel,
            message,
            opts
        });
        const { collapsed } = opts;
        // @ts-expect-error
        options.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
        return this._getLogFunction(options);
    }
    groupCollapsed(logLevel, message, opts = {}) {
        return this.group(logLevel, message, Object.assign({}, opts, {
            collapsed: true
        }));
    }
    groupEnd(logLevel) {
        return this._getLogFunction(logLevel, '', console.groupEnd || noop);
    }
    // EXPERIMENTAL
    withGroup(logLevel, message, func) {
        this.group(logLevel, message)();
        try {
            func();
        } finally{
            this.groupEnd(logLevel)();
        }
    }
    trace() {
        if (console.trace) {
            console.trace();
        }
    }
    // PRIVATE METHODS
    /** Deduces log level from a variety of arguments */ _shouldLog(logLevel) {
        return this.isEnabled() && this.getLevel() >= normalizeLogLevel(logLevel);
    }
    _getLogFunction(logLevel, message, method, args, opts) {
        if (this._shouldLog(logLevel)) {
            // normalized opts + timings
            opts = normalizeArguments({
                logLevel,
                message,
                args,
                opts
            });
            method = method || opts.method;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(method);
            opts.total = this.getTotal();
            opts.delta = this.getDelta();
            // reset delta timer
            this._deltaTs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$utils$2f$hi$2d$res$2d$timestamp$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getHiResTimestamp"])();
            const tag = opts.tag || opts.message;
            if (opts.once && tag) {
                if (!cache[tag]) {
                    cache[tag] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$utils$2f$hi$2d$res$2d$timestamp$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getHiResTimestamp"])();
                } else {
                    return noop;
                }
            }
            // TODO - Make throttling work with groups
            // if (opts.nothrottle || !throttle(tag, this.LOG_THROTTLE_TIMEOUT)) {
            //   return noop;
            // }
            message = decorateMessage(this.id, opts.message, opts);
            // Bind console function so that it can be called after being returned
            return method.bind(console, message, ...opts.args);
        }
        return noop;
    }
}
Log.VERSION = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$env$2f$dist$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["VERSION"];
/**
 * Get logLevel from first argument:
 * - log(logLevel, message, args) => logLevel
 * - log(message, args) => 0
 * - log({logLevel, ...}, message, args) => logLevel
 * - log({logLevel, message, args}) => logLevel
 */ function normalizeLogLevel(logLevel) {
    if (!logLevel) {
        return 0;
    }
    let resolvedLevel;
    switch(typeof logLevel){
        case 'number':
            resolvedLevel = logLevel;
            break;
        case 'object':
            // Backward compatibility
            // TODO - deprecate `priority`
            // @ts-expect-error
            resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
            break;
        default:
            return 0;
    }
    // 'log level must be a number'
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
    return resolvedLevel;
}
function normalizeArguments(opts) {
    const { logLevel, message } = opts;
    opts.logLevel = normalizeLogLevel(logLevel);
    // We use `arguments` instead of rest parameters (...args) because IE
    // does not support the syntax. Rest parameters is transpiled to code with
    // perf impact. Doing it here instead avoids constructing args when logging is
    // disabled.
    // TODO - remove when/if IE support is dropped
    const args = opts.args ? Array.from(opts.args) : [];
    // args should only contain arguments that appear after `message`
    // eslint-disable-next-line no-empty
    while(args.length && args.shift() !== message){}
    switch(typeof logLevel){
        case 'string':
        case 'function':
            if (message !== undefined) {
                args.unshift(message);
            }
            opts.message = logLevel;
            break;
        case 'object':
            Object.assign(opts, logLevel);
            break;
        default:
    }
    // Resolve functions into strings by calling them
    if (typeof opts.message === 'function') {
        opts.message = opts.message();
    }
    const messageType = typeof opts.message;
    // 'log message must be a string' or object
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$utils$2f$assert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(messageType === 'string' || messageType === 'object');
    // original opts + normalized opts + opts arg + fixed up message
    return Object.assign(opts, {
        args
    }, opts.opts);
}
function decorateMessage(id, message, opts) {
    if (typeof message === 'string') {
        const time = opts.time ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$utils$2f$formatters$2e$js__$5b$client$5d$__$28$ecmascript$29$__["leftPad"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$utils$2f$formatters$2e$js__$5b$client$5d$__$28$ecmascript$29$__["formatTime"])(opts.total)) : '';
        message = opts.time ? `${id}: ${time}  ${message}` : `${id}: ${message}`;
        message = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$log$2f$dist$2f$utils$2f$color$2e$js__$5b$client$5d$__$28$ecmascript$29$__["addColor"])(message, opts.color, opts.background);
    }
    return message;
}
function getTableHeader(table) {
    for(const key in table){
        for(const title in table[key]){
            return title || 'untitled';
        }
    }
    return 'empty';
} //# sourceMappingURL=log.js.map
}}),
"[project]/node_modules/@probe.gl/stats/dist/utils/hi-res-timestamp.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
__turbopack_context__.s({
    "default": (()=>getHiResTimestamp)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
function getHiResTimestamp() {
    let timestamp;
    // Get best timer available.
    if (typeof window !== 'undefined' && window.performance) {
        timestamp = window.performance.now();
    } else if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"] !== 'undefined' && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].hrtime) {
        const timeParts = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].hrtime();
        timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;
    } else {
        timestamp = Date.now();
    }
    return timestamp;
} //# sourceMappingURL=hi-res-timestamp.js.map
}}),
"[project]/node_modules/@probe.gl/stats/dist/lib/stat.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>Stat)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$utils$2f$hi$2d$res$2d$timestamp$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/stats/dist/utils/hi-res-timestamp.js [client] (ecmascript)");
;
class Stat {
    constructor(name, type){
        this.sampleSize = 1;
        this.time = 0;
        this.count = 0;
        this.samples = 0;
        this.lastTiming = 0;
        this.lastSampleTime = 0;
        this.lastSampleCount = 0;
        this._count = 0;
        this._time = 0;
        this._samples = 0;
        this._startTime = 0;
        this._timerPending = false;
        this.name = name;
        this.type = type;
        this.reset();
    }
    reset() {
        this.time = 0;
        this.count = 0;
        this.samples = 0;
        this.lastTiming = 0;
        this.lastSampleTime = 0;
        this.lastSampleCount = 0;
        this._count = 0;
        this._time = 0;
        this._samples = 0;
        this._startTime = 0;
        this._timerPending = false;
        return this;
    }
    setSampleSize(samples) {
        this.sampleSize = samples;
        return this;
    }
    /** Call to increment count (+1) */ incrementCount() {
        this.addCount(1);
        return this;
    }
    /** Call to decrement count (-1) */ decrementCount() {
        this.subtractCount(1);
        return this;
    }
    /** Increase count */ addCount(value) {
        this._count += value;
        this._samples++;
        this._checkSampling();
        return this;
    }
    /** Decrease count */ subtractCount(value) {
        this._count -= value;
        this._samples++;
        this._checkSampling();
        return this;
    }
    /** Add an arbitrary timing and bump the count */ addTime(time) {
        this._time += time;
        this.lastTiming = time;
        this._samples++;
        this._checkSampling();
        return this;
    }
    /** Start a timer */ timeStart() {
        this._startTime = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$utils$2f$hi$2d$res$2d$timestamp$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])();
        this._timerPending = true;
        return this;
    }
    /** End a timer. Adds to time and bumps the timing count. */ timeEnd() {
        if (!this._timerPending) {
            return this;
        }
        this.addTime((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$utils$2f$hi$2d$res$2d$timestamp$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])() - this._startTime);
        this._timerPending = false;
        this._checkSampling();
        return this;
    }
    getSampleAverageCount() {
        return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
    }
    /** Calculate average time / count for the previous window */ getSampleAverageTime() {
        return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
    }
    /** Calculate counts per second for the previous window */ getSampleHz() {
        return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1000) : 0;
    }
    getAverageCount() {
        return this.samples > 0 ? this.count / this.samples : 0;
    }
    /** Calculate average time / count */ getAverageTime() {
        return this.samples > 0 ? this.time / this.samples : 0;
    }
    /** Calculate counts per second */ getHz() {
        return this.time > 0 ? this.samples / (this.time / 1000) : 0;
    }
    _checkSampling() {
        if (this._samples === this.sampleSize) {
            this.lastSampleTime = this._time;
            this.lastSampleCount = this._count;
            this.count += this._count;
            this.time += this._time;
            this.samples += this._samples;
            this._time = 0;
            this._count = 0;
            this._samples = 0;
        }
    }
} //# sourceMappingURL=stat.js.map
}}),
"[project]/node_modules/@probe.gl/stats/dist/lib/stats.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// probe.gl, MIT license
__turbopack_context__.s({
    "default": (()=>Stats)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$lib$2f$stat$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/stats/dist/lib/stat.js [client] (ecmascript)");
;
class Stats {
    constructor(options){
        this.stats = {};
        this.id = options.id;
        this.stats = {};
        this._initializeStats(options.stats);
        Object.seal(this);
    }
    /** Acquire a stat. Create if it doesn't exist. */ get(name, type = 'count') {
        return this._getOrCreate({
            name,
            type
        });
    }
    get size() {
        return Object.keys(this.stats).length;
    }
    /** Reset all stats */ reset() {
        for (const stat of Object.values(this.stats)){
            stat.reset();
        }
        return this;
    }
    forEach(fn) {
        for (const stat of Object.values(this.stats)){
            fn(stat);
        }
    }
    getTable() {
        const table = {};
        this.forEach((stat)=>{
            table[stat.name] = {
                time: stat.time || 0,
                count: stat.count || 0,
                average: stat.getAverageTime() || 0,
                hz: stat.getHz() || 0
            };
        });
        return table;
    }
    _initializeStats(stats = []) {
        stats.forEach((stat)=>this._getOrCreate(stat));
    }
    _getOrCreate(stat) {
        const { name, type } = stat;
        let result = this.stats[name];
        if (!result) {
            if (stat instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$lib$2f$stat$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"]) {
                result = stat;
            } else {
                result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$lib$2f$stat$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"](name, type);
            }
            this.stats[name] = result;
        }
        return result;
    }
} //# sourceMappingURL=stats.js.map
}}),
"[project]/node_modules/@probe.gl/stats/dist/index.js [client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
;
;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@probe.gl/stats/dist/index.js [client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$lib$2f$stats$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/stats/dist/lib/stats.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$lib$2f$stat$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/stats/dist/lib/stat.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$utils$2f$hi$2d$res$2d$timestamp$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/stats/dist/utils/hi-res-timestamp.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/stats/dist/index.js [client] (ecmascript) <locals>");
}}),
"[project]/node_modules/@probe.gl/stats/dist/lib/stats.js [client] (ecmascript) <export default as Stats>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "Stats": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$lib$2f$stats$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$probe$2e$gl$2f$stats$2f$dist$2f$lib$2f$stats$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@probe.gl/stats/dist/lib/stats.js [client] (ecmascript)");
}}),
"[project]/node_modules/@mapbox/tiny-sdf/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>TinySDF)
});
const INF = 1e20;
class TinySDF {
    constructor({ fontSize = 24, buffer = 3, radius = 8, cutoff = 0.25, fontFamily = 'sans-serif', fontWeight = 'normal', fontStyle = 'normal' } = {}){
        this.buffer = buffer;
        this.cutoff = cutoff;
        this.radius = radius;
        // make the canvas size big enough to both have the specified buffer around the glyph
        // for "halo", and account for some glyphs possibly being larger than their font size
        const size = this.size = fontSize + buffer * 4;
        const canvas = this._createCanvas(size);
        const ctx = this.ctx = canvas.getContext('2d', {
            willReadFrequently: true
        });
        ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;
        ctx.textBaseline = 'alphabetic';
        ctx.textAlign = 'left'; // Necessary so that RTL text doesn't have different alignment
        ctx.fillStyle = 'black';
        // temporary arrays for the distance transform
        this.gridOuter = new Float64Array(size * size);
        this.gridInner = new Float64Array(size * size);
        this.f = new Float64Array(size);
        this.z = new Float64Array(size + 1);
        this.v = new Uint16Array(size);
    }
    _createCanvas(size) {
        const canvas = document.createElement('canvas');
        canvas.width = canvas.height = size;
        return canvas;
    }
    draw(char) {
        const { width: glyphAdvance, actualBoundingBoxAscent, actualBoundingBoxDescent, actualBoundingBoxLeft, actualBoundingBoxRight } = this.ctx.measureText(char);
        // The integer/pixel part of the top alignment is encoded in metrics.glyphTop
        // The remainder is implicitly encoded in the rasterization
        const glyphTop = Math.ceil(actualBoundingBoxAscent);
        const glyphLeft = 0;
        // If the glyph overflows the canvas size, it will be clipped at the bottom/right
        const glyphWidth = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(actualBoundingBoxRight - actualBoundingBoxLeft)));
        const glyphHeight = Math.min(this.size - this.buffer, glyphTop + Math.ceil(actualBoundingBoxDescent));
        const width = glyphWidth + 2 * this.buffer;
        const height = glyphHeight + 2 * this.buffer;
        const len = Math.max(width * height, 0);
        const data = new Uint8ClampedArray(len);
        const glyph = {
            data,
            width,
            height,
            glyphWidth,
            glyphHeight,
            glyphTop,
            glyphLeft,
            glyphAdvance
        };
        if (glyphWidth === 0 || glyphHeight === 0) return glyph;
        const { ctx, buffer, gridInner, gridOuter } = this;
        ctx.clearRect(buffer, buffer, glyphWidth, glyphHeight);
        ctx.fillText(char, buffer, buffer + glyphTop);
        const imgData = ctx.getImageData(buffer, buffer, glyphWidth, glyphHeight);
        // Initialize grids outside the glyph range to alpha 0
        gridOuter.fill(INF, 0, len);
        gridInner.fill(0, 0, len);
        for(let y = 0; y < glyphHeight; y++){
            for(let x = 0; x < glyphWidth; x++){
                const a = imgData.data[4 * (y * glyphWidth + x) + 3] / 255; // alpha value
                if (a === 0) continue; // empty pixels
                const j = (y + buffer) * width + x + buffer;
                if (a === 1) {
                    gridOuter[j] = 0;
                    gridInner[j] = INF;
                } else {
                    const d = 0.5 - a;
                    gridOuter[j] = d > 0 ? d * d : 0;
                    gridInner[j] = d < 0 ? d * d : 0;
                }
            }
        }
        edt(gridOuter, 0, 0, width, height, width, this.f, this.v, this.z);
        edt(gridInner, buffer, buffer, glyphWidth, glyphHeight, width, this.f, this.v, this.z);
        for(let i = 0; i < len; i++){
            const d = Math.sqrt(gridOuter[i]) - Math.sqrt(gridInner[i]);
            data[i] = Math.round(255 - 255 * (d / this.radius + this.cutoff));
        }
        return glyph;
    }
}
// 2D Euclidean squared distance transform by Felzenszwalb & Huttenlocher https://cs.brown.edu/~pff/papers/dt-final.pdf
function edt(data, x0, y0, width, height, gridSize, f, v, z) {
    for(let x = x0; x < x0 + width; x++)edt1d(data, y0 * gridSize + x, gridSize, height, f, v, z);
    for(let y = y0; y < y0 + height; y++)edt1d(data, y * gridSize + x0, 1, width, f, v, z);
}
// 1D squared distance transform
function edt1d(grid, offset, stride, length, f, v, z) {
    v[0] = 0;
    z[0] = -INF;
    z[1] = INF;
    f[0] = grid[offset];
    for(let q = 1, k = 0, s = 0; q < length; q++){
        f[q] = grid[offset + q * stride];
        const q2 = q * q;
        do {
            const r = v[k];
            s = (f[q] - f[r] + q2 - r * r) / (q - r) / 2;
        }while (s <= z[k] && --k > -1)
        k++;
        v[k] = q;
        z[k] = s;
        z[k + 1] = INF;
    }
    for(let q = 0, k = 0; q < length; q++){
        while(z[k + 1] < q)k++;
        const r = v[k];
        const qr = q - r;
        grid[offset + q * stride] = f[r] + qr * qr;
    }
}
}}),
"[project]/node_modules/@mapbox/tile-cover/index.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var tilebelt = __turbopack_context__.r("[project]/node_modules/tilebelt/index.js [client] (ecmascript)");
/**
 * Given a geometry, create cells and return them in a format easily readable
 * by any software that reads GeoJSON.
 *
 * @alias geojson
 * @param {Object} geom GeoJSON geometry
 * @param {Object} limits an object with min_zoom and max_zoom properties
 * specifying the minimum and maximum level to be tiled.
 * @returns {Object} FeatureCollection of cells formatted as GeoJSON Features
 */ exports.geojson = function(geom, limits) {
    return {
        type: 'FeatureCollection',
        features: getTiles(geom, limits).map(tileToFeature)
    };
};
function tileToFeature(t) {
    return {
        type: 'Feature',
        geometry: tilebelt.tileToGeoJSON(t),
        properties: {}
    };
}
/**
 * Given a geometry, create cells and return them in their raw form,
 * as an array of cell identifiers.
 *
 * @alias tiles
 * @param {Object} geom GeoJSON geometry
 * @param {Object} limits an object with min_zoom and max_zoom properties
 * specifying the minimum and maximum level to be tiled.
 * @returns {Array<Array<number>>} An array of tiles given as [x, y, z] arrays
 */ exports.tiles = getTiles;
/**
 * Given a geometry, create cells and return them as
 * [quadkey](http://msdn.microsoft.com/en-us/library/bb259689.aspx) indexes.
 *
 * @alias indexes
 * @param {Object} geom GeoJSON geometry
 * @param {Object} limits an object with min_zoom and max_zoom properties
 * specifying the minimum and maximum level to be tiled.
 * @returns {Array<String>} An array of tiles given as quadkeys.
 */ exports.indexes = function(geom, limits) {
    return getTiles(geom, limits).map(tilebelt.tileToQuadkey);
};
function getTiles(geom, limits) {
    var i, tile, coords = geom.coordinates, maxZoom = limits.max_zoom, tileHash = {}, tiles = [];
    if (geom.type === 'Point') {
        return [
            tilebelt.pointToTile(coords[0], coords[1], maxZoom)
        ];
    } else if (geom.type === 'MultiPoint') {
        for(i = 0; i < coords.length; i++){
            tile = tilebelt.pointToTile(coords[i][0], coords[i][1], maxZoom);
            tileHash[toID(tile[0], tile[1], tile[2])] = true;
        }
    } else if (geom.type === 'LineString') {
        lineCover(tileHash, coords, maxZoom);
    } else if (geom.type === 'MultiLineString') {
        for(i = 0; i < coords.length; i++){
            lineCover(tileHash, coords[i], maxZoom);
        }
    } else if (geom.type === 'Polygon') {
        polygonCover(tileHash, tiles, coords, maxZoom);
    } else if (geom.type === 'MultiPolygon') {
        for(i = 0; i < coords.length; i++){
            polygonCover(tileHash, tiles, coords[i], maxZoom);
        }
    } else {
        throw new Error('Geometry type not implemented');
    }
    if (limits.min_zoom !== maxZoom) {
        // sync tile hash and tile array so that both contain the same tiles
        var len = tiles.length;
        appendHashTiles(tileHash, tiles);
        for(i = 0; i < len; i++){
            var t = tiles[i];
            tileHash[toID(t[0], t[1], t[2])] = true;
        }
        return mergeTiles(tileHash, tiles, limits);
    }
    appendHashTiles(tileHash, tiles);
    return tiles;
}
function mergeTiles(tileHash, tiles, limits) {
    var mergedTiles = [];
    for(var z = limits.max_zoom; z > limits.min_zoom; z--){
        var parentTileHash = {};
        var parentTiles = [];
        for(var i = 0; i < tiles.length; i++){
            var t = tiles[i];
            if (t[0] % 2 === 0 && t[1] % 2 === 0) {
                var id2 = toID(t[0] + 1, t[1], z), id3 = toID(t[0], t[1] + 1, z), id4 = toID(t[0] + 1, t[1] + 1, z);
                if (tileHash[id2] && tileHash[id3] && tileHash[id4]) {
                    tileHash[toID(t[0], t[1], t[2])] = false;
                    tileHash[id2] = false;
                    tileHash[id3] = false;
                    tileHash[id4] = false;
                    var parentTile = [
                        t[0] / 2,
                        t[1] / 2,
                        z - 1
                    ];
                    if (z - 1 === limits.min_zoom) mergedTiles.push(parentTile);
                    else {
                        parentTileHash[toID(t[0] / 2, t[1] / 2, z - 1)] = true;
                        parentTiles.push(parentTile);
                    }
                }
            }
        }
        for(i = 0; i < tiles.length; i++){
            t = tiles[i];
            if (tileHash[toID(t[0], t[1], t[2])]) mergedTiles.push(t);
        }
        tileHash = parentTileHash;
        tiles = parentTiles;
    }
    return mergedTiles;
}
function polygonCover(tileHash, tileArray, geom, zoom) {
    var intersections = [];
    for(var i = 0; i < geom.length; i++){
        var ring = [];
        lineCover(tileHash, geom[i], zoom, ring);
        for(var j = 0, len = ring.length, k = len - 1; j < len; k = j++){
            var m = (j + 1) % len;
            var y = ring[j][1];
            // add interesction if it's not local extremum or duplicate
            if ((y > ring[k][1] || y > ring[m][1]) && // not local minimum
            (y < ring[k][1] || y < ring[m][1]) && // not local maximum
            y !== ring[m][1]) intersections.push(ring[j]);
        }
    }
    intersections.sort(compareTiles); // sort by y, then x
    for(i = 0; i < intersections.length; i += 2){
        // fill tiles between pairs of intersections
        y = intersections[i][1];
        for(var x = intersections[i][0] + 1; x < intersections[i + 1][0]; x++){
            var id = toID(x, y, zoom);
            if (!tileHash[id]) {
                tileArray.push([
                    x,
                    y,
                    zoom
                ]);
            }
        }
    }
}
function compareTiles(a, b) {
    return a[1] - b[1] || a[0] - b[0];
}
function lineCover(tileHash, coords, maxZoom, ring) {
    var prevX, prevY;
    for(var i = 0; i < coords.length - 1; i++){
        var start = tilebelt.pointToTileFraction(coords[i][0], coords[i][1], maxZoom), stop = tilebelt.pointToTileFraction(coords[i + 1][0], coords[i + 1][1], maxZoom), x0 = start[0], y0 = start[1], x1 = stop[0], y1 = stop[1], dx = x1 - x0, dy = y1 - y0;
        if (dy === 0 && dx === 0) continue;
        var sx = dx > 0 ? 1 : -1, sy = dy > 0 ? 1 : -1, x = Math.floor(x0), y = Math.floor(y0), tMaxX = dx === 0 ? Infinity : Math.abs(((dx > 0 ? 1 : 0) + x - x0) / dx), tMaxY = dy === 0 ? Infinity : Math.abs(((dy > 0 ? 1 : 0) + y - y0) / dy), tdx = Math.abs(sx / dx), tdy = Math.abs(sy / dy);
        if (x !== prevX || y !== prevY) {
            tileHash[toID(x, y, maxZoom)] = true;
            if (ring && y !== prevY) ring.push([
                x,
                y
            ]);
            prevX = x;
            prevY = y;
        }
        while(tMaxX < 1 || tMaxY < 1){
            if (tMaxX < tMaxY) {
                tMaxX += tdx;
                x += sx;
            } else {
                tMaxY += tdy;
                y += sy;
            }
            tileHash[toID(x, y, maxZoom)] = true;
            if (ring && y !== prevY) ring.push([
                x,
                y
            ]);
            prevX = x;
            prevY = y;
        }
    }
    if (ring && y === ring[0][1]) ring.pop();
}
function appendHashTiles(hash, tiles) {
    var keys = Object.keys(hash);
    for(var i = 0; i < keys.length; i++){
        tiles.push(fromID(+keys[i]));
    }
}
function toID(x, y, z) {
    var dim = 2 * (1 << z);
    return (dim * y + x) * 32 + z;
}
function fromID(id) {
    var z = id % 32, dim = 2 * (1 << z), xy = (id - z) / 32, x = xy % dim, y = (xy - x) / dim % dim;
    return [
        x,
        y,
        z
    ];
}
}}),
"[project]/node_modules/earcut/src/earcut.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
module.exports = earcut;
module.exports.default = earcut;
function earcut(data, holeIndices, dim) {
    dim = dim || 2;
    var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev) return triangles;
    var minX, minY, maxX, maxY, x, y, invSize;
    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for(var i = dim; i < outerLen; i += dim){
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }
        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
    return triangles;
}
// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;
    if (clockwise === signedArea(data, start, end, dim) > 0) {
        for(i = start; i < end; i += dim)last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for(i = end - dim; i >= start; i -= dim)last = insertNode(i, data[i], data[i + 1], last);
    }
    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }
    return last;
}
// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;
    var p = start, again;
    do {
        again = false;
        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;
        } else {
            p = p.next;
        }
    }while (again || p !== end)
    return end;
}
// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;
    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
    var stop = ear, prev, next;
    // iterate through ears, slicing them one by one
    while(ear.prev !== ear.next){
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim | 0);
            triangles.push(ear.i / dim | 0);
            triangles.push(next.i / dim | 0);
            removeNode(ear);
            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;
            continue;
        }
        ear = next;
        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }
            break;
        }
    }
}
// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
    // now make sure we don't have other points inside the potential ear
    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
    var p = c.next;
    while(p !== a){
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }
    return true;
}
function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
    // z-order range for the current triangle bbox;
    var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
    var p = ear.prevZ, n = ear.nextZ;
    // look for points inside the triangle in both directions
    while(p && p.z >= minZ && n && n.z <= maxZ){
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }
    // look for remaining points in decreasing z-order
    while(p && p.z >= minZ){
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }
    // look for remaining points in increasing z-order
    while(n && n.z <= maxZ){
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }
    return true;
}
// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev, b = p.next.next;
        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
            triangles.push(a.i / dim | 0);
            triangles.push(p.i / dim | 0);
            triangles.push(b.i / dim | 0);
            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);
            p = start = b;
        }
        p = p.next;
    }while (p !== start)
    return filterPoints(p);
}
// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while(b !== a.prev){
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);
                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);
                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
                return;
            }
            b = b.next;
        }
        a = a.next;
    }while (a !== start)
}
// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [], i, len, start, end, list;
    for(i = 0, len = holeIndices.length; i < len; i++){
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }
    queue.sort(compareX);
    // process holes from left to right
    for(i = 0; i < queue.length; i++){
        outerNode = eliminateHole(queue[i], outerNode);
    }
    return outerNode;
}
function compareX(a, b) {
    return a.x - b.x;
}
// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    var bridge = findHoleBridge(hole, outerNode);
    if (!bridge) {
        return outerNode;
    }
    var bridgeReverse = splitPolygon(bridge, hole);
    // filter collinear points around the cuts
    filterPoints(bridgeReverse, bridgeReverse.next);
    return filterPoints(bridge, bridge.next);
}
// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                m = p.x < p.next.x ? p : p.next;
                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint
            }
        }
        p = p.next;
    }while (p !== outerNode)
    if (!m) return null;
    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point
    var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
    p = m;
    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential
            if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
                m = p;
                tanMin = tan;
            }
        }
        p = p.next;
    }while (p !== stop)
    return m;
}
// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}
// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    }while (p !== start)
    p.prevZ.nextZ = null;
    p.prevZ = null;
    sortLinked(p);
}
// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;
        while(p){
            numMerges++;
            q = p;
            pSize = 0;
            for(i = 0; i < inSize; i++){
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;
            while(pSize > 0 || qSize > 0 && q){
                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }
                if (tail) tail.nextZ = e;
                else list = e;
                e.prevZ = tail;
                tail = e;
            }
            p = q;
        }
        tail.nextZ = null;
        inSize *= 2;
    }while (numMerges > 1)
    return list;
}
// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = (x - minX) * invSize | 0;
    y = (y - minY) * invSize | 0;
    x = (x | x << 8) & 0x00FF00FF;
    x = (x | x << 4) & 0x0F0F0F0F;
    x = (x | x << 2) & 0x33333333;
    x = (x | x << 1) & 0x55555555;
    y = (y | y << 8) & 0x00FF00FF;
    y = (y | y << 4) & 0x0F0F0F0F;
    y = (y | y << 2) & 0x33333333;
    y = (y | y << 1) & 0x55555555;
    return x | y << 1;
}
// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start, leftmost = start;
    do {
        if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
        p = p.next;
    }while (p !== start)
    return leftmost;
}
// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
}
// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
    (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
    (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
    equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}
// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}
// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}
// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    var o1 = sign(area(p1, q1, p2));
    var o2 = sign(area(p1, q1, q2));
    var o3 = sign(area(p2, q2, p1));
    var o4 = sign(area(p2, q2, q1));
    if (o1 !== o2 && o3 !== o4) return true; // general case
    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2
    return false;
}
// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}
function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}
// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
        p = p.next;
    }while (p !== a)
    return false;
}
// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}
// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
    do {
        if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
        p = p.next;
    }while (p !== a)
    return inside;
}
// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
    a.next = b;
    b.prev = a;
    a2.next = an;
    an.prev = a2;
    b2.next = a2;
    a2.prev = b2;
    bp.next = b2;
    b2.prev = bp;
    return b2;
}
// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);
    if (!last) {
        p.prev = p;
        p.next = p;
    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}
function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;
    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}
function Node(i, x, y) {
    // vertex index in coordinates array
    this.i = i;
    // vertex coordinates
    this.x = x;
    this.y = y;
    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;
    // z-order curve value
    this.z = 0;
    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;
    // indicates whether this is a steiner point
    this.steiner = false;
}
// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function(data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for(var i = 0, len = holeIndices.length; i < len; i++){
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }
    var trianglesArea = 0;
    for(i = 0; i < triangles.length; i += 3){
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }
    return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
};
function signedArea(data, start, end, dim) {
    var sum = 0;
    for(var i = start, j = end - dim; i < end; i += dim){
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}
// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function(data) {
    var dim = data[0][0].length, result = {
        vertices: [],
        holes: [],
        dimensions: dim
    }, holeIndex = 0;
    for(var i = 0; i < data.length; i++){
        for(var j = 0; j < data[i].length; j++){
            for(var d = 0; d < dim; d++)result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};
}}),
"[project]/node_modules/tilebelt/index.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// a tile is an array [x,y,z]
var d2r = Math.PI / 180, r2d = 180 / Math.PI;
function tileToBBOX(tile) {
    var e = tile2lon(tile[0] + 1, tile[2]);
    var w = tile2lon(tile[0], tile[2]);
    var s = tile2lat(tile[1] + 1, tile[2]);
    var n = tile2lat(tile[1], tile[2]);
    return [
        w,
        s,
        e,
        n
    ];
}
function tileToGeoJSON(tile) {
    var bbox = tileToBBOX(tile);
    var poly = {
        type: 'Polygon',
        coordinates: [
            [
                [
                    bbox[0],
                    bbox[1]
                ],
                [
                    bbox[0],
                    bbox[3]
                ],
                [
                    bbox[2],
                    bbox[3]
                ],
                [
                    bbox[2],
                    bbox[1]
                ],
                [
                    bbox[0],
                    bbox[1]
                ]
            ]
        ]
    };
    return poly;
}
function tile2lon(x, z) {
    return x / Math.pow(2, z) * 360 - 180;
}
function tile2lat(y, z) {
    var n = Math.PI - 2 * Math.PI * y / Math.pow(2, z);
    return r2d * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
}
function pointToTile(lon, lat, z) {
    var tile = pointToTileFraction(lon, lat, z);
    tile[0] = Math.floor(tile[0]);
    tile[1] = Math.floor(tile[1]);
    return tile;
}
function getChildren(tile) {
    return [
        [
            tile[0] * 2,
            tile[1] * 2,
            tile[2] + 1
        ],
        [
            tile[0] * 2 + 1,
            tile[1] * 2,
            tile[2] + 1
        ],
        [
            tile[0] * 2 + 1,
            tile[1] * 2 + 1,
            tile[2] + 1
        ],
        [
            tile[0] * 2,
            tile[1] * 2 + 1,
            tile[2] + 1
        ]
    ];
}
function getParent(tile) {
    // top left
    if (tile[0] % 2 === 0 && tile[1] % 2 === 0) {
        return [
            tile[0] / 2,
            tile[1] / 2,
            tile[2] - 1
        ];
    } else if (tile[0] % 2 === 0 && !tile[1] % 2 === 0) {
        return [
            tile[0] / 2,
            (tile[1] - 1) / 2,
            tile[2] - 1
        ];
    } else if (!tile[0] % 2 === 0 && tile[1] % 2 === 0) {
        return [
            (tile[0] - 1) / 2,
            tile[1] / 2,
            tile[2] - 1
        ];
    } else {
        return [
            (tile[0] - 1) / 2,
            (tile[1] - 1) / 2,
            tile[2] - 1
        ];
    }
}
function getSiblings(tile) {
    return getChildren(getParent(tile));
}
function hasSiblings(tile, tiles) {
    var siblings = getSiblings(tile);
    for(var i = 0; i < siblings.length; i++){
        if (!hasTile(tiles, siblings[i])) return false;
    }
    return true;
}
function hasTile(tiles, tile) {
    for(var i = 0; i < tiles.length; i++){
        if (tilesEqual(tiles[i], tile)) return true;
    }
    return false;
}
function tilesEqual(tile1, tile2) {
    return tile1[0] === tile2[0] && tile1[1] === tile2[1] && tile1[2] === tile2[2];
}
function tileToQuadkey(tile) {
    var index = '';
    for(var z = tile[2]; z > 0; z--){
        var b = 0;
        var mask = 1 << z - 1;
        if ((tile[0] & mask) !== 0) b++;
        if ((tile[1] & mask) !== 0) b += 2;
        index += b.toString();
    }
    return index;
}
function quadkeyToTile(quadkey) {
    var x = 0;
    var y = 0;
    var z = quadkey.length;
    for(var i = z; i > 0; i--){
        var mask = 1 << i - 1;
        switch(quadkey[z - i]){
            case '0':
                break;
            case '1':
                x |= mask;
                break;
            case '2':
                y |= mask;
                break;
            case '3':
                x |= mask;
                y |= mask;
                break;
        }
    }
    return [
        x,
        y,
        z
    ];
}
function bboxToTile(bboxCoords) {
    var min = pointToTile(bboxCoords[0], bboxCoords[1], 32);
    var max = pointToTile(bboxCoords[2], bboxCoords[3], 32);
    var bbox = [
        min[0],
        min[1],
        max[0],
        max[1]
    ];
    var z = getBboxZoom(bbox);
    if (z === 0) return [
        0,
        0,
        0
    ];
    var x = bbox[0] >>> 32 - z;
    var y = bbox[1] >>> 32 - z;
    return [
        x,
        y,
        z
    ];
}
function getBboxZoom(bbox) {
    var MAX_ZOOM = 28;
    for(var z = 0; z < MAX_ZOOM; z++){
        var mask = 1 << 32 - (z + 1);
        if ((bbox[0] & mask) != (bbox[2] & mask) || (bbox[1] & mask) != (bbox[3] & mask)) {
            return z;
        }
    }
    return MAX_ZOOM;
}
function pointToTileFraction(lon, lat, z) {
    var sin = Math.sin(lat * d2r), z2 = Math.pow(2, z), x = z2 * (lon / 360 + 0.5), y = z2 * (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);
    return [
        x,
        y,
        z
    ];
}
module.exports = {
    tileToGeoJSON: tileToGeoJSON,
    tileToBBOX: tileToBBOX,
    getChildren: getChildren,
    getParent: getParent,
    getSiblings: getSiblings,
    hasTile: hasTile,
    hasSiblings: hasSiblings,
    tilesEqual: tilesEqual,
    tileToQuadkey: tileToQuadkey,
    quadkeyToTile: quadkeyToTile,
    pointToTile: pointToTile,
    bboxToTile: bboxToTile,
    pointToTileFraction: pointToTileFraction
};
}}),
"[project]/node_modules/quadbin/dist/index.esm.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "bigIntToHex": (()=>bigIntToHex),
    "cellToBoundary": (()=>cellToBoundary),
    "cellToChildren": (()=>cellToChildren),
    "cellToOffset": (()=>cellToOffset),
    "cellToParent": (()=>cellToParent),
    "cellToTile": (()=>cellToTile),
    "cellToWorldBounds": (()=>cellToWorldBounds),
    "geometryToCells": (()=>geometryToCells),
    "getCellPolygon": (()=>getCellPolygon),
    "getResolution": (()=>getResolution),
    "hexToBigInt": (()=>hexToBigInt),
    "tileToCell": (()=>tileToCell)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mapbox$2f$tile$2d$cover$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mapbox/tile-cover/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/index.js [client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@math.gl/web-mercator/dist/web-mercator-utils.js [client] (ecmascript)");
;
;
const B = [
    0x5555555555555555n,
    0x3333333333333333n,
    0x0f0f0f0f0f0f0f0fn,
    0x00ff00ff00ff00ffn,
    0x0000ffff0000ffffn,
    0x00000000ffffffffn
];
const S = [
    0n,
    1n,
    2n,
    4n,
    8n,
    16n
];
const TILE_SIZE = 512;
function cellToOffset(quadbin) {
    const { x, y, z } = cellToTile(quadbin);
    const scale = TILE_SIZE / (1 << z);
    return [
        x * scale,
        TILE_SIZE - y * scale,
        scale
    ];
}
function cellToWorldBounds(quadbin, coverage) {
    const [xOffset, yOffset, scale] = cellToOffset(quadbin);
    return [
        [
            xOffset,
            yOffset
        ],
        [
            xOffset + coverage * scale,
            yOffset - coverage * scale
        ]
    ];
}
function getCellPolygon(quadbin, coverage = 1) {
    const [topLeft, bottomRight] = cellToWorldBounds(quadbin, coverage);
    const [w, n] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["worldToLngLat"])(topLeft);
    const [e, s] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$math$2e$gl$2f$web$2d$mercator$2f$dist$2f$web$2d$mercator$2d$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["worldToLngLat"])(bottomRight);
    return [
        e,
        n,
        e,
        s,
        w,
        s,
        w,
        n,
        e,
        n
    ];
}
function hexToBigInt(hex) {
    return BigInt(`0x${hex}`);
}
function bigIntToHex(index) {
    return index.toString(16);
}
function tileToCell(tile) {
    if (tile.z < 0 || tile.z > 26) {
        throw new Error('Wrong zoom');
    }
    const z = BigInt(tile.z);
    let x = BigInt(tile.x) << 32n - z;
    let y = BigInt(tile.y) << 32n - z;
    for(let i = 0; i < 5; i++){
        const s = S[5 - i];
        const b = B[4 - i];
        x = (x | x << s) & b;
        y = (y | y << s) & b;
    }
    const quadbin = 0x4000000000000000n | 1n << 59n | // | (mode << 59) | (mode_dep << 57)
    z << 52n | (x | y << 1n) >> 12n | 0xfffffffffffffn >> z * 2n;
    return quadbin;
}
function cellToTile(quadbin) {
    const mode = quadbin >> 59n & 7n;
    const modeDep = quadbin >> 57n & 3n;
    const z = quadbin >> 52n & 0x1fn;
    const q = (quadbin & 0xfffffffffffffn) << 12n;
    if (mode !== 1n && modeDep !== 0n) {
        throw new Error('Wrong mode');
    }
    let x = q;
    let y = q >> 1n;
    for(let i = 0; i < 6; i++){
        const s = S[i];
        const b = B[i];
        x = (x | x >> s) & b;
        y = (y | y >> s) & b;
    }
    x = x >> 32n - z;
    y = y >> 32n - z;
    return {
        z: Number(z),
        x: Number(x),
        y: Number(y)
    };
}
function getResolution(quadbin) {
    return quadbin >> 52n & 0x1fn;
}
function cellToParent(quadbin) {
    const zparent = getResolution(quadbin) - 1n;
    const parent = quadbin & ~(0x1fn << 52n) | zparent << 52n | 0xfffffffffffffn >> zparent * 2n;
    return parent;
}
/**
 * Returns the children of a cell.
 *
 * @privateRemarks Order of the child cells would, preferably, be
 *  row-major starting from NW and ending at SE.
 */ function cellToChildren(quadbin, resolution) {
    if (resolution < 0 || resolution > 26 || resolution < getResolution(quadbin)) {
        throw new Error('Invalid resolution');
    }
    const zoomLevelMask = ~(0x1fn << 52n);
    const blockRange = 1n << (resolution - (quadbin >> 52n & 0x1fn) << 1n);
    const sqrtBlockRange = 1n << resolution - (quadbin >> 52n & 0x1fn);
    const blockShift = 52n - (resolution << 1n);
    const childBase = (quadbin & zoomLevelMask | resolution << 52n) & ~(blockRange - 1n << blockShift);
    const children = [];
    for(let blockRow = 0n; blockRow < sqrtBlockRange; blockRow++){
        for(let blockColumn = 0n; blockColumn < sqrtBlockRange; blockColumn++){
            children.push(childBase | blockRow * sqrtBlockRange + blockColumn << blockShift);
        }
    }
    return children;
}
function geometryToCells(geometry, resolution) {
    const zoom = Number(resolution);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mapbox$2f$tile$2d$cover$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["tiles"])(geometry, {
        min_zoom: zoom,
        max_zoom: zoom
    }).map(([x, y, z])=>tileToCell({
            x,
            y,
            z
        }));
}
function cellToBoundary(cell) {
    const bbox = getCellPolygon(cell);
    const boundary = [
        [
            bbox[0],
            bbox[1]
        ],
        [
            bbox[2],
            bbox[3]
        ],
        [
            bbox[4],
            bbox[5]
        ],
        [
            bbox[6],
            bbox[7]
        ],
        [
            bbox[0],
            bbox[1]
        ]
    ];
    return {
        type: 'Polygon',
        coordinates: [
            boundary
        ]
    };
}
;
 //# sourceMappingURL=index.esm.js.map
}}),
"[project]/node_modules/ieee754/index.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8){}
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8){}
    if (e === 0) {
        e = 1 - eBias;
    } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) {
            value += rt / c;
        } else {
            value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8){}
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8){}
    buffer[offset + i - d] |= s * 128;
};
}}),
"[project]/node_modules/pbf/index.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
module.exports = Pbf;
var ieee754 = __turbopack_context__.r("[project]/node_modules/ieee754/index.js [client] (ecmascript)");
function Pbf(buf) {
    this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
    this.pos = 0;
    this.type = 0;
    this.length = this.buf.length;
}
Pbf.Varint = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum
Pbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64
Pbf.Bytes = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields
Pbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32
var SHIFT_LEFT_32 = (1 << 16) * (1 << 16), SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
// Threshold chosen based on both benchmarking and knowledge about browser string
// data structures (which currently switch structure types at 12 bytes or more)
var TEXT_DECODER_MIN_LENGTH = 12;
var utf8TextDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf-8');
Pbf.prototype = {
    destroy: function() {
        this.buf = null;
    },
    // === READING =================================================================
    readFields: function(readField, result, end) {
        end = end || this.length;
        while(this.pos < end){
            var val = this.readVarint(), tag = val >> 3, startPos = this.pos;
            this.type = val & 0x7;
            readField(tag, result, this);
            if (this.pos === startPos) this.skip(val);
        }
        return result;
    },
    readMessage: function(readField, result) {
        return this.readFields(readField, result, this.readVarint() + this.pos);
    },
    readFixed32: function() {
        var val = readUInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
    },
    readSFixed32: function() {
        var val = readInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
    },
    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)
    readFixed64: function() {
        var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },
    readSFixed64: function() {
        var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },
    readFloat: function() {
        var val = ieee754.read(this.buf, this.pos, true, 23, 4);
        this.pos += 4;
        return val;
    },
    readDouble: function() {
        var val = ieee754.read(this.buf, this.pos, true, 52, 8);
        this.pos += 8;
        return val;
    },
    readVarint: function(isSigned) {
        var buf = this.buf, val, b;
        b = buf[this.pos++];
        val = b & 0x7f;
        if (b < 0x80) return val;
        b = buf[this.pos++];
        val |= (b & 0x7f) << 7;
        if (b < 0x80) return val;
        b = buf[this.pos++];
        val |= (b & 0x7f) << 14;
        if (b < 0x80) return val;
        b = buf[this.pos++];
        val |= (b & 0x7f) << 21;
        if (b < 0x80) return val;
        b = buf[this.pos];
        val |= (b & 0x0f) << 28;
        return readVarintRemainder(val, isSigned, this);
    },
    readVarint64: function() {
        return this.readVarint(true);
    },
    readSVarint: function() {
        var num = this.readVarint();
        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding
    },
    readBoolean: function() {
        return Boolean(this.readVarint());
    },
    readString: function() {
        var end = this.readVarint() + this.pos;
        var pos = this.pos;
        this.pos = end;
        if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {
            // longer strings are fast with the built-in browser TextDecoder API
            return readUtf8TextDecoder(this.buf, pos, end);
        }
        // short strings are fast with our custom implementation
        return readUtf8(this.buf, pos, end);
    },
    readBytes: function() {
        var end = this.readVarint() + this.pos, buffer = this.buf.subarray(this.pos, end);
        this.pos = end;
        return buffer;
    },
    // verbose for performance reasons; doesn't affect gzipped size
    readPackedVarint: function(arr, isSigned) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readVarint(isSigned));
        var end = readPackedEnd(this);
        arr = arr || [];
        while(this.pos < end)arr.push(this.readVarint(isSigned));
        return arr;
    },
    readPackedSVarint: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readSVarint());
        var end = readPackedEnd(this);
        arr = arr || [];
        while(this.pos < end)arr.push(this.readSVarint());
        return arr;
    },
    readPackedBoolean: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readBoolean());
        var end = readPackedEnd(this);
        arr = arr || [];
        while(this.pos < end)arr.push(this.readBoolean());
        return arr;
    },
    readPackedFloat: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readFloat());
        var end = readPackedEnd(this);
        arr = arr || [];
        while(this.pos < end)arr.push(this.readFloat());
        return arr;
    },
    readPackedDouble: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readDouble());
        var end = readPackedEnd(this);
        arr = arr || [];
        while(this.pos < end)arr.push(this.readDouble());
        return arr;
    },
    readPackedFixed32: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readFixed32());
        var end = readPackedEnd(this);
        arr = arr || [];
        while(this.pos < end)arr.push(this.readFixed32());
        return arr;
    },
    readPackedSFixed32: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readSFixed32());
        var end = readPackedEnd(this);
        arr = arr || [];
        while(this.pos < end)arr.push(this.readSFixed32());
        return arr;
    },
    readPackedFixed64: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readFixed64());
        var end = readPackedEnd(this);
        arr = arr || [];
        while(this.pos < end)arr.push(this.readFixed64());
        return arr;
    },
    readPackedSFixed64: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readSFixed64());
        var end = readPackedEnd(this);
        arr = arr || [];
        while(this.pos < end)arr.push(this.readSFixed64());
        return arr;
    },
    skip: function(val) {
        var type = val & 0x7;
        if (type === Pbf.Varint) while(this.buf[this.pos++] > 0x7f){}
        else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;
        else if (type === Pbf.Fixed32) this.pos += 4;
        else if (type === Pbf.Fixed64) this.pos += 8;
        else throw new Error('Unimplemented type: ' + type);
    },
    // === WRITING =================================================================
    writeTag: function(tag, type) {
        this.writeVarint(tag << 3 | type);
    },
    realloc: function(min) {
        var length = this.length || 16;
        while(length < this.pos + min)length *= 2;
        if (length !== this.length) {
            var buf = new Uint8Array(length);
            buf.set(this.buf);
            this.buf = buf;
            this.length = length;
        }
    },
    finish: function() {
        this.length = this.pos;
        this.pos = 0;
        return this.buf.subarray(0, this.length);
    },
    writeFixed32: function(val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
    },
    writeSFixed32: function(val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
    },
    writeFixed64: function(val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },
    writeSFixed64: function(val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },
    writeVarint: function(val) {
        val = +val || 0;
        if (val > 0xfffffff || val < 0) {
            writeBigVarint(val, this);
            return;
        }
        this.realloc(4);
        this.buf[this.pos++] = val & 0x7f | (val > 0x7f ? 0x80 : 0);
        if (val <= 0x7f) return;
        this.buf[this.pos++] = (val >>>= 7) & 0x7f | (val > 0x7f ? 0x80 : 0);
        if (val <= 0x7f) return;
        this.buf[this.pos++] = (val >>>= 7) & 0x7f | (val > 0x7f ? 0x80 : 0);
        if (val <= 0x7f) return;
        this.buf[this.pos++] = val >>> 7 & 0x7f;
    },
    writeSVarint: function(val) {
        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
    },
    writeBoolean: function(val) {
        this.writeVarint(Boolean(val));
    },
    writeString: function(str) {
        str = String(str);
        this.realloc(str.length * 4);
        this.pos++; // reserve 1 byte for short string length
        var startPos = this.pos;
        // write the string directly to the buffer and see how much was written
        this.pos = writeUtf8(this.buf, str, this.pos);
        var len = this.pos - startPos;
        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);
        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },
    writeFloat: function(val) {
        this.realloc(4);
        ieee754.write(this.buf, val, this.pos, true, 23, 4);
        this.pos += 4;
    },
    writeDouble: function(val) {
        this.realloc(8);
        ieee754.write(this.buf, val, this.pos, true, 52, 8);
        this.pos += 8;
    },
    writeBytes: function(buffer) {
        var len = buffer.length;
        this.writeVarint(len);
        this.realloc(len);
        for(var i = 0; i < len; i++)this.buf[this.pos++] = buffer[i];
    },
    writeRawMessage: function(fn, obj) {
        this.pos++; // reserve 1 byte for short message length
        // write the message directly to the buffer and see how much was written
        var startPos = this.pos;
        fn(obj, this);
        var len = this.pos - startPos;
        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);
        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },
    writeMessage: function(tag, fn, obj) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeRawMessage(fn, obj);
    },
    writePackedVarint: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedVarint, arr);
    },
    writePackedSVarint: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedSVarint, arr);
    },
    writePackedBoolean: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedBoolean, arr);
    },
    writePackedFloat: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedFloat, arr);
    },
    writePackedDouble: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedDouble, arr);
    },
    writePackedFixed32: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedFixed32, arr);
    },
    writePackedSFixed32: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedSFixed32, arr);
    },
    writePackedFixed64: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedFixed64, arr);
    },
    writePackedSFixed64: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedSFixed64, arr);
    },
    writeBytesField: function(tag, buffer) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeBytes(buffer);
    },
    writeFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFixed32(val);
    },
    writeSFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeSFixed32(val);
    },
    writeFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeFixed64(val);
    },
    writeSFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeSFixed64(val);
    },
    writeVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeVarint(val);
    },
    writeSVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeSVarint(val);
    },
    writeStringField: function(tag, str) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeString(str);
    },
    writeFloatField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFloat(val);
    },
    writeDoubleField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeDouble(val);
    },
    writeBooleanField: function(tag, val) {
        this.writeVarintField(tag, Boolean(val));
    }
};
function readVarintRemainder(l, s, p) {
    var buf = p.buf, h, b;
    b = buf[p.pos++];
    h = (b & 0x70) >> 4;
    if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++];
    h |= (b & 0x7f) << 3;
    if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++];
    h |= (b & 0x7f) << 10;
    if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++];
    h |= (b & 0x7f) << 17;
    if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++];
    h |= (b & 0x7f) << 24;
    if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++];
    h |= (b & 0x01) << 31;
    if (b < 0x80) return toNum(l, h, s);
    throw new Error('Expected varint not more than 10 bytes');
}
function readPackedEnd(pbf) {
    return pbf.type === Pbf.Bytes ? pbf.readVarint() + pbf.pos : pbf.pos + 1;
}
function toNum(low, high, isSigned) {
    if (isSigned) {
        return high * 0x100000000 + (low >>> 0);
    }
    return (high >>> 0) * 0x100000000 + (low >>> 0);
}
function writeBigVarint(val, pbf) {
    var low, high;
    if (val >= 0) {
        low = val % 0x100000000 | 0;
        high = val / 0x100000000 | 0;
    } else {
        low = ~(-val % 0x100000000);
        high = ~(-val / 0x100000000);
        if (low ^ 0xffffffff) {
            low = low + 1 | 0;
        } else {
            low = 0;
            high = high + 1 | 0;
        }
    }
    if (val >= 0x10000000000000000 || val < -0x10000000000000000) {
        throw new Error('Given varint doesn\'t fit into 10 bytes');
    }
    pbf.realloc(10);
    writeBigVarintLow(low, high, pbf);
    writeBigVarintHigh(high, pbf);
}
function writeBigVarintLow(low, high, pbf) {
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80;
    low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80;
    low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80;
    low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80;
    low >>>= 7;
    pbf.buf[pbf.pos] = low & 0x7f;
}
function writeBigVarintHigh(high, pbf) {
    var lsb = (high & 0x07) << 4;
    pbf.buf[pbf.pos++] |= lsb | ((high >>>= 3) ? 0x80 : 0);
    if (!high) return;
    pbf.buf[pbf.pos++] = high & 0x7f | ((high >>>= 7) ? 0x80 : 0);
    if (!high) return;
    pbf.buf[pbf.pos++] = high & 0x7f | ((high >>>= 7) ? 0x80 : 0);
    if (!high) return;
    pbf.buf[pbf.pos++] = high & 0x7f | ((high >>>= 7) ? 0x80 : 0);
    if (!high) return;
    pbf.buf[pbf.pos++] = high & 0x7f | ((high >>>= 7) ? 0x80 : 0);
    if (!high) return;
    pbf.buf[pbf.pos++] = high & 0x7f;
}
function makeRoomForExtraLength(startPos, len, pbf) {
    var extraLen = len <= 0x3fff ? 1 : len <= 0x1fffff ? 2 : len <= 0xfffffff ? 3 : Math.floor(Math.log(len) / (Math.LN2 * 7));
    // if 1 byte isn't enough for encoding message length, shift the data to the right
    pbf.realloc(extraLen);
    for(var i = pbf.pos - 1; i >= startPos; i--)pbf.buf[i + extraLen] = pbf.buf[i];
}
function writePackedVarint(arr, pbf) {
    for(var i = 0; i < arr.length; i++)pbf.writeVarint(arr[i]);
}
function writePackedSVarint(arr, pbf) {
    for(var i = 0; i < arr.length; i++)pbf.writeSVarint(arr[i]);
}
function writePackedFloat(arr, pbf) {
    for(var i = 0; i < arr.length; i++)pbf.writeFloat(arr[i]);
}
function writePackedDouble(arr, pbf) {
    for(var i = 0; i < arr.length; i++)pbf.writeDouble(arr[i]);
}
function writePackedBoolean(arr, pbf) {
    for(var i = 0; i < arr.length; i++)pbf.writeBoolean(arr[i]);
}
function writePackedFixed32(arr, pbf) {
    for(var i = 0; i < arr.length; i++)pbf.writeFixed32(arr[i]);
}
function writePackedSFixed32(arr, pbf) {
    for(var i = 0; i < arr.length; i++)pbf.writeSFixed32(arr[i]);
}
function writePackedFixed64(arr, pbf) {
    for(var i = 0; i < arr.length; i++)pbf.writeFixed64(arr[i]);
}
function writePackedSFixed64(arr, pbf) {
    for(var i = 0; i < arr.length; i++)pbf.writeSFixed64(arr[i]);
}
// Buffer code below from https://github.com/feross/buffer, MIT-licensed
function readUInt32(buf, pos) {
    return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + buf[pos + 3] * 0x1000000;
}
function writeInt32(buf, val, pos) {
    buf[pos] = val;
    buf[pos + 1] = val >>> 8;
    buf[pos + 2] = val >>> 16;
    buf[pos + 3] = val >>> 24;
}
function readInt32(buf, pos) {
    return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + (buf[pos + 3] << 24);
}
function readUtf8(buf, pos, end) {
    var str = '';
    var i = pos;
    while(i < end){
        var b0 = buf[i];
        var c = null; // codepoint
        var bytesPerSequence = b0 > 0xEF ? 4 : b0 > 0xDF ? 3 : b0 > 0xBF ? 2 : 1;
        if (i + bytesPerSequence > end) break;
        var b1, b2, b3;
        if (bytesPerSequence === 1) {
            if (b0 < 0x80) {
                c = b0;
            }
        } else if (bytesPerSequence === 2) {
            b1 = buf[i + 1];
            if ((b1 & 0xC0) === 0x80) {
                c = (b0 & 0x1F) << 0x6 | b1 & 0x3F;
                if (c <= 0x7F) {
                    c = null;
                }
            }
        } else if (bytesPerSequence === 3) {
            b1 = buf[i + 1];
            b2 = buf[i + 2];
            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80) {
                c = (b0 & 0xF) << 0xC | (b1 & 0x3F) << 0x6 | b2 & 0x3F;
                if (c <= 0x7FF || c >= 0xD800 && c <= 0xDFFF) {
                    c = null;
                }
            }
        } else if (bytesPerSequence === 4) {
            b1 = buf[i + 1];
            b2 = buf[i + 2];
            b3 = buf[i + 3];
            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
                c = (b0 & 0xF) << 0x12 | (b1 & 0x3F) << 0xC | (b2 & 0x3F) << 0x6 | b3 & 0x3F;
                if (c <= 0xFFFF || c >= 0x110000) {
                    c = null;
                }
            }
        }
        if (c === null) {
            c = 0xFFFD;
            bytesPerSequence = 1;
        } else if (c > 0xFFFF) {
            c -= 0x10000;
            str += String.fromCharCode(c >>> 10 & 0x3FF | 0xD800);
            c = 0xDC00 | c & 0x3FF;
        }
        str += String.fromCharCode(c);
        i += bytesPerSequence;
    }
    return str;
}
function readUtf8TextDecoder(buf, pos, end) {
    return utf8TextDecoder.decode(buf.subarray(pos, end));
}
function writeUtf8(buf, str, pos) {
    for(var i = 0, c, lead; i < str.length; i++){
        c = str.charCodeAt(i); // code point
        if (c > 0xD7FF && c < 0xE000) {
            if (lead) {
                if (c < 0xDC00) {
                    buf[pos++] = 0xEF;
                    buf[pos++] = 0xBF;
                    buf[pos++] = 0xBD;
                    lead = c;
                    continue;
                } else {
                    c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;
                    lead = null;
                }
            } else {
                if (c > 0xDBFF || i + 1 === str.length) {
                    buf[pos++] = 0xEF;
                    buf[pos++] = 0xBF;
                    buf[pos++] = 0xBD;
                } else {
                    lead = c;
                }
                continue;
            }
        } else if (lead) {
            buf[pos++] = 0xEF;
            buf[pos++] = 0xBF;
            buf[pos++] = 0xBD;
            lead = null;
        }
        if (c < 0x80) {
            buf[pos++] = c;
        } else {
            if (c < 0x800) {
                buf[pos++] = c >> 0x6 | 0xC0;
            } else {
                if (c < 0x10000) {
                    buf[pos++] = c >> 0xC | 0xE0;
                } else {
                    buf[pos++] = c >> 0x12 | 0xF0;
                    buf[pos++] = c >> 0xC & 0x3F | 0x80;
                }
                buf[pos++] = c >> 0x6 & 0x3F | 0x80;
            }
            buf[pos++] = c & 0x3F | 0x80;
        }
    }
    return pos;
}
}}),
"[project]/node_modules/point-in-polygon-hao/dist/esm/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>pointInPolygon)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$robust$2d$predicates$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/robust-predicates/index.js [client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$robust$2d$predicates$2f$esm$2f$orient2d$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/robust-predicates/esm/orient2d.js [client] (ecmascript)");
;
function pointInPolygon(p, polygon) {
    var i;
    var ii;
    var k = 0;
    var f;
    var u1;
    var v1;
    var u2;
    var v2;
    var currentP;
    var nextP;
    var x = p[0];
    var y = p[1];
    var numContours = polygon.length;
    for(i = 0; i < numContours; i++){
        ii = 0;
        var contour = polygon[i];
        var contourLen = contour.length - 1;
        currentP = contour[0];
        if (currentP[0] !== contour[contourLen][0] && currentP[1] !== contour[contourLen][1]) {
            throw new Error('First and last coordinates in a ring must be the same');
        }
        u1 = currentP[0] - x;
        v1 = currentP[1] - y;
        for(ii; ii < contourLen; ii++){
            nextP = contour[ii + 1];
            u2 = nextP[0] - x;
            v2 = nextP[1] - y;
            if (v1 === 0 && v2 === 0) {
                if (u2 <= 0 && u1 >= 0 || u1 <= 0 && u2 >= 0) {
                    return 0;
                }
            } else if (v2 >= 0 && v1 <= 0 || v2 <= 0 && v1 >= 0) {
                f = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$robust$2d$predicates$2f$esm$2f$orient2d$2e$js__$5b$client$5d$__$28$ecmascript$29$__["orient2d"])(u1, u2, v1, v2, 0, 0);
                if (f === 0) {
                    return 0;
                }
                if (f > 0 && v2 > 0 && v1 <= 0 || f < 0 && v2 <= 0 && v1 > 0) {
                    k++;
                }
            }
            currentP = nextP;
            v1 = v2;
            u1 = u2;
        }
    }
    if (k % 2 === 0) {
        return false;
    }
    return true;
}
;
}}),
"[project]/node_modules/@turf/helpers/dist/esm/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// index.ts
__turbopack_context__.s({
    "areaFactors": (()=>areaFactors),
    "azimuthToBearing": (()=>azimuthToBearing),
    "bearingToAzimuth": (()=>bearingToAzimuth),
    "convertArea": (()=>convertArea),
    "convertLength": (()=>convertLength),
    "degreesToRadians": (()=>degreesToRadians),
    "earthRadius": (()=>earthRadius),
    "factors": (()=>factors),
    "feature": (()=>feature),
    "featureCollection": (()=>featureCollection),
    "geometry": (()=>geometry),
    "geometryCollection": (()=>geometryCollection),
    "isNumber": (()=>isNumber),
    "isObject": (()=>isObject),
    "lengthToDegrees": (()=>lengthToDegrees),
    "lengthToRadians": (()=>lengthToRadians),
    "lineString": (()=>lineString),
    "lineStrings": (()=>lineStrings),
    "multiLineString": (()=>multiLineString),
    "multiPoint": (()=>multiPoint),
    "multiPolygon": (()=>multiPolygon),
    "point": (()=>point),
    "points": (()=>points),
    "polygon": (()=>polygon),
    "polygons": (()=>polygons),
    "radiansToDegrees": (()=>radiansToDegrees),
    "radiansToLength": (()=>radiansToLength),
    "round": (()=>round),
    "validateBBox": (()=>validateBBox),
    "validateId": (()=>validateId)
});
var earthRadius = 63710088e-1;
var factors = {
    centimeters: earthRadius * 100,
    centimetres: earthRadius * 100,
    degrees: 360 / (2 * Math.PI),
    feet: earthRadius * 3.28084,
    inches: earthRadius * 39.37,
    kilometers: earthRadius / 1e3,
    kilometres: earthRadius / 1e3,
    meters: earthRadius,
    metres: earthRadius,
    miles: earthRadius / 1609.344,
    millimeters: earthRadius * 1e3,
    millimetres: earthRadius * 1e3,
    nauticalmiles: earthRadius / 1852,
    radians: 1,
    yards: earthRadius * 1.0936
};
var areaFactors = {
    acres: 247105e-9,
    centimeters: 1e4,
    centimetres: 1e4,
    feet: 10.763910417,
    hectares: 1e-4,
    inches: 1550.003100006,
    kilometers: 1e-6,
    kilometres: 1e-6,
    meters: 1,
    metres: 1,
    miles: 386e-9,
    nauticalmiles: 29155334959812285e-23,
    millimeters: 1e6,
    millimetres: 1e6,
    yards: 1.195990046
};
function feature(geom, properties, options = {}) {
    const feat = {
        type: "Feature"
    };
    if (options.id === 0 || options.id) {
        feat.id = options.id;
    }
    if (options.bbox) {
        feat.bbox = options.bbox;
    }
    feat.properties = properties || {};
    feat.geometry = geom;
    return feat;
}
function geometry(type, coordinates, _options = {}) {
    switch(type){
        case "Point":
            return point(coordinates).geometry;
        case "LineString":
            return lineString(coordinates).geometry;
        case "Polygon":
            return polygon(coordinates).geometry;
        case "MultiPoint":
            return multiPoint(coordinates).geometry;
        case "MultiLineString":
            return multiLineString(coordinates).geometry;
        case "MultiPolygon":
            return multiPolygon(coordinates).geometry;
        default:
            throw new Error(type + " is invalid");
    }
}
function point(coordinates, properties, options = {}) {
    if (!coordinates) {
        throw new Error("coordinates is required");
    }
    if (!Array.isArray(coordinates)) {
        throw new Error("coordinates must be an Array");
    }
    if (coordinates.length < 2) {
        throw new Error("coordinates must be at least 2 numbers long");
    }
    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {
        throw new Error("coordinates must contain numbers");
    }
    const geom = {
        type: "Point",
        coordinates
    };
    return feature(geom, properties, options);
}
function points(coordinates, properties, options = {}) {
    return featureCollection(coordinates.map((coords)=>{
        return point(coords, properties);
    }), options);
}
function polygon(coordinates, properties, options = {}) {
    for (const ring of coordinates){
        if (ring.length < 4) {
            throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
        }
        if (ring[ring.length - 1].length !== ring[0].length) {
            throw new Error("First and last Position are not equivalent.");
        }
        for(let j = 0; j < ring[ring.length - 1].length; j++){
            if (ring[ring.length - 1][j] !== ring[0][j]) {
                throw new Error("First and last Position are not equivalent.");
            }
        }
    }
    const geom = {
        type: "Polygon",
        coordinates
    };
    return feature(geom, properties, options);
}
function polygons(coordinates, properties, options = {}) {
    return featureCollection(coordinates.map((coords)=>{
        return polygon(coords, properties);
    }), options);
}
function lineString(coordinates, properties, options = {}) {
    if (coordinates.length < 2) {
        throw new Error("coordinates must be an array of two or more positions");
    }
    const geom = {
        type: "LineString",
        coordinates
    };
    return feature(geom, properties, options);
}
function lineStrings(coordinates, properties, options = {}) {
    return featureCollection(coordinates.map((coords)=>{
        return lineString(coords, properties);
    }), options);
}
function featureCollection(features, options = {}) {
    const fc = {
        type: "FeatureCollection"
    };
    if (options.id) {
        fc.id = options.id;
    }
    if (options.bbox) {
        fc.bbox = options.bbox;
    }
    fc.features = features;
    return fc;
}
function multiLineString(coordinates, properties, options = {}) {
    const geom = {
        type: "MultiLineString",
        coordinates
    };
    return feature(geom, properties, options);
}
function multiPoint(coordinates, properties, options = {}) {
    const geom = {
        type: "MultiPoint",
        coordinates
    };
    return feature(geom, properties, options);
}
function multiPolygon(coordinates, properties, options = {}) {
    const geom = {
        type: "MultiPolygon",
        coordinates
    };
    return feature(geom, properties, options);
}
function geometryCollection(geometries, properties, options = {}) {
    const geom = {
        type: "GeometryCollection",
        geometries
    };
    return feature(geom, properties, options);
}
function round(num, precision = 0) {
    if (precision && !(precision >= 0)) {
        throw new Error("precision must be a positive number");
    }
    const multiplier = Math.pow(10, precision || 0);
    return Math.round(num * multiplier) / multiplier;
}
function radiansToLength(radians, units = "kilometers") {
    const factor = factors[units];
    if (!factor) {
        throw new Error(units + " units is invalid");
    }
    return radians * factor;
}
function lengthToRadians(distance, units = "kilometers") {
    const factor = factors[units];
    if (!factor) {
        throw new Error(units + " units is invalid");
    }
    return distance / factor;
}
function lengthToDegrees(distance, units) {
    return radiansToDegrees(lengthToRadians(distance, units));
}
function bearingToAzimuth(bearing) {
    let angle = bearing % 360;
    if (angle < 0) {
        angle += 360;
    }
    return angle;
}
function azimuthToBearing(angle) {
    angle = angle % 360;
    if (angle > 180) {
        return angle - 360;
    } else if (angle < -180) {
        return angle + 360;
    }
    return angle;
}
function radiansToDegrees(radians) {
    const normalisedRadians = radians % (2 * Math.PI);
    return normalisedRadians * 180 / Math.PI;
}
function degreesToRadians(degrees) {
    const normalisedDegrees = degrees % 360;
    return normalisedDegrees * Math.PI / 180;
}
function convertLength(length, originalUnit = "kilometers", finalUnit = "kilometers") {
    if (!(length >= 0)) {
        throw new Error("length must be a positive number");
    }
    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);
}
function convertArea(area, originalUnit = "meters", finalUnit = "kilometers") {
    if (!(area >= 0)) {
        throw new Error("area must be a positive number");
    }
    const startFactor = areaFactors[originalUnit];
    if (!startFactor) {
        throw new Error("invalid original units");
    }
    const finalFactor = areaFactors[finalUnit];
    if (!finalFactor) {
        throw new Error("invalid final units");
    }
    return area / startFactor * finalFactor;
}
function isNumber(num) {
    return !isNaN(num) && num !== null && !Array.isArray(num);
}
function isObject(input) {
    return input !== null && typeof input === "object" && !Array.isArray(input);
}
function validateBBox(bbox) {
    if (!bbox) {
        throw new Error("bbox is required");
    }
    if (!Array.isArray(bbox)) {
        throw new Error("bbox must be an Array");
    }
    if (bbox.length !== 4 && bbox.length !== 6) {
        throw new Error("bbox must be an Array of 4 or 6 numbers");
    }
    bbox.forEach((num)=>{
        if (!isNumber(num)) {
            throw new Error("bbox must only contain numbers");
        }
    });
}
function validateId(id) {
    if (!id) {
        throw new Error("id is required");
    }
    if ([
        "string",
        "number"
    ].indexOf(typeof id) === -1) {
        throw new Error("id must be a number or a string");
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/invariant/dist/esm/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// index.ts
__turbopack_context__.s({
    "collectionOf": (()=>collectionOf),
    "containsNumber": (()=>containsNumber),
    "featureOf": (()=>featureOf),
    "geojsonType": (()=>geojsonType),
    "getCoord": (()=>getCoord),
    "getCoords": (()=>getCoords),
    "getGeom": (()=>getGeom),
    "getType": (()=>getType)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turf/helpers/dist/esm/index.js [client] (ecmascript)");
;
function getCoord(coord) {
    if (!coord) {
        throw new Error("coord is required");
    }
    if (!Array.isArray(coord)) {
        if (coord.type === "Feature" && coord.geometry !== null && coord.geometry.type === "Point") {
            return [
                ...coord.geometry.coordinates
            ];
        }
        if (coord.type === "Point") {
            return [
                ...coord.coordinates
            ];
        }
    }
    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {
        return [
            ...coord
        ];
    }
    throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
function getCoords(coords) {
    if (Array.isArray(coords)) {
        return coords;
    }
    if (coords.type === "Feature") {
        if (coords.geometry !== null) {
            return coords.geometry.coordinates;
        }
    } else {
        if (coords.coordinates) {
            return coords.coordinates;
        }
    }
    throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
}
function containsNumber(coordinates) {
    if (coordinates.length > 1 && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isNumber"])(coordinates[0]) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isNumber"])(coordinates[1])) {
        return true;
    }
    if (Array.isArray(coordinates[0]) && coordinates[0].length) {
        return containsNumber(coordinates[0]);
    }
    throw new Error("coordinates must only contain numbers");
}
function geojsonType(value, type, name) {
    if (!type || !name) {
        throw new Error("type and name required");
    }
    if (!value || value.type !== type) {
        throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + value.type);
    }
}
function featureOf(feature, type, name) {
    if (!feature) {
        throw new Error("No feature passed");
    }
    if (!name) {
        throw new Error(".featureOf() requires a name");
    }
    if (!feature || feature.type !== "Feature" || !feature.geometry) {
        throw new Error("Invalid input to " + name + ", Feature with geometry required");
    }
    if (!feature.geometry || feature.geometry.type !== type) {
        throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature.geometry.type);
    }
}
function collectionOf(featureCollection, type, name) {
    if (!featureCollection) {
        throw new Error("No featureCollection passed");
    }
    if (!name) {
        throw new Error(".collectionOf() requires a name");
    }
    if (!featureCollection || featureCollection.type !== "FeatureCollection") {
        throw new Error("Invalid input to " + name + ", FeatureCollection required");
    }
    for (const feature of featureCollection.features){
        if (!feature || feature.type !== "Feature" || !feature.geometry) {
            throw new Error("Invalid input to " + name + ", Feature with geometry required");
        }
        if (!feature.geometry || feature.geometry.type !== type) {
            throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature.geometry.type);
        }
    }
}
function getGeom(geojson) {
    if (geojson.type === "Feature") {
        return geojson.geometry;
    }
    return geojson;
}
function getType(geojson, _name) {
    if (geojson.type === "FeatureCollection") {
        return "FeatureCollection";
    }
    if (geojson.type === "GeometryCollection") {
        return "GeometryCollection";
    }
    if (geojson.type === "Feature" && geojson.geometry !== null) {
        return geojson.geometry.type;
    }
    return geojson.type;
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// index.ts
__turbopack_context__.s({
    "booleanPointInPolygon": (()=>booleanPointInPolygon),
    "default": (()=>turf_boolean_point_in_polygon_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$point$2d$in$2d$polygon$2d$hao$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/point-in-polygon-hao/dist/esm/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turf/invariant/dist/esm/index.js [client] (ecmascript)");
;
;
function booleanPointInPolygon(point, polygon, options = {}) {
    if (!point) {
        throw new Error("point is required");
    }
    if (!polygon) {
        throw new Error("polygon is required");
    }
    const pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getCoord"])(point);
    const geom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getGeom"])(polygon);
    const type = geom.type;
    const bbox = polygon.bbox;
    let polys = geom.coordinates;
    if (bbox && inBBox(pt, bbox) === false) {
        return false;
    }
    if (type === "Polygon") {
        polys = [
            polys
        ];
    }
    let result = false;
    for(var i = 0; i < polys.length; ++i){
        const polyResult = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$point$2d$in$2d$polygon$2d$hao$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(pt, polys[i]);
        if (polyResult === 0) return options.ignoreBoundary ? false : true;
        else if (polyResult) result = true;
    }
    return result;
}
function inBBox(pt, bbox) {
    return bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1];
}
var turf_boolean_point_in_polygon_default = booleanPointInPolygon;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/line-intersect/dist/esm/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// index.ts
__turbopack_context__.s({
    "default": (()=>turf_line_intersect_default),
    "lineIntersect": (()=>lineIntersect)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turf/helpers/dist/esm/index.js [client] (ecmascript)");
// lib/sweepline-intersections-export.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sweepline$2d$intersections$2f$dist$2f$sweeplineIntersections$2e$esm$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/sweepline-intersections/dist/sweeplineIntersections.esm.js [client] (ecmascript)");
;
;
var sweeplineIntersections = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sweepline$2d$intersections$2f$dist$2f$sweeplineIntersections$2e$esm$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"];
// index.ts
function lineIntersect(line1, line2, options = {}) {
    const { removeDuplicates = true, ignoreSelfIntersections = true } = options;
    let features = [];
    if (line1.type === "FeatureCollection") features = features.concat(line1.features);
    else if (line1.type === "Feature") features.push(line1);
    else if (line1.type === "LineString" || line1.type === "Polygon" || line1.type === "MultiLineString" || line1.type === "MultiPolygon") {
        features.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["feature"])(line1));
    }
    if (line2.type === "FeatureCollection") features = features.concat(line2.features);
    else if (line2.type === "Feature") features.push(line2);
    else if (line2.type === "LineString" || line2.type === "Polygon" || line2.type === "MultiLineString" || line2.type === "MultiPolygon") {
        features.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["feature"])(line2));
    }
    const intersections = sweeplineIntersections((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["featureCollection"])(features), ignoreSelfIntersections);
    let results = [];
    if (removeDuplicates) {
        const unique = {};
        intersections.forEach((intersection)=>{
            const key = intersection.join(",");
            if (!unique[key]) {
                unique[key] = true;
                results.push(intersection);
            }
        });
    } else {
        results = intersections;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["featureCollection"])(results.map((r)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["point"])(r)));
}
var turf_line_intersect_default = lineIntersect;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/meta/dist/esm/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// index.js
__turbopack_context__.s({
    "coordAll": (()=>coordAll),
    "coordEach": (()=>coordEach),
    "coordReduce": (()=>coordReduce),
    "featureEach": (()=>featureEach),
    "featureReduce": (()=>featureReduce),
    "findPoint": (()=>findPoint),
    "findSegment": (()=>findSegment),
    "flattenEach": (()=>flattenEach),
    "flattenReduce": (()=>flattenReduce),
    "geomEach": (()=>geomEach),
    "geomReduce": (()=>geomReduce),
    "lineEach": (()=>lineEach),
    "lineReduce": (()=>lineReduce),
    "propEach": (()=>propEach),
    "propReduce": (()=>propReduce),
    "segmentEach": (()=>segmentEach),
    "segmentReduce": (()=>segmentReduce)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turf/helpers/dist/esm/index.js [client] (ecmascript)");
;
function coordEach(geojson, callback, excludeWrapCoord) {
    if (geojson === null) return;
    var j, k, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === "FeatureCollection", isFeature = type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
    for(var featureIndex = 0; featureIndex < stop; featureIndex++){
        geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;
        isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
        for(var geomIndex = 0; geomIndex < stopG; geomIndex++){
            var multiFeatureIndex = 0;
            var geometryIndex = 0;
            geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;
            if (geometry === null) continue;
            coords = geometry.coordinates;
            var geomType = geometry.type;
            wrapShrink = excludeWrapCoord && (geomType === "Polygon" || geomType === "MultiPolygon") ? 1 : 0;
            switch(geomType){
                case null:
                    break;
                case "Point":
                    if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                    coordIndex++;
                    multiFeatureIndex++;
                    break;
                case "LineString":
                case "MultiPoint":
                    for(j = 0; j < coords.length; j++){
                        if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                        coordIndex++;
                        if (geomType === "MultiPoint") multiFeatureIndex++;
                    }
                    if (geomType === "LineString") multiFeatureIndex++;
                    break;
                case "Polygon":
                case "MultiLineString":
                    for(j = 0; j < coords.length; j++){
                        for(k = 0; k < coords[j].length - wrapShrink; k++){
                            if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                            coordIndex++;
                        }
                        if (geomType === "MultiLineString") multiFeatureIndex++;
                        if (geomType === "Polygon") geometryIndex++;
                    }
                    if (geomType === "Polygon") multiFeatureIndex++;
                    break;
                case "MultiPolygon":
                    for(j = 0; j < coords.length; j++){
                        geometryIndex = 0;
                        for(k = 0; k < coords[j].length; k++){
                            for(l = 0; l < coords[j][k].length - wrapShrink; l++){
                                if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                                coordIndex++;
                            }
                            geometryIndex++;
                        }
                        multiFeatureIndex++;
                    }
                    break;
                case "GeometryCollection":
                    for(j = 0; j < geometry.geometries.length; j++)if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;
                    break;
                default:
                    throw new Error("Unknown Geometry Type");
            }
        }
    }
}
function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
    var previousValue = initialValue;
    coordEach(geojson, function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
        if (coordIndex === 0 && initialValue === void 0) previousValue = currentCoord;
        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);
    }, excludeWrapCoord);
    return previousValue;
}
function propEach(geojson, callback) {
    var i;
    switch(geojson.type){
        case "FeatureCollection":
            for(i = 0; i < geojson.features.length; i++){
                if (callback(geojson.features[i].properties, i) === false) break;
            }
            break;
        case "Feature":
            callback(geojson.properties, 0);
            break;
    }
}
function propReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    propEach(geojson, function(currentProperties, featureIndex) {
        if (featureIndex === 0 && initialValue === void 0) previousValue = currentProperties;
        else previousValue = callback(previousValue, currentProperties, featureIndex);
    });
    return previousValue;
}
function featureEach(geojson, callback) {
    if (geojson.type === "Feature") {
        callback(geojson, 0);
    } else if (geojson.type === "FeatureCollection") {
        for(var i = 0; i < geojson.features.length; i++){
            if (callback(geojson.features[i], i) === false) break;
        }
    }
}
function featureReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    featureEach(geojson, function(currentFeature, featureIndex) {
        if (featureIndex === 0 && initialValue === void 0) previousValue = currentFeature;
        else previousValue = callback(previousValue, currentFeature, featureIndex);
    });
    return previousValue;
}
function coordAll(geojson) {
    var coords = [];
    coordEach(geojson, function(coord) {
        coords.push(coord);
    });
    return coords;
}
function geomEach(geojson, callback) {
    var i, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === "FeatureCollection", isFeature = geojson.type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
    for(i = 0; i < stop; i++){
        geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;
        featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};
        featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;
        featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;
        isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
        for(g = 0; g < stopG; g++){
            geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
            if (geometry === null) {
                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;
                continue;
            }
            switch(geometry.type){
                case "Point":
                case "LineString":
                case "MultiPoint":
                case "Polygon":
                case "MultiLineString":
                case "MultiPolygon":
                    {
                        if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;
                        break;
                    }
                case "GeometryCollection":
                    {
                        for(j = 0; j < geometry.geometries.length; j++){
                            if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;
                        }
                        break;
                    }
                default:
                    throw new Error("Unknown Geometry Type");
            }
        }
        featureIndex++;
    }
}
function geomReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    geomEach(geojson, function(currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
        if (featureIndex === 0 && initialValue === void 0) previousValue = currentGeometry;
        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);
    });
    return previousValue;
}
function flattenEach(geojson, callback) {
    geomEach(geojson, function(geometry, featureIndex, properties, bbox, id) {
        var type = geometry === null ? null : geometry.type;
        switch(type){
            case null:
            case "Point":
            case "LineString":
            case "Polygon":
                if (callback((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["feature"])(geometry, properties, {
                    bbox,
                    id
                }), featureIndex, 0) === false) return false;
                return;
        }
        var geomType;
        switch(type){
            case "MultiPoint":
                geomType = "Point";
                break;
            case "MultiLineString":
                geomType = "LineString";
                break;
            case "MultiPolygon":
                geomType = "Polygon";
                break;
        }
        for(var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++){
            var coordinate = geometry.coordinates[multiFeatureIndex];
            var geom = {
                type: geomType,
                coordinates: coordinate
            };
            if (callback((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["feature"])(geom, properties), featureIndex, multiFeatureIndex) === false) return false;
        }
    });
}
function flattenReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    flattenEach(geojson, function(currentFeature, featureIndex, multiFeatureIndex) {
        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === void 0) previousValue = currentFeature;
        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);
    });
    return previousValue;
}
function segmentEach(geojson, callback) {
    flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {
        var segmentIndex = 0;
        if (!feature2.geometry) return;
        var type = feature2.geometry.type;
        if (type === "Point" || type === "MultiPoint") return;
        var previousCoords;
        var previousFeatureIndex = 0;
        var previousMultiIndex = 0;
        var prevGeomIndex = 0;
        if (coordEach(feature2, function(currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {
            if (previousCoords === void 0 || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {
                previousCoords = currentCoord;
                previousFeatureIndex = featureIndex;
                previousMultiIndex = multiPartIndexCoord;
                prevGeomIndex = geometryIndex;
                segmentIndex = 0;
                return;
            }
            var currentSegment = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["lineString"])([
                previousCoords,
                currentCoord
            ], feature2.properties);
            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;
            segmentIndex++;
            previousCoords = currentCoord;
        }) === false) return false;
    });
}
function segmentReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    var started = false;
    segmentEach(geojson, function(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
        if (started === false && initialValue === void 0) previousValue = currentSegment;
        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);
        started = true;
    });
    return previousValue;
}
function lineEach(geojson, callback) {
    if (!geojson) throw new Error("geojson is required");
    flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {
        if (feature2.geometry === null) return;
        var type = feature2.geometry.type;
        var coords = feature2.geometry.coordinates;
        switch(type){
            case "LineString":
                if (callback(feature2, featureIndex, multiFeatureIndex, 0, 0) === false) return false;
                break;
            case "Polygon":
                for(var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++){
                    if (callback((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["lineString"])(coords[geometryIndex], feature2.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                }
                break;
        }
    });
}
function lineReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    lineEach(geojson, function(currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
        if (featureIndex === 0 && initialValue === void 0) previousValue = currentLine;
        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);
    });
    return previousValue;
}
function findSegment(geojson, options) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    var featureIndex = options.featureIndex || 0;
    var multiFeatureIndex = options.multiFeatureIndex || 0;
    var geometryIndex = options.geometryIndex || 0;
    var segmentIndex = options.segmentIndex || 0;
    var properties = options.properties;
    var geometry;
    switch(geojson.type){
        case "FeatureCollection":
            if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;
            properties = properties || geojson.features[featureIndex].properties;
            geometry = geojson.features[featureIndex].geometry;
            break;
        case "Feature":
            properties = properties || geojson.properties;
            geometry = geojson.geometry;
            break;
        case "Point":
        case "MultiPoint":
            return null;
        case "LineString":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon":
            geometry = geojson;
            break;
        default:
            throw new Error("geojson is invalid");
    }
    if (geometry === null) return null;
    var coords = geometry.coordinates;
    switch(geometry.type){
        case "Point":
        case "MultiPoint":
            return null;
        case "LineString":
            if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["lineString"])([
                coords[segmentIndex],
                coords[segmentIndex + 1]
            ], properties, options);
        case "Polygon":
            if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
            if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["lineString"])([
                coords[geometryIndex][segmentIndex],
                coords[geometryIndex][segmentIndex + 1]
            ], properties, options);
        case "MultiLineString":
            if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
            if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["lineString"])([
                coords[multiFeatureIndex][segmentIndex],
                coords[multiFeatureIndex][segmentIndex + 1]
            ], properties, options);
        case "MultiPolygon":
            if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
            if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
            if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["lineString"])([
                coords[multiFeatureIndex][geometryIndex][segmentIndex],
                coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]
            ], properties, options);
    }
    throw new Error("geojson is invalid");
}
function findPoint(geojson, options) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    var featureIndex = options.featureIndex || 0;
    var multiFeatureIndex = options.multiFeatureIndex || 0;
    var geometryIndex = options.geometryIndex || 0;
    var coordIndex = options.coordIndex || 0;
    var properties = options.properties;
    var geometry;
    switch(geojson.type){
        case "FeatureCollection":
            if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;
            properties = properties || geojson.features[featureIndex].properties;
            geometry = geojson.features[featureIndex].geometry;
            break;
        case "Feature":
            properties = properties || geojson.properties;
            geometry = geojson.geometry;
            break;
        case "Point":
        case "MultiPoint":
            return null;
        case "LineString":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon":
            geometry = geojson;
            break;
        default:
            throw new Error("geojson is invalid");
    }
    if (geometry === null) return null;
    var coords = geometry.coordinates;
    switch(geometry.type){
        case "Point":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["point"])(coords, properties, options);
        case "MultiPoint":
            if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["point"])(coords[multiFeatureIndex], properties, options);
        case "LineString":
            if (coordIndex < 0) coordIndex = coords.length + coordIndex;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["point"])(coords[coordIndex], properties, options);
        case "Polygon":
            if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
            if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["point"])(coords[geometryIndex][coordIndex], properties, options);
        case "MultiLineString":
            if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
            if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["point"])(coords[multiFeatureIndex][coordIndex], properties, options);
        case "MultiPolygon":
            if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
            if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
            if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["point"])(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);
    }
    throw new Error("geojson is invalid");
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/polygon-to-line/dist/esm/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// index.ts
__turbopack_context__.s({
    "coordsToLine": (()=>coordsToLine),
    "default": (()=>turf_polygon_to_line_default),
    "multiPolygonToLine": (()=>multiPolygonToLine),
    "polygonToLine": (()=>polygonToLine),
    "singlePolygonToLine": (()=>singlePolygonToLine)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turf/helpers/dist/esm/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turf/invariant/dist/esm/index.js [client] (ecmascript)");
;
;
function polygonToLine(poly, options = {}) {
    const geom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getGeom"])(poly);
    if (!options.properties && poly.type === "Feature") {
        options.properties = poly.properties;
    }
    switch(geom.type){
        case "Polygon":
            return singlePolygonToLine(geom, options);
        case "MultiPolygon":
            return multiPolygonToLine(geom, options);
        default:
            throw new Error("invalid poly");
    }
}
function singlePolygonToLine(poly, options = {}) {
    const geom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getGeom"])(poly);
    const coords = geom.coordinates;
    const properties = options.properties ? options.properties : poly.type === "Feature" ? poly.properties : {};
    return coordsToLine(coords, properties);
}
function multiPolygonToLine(multiPoly, options = {}) {
    const geom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getGeom"])(multiPoly);
    const coords = geom.coordinates;
    const properties = options.properties ? options.properties : multiPoly.type === "Feature" ? multiPoly.properties : {};
    const lines = [];
    coords.forEach((coord)=>{
        lines.push(coordsToLine(coord, properties));
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["featureCollection"])(lines);
}
function coordsToLine(coords, properties) {
    if (coords.length > 1) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["multiLineString"])(coords, properties);
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["lineString"])(coords[0], properties);
}
var turf_polygon_to_line_default = polygonToLine;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/boolean-disjoint/dist/esm/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// index.ts
__turbopack_context__.s({
    "booleanDisjoint": (()=>booleanDisjoint),
    "default": (()=>turf_boolean_disjoint_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turf/line-intersect/dist/esm/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turf/meta/dist/esm/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$polygon$2d$to$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turf/polygon-to-line/dist/esm/index.js [client] (ecmascript)");
;
;
;
;
function booleanDisjoint(feature1, feature2, { ignoreSelfIntersections = true } = {
    ignoreSelfIntersections: true
}) {
    let bool = true;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["flattenEach"])(feature1, (flatten1)=>{
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["flattenEach"])(feature2, (flatten2)=>{
            if (bool === false) {
                return false;
            }
            bool = disjoint(flatten1.geometry, flatten2.geometry, ignoreSelfIntersections);
        });
    });
    return bool;
}
function disjoint(geom1, geom2, ignoreSelfIntersections) {
    switch(geom1.type){
        case "Point":
            switch(geom2.type){
                case "Point":
                    return !compareCoords(geom1.coordinates, geom2.coordinates);
                case "LineString":
                    return !isPointOnLine(geom2, geom1);
                case "Polygon":
                    return !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(geom1, geom2);
            }
            break;
        case "LineString":
            switch(geom2.type){
                case "Point":
                    return !isPointOnLine(geom1, geom2);
                case "LineString":
                    return !isLineOnLine(geom1, geom2, ignoreSelfIntersections);
                case "Polygon":
                    return !isLineInPoly(geom2, geom1, ignoreSelfIntersections);
            }
            break;
        case "Polygon":
            switch(geom2.type){
                case "Point":
                    return !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(geom2, geom1);
                case "LineString":
                    return !isLineInPoly(geom1, geom2, ignoreSelfIntersections);
                case "Polygon":
                    return !isPolyInPoly(geom2, geom1, ignoreSelfIntersections);
            }
    }
    return false;
}
function isPointOnLine(lineString, pt) {
    for(let i = 0; i < lineString.coordinates.length - 1; i++){
        if (isPointOnLineSegment(lineString.coordinates[i], lineString.coordinates[i + 1], pt.coordinates)) {
            return true;
        }
    }
    return false;
}
function isLineOnLine(lineString1, lineString2, ignoreSelfIntersections) {
    const doLinesIntersect = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["lineIntersect"])(lineString1, lineString2, {
        ignoreSelfIntersections
    });
    if (doLinesIntersect.features.length > 0) {
        return true;
    }
    return false;
}
function isLineInPoly(polygon, lineString, ignoreSelfIntersections) {
    for (const coord of lineString.coordinates){
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(coord, polygon)) {
            return true;
        }
    }
    const doLinesIntersect = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["lineIntersect"])(lineString, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$polygon$2d$to$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["polygonToLine"])(polygon), {
        ignoreSelfIntersections
    });
    if (doLinesIntersect.features.length > 0) {
        return true;
    }
    return false;
}
function isPolyInPoly(feature1, feature2, ignoreSelfIntersections) {
    for (const coord1 of feature1.coordinates[0]){
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(coord1, feature2)) {
            return true;
        }
    }
    for (const coord2 of feature2.coordinates[0]){
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(coord2, feature1)) {
            return true;
        }
    }
    const doLinesIntersect = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["lineIntersect"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$polygon$2d$to$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["polygonToLine"])(feature1), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$polygon$2d$to$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["polygonToLine"])(feature2), {
        ignoreSelfIntersections
    });
    if (doLinesIntersect.features.length > 0) {
        return true;
    }
    return false;
}
function isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt) {
    const dxc = pt[0] - lineSegmentStart[0];
    const dyc = pt[1] - lineSegmentStart[1];
    const dxl = lineSegmentEnd[0] - lineSegmentStart[0];
    const dyl = lineSegmentEnd[1] - lineSegmentStart[1];
    const cross = dxc * dyl - dyc * dxl;
    if (cross !== 0) {
        return false;
    }
    if (Math.abs(dxl) >= Math.abs(dyl)) {
        if (dxl > 0) {
            return lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0];
        } else {
            return lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];
        }
    } else if (dyl > 0) {
        return lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1];
    } else {
        return lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];
    }
}
function compareCoords(pair1, pair2) {
    return pair1[0] === pair2[0] && pair1[1] === pair2[1];
}
var turf_boolean_disjoint_default = booleanDisjoint;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/boolean-intersects/dist/esm/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// index.ts
__turbopack_context__.s({
    "booleanIntersects": (()=>booleanIntersects),
    "default": (()=>turf_boolean_intersects_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$disjoint$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turf/boolean-disjoint/dist/esm/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turf/meta/dist/esm/index.js [client] (ecmascript)");
;
;
function booleanIntersects(feature1, feature2, { ignoreSelfIntersections = true } = {}) {
    let bool = false;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["flattenEach"])(feature1, (flatten1)=>{
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["flattenEach"])(feature2, (flatten2)=>{
            if (bool === true) {
                return true;
            }
            bool = !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$disjoint$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["booleanDisjoint"])(flatten1.geometry, flatten2.geometry, {
                ignoreSelfIntersections
            });
        });
    });
    return bool;
}
var turf_boolean_intersects_default = booleanIntersects;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/bbox-polygon/dist/esm/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// index.ts
__turbopack_context__.s({
    "bboxPolygon": (()=>bboxPolygon),
    "default": (()=>turf_bbox_polygon_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turf/helpers/dist/esm/index.js [client] (ecmascript)");
;
function bboxPolygon(bbox, options = {}) {
    const west = Number(bbox[0]);
    const south = Number(bbox[1]);
    const east = Number(bbox[2]);
    const north = Number(bbox[3]);
    if (bbox.length === 6) {
        throw new Error("@turf/bbox-polygon does not support BBox with 6 positions");
    }
    const lowLeft = [
        west,
        south
    ];
    const topLeft = [
        west,
        north
    ];
    const topRight = [
        east,
        north
    ];
    const lowRight = [
        east,
        south
    ];
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["polygon"])([
        [
            lowLeft,
            lowRight,
            topRight,
            topLeft,
            lowLeft
        ]
    ], options.properties, {
        bbox,
        id: options.id
    });
}
var turf_bbox_polygon_default = bboxPolygon;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/bbox/dist/esm/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// index.ts
__turbopack_context__.s({
    "bbox": (()=>bbox),
    "default": (()=>turf_bbox_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turf/meta/dist/esm/index.js [client] (ecmascript)");
;
function bbox(geojson, options = {}) {
    if (geojson.bbox != null && true !== options.recompute) {
        return geojson.bbox;
    }
    const result = [
        Infinity,
        Infinity,
        -Infinity,
        -Infinity
    ];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["coordEach"])(geojson, (coord)=>{
        if (result[0] > coord[0]) {
            result[0] = coord[0];
        }
        if (result[1] > coord[1]) {
            result[1] = coord[1];
        }
        if (result[2] < coord[0]) {
            result[2] = coord[0];
        }
        if (result[3] < coord[1]) {
            result[3] = coord[1];
        }
    });
    return result;
}
var turf_bbox_default = bbox;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/boolean-point-on-line/dist/esm/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// index.ts
__turbopack_context__.s({
    "booleanPointOnLine": (()=>booleanPointOnLine),
    "default": (()=>turf_boolean_point_on_line_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turf/invariant/dist/esm/index.js [client] (ecmascript)");
;
function booleanPointOnLine(pt, line, options = {}) {
    const ptCoords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getCoord"])(pt);
    const lineCoords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getCoords"])(line);
    for(let i = 0; i < lineCoords.length - 1; i++){
        let ignoreBoundary = false;
        if (options.ignoreEndVertices) {
            if (i === 0) {
                ignoreBoundary = "start";
            }
            if (i === lineCoords.length - 2) {
                ignoreBoundary = "end";
            }
            if (i === 0 && i + 1 === lineCoords.length - 1) {
                ignoreBoundary = "both";
            }
        }
        if (isPointOnLineSegment(lineCoords[i], lineCoords[i + 1], ptCoords, ignoreBoundary, typeof options.epsilon === "undefined" ? null : options.epsilon)) {
            return true;
        }
    }
    return false;
}
function isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt, excludeBoundary, epsilon) {
    const x = pt[0];
    const y = pt[1];
    const x1 = lineSegmentStart[0];
    const y1 = lineSegmentStart[1];
    const x2 = lineSegmentEnd[0];
    const y2 = lineSegmentEnd[1];
    const dxc = pt[0] - x1;
    const dyc = pt[1] - y1;
    const dxl = x2 - x1;
    const dyl = y2 - y1;
    const cross = dxc * dyl - dyc * dxl;
    if (epsilon !== null) {
        if (Math.abs(cross) > epsilon) {
            return false;
        }
    } else if (cross !== 0) {
        return false;
    }
    if (Math.abs(dxl) === Math.abs(dyl) && Math.abs(dxl) === 0) {
        if (excludeBoundary) {
            return false;
        }
        if (pt[0] === lineSegmentStart[0] && pt[1] === lineSegmentStart[1]) {
            return true;
        } else {
            return false;
        }
    }
    if (!excludeBoundary) {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            return dxl > 0 ? x1 <= x && x <= x2 : x2 <= x && x <= x1;
        }
        return dyl > 0 ? y1 <= y && y <= y2 : y2 <= y && y <= y1;
    } else if (excludeBoundary === "start") {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            return dxl > 0 ? x1 < x && x <= x2 : x2 <= x && x < x1;
        }
        return dyl > 0 ? y1 < y && y <= y2 : y2 <= y && y < y1;
    } else if (excludeBoundary === "end") {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            return dxl > 0 ? x1 <= x && x < x2 : x2 < x && x <= x1;
        }
        return dyl > 0 ? y1 <= y && y < y2 : y2 < y && y <= y1;
    } else if (excludeBoundary === "both") {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            return dxl > 0 ? x1 < x && x < x2 : x2 < x && x < x1;
        }
        return dyl > 0 ? y1 < y && y < y2 : y2 < y && y < y1;
    }
    return false;
}
var turf_boolean_point_on_line_default = booleanPointOnLine;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/boolean-within/dist/esm/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// index.ts
__turbopack_context__.s({
    "booleanWithin": (()=>booleanWithin),
    "default": (()=>turf_boolean_within_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turf/bbox/dist/esm/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turf/boolean-point-on-line/dist/esm/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turf/invariant/dist/esm/index.js [client] (ecmascript)");
;
;
;
;
function booleanWithin(feature1, feature2) {
    var geom1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getGeom"])(feature1);
    var geom2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getGeom"])(feature2);
    var type1 = geom1.type;
    var type2 = geom2.type;
    switch(type1){
        case "Point":
            switch(type2){
                case "MultiPoint":
                    return isPointInMultiPoint(geom1, geom2);
                case "LineString":
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])(geom1, geom2, {
                        ignoreEndVertices: true
                    });
                case "Polygon":
                case "MultiPolygon":
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(geom1, geom2, {
                        ignoreBoundary: true
                    });
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "MultiPoint":
            switch(type2){
                case "MultiPoint":
                    return isMultiPointInMultiPoint(geom1, geom2);
                case "LineString":
                    return isMultiPointOnLine(geom1, geom2);
                case "Polygon":
                case "MultiPolygon":
                    return isMultiPointInPoly(geom1, geom2);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "LineString":
            switch(type2){
                case "LineString":
                    return isLineOnLine(geom1, geom2);
                case "Polygon":
                case "MultiPolygon":
                    return isLineInPoly(geom1, geom2);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "Polygon":
            switch(type2){
                case "Polygon":
                case "MultiPolygon":
                    return isPolyInPoly(geom1, geom2);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        default:
            throw new Error("feature1 " + type1 + " geometry not supported");
    }
}
function isPointInMultiPoint(point, multiPoint) {
    var i;
    var output = false;
    for(i = 0; i < multiPoint.coordinates.length; i++){
        if (compareCoords(multiPoint.coordinates[i], point.coordinates)) {
            output = true;
            break;
        }
    }
    return output;
}
function isMultiPointInMultiPoint(multiPoint1, multiPoint2) {
    for(var i = 0; i < multiPoint1.coordinates.length; i++){
        var anyMatch = false;
        for(var i2 = 0; i2 < multiPoint2.coordinates.length; i2++){
            if (compareCoords(multiPoint1.coordinates[i], multiPoint2.coordinates[i2])) {
                anyMatch = true;
            }
        }
        if (!anyMatch) {
            return false;
        }
    }
    return true;
}
function isMultiPointOnLine(multiPoint, lineString) {
    var foundInsidePoint = false;
    for(var i = 0; i < multiPoint.coordinates.length; i++){
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])(multiPoint.coordinates[i], lineString)) {
            return false;
        }
        if (!foundInsidePoint) {
            foundInsidePoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])(multiPoint.coordinates[i], lineString, {
                ignoreEndVertices: true
            });
        }
    }
    return foundInsidePoint;
}
function isMultiPointInPoly(multiPoint, polygon) {
    var output = true;
    var oneInside = false;
    var isInside = false;
    for(var i = 0; i < multiPoint.coordinates.length; i++){
        isInside = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(multiPoint.coordinates[i], polygon);
        if (!isInside) {
            output = false;
            break;
        }
        if ("TURBOPACK compile-time truthy", 1) {
            isInside = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(multiPoint.coordinates[i], polygon, {
                ignoreBoundary: true
            });
        }
    }
    return output && isInside;
}
function isLineOnLine(lineString1, lineString2) {
    for(var i = 0; i < lineString1.coordinates.length; i++){
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])(lineString1.coordinates[i], lineString2)) {
            return false;
        }
    }
    return true;
}
function isLineInPoly(linestring, polygon) {
    var polyBbox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["bbox"])(polygon);
    var lineBbox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["bbox"])(linestring);
    if (!doBBoxOverlap(polyBbox, lineBbox)) {
        return false;
    }
    var foundInsidePoint = false;
    for(var i = 0; i < linestring.coordinates.length; i++){
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(linestring.coordinates[i], polygon)) {
            return false;
        }
        if (!foundInsidePoint) {
            foundInsidePoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(linestring.coordinates[i], polygon, {
                ignoreBoundary: true
            });
        }
        if (!foundInsidePoint && i < linestring.coordinates.length - 1) {
            var midpoint = getMidpoint(linestring.coordinates[i], linestring.coordinates[i + 1]);
            foundInsidePoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(midpoint, polygon, {
                ignoreBoundary: true
            });
        }
    }
    return foundInsidePoint;
}
function isPolyInPoly(geometry1, geometry2) {
    var poly1Bbox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["bbox"])(geometry1);
    var poly2Bbox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["bbox"])(geometry2);
    if (!doBBoxOverlap(poly2Bbox, poly1Bbox)) {
        return false;
    }
    for(var i = 0; i < geometry1.coordinates[0].length; i++){
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(geometry1.coordinates[0][i], geometry2)) {
            return false;
        }
    }
    return true;
}
function doBBoxOverlap(bbox1, bbox2) {
    if (bbox1[0] > bbox2[0]) return false;
    if (bbox1[2] < bbox2[2]) return false;
    if (bbox1[1] > bbox2[1]) return false;
    if (bbox1[3] < bbox2[3]) return false;
    return true;
}
function compareCoords(pair1, pair2) {
    return pair1[0] === pair2[0] && pair1[1] === pair2[1];
}
function getMidpoint(pair1, pair2) {
    return [
        (pair1[0] + pair2[0]) / 2,
        (pair1[1] + pair2[1]) / 2
    ];
}
var turf_boolean_within_default = booleanWithin;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/intersect/dist/esm/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// index.ts
__turbopack_context__.s({
    "default": (()=>turf_intersect_default),
    "intersect": (()=>intersect)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turf/helpers/dist/esm/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turf/meta/dist/esm/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$polyclip$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/polyclip-ts/dist/esm/index.js [client] (ecmascript)");
;
;
;
function intersect(features, options = {}) {
    const geoms = [];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["geomEach"])(features, (geom)=>{
        geoms.push(geom.coordinates);
    });
    if (geoms.length < 2) {
        throw new Error("Must specify at least 2 geometries");
    }
    const intersection2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$polyclip$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["intersection"])(geoms[0], ...geoms.slice(1));
    if (intersection2.length === 0) return null;
    if (intersection2.length === 1) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["polygon"])(intersection2[0], options.properties);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["multiPolygon"])(intersection2, options.properties);
}
var turf_intersect_default = intersect;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/bbox-clip/dist/esm/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// index.ts
__turbopack_context__.s({
    "bboxClip": (()=>bboxClip),
    "default": (()=>turf_bbox_clip_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turf/helpers/dist/esm/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turf/invariant/dist/esm/index.js [client] (ecmascript)");
;
;
// lib/lineclip.ts
function lineclip(points, bbox, result) {
    var len = points.length, codeA = bitCode(points[0], bbox), part = [], i, codeB, lastCode;
    let a;
    let b;
    if (!result) result = [];
    for(i = 1; i < len; i++){
        a = points[i - 1];
        b = points[i];
        codeB = lastCode = bitCode(b, bbox);
        while(true){
            if (!(codeA | codeB)) {
                part.push(a);
                if (codeB !== lastCode) {
                    part.push(b);
                    if (i < len - 1) {
                        result.push(part);
                        part = [];
                    }
                } else if (i === len - 1) {
                    part.push(b);
                }
                break;
            } else if (codeA & codeB) {
                break;
            } else if (codeA) {
                a = intersect(a, b, codeA, bbox);
                codeA = bitCode(a, bbox);
            } else {
                b = intersect(a, b, codeB, bbox);
                codeB = bitCode(b, bbox);
            }
        }
        codeA = lastCode;
    }
    if (part.length) result.push(part);
    return result;
}
function polygonclip(points, bbox) {
    var result, edge, prev, prevInside, i, p, inside;
    for(edge = 1; edge <= 8; edge *= 2){
        result = [];
        prev = points[points.length - 1];
        prevInside = !(bitCode(prev, bbox) & edge);
        for(i = 0; i < points.length; i++){
            p = points[i];
            inside = !(bitCode(p, bbox) & edge);
            if (inside !== prevInside) result.push(intersect(prev, p, edge, bbox));
            if (inside) result.push(p);
            prev = p;
            prevInside = inside;
        }
        points = result;
        if (!points.length) break;
    }
    return result;
}
function intersect(a, b, edge, bbox) {
    return edge & 8 ? [
        a[0] + (b[0] - a[0]) * (bbox[3] - a[1]) / (b[1] - a[1]),
        bbox[3]
    ] : edge & 4 ? [
        a[0] + (b[0] - a[0]) * (bbox[1] - a[1]) / (b[1] - a[1]),
        bbox[1]
    ] : edge & 2 ? [
        bbox[2],
        a[1] + (b[1] - a[1]) * (bbox[2] - a[0]) / (b[0] - a[0])
    ] : edge & 1 ? [
        bbox[0],
        a[1] + (b[1] - a[1]) * (bbox[0] - a[0]) / (b[0] - a[0])
    ] : null;
}
function bitCode(p, bbox) {
    var code = 0;
    if (p[0] < bbox[0]) code |= 1;
    else if (p[0] > bbox[2]) code |= 2;
    if (p[1] < bbox[1]) code |= 4;
    else if (p[1] > bbox[3]) code |= 8;
    return code;
}
// index.ts
function bboxClip(feature, bbox) {
    const geom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getGeom"])(feature);
    const type = geom.type;
    const properties = feature.type === "Feature" ? feature.properties : {};
    let coords = geom.coordinates;
    switch(type){
        case "LineString":
        case "MultiLineString":
            {
                const lines = [];
                if (type === "LineString") {
                    coords = [
                        coords
                    ];
                }
                coords.forEach((line)=>{
                    lineclip(line, bbox, lines);
                });
                if (lines.length === 1) {
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["lineString"])(lines[0], properties);
                }
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["multiLineString"])(lines, properties);
            }
        case "Polygon":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["polygon"])(clipPolygon(coords, bbox), properties);
        case "MultiPolygon":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["multiPolygon"])(coords.map((poly)=>{
                return clipPolygon(poly, bbox);
            }), properties);
        default:
            throw new Error("geometry " + type + " not supported");
    }
}
function clipPolygon(rings, bbox) {
    const outRings = [];
    for (const ring of rings){
        const clipped = polygonclip(ring, bbox);
        if (clipped.length > 0) {
            if (clipped[0][0] !== clipped[clipped.length - 1][0] || clipped[0][1] !== clipped[clipped.length - 1][1]) {
                clipped.push(clipped[0]);
            }
            if (clipped.length >= 4) {
                outRings.push(clipped);
            }
        }
    }
    return outRings;
}
var turf_bbox_clip_default = bboxClip;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/union/dist/esm/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// index.ts
__turbopack_context__.s({
    "default": (()=>turf_union_default),
    "union": (()=>union2)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$polyclip$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/polyclip-ts/dist/esm/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turf/helpers/dist/esm/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turf/meta/dist/esm/index.js [client] (ecmascript)");
;
;
;
function union2(features, options = {}) {
    const geoms = [];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["geomEach"])(features, (geom)=>{
        geoms.push(geom.coordinates);
    });
    if (geoms.length < 2) {
        throw new Error("Must have at least 2 geometries");
    }
    const unioned = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$polyclip$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["union"])(geoms[0], ...geoms.slice(1));
    if (unioned.length === 0) return null;
    if (unioned.length === 1) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["polygon"])(unioned[0], options.properties);
    else return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["multiPolygon"])(unioned, options.properties);
}
var turf_union_default = union2;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/clean-coords/dist/esm/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// index.ts
__turbopack_context__.s({
    "cleanCoords": (()=>cleanCoords),
    "default": (()=>turf_clean_coords_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turf/helpers/dist/esm/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turf/invariant/dist/esm/index.js [client] (ecmascript)");
;
;
function cleanCoords(geojson, options = {}) {
    var mutate = typeof options === "object" ? options.mutate : options;
    if (!geojson) throw new Error("geojson is required");
    var type = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getType"])(geojson);
    var newCoords = [];
    switch(type){
        case "LineString":
            newCoords = cleanLine(geojson, type);
            break;
        case "MultiLineString":
        case "Polygon":
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getCoords"])(geojson).forEach(function(line) {
                newCoords.push(cleanLine(line, type));
            });
            break;
        case "MultiPolygon":
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getCoords"])(geojson).forEach(function(polygons) {
                var polyPoints = [];
                polygons.forEach(function(ring) {
                    polyPoints.push(cleanLine(ring, type));
                });
                newCoords.push(polyPoints);
            });
            break;
        case "Point":
            return geojson;
        case "MultiPoint":
            var existing = {};
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getCoords"])(geojson).forEach(function(coord) {
                var key = coord.join("-");
                if (!Object.prototype.hasOwnProperty.call(existing, key)) {
                    newCoords.push(coord);
                    existing[key] = true;
                }
            });
            break;
        default:
            throw new Error(type + " geometry not supported");
    }
    if (geojson.coordinates) {
        if (mutate === true) {
            geojson.coordinates = newCoords;
            return geojson;
        }
        return {
            type,
            coordinates: newCoords
        };
    } else {
        if (mutate === true) {
            geojson.geometry.coordinates = newCoords;
            return geojson;
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["feature"])({
            type,
            coordinates: newCoords
        }, geojson.properties, {
            bbox: geojson.bbox,
            id: geojson.id
        });
    }
}
function cleanLine(line, type) {
    var points = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getCoords"])(line);
    if (points.length === 2 && !equals(points[0], points[1])) return points;
    var newPoints = [];
    var secondToLast = points.length - 1;
    var newPointsLength = newPoints.length;
    newPoints.push(points[0]);
    for(var i = 1; i < secondToLast; i++){
        var prevAddedPoint = newPoints[newPoints.length - 1];
        if (points[i][0] === prevAddedPoint[0] && points[i][1] === prevAddedPoint[1]) continue;
        else {
            newPoints.push(points[i]);
            newPointsLength = newPoints.length;
            if (newPointsLength > 2) {
                if (isPointOnLineSegment(newPoints[newPointsLength - 3], newPoints[newPointsLength - 1], newPoints[newPointsLength - 2])) newPoints.splice(newPoints.length - 2, 1);
            }
        }
    }
    newPoints.push(points[points.length - 1]);
    newPointsLength = newPoints.length;
    if ((type === "Polygon" || type === "MultiPolygon") && equals(points[0], points[points.length - 1]) && newPointsLength < 4) {
        throw new Error("invalid polygon");
    }
    if (type === "LineString" && newPointsLength < 3) {
        return newPoints;
    }
    if (isPointOnLineSegment(newPoints[newPointsLength - 3], newPoints[newPointsLength - 1], newPoints[newPointsLength - 2])) newPoints.splice(newPoints.length - 2, 1);
    return newPoints;
}
function equals(pt1, pt2) {
    return pt1[0] === pt2[0] && pt1[1] === pt2[1];
}
function isPointOnLineSegment(start, end, point) {
    var x = point[0], y = point[1];
    var startX = start[0], startY = start[1];
    var endX = end[0], endY = end[1];
    var dxc = x - startX;
    var dyc = y - startY;
    var dxl = endX - startX;
    var dyl = endY - startY;
    var cross = dxc * dyl - dyc * dxl;
    if (cross !== 0) return false;
    else if (Math.abs(dxl) >= Math.abs(dyl)) return dxl > 0 ? startX <= x && x <= endX : endX <= x && x <= startX;
    else return dyl > 0 ? startY <= y && y <= endY : endY <= y && y <= startY;
}
var turf_clean_coords_default = cleanCoords;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/boolean-equal/dist/esm/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// index.ts
__turbopack_context__.s({
    "booleanEqual": (()=>booleanEqual),
    "default": (()=>turf_boolean_equal_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$geojson$2d$equality$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/geojson-equality-ts/dist/esm/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clean$2d$coords$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turf/clean-coords/dist/esm/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turf/invariant/dist/esm/index.js [client] (ecmascript)");
;
;
;
function booleanEqual(feature1, feature2, options = {}) {
    let precision = options.precision;
    precision = precision === void 0 || precision === null || isNaN(precision) ? 6 : precision;
    if (typeof precision !== "number" || !(precision >= 0)) {
        throw new Error("precision must be a positive number");
    }
    const type1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getGeom"])(feature1).type;
    const type2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getGeom"])(feature2).type;
    if (type1 !== type2) return false;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$geojson$2d$equality$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["geojsonEquality"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clean$2d$coords$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["cleanCoords"])(feature1), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clean$2d$coords$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["cleanCoords"])(feature2), {
        precision
    });
}
var turf_boolean_equal_default = booleanEqual;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/sweepline-intersections/dist/sweeplineIntersections.esm.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
class TinyQueue {
    constructor(data = [], compare = defaultCompare){
        this.data = data;
        this.length = this.data.length;
        this.compare = compare;
        if (this.length > 0) {
            for(let i = (this.length >> 1) - 1; i >= 0; i--)this._down(i);
        }
    }
    push(item) {
        this.data.push(item);
        this.length++;
        this._up(this.length - 1);
    }
    pop() {
        if (this.length === 0) return undefined;
        const top = this.data[0];
        const bottom = this.data.pop();
        this.length--;
        if (this.length > 0) {
            this.data[0] = bottom;
            this._down(0);
        }
        return top;
    }
    peek() {
        return this.data[0];
    }
    _up(pos) {
        const { data, compare } = this;
        const item = data[pos];
        while(pos > 0){
            const parent = pos - 1 >> 1;
            const current = data[parent];
            if (compare(item, current) >= 0) break;
            data[pos] = current;
            pos = parent;
        }
        data[pos] = item;
    }
    _down(pos) {
        const { data, compare } = this;
        const halfLength = this.length >> 1;
        const item = data[pos];
        while(pos < halfLength){
            let left = (pos << 1) + 1;
            let best = data[left];
            const right = left + 1;
            if (right < this.length && compare(data[right], best) < 0) {
                left = right;
                best = data[right];
            }
            if (compare(best, item) >= 0) break;
            data[pos] = best;
            pos = left;
        }
        data[pos] = item;
    }
}
function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}
function checkWhichEventIsLeft(e1, e2) {
    if (e1.p.x > e2.p.x) return 1;
    if (e1.p.x < e2.p.x) return -1;
    if (e1.p.y !== e2.p.y) return e1.p.y > e2.p.y ? 1 : -1;
    return 1;
}
function checkWhichSegmentHasRightEndpointFirst(seg1, seg2) {
    if (seg1.rightSweepEvent.p.x > seg2.rightSweepEvent.p.x) return 1;
    if (seg1.rightSweepEvent.p.x < seg2.rightSweepEvent.p.x) return -1;
    if (seg1.rightSweepEvent.p.y !== seg2.rightSweepEvent.p.y) return seg1.rightSweepEvent.p.y < seg2.rightSweepEvent.p.y ? 1 : -1;
    return 1;
}
class Event {
    constructor(p, featureId, ringId, eventId){
        this.p = {
            x: p[0],
            y: p[1]
        };
        this.featureId = featureId;
        this.ringId = ringId;
        this.eventId = eventId;
        this.otherEvent = null;
        this.isLeftEndpoint = null;
    }
    isSamePoint(eventToCheck) {
        return this.p.x === eventToCheck.p.x && this.p.y === eventToCheck.p.y;
    }
}
function fillEventQueue(geojson, eventQueue) {
    if (geojson.type === 'FeatureCollection') {
        const features = geojson.features;
        for(let i = 0; i < features.length; i++){
            processFeature(features[i], eventQueue);
        }
    } else {
        processFeature(geojson, eventQueue);
    }
}
let featureId = 0;
let ringId = 0;
let eventId = 0;
function processFeature(featureOrGeometry, eventQueue) {
    const geom = featureOrGeometry.type === 'Feature' ? featureOrGeometry.geometry : featureOrGeometry;
    let coords = geom.coordinates;
    // standardise the input
    if (geom.type === 'Polygon' || geom.type === 'MultiLineString') coords = [
        coords
    ];
    if (geom.type === 'LineString') coords = [
        [
            coords
        ]
    ];
    for(let i = 0; i < coords.length; i++){
        for(let ii = 0; ii < coords[i].length; ii++){
            let currentP = coords[i][ii][0];
            let nextP = null;
            ringId = ringId + 1;
            for(let iii = 0; iii < coords[i][ii].length - 1; iii++){
                nextP = coords[i][ii][iii + 1];
                const e1 = new Event(currentP, featureId, ringId, eventId);
                const e2 = new Event(nextP, featureId, ringId, eventId + 1);
                e1.otherEvent = e2;
                e2.otherEvent = e1;
                if (checkWhichEventIsLeft(e1, e2) > 0) {
                    e2.isLeftEndpoint = true;
                    e1.isLeftEndpoint = false;
                } else {
                    e1.isLeftEndpoint = true;
                    e2.isLeftEndpoint = false;
                }
                eventQueue.push(e1);
                eventQueue.push(e2);
                currentP = nextP;
                eventId = eventId + 1;
            }
        }
    }
    featureId = featureId + 1;
}
class Segment {
    constructor(event){
        this.leftSweepEvent = event;
        this.rightSweepEvent = event.otherEvent;
    }
}
function testSegmentIntersect(seg1, seg2) {
    if (seg1 === null || seg2 === null) return false;
    if (seg1.leftSweepEvent.ringId === seg2.leftSweepEvent.ringId && (seg1.rightSweepEvent.isSamePoint(seg2.leftSweepEvent) || seg1.rightSweepEvent.isSamePoint(seg2.leftSweepEvent) || seg1.rightSweepEvent.isSamePoint(seg2.rightSweepEvent) || seg1.leftSweepEvent.isSamePoint(seg2.leftSweepEvent) || seg1.leftSweepEvent.isSamePoint(seg2.rightSweepEvent))) return false;
    const x1 = seg1.leftSweepEvent.p.x;
    const y1 = seg1.leftSweepEvent.p.y;
    const x2 = seg1.rightSweepEvent.p.x;
    const y2 = seg1.rightSweepEvent.p.y;
    const x3 = seg2.leftSweepEvent.p.x;
    const y3 = seg2.leftSweepEvent.p.y;
    const x4 = seg2.rightSweepEvent.p.x;
    const y4 = seg2.rightSweepEvent.p.y;
    const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
    const numeA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
    const numeB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
    if (denom === 0) {
        if (numeA === 0 && numeB === 0) return false;
        return false;
    }
    const uA = numeA / denom;
    const uB = numeB / denom;
    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {
        const x = x1 + uA * (x2 - x1);
        const y = y1 + uA * (y2 - y1);
        return [
            x,
            y
        ];
    }
    return false;
}
// import {debugEventAndSegments, debugRemovingSegment} from './debug'
function runCheck(eventQueue, ignoreSelfIntersections) {
    ignoreSelfIntersections = ignoreSelfIntersections ? ignoreSelfIntersections : false;
    const intersectionPoints = [];
    const outQueue = new TinyQueue([], checkWhichSegmentHasRightEndpointFirst);
    while(eventQueue.length){
        const event = eventQueue.pop();
        if (event.isLeftEndpoint) {
            // debugEventAndSegments(event.p, outQueue.data)
            const segment = new Segment(event);
            for(let i = 0; i < outQueue.data.length; i++){
                const otherSeg = outQueue.data[i];
                if (ignoreSelfIntersections) {
                    if (otherSeg.leftSweepEvent.featureId === event.featureId) continue;
                }
                const intersection = testSegmentIntersect(segment, otherSeg);
                if (intersection !== false) intersectionPoints.push(intersection);
            }
            outQueue.push(segment);
        } else if (event.isLeftEndpoint === false) {
            outQueue.pop();
        // const seg = outQueue.pop()
        // debugRemovingSegment(event.p, seg)
        }
    }
    return intersectionPoints;
}
function sweeplineIntersections(geojson, ignoreSelfIntersections) {
    const eventQueue = new TinyQueue([], checkWhichEventIsLeft);
    fillEventQueue(geojson, eventQueue);
    return runCheck(eventQueue, ignoreSelfIntersections);
}
const __TURBOPACK__default__export__ = sweeplineIntersections;
}}),
"[project]/node_modules/bignumber.js/bignumber.mjs [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/*
 *      bignumber.js v9.1.2
 *      A JavaScript library for arbitrary-precision arithmetic.
 *      https://github.com/MikeMcl/bignumber.js
 *      Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
 *      MIT Licensed.
 *
 *      BigNumber.prototype methods     |  BigNumber methods
 *                                      |
 *      absoluteValue            abs    |  clone
 *      comparedTo                      |  config               set
 *      decimalPlaces            dp     |      DECIMAL_PLACES
 *      dividedBy                div    |      ROUNDING_MODE
 *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
 *      exponentiatedBy          pow    |      RANGE
 *      integerValue                    |      CRYPTO
 *      isEqualTo                eq     |      MODULO_MODE
 *      isFinite                        |      POW_PRECISION
 *      isGreaterThan            gt     |      FORMAT
 *      isGreaterThanOrEqualTo   gte    |      ALPHABET
 *      isInteger                       |  isBigNumber
 *      isLessThan               lt     |  maximum              max
 *      isLessThanOrEqualTo      lte    |  minimum              min
 *      isNaN                           |  random
 *      isNegative                      |  sum
 *      isPositive                      |
 *      isZero                          |
 *      minus                           |
 *      modulo                   mod    |
 *      multipliedBy             times  |
 *      negated                         |
 *      plus                            |
 *      precision                sd     |
 *      shiftedBy                       |
 *      squareRoot               sqrt   |
 *      toExponential                   |
 *      toFixed                         |
 *      toFormat                        |
 *      toFraction                      |
 *      toJSON                          |
 *      toNumber                        |
 *      toPrecision                     |
 *      toString                        |
 *      valueOf                         |
 *
 */ __turbopack_context__.s({
    "BigNumber": (()=>BigNumber),
    "default": (()=>__TURBOPACK__default__export__)
});
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = '[BigNumber Error] ', tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ', BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 0x1fffffffffffff, // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
POWS_TEN = [
    1,
    10,
    100,
    1e3,
    1e4,
    1e5,
    1e6,
    1e7,
    1e8,
    1e9,
    1e10,
    1e11,
    1e12,
    1e13
], SQRT_BASE = 1e7, // EDITABLE
// The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
// the arguments to toExponential, toFixed, toFormat, and toPrecision.
MAX = 1E9; // 0 to MAX_INT32
/*
 * Create and return a BigNumber constructor.
 */ function clone(configObject) {
    var div, convertBase, parseNumeric, P = BigNumber.prototype = {
        constructor: BigNumber,
        toString: null,
        valueOf: null
    }, ONE = new BigNumber(1), //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------
    // The default values below must be integers within the inclusive ranges stated.
    // The values can also be changed at run-time using BigNumber.set.
    // The maximum number of decimal places for operations involving division.
    DECIMAL_PLACES = 20, // The rounding mode used when rounding to the above decimal places, and when using
    // toExponential, toFixed, toFormat and toPrecision, and round (default value).
    // UP         0 Away from zero.
    // DOWN       1 Towards zero.
    // CEIL       2 Towards +Infinity.
    // FLOOR      3 Towards -Infinity.
    // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
    // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
    // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
    // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
    // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
    ROUNDING_MODE = 4, // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]
    // The exponent value at and beneath which toString returns exponential notation.
    // Number type: -7
    TO_EXP_NEG = -7, // The exponent value at and above which toString returns exponential notation.
    // Number type: 21
    TO_EXP_POS = 21, // RANGE : [MIN_EXP, MAX_EXP]
    // The minimum exponent value, beneath which underflow to zero occurs.
    // Number type: -324  (5e-324)
    MIN_EXP = -1e7, // The maximum exponent value, above which overflow to Infinity occurs.
    // Number type:  308  (1.7976931348623157e+308)
    // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
    MAX_EXP = 1e7, // Whether to use cryptographically-secure random number generation, if available.
    CRYPTO = false, // The modulo mode used when calculating the modulus: a mod n.
    // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
    // The remainder (r) is calculated as: r = a - n * q.
    //
    // UP        0 The remainder is positive if the dividend is negative, else is negative.
    // DOWN      1 The remainder has the same sign as the dividend.
    //             This modulo mode is commonly known as 'truncated division' and is
    //             equivalent to (a % n) in JavaScript.
    // FLOOR     3 The remainder has the same sign as the divisor (Python %).
    // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
    // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
    //             The remainder is always positive.
    //
    // The truncated division, floored division, Euclidian division and IEEE 754 remainder
    // modes are commonly used for the modulus operation.
    // Although the other rounding modes can also be used, they may not give useful results.
    MODULO_MODE = 1, // The maximum number of significant digits of the result of the exponentiatedBy operation.
    // If POW_PRECISION is 0, there will be unlimited significant digits.
    POW_PRECISION = 0, // The format specification used by the BigNumber.prototype.toFormat method.
    FORMAT = {
        prefix: '',
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ',',
        decimalSeparator: '.',
        fractionGroupSize: 0,
        fractionGroupSeparator: '\xA0',
        suffix: ''
    }, // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
    // '-', '.', whitespace, or repeated character.
    // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
    ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz', alphabetHasNormalDecimalDigits = true;
    //------------------------------------------------------------------------------------------
    // CONSTRUCTOR
    /*
   * The BigNumber constructor and exported function.
   * Create and return a new instance of a BigNumber object.
   *
   * v {number|string|BigNumber} A numeric value.
   * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
   */ function BigNumber(v, b) {
        var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
        // Enable constructor call without `new`.
        if (!(x instanceof BigNumber)) return new BigNumber(v, b);
        if (b == null) {
            if (v && v._isBigNumber === true) {
                x.s = v.s;
                if (!v.c || v.e > MAX_EXP) {
                    x.c = x.e = null;
                } else if (v.e < MIN_EXP) {
                    x.c = [
                        x.e = 0
                    ];
                } else {
                    x.e = v.e;
                    x.c = v.c.slice();
                }
                return;
            }
            if ((isNum = typeof v == 'number') && v * 0 == 0) {
                // Use `1 / n` to handle minus zero also.
                x.s = 1 / v < 0 ? (v = -v, -1) : 1;
                // Fast path for integers, where n < 2147483648 (2**31).
                if (v === ~~v) {
                    for(e = 0, i = v; i >= 10; i /= 10, e++);
                    if (e > MAX_EXP) {
                        x.c = x.e = null;
                    } else {
                        x.e = e;
                        x.c = [
                            v
                        ];
                    }
                    return;
                }
                str = String(v);
            } else {
                if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);
                x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
            }
            // Decimal point?
            if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
            // Exponential form?
            if ((i = str.search(/e/i)) > 0) {
                // Determine exponent.
                if (e < 0) e = i;
                e += +str.slice(i + 1);
                str = str.substring(0, i);
            } else if (e < 0) {
                // Integer.
                e = str.length;
            }
        } else {
            // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
            intCheck(b, 2, ALPHABET.length, 'Base');
            // Allow exponential notation to be used with base 10 argument, while
            // also rounding to DECIMAL_PLACES as with other bases.
            if (b == 10 && alphabetHasNormalDecimalDigits) {
                x = new BigNumber(v);
                return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
            }
            str = String(v);
            if (isNum = typeof v == 'number') {
                // Avoid potential interpretation of Infinity and NaN as base 44+ values.
                if (v * 0 != 0) return parseNumeric(x, str, isNum, b);
                x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
                // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
                if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
                    throw Error(tooManyDigits + v);
                }
            } else {
                x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
            alphabet = ALPHABET.slice(0, b);
            e = i = 0;
            // Check that str is a valid base b number.
            // Don't use RegExp, so alphabet can contain special characters.
            for(len = str.length; i < len; i++){
                if (alphabet.indexOf(c = str.charAt(i)) < 0) {
                    if (c == '.') {
                        // If '.' is not the first character and it has not be found before.
                        if (i > e) {
                            e = len;
                            continue;
                        }
                    } else if (!caseChanged) {
                        // Allow e.g. hexadecimal 'FF' as well as 'ff'.
                        if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                            caseChanged = true;
                            i = -1;
                            e = 0;
                            continue;
                        }
                    }
                    return parseNumeric(x, String(v), isNum, b);
                }
            }
            // Prevent later check for length on converted number.
            isNum = false;
            str = convertBase(str, b, 10, x.s);
            // Decimal point?
            if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
            else e = str.length;
        }
        // Determine leading zeros.
        for(i = 0; str.charCodeAt(i) === 48; i++);
        // Determine trailing zeros.
        for(len = str.length; str.charCodeAt(--len) === 48;);
        if (str = str.slice(i, ++len)) {
            len -= i;
            // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
            if (isNum && BigNumber.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
                throw Error(tooManyDigits + x.s * v);
            }
            // Overflow?
            if ((e = e - i - 1) > MAX_EXP) {
                // Infinity.
                x.c = x.e = null;
            // Underflow?
            } else if (e < MIN_EXP) {
                // Zero.
                x.c = [
                    x.e = 0
                ];
            } else {
                x.e = e;
                x.c = [];
                // Transform base
                // e is the base 10 exponent.
                // i is where to slice str to get the first element of the coefficient array.
                i = (e + 1) % LOG_BASE;
                if (e < 0) i += LOG_BASE; // i < 1
                if (i < len) {
                    if (i) x.c.push(+str.slice(0, i));
                    for(len -= LOG_BASE; i < len;){
                        x.c.push(+str.slice(i, i += LOG_BASE));
                    }
                    i = LOG_BASE - (str = str.slice(i)).length;
                } else {
                    i -= len;
                }
                for(; i--; str += '0');
                x.c.push(+str);
            }
        } else {
            // Zero.
            x.c = [
                x.e = 0
            ];
        }
    }
    // CONSTRUCTOR PROPERTIES
    BigNumber.clone = clone;
    BigNumber.ROUND_UP = 0;
    BigNumber.ROUND_DOWN = 1;
    BigNumber.ROUND_CEIL = 2;
    BigNumber.ROUND_FLOOR = 3;
    BigNumber.ROUND_HALF_UP = 4;
    BigNumber.ROUND_HALF_DOWN = 5;
    BigNumber.ROUND_HALF_EVEN = 6;
    BigNumber.ROUND_HALF_CEIL = 7;
    BigNumber.ROUND_HALF_FLOOR = 8;
    BigNumber.EUCLID = 9;
    /*
   * Configure infrequently-changing library-wide settings.
   *
   * Accept an object with the following optional properties (if the value of a property is
   * a number, it must be an integer within the inclusive range stated):
   *
   *   DECIMAL_PLACES   {number}           0 to MAX
   *   ROUNDING_MODE    {number}           0 to 8
   *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
   *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
   *   CRYPTO           {boolean}          true or false
   *   MODULO_MODE      {number}           0 to 9
   *   POW_PRECISION       {number}           0 to MAX
   *   ALPHABET         {string}           A string of two or more unique characters which does
   *                                       not contain '.'.
   *   FORMAT           {object}           An object with some of the following properties:
   *     prefix                 {string}
   *     groupSize              {number}
   *     secondaryGroupSize     {number}
   *     groupSeparator         {string}
   *     decimalSeparator       {string}
   *     fractionGroupSize      {number}
   *     fractionGroupSeparator {string}
   *     suffix                 {string}
   *
   * (The values assigned to the above FORMAT object properties are not checked for validity.)
   *
   * E.g.
   * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
   *
   * Ignore properties/parameters set to null or undefined, except for ALPHABET.
   *
   * Return an object with the properties current values.
   */ BigNumber.config = BigNumber.set = function(obj) {
        var p, v;
        if (obj != null) {
            if (typeof obj == 'object') {
                // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
                // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
                if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
                    v = obj[p];
                    intCheck(v, 0, MAX, p);
                    DECIMAL_PLACES = v;
                }
                // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
                // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
                if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
                    v = obj[p];
                    intCheck(v, 0, 8, p);
                    ROUNDING_MODE = v;
                }
                // EXPONENTIAL_AT {number|number[]}
                // Integer, -MAX to MAX inclusive or
                // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
                // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
                if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
                    v = obj[p];
                    if (v && v.pop) {
                        intCheck(v[0], -MAX, 0, p);
                        intCheck(v[1], 0, MAX, p);
                        TO_EXP_NEG = v[0];
                        TO_EXP_POS = v[1];
                    } else {
                        intCheck(v, -MAX, MAX, p);
                        TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                    }
                }
                // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
                // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
                // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
                if (obj.hasOwnProperty(p = 'RANGE')) {
                    v = obj[p];
                    if (v && v.pop) {
                        intCheck(v[0], -MAX, -1, p);
                        intCheck(v[1], 1, MAX, p);
                        MIN_EXP = v[0];
                        MAX_EXP = v[1];
                    } else {
                        intCheck(v, -MAX, MAX, p);
                        if (v) {
                            MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                        } else {
                            throw Error(bignumberError + p + ' cannot be zero: ' + v);
                        }
                    }
                }
                // CRYPTO {boolean} true or false.
                // '[BigNumber Error] CRYPTO not true or false: {v}'
                // '[BigNumber Error] crypto unavailable'
                if (obj.hasOwnProperty(p = 'CRYPTO')) {
                    v = obj[p];
                    if (v === !!v) {
                        if (v) {
                            if (typeof crypto != 'undefined' && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                                CRYPTO = v;
                            } else {
                                CRYPTO = !v;
                                throw Error(bignumberError + 'crypto unavailable');
                            }
                        } else {
                            CRYPTO = v;
                        }
                    } else {
                        throw Error(bignumberError + p + ' not true or false: ' + v);
                    }
                }
                // MODULO_MODE {number} Integer, 0 to 9 inclusive.
                // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
                if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
                    v = obj[p];
                    intCheck(v, 0, 9, p);
                    MODULO_MODE = v;
                }
                // POW_PRECISION {number} Integer, 0 to MAX inclusive.
                // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
                if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
                    v = obj[p];
                    intCheck(v, 0, MAX, p);
                    POW_PRECISION = v;
                }
                // FORMAT {object}
                // '[BigNumber Error] FORMAT not an object: {v}'
                if (obj.hasOwnProperty(p = 'FORMAT')) {
                    v = obj[p];
                    if (typeof v == 'object') FORMAT = v;
                    else throw Error(bignumberError + p + ' not an object: ' + v);
                }
                // ALPHABET {string}
                // '[BigNumber Error] ALPHABET invalid: {v}'
                if (obj.hasOwnProperty(p = 'ALPHABET')) {
                    v = obj[p];
                    // Disallow if less than two characters,
                    // or if it contains '+', '-', '.', whitespace, or a repeated character.
                    if (typeof v == 'string' && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                        alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';
                        ALPHABET = v;
                    } else {
                        throw Error(bignumberError + p + ' invalid: ' + v);
                    }
                }
            } else {
                // '[BigNumber Error] Object expected: {v}'
                throw Error(bignumberError + 'Object expected: ' + obj);
            }
        }
        return {
            DECIMAL_PLACES: DECIMAL_PLACES,
            ROUNDING_MODE: ROUNDING_MODE,
            EXPONENTIAL_AT: [
                TO_EXP_NEG,
                TO_EXP_POS
            ],
            RANGE: [
                MIN_EXP,
                MAX_EXP
            ],
            CRYPTO: CRYPTO,
            MODULO_MODE: MODULO_MODE,
            POW_PRECISION: POW_PRECISION,
            FORMAT: FORMAT,
            ALPHABET: ALPHABET
        };
    };
    /*
   * Return true if v is a BigNumber instance, otherwise return false.
   *
   * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
   *
   * v {any}
   *
   * '[BigNumber Error] Invalid BigNumber: {v}'
   */ BigNumber.isBigNumber = function(v) {
        if (!v || v._isBigNumber !== true) return false;
        if (!BigNumber.DEBUG) return true;
        var i, n, c = v.c, e = v.e, s = v.s;
        out: if (({}).toString.call(c) == '[object Array]') {
            if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
                // If the first element is zero, the BigNumber value must be zero.
                if (c[0] === 0) {
                    if (e === 0 && c.length === 1) return true;
                    break out;
                }
                // Calculate number of digits that c[0] should have, based on the exponent.
                i = (e + 1) % LOG_BASE;
                if (i < 1) i += LOG_BASE;
                // Calculate number of digits of c[0].
                //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
                if (String(c[0]).length == i) {
                    for(i = 0; i < c.length; i++){
                        n = c[i];
                        if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
                    }
                    // Last element cannot be zero, unless it is the only element.
                    if (n !== 0) return true;
                }
            }
        // Infinity/NaN
        } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
            return true;
        }
        throw Error(bignumberError + 'Invalid BigNumber: ' + v);
    };
    /*
   * Return a new BigNumber whose value is the maximum of the arguments.
   *
   * arguments {number|string|BigNumber}
   */ BigNumber.maximum = BigNumber.max = function() {
        return maxOrMin(arguments, -1);
    };
    /*
   * Return a new BigNumber whose value is the minimum of the arguments.
   *
   * arguments {number|string|BigNumber}
   */ BigNumber.minimum = BigNumber.min = function() {
        return maxOrMin(arguments, 1);
    };
    /*
   * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
   * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
   * zeros are produced).
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
   * '[BigNumber Error] crypto unavailable'
   */ BigNumber.random = function() {
        var pow2_53 = 0x20000000000000;
        // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
        // Check if Math.random() produces more than 32 bits of randomness.
        // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
        // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
        var random53bitInt = Math.random() * pow2_53 & 0x1fffff ? function() {
            return mathfloor(Math.random() * pow2_53);
        } : function() {
            return (Math.random() * 0x40000000 | 0) * 0x800000 + (Math.random() * 0x800000 | 0);
        };
        return function(dp) {
            var a, b, e, k, v, i = 0, c = [], rand = new BigNumber(ONE);
            if (dp == null) dp = DECIMAL_PLACES;
            else intCheck(dp, 0, MAX);
            k = mathceil(dp / LOG_BASE);
            if (CRYPTO) {
                // Browsers supporting crypto.getRandomValues.
                if (crypto.getRandomValues) {
                    a = crypto.getRandomValues(new Uint32Array(k *= 2));
                    for(; i < k;){
                        // 53 bits:
                        // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
                        // 11111 11111111 11111111 11111111 11100000 00000000 00000000
                        // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
                        //                                     11111 11111111 11111111
                        // 0x20000 is 2^21.
                        v = a[i] * 0x20000 + (a[i + 1] >>> 11);
                        // Rejection sampling:
                        // 0 <= v < 9007199254740992
                        // Probability that v >= 9e15, is
                        // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
                        if (v >= 9e15) {
                            b = crypto.getRandomValues(new Uint32Array(2));
                            a[i] = b[0];
                            a[i + 1] = b[1];
                        } else {
                            // 0 <= v <= 8999999999999999
                            // 0 <= (v % 1e14) <= 99999999999999
                            c.push(v % 1e14);
                            i += 2;
                        }
                    }
                    i = k / 2;
                // Node.js supporting crypto.randomBytes.
                } else if (crypto.randomBytes) {
                    // buffer
                    a = crypto.randomBytes(k *= 7);
                    for(; i < k;){
                        // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
                        // 0x100000000 is 2^32, 0x1000000 is 2^24
                        // 11111 11111111 11111111 11111111 11111111 11111111 11111111
                        // 0 <= v < 9007199254740992
                        v = (a[i] & 31) * 0x1000000000000 + a[i + 1] * 0x10000000000 + a[i + 2] * 0x100000000 + a[i + 3] * 0x1000000 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                        if (v >= 9e15) {
                            crypto.randomBytes(7).copy(a, i);
                        } else {
                            // 0 <= (v % 1e14) <= 99999999999999
                            c.push(v % 1e14);
                            i += 7;
                        }
                    }
                    i = k / 7;
                } else {
                    CRYPTO = false;
                    throw Error(bignumberError + 'crypto unavailable');
                }
            }
            // Use Math.random.
            if (!CRYPTO) {
                for(; i < k;){
                    v = random53bitInt();
                    if (v < 9e15) c[i++] = v % 1e14;
                }
            }
            k = c[--i];
            dp %= LOG_BASE;
            // Convert trailing digits to zeros according to dp.
            if (k && dp) {
                v = POWS_TEN[LOG_BASE - dp];
                c[i] = mathfloor(k / v) * v;
            }
            // Remove trailing elements which are zero.
            for(; c[i] === 0; c.pop(), i--);
            // Zero?
            if (i < 0) {
                c = [
                    e = 0
                ];
            } else {
                // Remove leading elements which are zero and adjust exponent accordingly.
                for(e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);
                // Count the digits of the first element of c to determine leading zeros, and...
                for(i = 1, v = c[0]; v >= 10; v /= 10, i++);
                // adjust the exponent accordingly.
                if (i < LOG_BASE) e -= LOG_BASE - i;
            }
            rand.e = e;
            rand.c = c;
            return rand;
        };
    }();
    /*
   * Return a BigNumber whose value is the sum of the arguments.
   *
   * arguments {number|string|BigNumber}
   */ BigNumber.sum = function() {
        var i = 1, args = arguments, sum = new BigNumber(args[0]);
        for(; i < args.length;)sum = sum.plus(args[i++]);
        return sum;
    };
    // PRIVATE FUNCTIONS
    // Called by BigNumber and BigNumber.prototype.toString.
    convertBase = function() {
        var decimal = '0123456789';
        /*
     * Convert string of baseIn to an array of numbers of baseOut.
     * Eg. toBaseOut('255', 10, 16) returns [15, 15].
     * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
     */ function toBaseOut(str, baseIn, baseOut, alphabet) {
            var j, arr = [
                0
            ], arrL, i = 0, len = str.length;
            for(; i < len;){
                for(arrL = arr.length; arrL--; arr[arrL] *= baseIn);
                arr[0] += alphabet.indexOf(str.charAt(i++));
                for(j = 0; j < arr.length; j++){
                    if (arr[j] > baseOut - 1) {
                        if (arr[j + 1] == null) arr[j + 1] = 0;
                        arr[j + 1] += arr[j] / baseOut | 0;
                        arr[j] %= baseOut;
                    }
                }
            }
            return arr.reverse();
        }
        // Convert a numeric string of baseIn to a numeric string of baseOut.
        // If the caller is toString, we are converting from base 10 to baseOut.
        // If the caller is BigNumber, we are converting from baseIn to base 10.
        return function(str, baseIn, baseOut, sign, callerIsToString) {
            var alphabet, d, e, k, r, x, xc, y, i = str.indexOf('.'), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
            // Non-integer.
            if (i >= 0) {
                k = POW_PRECISION;
                // Unlimited precision.
                POW_PRECISION = 0;
                str = str.replace('.', '');
                y = new BigNumber(baseIn);
                x = y.pow(str.length - i);
                POW_PRECISION = k;
                // Convert str as if an integer, then restore the fraction part by dividing the
                // result by its base raised to a power.
                y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'), 10, baseOut, decimal);
                y.e = y.c.length;
            }
            // Convert the number as integer.
            xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
            // xc now represents str as an integer and converted to baseOut. e is the exponent.
            e = k = xc.length;
            // Remove trailing zeros.
            for(; xc[--k] == 0; xc.pop());
            // Zero?
            if (!xc[0]) return alphabet.charAt(0);
            // Does str represent an integer? If so, no need for the division.
            if (i < 0) {
                --e;
            } else {
                x.c = xc;
                x.e = e;
                // The sign is needed for correct rounding.
                x.s = sign;
                x = div(x, y, dp, rm, baseOut);
                xc = x.c;
                r = x.r;
                e = x.e;
            }
            // xc now represents str converted to baseOut.
            // THe index of the rounding digit.
            d = e + dp + 1;
            // The rounding digit: the digit to the right of the digit that may be rounded up.
            i = xc[d];
            // Look at the rounding digits and mode to determine whether to round up.
            k = baseOut / 2;
            r = r || d < 0 || xc[d + 1] != null;
            r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
            // If the index of the rounding digit is not greater than zero, or xc represents
            // zero, then the result of the base conversion is zero or, if rounding up, a value
            // such as 0.00001.
            if (d < 1 || !xc[0]) {
                // 1^-dp or 0
                str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
            } else {
                // Truncate xc to the required number of decimal places.
                xc.length = d;
                // Round up?
                if (r) {
                    // Rounding up may mean the previous digit has to be rounded up and so on.
                    for(--baseOut; ++xc[--d] > baseOut;){
                        xc[d] = 0;
                        if (!d) {
                            ++e;
                            xc = [
                                1
                            ].concat(xc);
                        }
                    }
                }
                // Determine trailing zeros.
                for(k = xc.length; !xc[--k];);
                // E.g. [4, 11, 15] becomes 4bf.
                for(i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));
                // Add leading zeros, decimal point and trailing zeros as required.
                str = toFixedPoint(str, e, alphabet.charAt(0));
            }
            // The caller will add the sign.
            return str;
        };
    }();
    // Perform division in the specified base. Called by div and convertBase.
    div = function() {
        // Assume non-zero x and k.
        function multiply(x, k, base) {
            var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
            for(x = x.slice(); i--;){
                xlo = x[i] % SQRT_BASE;
                xhi = x[i] / SQRT_BASE | 0;
                m = khi * xlo + xhi * klo;
                temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
                carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
                x[i] = temp % base;
            }
            if (carry) x = [
                carry
            ].concat(x);
            return x;
        }
        function compare(a, b, aL, bL) {
            var i, cmp;
            if (aL != bL) {
                cmp = aL > bL ? 1 : -1;
            } else {
                for(i = cmp = 0; i < aL; i++){
                    if (a[i] != b[i]) {
                        cmp = a[i] > b[i] ? 1 : -1;
                        break;
                    }
                }
            }
            return cmp;
        }
        function subtract(a, b, aL, base) {
            var i = 0;
            // Subtract b from a.
            for(; aL--;){
                a[aL] -= i;
                i = a[aL] < b[aL] ? 1 : 0;
                a[aL] = i * base + a[aL] - b[aL];
            }
            // Remove leading zeros.
            for(; !a[0] && a.length > 1; a.splice(0, 1));
        }
        // x: dividend, y: divisor.
        return function(x, y, dp, rm, base) {
            var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
            // Either NaN, Infinity or 0?
            if (!xc || !xc[0] || !yc || !yc[0]) {
                return new BigNumber(// Return NaN if either NaN, or both Infinity or 0.
                !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
                xc && xc[0] == 0 || !yc ? s * 0 : s / 0);
            }
            q = new BigNumber(s);
            qc = q.c = [];
            e = x.e - y.e;
            s = dp + e + 1;
            if (!base) {
                base = BASE;
                e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
                s = s / LOG_BASE | 0;
            }
            // Result exponent may be one less then the current value of e.
            // The coefficients of the BigNumbers from convertBase may have trailing zeros.
            for(i = 0; yc[i] == (xc[i] || 0); i++);
            if (yc[i] > (xc[i] || 0)) e--;
            if (s < 0) {
                qc.push(1);
                more = true;
            } else {
                xL = xc.length;
                yL = yc.length;
                i = 0;
                s += 2;
                // Normalise xc and yc so highest order digit of yc is >= base / 2.
                n = mathfloor(base / (yc[0] + 1));
                // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
                // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
                if (n > 1) {
                    yc = multiply(yc, n, base);
                    xc = multiply(xc, n, base);
                    yL = yc.length;
                    xL = xc.length;
                }
                xi = yL;
                rem = xc.slice(0, yL);
                remL = rem.length;
                // Add zeros to make remainder as long as divisor.
                for(; remL < yL; rem[remL++] = 0);
                yz = yc.slice();
                yz = [
                    0
                ].concat(yz);
                yc0 = yc[0];
                if (yc[1] >= base / 2) yc0++;
                // Not necessary, but to prevent trial digit n > base, when using base 3.
                // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;
                do {
                    n = 0;
                    // Compare divisor and remainder.
                    cmp = compare(yc, rem, yL, remL);
                    // If divisor < remainder.
                    if (cmp < 0) {
                        // Calculate trial digit, n.
                        rem0 = rem[0];
                        if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
                        // n is how many times the divisor goes into the current remainder.
                        n = mathfloor(rem0 / yc0);
                        //  Algorithm:
                        //  product = divisor multiplied by trial digit (n).
                        //  Compare product and remainder.
                        //  If product is greater than remainder:
                        //    Subtract divisor from product, decrement trial digit.
                        //  Subtract product from remainder.
                        //  If product was less than remainder at the last compare:
                        //    Compare new remainder and divisor.
                        //    If remainder is greater than divisor:
                        //      Subtract divisor from remainder, increment trial digit.
                        if (n > 1) {
                            // n may be > base only when base is 3.
                            if (n >= base) n = base - 1;
                            // product = divisor * trial digit.
                            prod = multiply(yc, n, base);
                            prodL = prod.length;
                            remL = rem.length;
                            // Compare product and remainder.
                            // If product > remainder then trial digit n too high.
                            // n is 1 too high about 5% of the time, and is not known to have
                            // ever been more than 1 too high.
                            while(compare(prod, rem, prodL, remL) == 1){
                                n--;
                                // Subtract divisor from product.
                                subtract(prod, yL < prodL ? yz : yc, prodL, base);
                                prodL = prod.length;
                                cmp = 1;
                            }
                        } else {
                            // n is 0 or 1, cmp is -1.
                            // If n is 0, there is no need to compare yc and rem again below,
                            // so change cmp to 1 to avoid it.
                            // If n is 1, leave cmp as -1, so yc and rem are compared again.
                            if (n == 0) {
                                // divisor < remainder, so n must be at least 1.
                                cmp = n = 1;
                            }
                            // product = divisor
                            prod = yc.slice();
                            prodL = prod.length;
                        }
                        if (prodL < remL) prod = [
                            0
                        ].concat(prod);
                        // Subtract product from remainder.
                        subtract(rem, prod, remL, base);
                        remL = rem.length;
                        // If product was < remainder.
                        if (cmp == -1) {
                            // Compare divisor and new remainder.
                            // If divisor < new remainder, subtract divisor from remainder.
                            // Trial digit n too low.
                            // n is 1 too low about 5% of the time, and very rarely 2 too low.
                            while(compare(yc, rem, yL, remL) < 1){
                                n++;
                                // Subtract divisor from remainder.
                                subtract(rem, yL < remL ? yz : yc, remL, base);
                                remL = rem.length;
                            }
                        }
                    } else if (cmp === 0) {
                        n++;
                        rem = [
                            0
                        ];
                    } // else cmp === 1 and n will be 0
                    // Add the next digit, n, to the result array.
                    qc[i++] = n;
                    // Update the remainder.
                    if (rem[0]) {
                        rem[remL++] = xc[xi] || 0;
                    } else {
                        rem = [
                            xc[xi]
                        ];
                        remL = 1;
                    }
                }while ((xi++ < xL || rem[0] != null) && s--)
                more = rem[0] != null;
                // Leading zero?
                if (!qc[0]) qc.splice(0, 1);
            }
            if (base == BASE) {
                // To calculate q.e, first get the number of digits of qc[0].
                for(i = 1, s = qc[0]; s >= 10; s /= 10, i++);
                round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
            // Caller is convertBase.
            } else {
                q.e = e;
                q.r = +more;
            }
            return q;
        };
    }();
    /*
   * Return a string representing the value of BigNumber n in fixed-point or exponential
   * notation rounded to the specified decimal places or significant digits.
   *
   * n: a BigNumber.
   * i: the index of the last digit required (i.e. the digit that may be rounded up).
   * rm: the rounding mode.
   * id: 1 (toExponential) or 2 (toPrecision).
   */ function format(n, i, rm, id) {
        var c0, e, ne, len, str;
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);
        if (!n.c) return n.toString();
        c0 = n.c[0];
        ne = n.e;
        if (i == null) {
            str = coeffToString(n.c);
            str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, '0');
        } else {
            n = round(new BigNumber(n), i, rm);
            // n.e may have changed if the value was rounded up.
            e = n.e;
            str = coeffToString(n.c);
            len = str.length;
            // toPrecision returns exponential notation if the number of significant digits
            // specified is less than the number of digits necessary to represent the integer
            // part of the value in fixed-point notation.
            // Exponential notation.
            if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
                // Append zeros?
                for(; len < i; str += '0', len++);
                str = toExponential(str, e);
            // Fixed-point notation.
            } else {
                i -= ne;
                str = toFixedPoint(str, e, '0');
                // Append zeros?
                if (e + 1 > len) {
                    if (--i > 0) for(str += '.'; i--; str += '0');
                } else {
                    i += e - len;
                    if (i > 0) {
                        if (e + 1 == len) str += '.';
                        for(; i--; str += '0');
                    }
                }
            }
        }
        return n.s < 0 && c0 ? '-' + str : str;
    }
    // Handle BigNumber.max and BigNumber.min.
    // If any number is NaN, return NaN.
    function maxOrMin(args, n) {
        var k, y, i = 1, x = new BigNumber(args[0]);
        for(; i < args.length; i++){
            y = new BigNumber(args[i]);
            if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
                x = y;
            }
        }
        return x;
    }
    /*
   * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
   * Called by minus, plus and times.
   */ function normalise(n, c, e) {
        var i = 1, j = c.length;
        // Remove trailing zeros.
        for(; !c[--j]; c.pop());
        // Calculate the base 10 exponent. First get the number of digits of c[0].
        for(j = c[0]; j >= 10; j /= 10, i++);
        // Overflow?
        if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
            // Infinity.
            n.c = n.e = null;
        // Underflow?
        } else if (e < MIN_EXP) {
            // Zero.
            n.c = [
                n.e = 0
            ];
        } else {
            n.e = e;
            n.c = c;
        }
        return n;
    }
    // Handle values that fail the validity test in BigNumber.
    parseNumeric = function() {
        var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
        return function(x, str, isNum, b) {
            var base, s = isNum ? str : str.replace(whitespaceOrPlus, '');
            // No exception on ±Infinity or NaN.
            if (isInfinityOrNaN.test(s)) {
                x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
            } else {
                if (!isNum) {
                    // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
                    s = s.replace(basePrefix, function(m, p1, p2) {
                        base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
                        return !b || b == base ? p1 : m;
                    });
                    if (b) {
                        base = b;
                        // E.g. '1.' to '1', '.1' to '0.1'
                        s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
                    }
                    if (str != s) return new BigNumber(s, base);
                }
                // '[BigNumber Error] Not a number: {n}'
                // '[BigNumber Error] Not a base {b} number: {n}'
                if (BigNumber.DEBUG) {
                    throw Error(bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
                }
                // NaN
                x.s = null;
            }
            x.c = x.e = null;
        };
    }();
    /*
   * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
   * If r is truthy, it is known that there are more digits after the rounding digit.
   */ function round(x, sd, rm, r) {
        var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
        // if x is not Infinity or NaN...
        if (xc) {
            // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
            // n is a base 1e14 number, the value of the element of array x.c containing rd.
            // ni is the index of n within x.c.
            // d is the number of digits of n.
            // i is the index of rd within n including leading zeros.
            // j is the actual index of rd within n (if < 0, rd is a leading zero).
            out: {
                // Get the number of digits of the first element of xc.
                for(d = 1, k = xc[0]; k >= 10; k /= 10, d++);
                i = sd - d;
                // If the rounding digit is in the first element of xc...
                if (i < 0) {
                    i += LOG_BASE;
                    j = sd;
                    n = xc[ni = 0];
                    // Get the rounding digit at index j of n.
                    rd = mathfloor(n / pows10[d - j - 1] % 10);
                } else {
                    ni = mathceil((i + 1) / LOG_BASE);
                    if (ni >= xc.length) {
                        if (r) {
                            // Needed by sqrt.
                            for(; xc.length <= ni; xc.push(0));
                            n = rd = 0;
                            d = 1;
                            i %= LOG_BASE;
                            j = i - LOG_BASE + 1;
                        } else {
                            break out;
                        }
                    } else {
                        n = k = xc[ni];
                        // Get the number of digits of n.
                        for(d = 1; k >= 10; k /= 10, d++);
                        // Get the index of rd within n.
                        i %= LOG_BASE;
                        // Get the index of rd within n, adjusted for leading zeros.
                        // The number of leading zeros of n is given by LOG_BASE - d.
                        j = i - LOG_BASE + d;
                        // Get the rounding digit at index j of n.
                        rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
                    }
                }
                r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
                // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
                // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
                xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
                r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
                (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
                if (sd < 1 || !xc[0]) {
                    xc.length = 0;
                    if (r) {
                        // Convert sd to decimal places.
                        sd -= x.e + 1;
                        // 1, 0.1, 0.01, 0.001, 0.0001 etc.
                        xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                        x.e = -sd || 0;
                    } else {
                        // Zero.
                        xc[0] = x.e = 0;
                    }
                    return x;
                }
                // Remove excess digits.
                if (i == 0) {
                    xc.length = ni;
                    k = 1;
                    ni--;
                } else {
                    xc.length = ni + 1;
                    k = pows10[LOG_BASE - i];
                    // E.g. 56700 becomes 56000 if 7 is the rounding digit.
                    // j > 0 means i > number of leading zeros of n.
                    xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
                }
                // Round up?
                if (r) {
                    for(;;){
                        // If the digit to be rounded up is in the first element of xc...
                        if (ni == 0) {
                            // i will be the length of xc[0] before k is added.
                            for(i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                            j = xc[0] += k;
                            for(k = 1; j >= 10; j /= 10, k++);
                            // if i != k the length has increased.
                            if (i != k) {
                                x.e++;
                                if (xc[0] == BASE) xc[0] = 1;
                            }
                            break;
                        } else {
                            xc[ni] += k;
                            if (xc[ni] != BASE) break;
                            xc[ni--] = 0;
                            k = 1;
                        }
                    }
                }
                // Remove trailing zeros.
                for(i = xc.length; xc[--i] === 0; xc.pop());
            }
            // Overflow? Infinity.
            if (x.e > MAX_EXP) {
                x.c = x.e = null;
            // Underflow? Zero.
            } else if (x.e < MIN_EXP) {
                x.c = [
                    x.e = 0
                ];
            }
        }
        return x;
    }
    function valueOf(n) {
        var str, e = n.e;
        if (e === null) return n.toString();
        str = coeffToString(n.c);
        str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, '0');
        return n.s < 0 ? '-' + str : str;
    }
    // PROTOTYPE/INSTANCE METHODS
    /*
   * Return a new BigNumber whose value is the absolute value of this BigNumber.
   */ P.absoluteValue = P.abs = function() {
        var x = new BigNumber(this);
        if (x.s < 0) x.s = 1;
        return x;
    };
    /*
   * Return
   *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
   *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
   *   0 if they have the same value,
   *   or null if the value of either is NaN.
   */ P.comparedTo = function(y, b) {
        return compare(this, new BigNumber(y, b));
    };
    /*
   * If dp is undefined or null or true or false, return the number of decimal places of the
   * value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
   *
   * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
   * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
   * ROUNDING_MODE if rm is omitted.
   *
   * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
   */ P.decimalPlaces = P.dp = function(dp, rm) {
        var c, n, v, x = this;
        if (dp != null) {
            intCheck(dp, 0, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(new BigNumber(x), dp + x.e + 1, rm);
        }
        if (!(c = x.c)) return null;
        n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
        // Subtract the number of trailing zeros of the last number.
        if (v = c[v]) for(; v % 10 == 0; v /= 10, n--);
        if (n < 0) n = 0;
        return n;
    };
    /*
   *  n / 0 = I
   *  n / N = N
   *  n / I = 0
   *  0 / n = 0
   *  0 / 0 = N
   *  0 / N = N
   *  0 / I = 0
   *  N / n = N
   *  N / 0 = N
   *  N / N = N
   *  N / I = N
   *  I / n = I
   *  I / 0 = I
   *  I / N = N
   *  I / I = N
   *
   * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
   * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
   */ P.dividedBy = P.div = function(y, b) {
        return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
    };
    /*
   * Return a new BigNumber whose value is the integer part of dividing the value of this
   * BigNumber by the value of BigNumber(y, b).
   */ P.dividedToIntegerBy = P.idiv = function(y, b) {
        return div(this, new BigNumber(y, b), 0, 1);
    };
    /*
   * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
   *
   * If m is present, return the result modulo m.
   * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
   * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
   *
   * The modular power operation works efficiently when x, n, and m are integers, otherwise it
   * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
   *
   * n {number|string|BigNumber} The exponent. An integer.
   * [m] {number|string|BigNumber} The modulus.
   *
   * '[BigNumber Error] Exponent not an integer: {n}'
   */ P.exponentiatedBy = P.pow = function(n, m) {
        var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
        n = new BigNumber(n);
        // Allow NaN and ±Infinity, but not other non-integers.
        if (n.c && !n.isInteger()) {
            throw Error(bignumberError + 'Exponent not an integer: ' + valueOf(n));
        }
        if (m != null) m = new BigNumber(m);
        // Exponent of MAX_SAFE_INTEGER is 15.
        nIsBig = n.e > 14;
        // If x is NaN, ±Infinity, ±0 or ±1, or n is ±Infinity, NaN or ±0.
        if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
            // The sign of the result of pow when x is negative depends on the evenness of n.
            // If +n overflows to ±Infinity, the evenness of n would be not be known.
            y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
            return m ? y.mod(m) : y;
        }
        nIsNeg = n.s < 0;
        if (m) {
            // x % m returns NaN if abs(m) is zero, or m is NaN.
            if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);
            isModExp = !nIsNeg && x.isInteger() && m.isInteger();
            if (isModExp) x = x.mod(m);
        // Overflow to ±Infinity: >=2**1e10 or >=1.0000024**1e15.
        // Underflow to ±0: <=0.79**1e10 or <=0.9999975**1e15.
        } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
            // If x is negative and n is odd, k = -0, else k = 0.
            k = x.s < 0 && isOdd(n) ? -0 : 0;
            // If x >= 1, k = ±Infinity.
            if (x.e > -1) k = 1 / k;
            // If n is negative return ±0, else return ±Infinity.
            return new BigNumber(nIsNeg ? 1 / k : k);
        } else if (POW_PRECISION) {
            // Truncating each coefficient array to a length of k after each multiplication
            // equates to truncating significant digits to POW_PRECISION + [28, 41],
            // i.e. there will be a minimum of 28 guard digits retained.
            k = mathceil(POW_PRECISION / LOG_BASE + 2);
        }
        if (nIsBig) {
            half = new BigNumber(0.5);
            if (nIsNeg) n.s = 1;
            nIsOdd = isOdd(n);
        } else {
            i = Math.abs(+valueOf(n));
            nIsOdd = i % 2;
        }
        y = new BigNumber(ONE);
        // Performs 54 loop iterations for n of 9007199254740991.
        for(;;){
            if (nIsOdd) {
                y = y.times(x);
                if (!y.c) break;
                if (k) {
                    if (y.c.length > k) y.c.length = k;
                } else if (isModExp) {
                    y = y.mod(m); //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
                }
            }
            if (i) {
                i = mathfloor(i / 2);
                if (i === 0) break;
                nIsOdd = i % 2;
            } else {
                n = n.times(half);
                round(n, n.e + 1, 1);
                if (n.e > 14) {
                    nIsOdd = isOdd(n);
                } else {
                    i = +valueOf(n);
                    if (i === 0) break;
                    nIsOdd = i % 2;
                }
            }
            x = x.times(x);
            if (k) {
                if (x.c && x.c.length > k) x.c.length = k;
            } else if (isModExp) {
                x = x.mod(m); //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
            }
        }
        if (isModExp) return y;
        if (nIsNeg) y = ONE.div(y);
        return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
    };
    /*
   * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
   * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
   *
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
   */ P.integerValue = function(rm) {
        var n = new BigNumber(this);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);
        return round(n, n.e + 1, rm);
    };
    /*
   * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
   * otherwise return false.
   */ P.isEqualTo = P.eq = function(y, b) {
        return compare(this, new BigNumber(y, b)) === 0;
    };
    /*
   * Return true if the value of this BigNumber is a finite number, otherwise return false.
   */ P.isFinite = function() {
        return !!this.c;
    };
    /*
   * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
   * otherwise return false.
   */ P.isGreaterThan = P.gt = function(y, b) {
        return compare(this, new BigNumber(y, b)) > 0;
    };
    /*
   * Return true if the value of this BigNumber is greater than or equal to the value of
   * BigNumber(y, b), otherwise return false.
   */ P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
        return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;
    };
    /*
   * Return true if the value of this BigNumber is an integer, otherwise return false.
   */ P.isInteger = function() {
        return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
    };
    /*
   * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
   * otherwise return false.
   */ P.isLessThan = P.lt = function(y, b) {
        return compare(this, new BigNumber(y, b)) < 0;
    };
    /*
   * Return true if the value of this BigNumber is less than or equal to the value of
   * BigNumber(y, b), otherwise return false.
   */ P.isLessThanOrEqualTo = P.lte = function(y, b) {
        return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
    };
    /*
   * Return true if the value of this BigNumber is NaN, otherwise return false.
   */ P.isNaN = function() {
        return !this.s;
    };
    /*
   * Return true if the value of this BigNumber is negative, otherwise return false.
   */ P.isNegative = function() {
        return this.s < 0;
    };
    /*
   * Return true if the value of this BigNumber is positive, otherwise return false.
   */ P.isPositive = function() {
        return this.s > 0;
    };
    /*
   * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
   */ P.isZero = function() {
        return !!this.c && this.c[0] == 0;
    };
    /*
   *  n - 0 = n
   *  n - N = N
   *  n - I = -I
   *  0 - n = -n
   *  0 - 0 = 0
   *  0 - N = N
   *  0 - I = -I
   *  N - n = N
   *  N - 0 = N
   *  N - N = N
   *  N - I = N
   *  I - n = I
   *  I - 0 = I
   *  I - N = N
   *  I - I = N
   *
   * Return a new BigNumber whose value is the value of this BigNumber minus the value of
   * BigNumber(y, b).
   */ P.minus = function(y, b) {
        var i, j, t, xLTy, x = this, a = x.s;
        y = new BigNumber(y, b);
        b = y.s;
        // Either NaN?
        if (!a || !b) return new BigNumber(NaN);
        // Signs differ?
        if (a != b) {
            y.s = -b;
            return x.plus(y);
        }
        var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
        if (!xe || !ye) {
            // Either Infinity?
            if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);
            // Either zero?
            if (!xc[0] || !yc[0]) {
                // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
                return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x : // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                ROUNDING_MODE == 3 ? -0 : 0);
            }
        }
        xe = bitFloor(xe);
        ye = bitFloor(ye);
        xc = xc.slice();
        // Determine which is the bigger number.
        if (a = xe - ye) {
            if (xLTy = a < 0) {
                a = -a;
                t = xc;
            } else {
                ye = xe;
                t = yc;
            }
            t.reverse();
            // Prepend zeros to equalise exponents.
            for(b = a; b--; t.push(0));
            t.reverse();
        } else {
            // Exponents equal. Check digit by digit.
            j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
            for(a = b = 0; b < j; b++){
                if (xc[b] != yc[b]) {
                    xLTy = xc[b] < yc[b];
                    break;
                }
            }
        }
        // x < y? Point xc to the array of the bigger number.
        if (xLTy) {
            t = xc;
            xc = yc;
            yc = t;
            y.s = -y.s;
        }
        b = (j = yc.length) - (i = xc.length);
        // Append zeros to xc if shorter.
        // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
        if (b > 0) for(; b--; xc[i++] = 0);
        b = BASE - 1;
        // Subtract yc from xc.
        for(; j > a;){
            if (xc[--j] < yc[j]) {
                for(i = j; i && !xc[--i]; xc[i] = b);
                --xc[i];
                xc[j] += BASE;
            }
            xc[j] -= yc[j];
        }
        // Remove leading zeros and adjust exponent accordingly.
        for(; xc[0] == 0; xc.splice(0, 1), --ye);
        // Zero?
        if (!xc[0]) {
            // Following IEEE 754 (2008) 6.3,
            // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
            y.s = ROUNDING_MODE == 3 ? -1 : 1;
            y.c = [
                y.e = 0
            ];
            return y;
        }
        // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
        // for finite x and y.
        return normalise(y, xc, ye);
    };
    /*
   *   n % 0 =  N
   *   n % N =  N
   *   n % I =  n
   *   0 % n =  0
   *  -0 % n = -0
   *   0 % 0 =  N
   *   0 % N =  N
   *   0 % I =  0
   *   N % n =  N
   *   N % 0 =  N
   *   N % N =  N
   *   N % I =  N
   *   I % n =  N
   *   I % 0 =  N
   *   I % N =  N
   *   I % I =  N
   *
   * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
   * BigNumber(y, b). The result depends on the value of MODULO_MODE.
   */ P.modulo = P.mod = function(y, b) {
        var q, s, x = this;
        y = new BigNumber(y, b);
        // Return NaN if x is Infinity or NaN, or y is NaN or zero.
        if (!x.c || !y.s || y.c && !y.c[0]) {
            return new BigNumber(NaN);
        // Return x if y is Infinity or x is zero.
        } else if (!y.c || x.c && !x.c[0]) {
            return new BigNumber(x);
        }
        if (MODULO_MODE == 9) {
            // Euclidian division: q = sign(y) * floor(x / abs(y))
            // r = x - qy    where  0 <= r < abs(y)
            s = y.s;
            y.s = 1;
            q = div(x, y, 0, 3);
            y.s = s;
            q.s *= s;
        } else {
            q = div(x, y, 0, MODULO_MODE);
        }
        y = x.minus(q.times(y));
        // To match JavaScript %, ensure sign of zero is sign of dividend.
        if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;
        return y;
    };
    /*
   *  n * 0 = 0
   *  n * N = N
   *  n * I = I
   *  0 * n = 0
   *  0 * 0 = 0
   *  0 * N = N
   *  0 * I = N
   *  N * n = N
   *  N * 0 = N
   *  N * N = N
   *  N * I = N
   *  I * n = I
   *  I * 0 = N
   *  I * N = N
   *  I * I = I
   *
   * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
   * of BigNumber(y, b).
   */ P.multipliedBy = P.times = function(y, b) {
        var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber(y, b)).c;
        // Either NaN, ±Infinity or ±0?
        if (!xc || !yc || !xc[0] || !yc[0]) {
            // Return NaN if either is NaN, or one is 0 and the other is Infinity.
            if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
                y.c = y.e = y.s = null;
            } else {
                y.s *= x.s;
                // Return ±Infinity if either is ±Infinity.
                if (!xc || !yc) {
                    y.c = y.e = null;
                // Return ±0 if either is ±0.
                } else {
                    y.c = [
                        0
                    ];
                    y.e = 0;
                }
            }
            return y;
        }
        e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
        y.s *= x.s;
        xcL = xc.length;
        ycL = yc.length;
        // Ensure xc points to longer array and xcL to its length.
        if (xcL < ycL) {
            zc = xc;
            xc = yc;
            yc = zc;
            i = xcL;
            xcL = ycL;
            ycL = i;
        }
        // Initialise the result array with zeros.
        for(i = xcL + ycL, zc = []; i--; zc.push(0));
        base = BASE;
        sqrtBase = SQRT_BASE;
        for(i = ycL; --i >= 0;){
            c = 0;
            ylo = yc[i] % sqrtBase;
            yhi = yc[i] / sqrtBase | 0;
            for(k = xcL, j = i + k; j > i;){
                xlo = xc[--k] % sqrtBase;
                xhi = xc[k] / sqrtBase | 0;
                m = yhi * xlo + xhi * ylo;
                xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
                c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
                zc[j--] = xlo % base;
            }
            zc[j] = c;
        }
        if (c) {
            ++e;
        } else {
            zc.splice(0, 1);
        }
        return normalise(y, zc, e);
    };
    /*
   * Return a new BigNumber whose value is the value of this BigNumber negated,
   * i.e. multiplied by -1.
   */ P.negated = function() {
        var x = new BigNumber(this);
        x.s = -x.s || null;
        return x;
    };
    /*
   *  n + 0 = n
   *  n + N = N
   *  n + I = I
   *  0 + n = n
   *  0 + 0 = 0
   *  0 + N = N
   *  0 + I = I
   *  N + n = N
   *  N + 0 = N
   *  N + N = N
   *  N + I = N
   *  I + n = I
   *  I + 0 = I
   *  I + N = N
   *  I + I = I
   *
   * Return a new BigNumber whose value is the value of this BigNumber plus the value of
   * BigNumber(y, b).
   */ P.plus = function(y, b) {
        var t, x = this, a = x.s;
        y = new BigNumber(y, b);
        b = y.s;
        // Either NaN?
        if (!a || !b) return new BigNumber(NaN);
        // Signs differ?
        if (a != b) {
            y.s = -b;
            return x.minus(y);
        }
        var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
        if (!xe || !ye) {
            // Return ±Infinity if either ±Infinity.
            if (!xc || !yc) return new BigNumber(a / 0);
            // Either zero?
            // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
            if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
        }
        xe = bitFloor(xe);
        ye = bitFloor(ye);
        xc = xc.slice();
        // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
        if (a = xe - ye) {
            if (a > 0) {
                ye = xe;
                t = yc;
            } else {
                a = -a;
                t = xc;
            }
            t.reverse();
            for(; a--; t.push(0));
            t.reverse();
        }
        a = xc.length;
        b = yc.length;
        // Point xc to the longer array, and b to the shorter length.
        if (a - b < 0) {
            t = yc;
            yc = xc;
            xc = t;
            b = a;
        }
        // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
        for(a = 0; b;){
            a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
            xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
        }
        if (a) {
            xc = [
                a
            ].concat(xc);
            ++ye;
        }
        // No need to check for zero, as +x + +y != 0 && -x + -y != 0
        // ye = MAX_EXP + 1 possible
        return normalise(y, xc, ye);
    };
    /*
   * If sd is undefined or null or true or false, return the number of significant digits of
   * the value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
   * If sd is true include integer-part trailing zeros in the count.
   *
   * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
   * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
   * ROUNDING_MODE if rm is omitted.
   *
   * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
   *                     boolean: whether to count integer-part trailing zeros: true or false.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
   */ P.precision = P.sd = function(sd, rm) {
        var c, n, v, x = this;
        if (sd != null && sd !== !!sd) {
            intCheck(sd, 1, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(new BigNumber(x), sd, rm);
        }
        if (!(c = x.c)) return null;
        v = c.length - 1;
        n = v * LOG_BASE + 1;
        if (v = c[v]) {
            // Subtract the number of trailing zeros of the last element.
            for(; v % 10 == 0; v /= 10, n--);
            // Add the number of digits of the first element.
            for(v = c[0]; v >= 10; v /= 10, n++);
        }
        if (sd && x.e + 1 > n) n = x.e + 1;
        return n;
    };
    /*
   * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
   * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
   *
   * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
   */ P.shiftedBy = function(k) {
        intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
        return this.times('1e' + k);
    };
    /*
   *  sqrt(-n) =  N
   *  sqrt(N) =  N
   *  sqrt(-I) =  N
   *  sqrt(I) =  I
   *  sqrt(0) =  0
   *  sqrt(-0) = -0
   *
   * Return a new BigNumber whose value is the square root of the value of this BigNumber,
   * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
   */ P.squareRoot = P.sqrt = function() {
        var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber('0.5');
        // Negative/NaN/Infinity/zero?
        if (s !== 1 || !c || !c[0]) {
            return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
        }
        // Initial estimate.
        s = Math.sqrt(+valueOf(x));
        // Math.sqrt underflow/overflow?
        // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
        if (s == 0 || s == 1 / 0) {
            n = coeffToString(c);
            if ((n.length + e) % 2 == 0) n += '0';
            s = Math.sqrt(+n);
            e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
            if (s == 1 / 0) {
                n = '5e' + e;
            } else {
                n = s.toExponential();
                n = n.slice(0, n.indexOf('e') + 1) + e;
            }
            r = new BigNumber(n);
        } else {
            r = new BigNumber(s + '');
        }
        // Check for zero.
        // r could be zero if MIN_EXP is changed after the this value was created.
        // This would cause a division by zero (x/t) and hence Infinity below, which would cause
        // coeffToString to throw.
        if (r.c[0]) {
            e = r.e;
            s = e + dp;
            if (s < 3) s = 0;
            // Newton-Raphson iteration.
            for(;;){
                t = r;
                r = half.times(t.plus(div(x, t, dp, 1)));
                if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
                    // The exponent of r may here be one less than the final result exponent,
                    // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
                    // are indexed correctly.
                    if (r.e < e) --s;
                    n = n.slice(s - 3, s + 1);
                    // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
                    // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
                    // iteration.
                    if (n == '9999' || !rep && n == '4999') {
                        // On the first iteration only, check to see if rounding up gives the
                        // exact result as the nines may infinitely repeat.
                        if (!rep) {
                            round(t, t.e + DECIMAL_PLACES + 2, 0);
                            if (t.times(t).eq(x)) {
                                r = t;
                                break;
                            }
                        }
                        dp += 4;
                        s += 4;
                        rep = 1;
                    } else {
                        // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
                        // result. If not, then there are further digits and m will be truthy.
                        if (!+n || !+n.slice(1) && n.charAt(0) == '5') {
                            // Truncate to the first rounding digit.
                            round(r, r.e + DECIMAL_PLACES + 2, 1);
                            m = !r.times(r).eq(x);
                        }
                        break;
                    }
                }
            }
        }
        return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
    };
    /*
   * Return a string representing the value of this BigNumber in exponential notation and
   * rounded using ROUNDING_MODE to dp fixed decimal places.
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
   */ P.toExponential = function(dp, rm) {
        if (dp != null) {
            intCheck(dp, 0, MAX);
            dp++;
        }
        return format(this, dp, rm, 1);
    };
    /*
   * Return a string representing the value of this BigNumber in fixed-point notation rounding
   * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
   *
   * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
   * but e.g. (-0.00001).toFixed(0) is '-0'.
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
   */ P.toFixed = function(dp, rm) {
        if (dp != null) {
            intCheck(dp, 0, MAX);
            dp = dp + this.e + 1;
        }
        return format(this, dp, rm);
    };
    /*
   * Return a string representing the value of this BigNumber in fixed-point notation rounded
   * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
   * of the format or FORMAT object (see BigNumber.set).
   *
   * The formatting object may contain some or all of the properties shown below.
   *
   * FORMAT = {
   *   prefix: '',
   *   groupSize: 3,
   *   secondaryGroupSize: 0,
   *   groupSeparator: ',',
   *   decimalSeparator: '.',
   *   fractionGroupSize: 0,
   *   fractionGroupSeparator: '\xA0',      // non-breaking space
   *   suffix: ''
   * };
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   * [format] {object} Formatting options. See FORMAT pbject above.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
   * '[BigNumber Error] Argument not an object: {format}'
   */ P.toFormat = function(dp, rm, format) {
        var str, x = this;
        if (format == null) {
            if (dp != null && rm && typeof rm == 'object') {
                format = rm;
                rm = null;
            } else if (dp && typeof dp == 'object') {
                format = dp;
                dp = rm = null;
            } else {
                format = FORMAT;
            }
        } else if (typeof format != 'object') {
            throw Error(bignumberError + 'Argument not an object: ' + format);
        }
        str = x.toFixed(dp, rm);
        if (x.c) {
            var i, arr = str.split('.'), g1 = +format.groupSize, g2 = +format.secondaryGroupSize, groupSeparator = format.groupSeparator || '', intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
            if (g2) {
                i = g1;
                g1 = g2;
                g2 = i;
                len -= i;
            }
            if (g1 > 0 && len > 0) {
                i = len % g1 || g1;
                intPart = intDigits.substr(0, i);
                for(; i < len; i += g1)intPart += groupSeparator + intDigits.substr(i, g1);
                if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
                if (isNeg) intPart = '-' + intPart;
            }
            str = fractionPart ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize) ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'), '$&' + (format.fractionGroupSeparator || '')) : fractionPart) : intPart;
        }
        return (format.prefix || '') + str + (format.suffix || '');
    };
    /*
   * Return an array of two BigNumbers representing the value of this BigNumber as a simple
   * fraction with an integer numerator and an integer denominator.
   * The denominator will be a positive non-zero value less than or equal to the specified
   * maximum denominator. If a maximum denominator is not specified, the denominator will be
   * the lowest value necessary to represent the number exactly.
   *
   * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
   *
   * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
   */ P.toFraction = function(md) {
        var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
        if (md != null) {
            n = new BigNumber(md);
            // Throw if md is less than one or is not an integer, unless it is Infinity.
            if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
                throw Error(bignumberError + 'Argument ' + (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
            }
        }
        if (!xc) return new BigNumber(x);
        d = new BigNumber(ONE);
        n1 = d0 = new BigNumber(ONE);
        d1 = n0 = new BigNumber(ONE);
        s = coeffToString(xc);
        // Determine initial denominator.
        // d is a power of 10 and the minimum max denominator that specifies the value exactly.
        e = d.e = s.length - x.e - 1;
        d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
        md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
        exp = MAX_EXP;
        MAX_EXP = 1 / 0;
        n = new BigNumber(s);
        // n0 = d1 = 0
        n0.c[0] = 0;
        for(;;){
            q = div(n, d, 0, 1);
            d2 = d0.plus(q.times(d1));
            if (d2.comparedTo(md) == 1) break;
            d0 = d1;
            d1 = d2;
            n1 = n0.plus(q.times(d2 = n1));
            n0 = d2;
            d = n.minus(q.times(d2 = d));
            n = d2;
        }
        d2 = div(md.minus(d0), d1, 0, 1);
        n0 = n0.plus(d2.times(n1));
        d0 = d0.plus(d2.times(d1));
        n0.s = n1.s = x.s;
        e = e * 2;
        // Determine which fraction is closer to x, n0/d0 or n1/d1
        r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [
            n1,
            d1
        ] : [
            n0,
            d0
        ];
        MAX_EXP = exp;
        return r;
    };
    /*
   * Return the value of this BigNumber converted to a number primitive.
   */ P.toNumber = function() {
        return +valueOf(this);
    };
    /*
   * Return a string representing the value of this BigNumber rounded to sd significant digits
   * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
   * necessary to represent the integer part of the value in fixed-point notation, then use
   * exponential notation.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
   */ P.toPrecision = function(sd, rm) {
        if (sd != null) intCheck(sd, 1, MAX);
        return format(this, sd, rm, 2);
    };
    /*
   * Return a string representing the value of this BigNumber in base b, or base 10 if b is
   * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
   * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
   * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
   * TO_EXP_NEG, return exponential notation.
   *
   * [b] {number} Integer, 2 to ALPHABET.length inclusive.
   *
   * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
   */ P.toString = function(b) {
        var str, n = this, s = n.s, e = n.e;
        // Infinity or NaN?
        if (e === null) {
            if (s) {
                str = 'Infinity';
                if (s < 0) str = '-' + str;
            } else {
                str = 'NaN';
            }
        } else {
            if (b == null) {
                str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, '0');
            } else if (b === 10 && alphabetHasNormalDecimalDigits) {
                n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
                str = toFixedPoint(coeffToString(n.c), n.e, '0');
            } else {
                intCheck(b, 2, ALPHABET.length, 'Base');
                str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
            }
            if (s < 0 && n.c[0]) str = '-' + str;
        }
        return str;
    };
    /*
   * Return as toString, but do not accept a base argument, and include the minus sign for
   * negative zero.
   */ P.valueOf = P.toJSON = function() {
        return valueOf(this);
    };
    P._isBigNumber = true;
    P[Symbol.toStringTag] = 'BigNumber';
    // Node.js v10.12.0+
    P[Symbol.for('nodejs.util.inspect.custom')] = P.valueOf;
    if (configObject != null) BigNumber.set(configObject);
    return BigNumber;
}
// PRIVATE HELPER FUNCTIONS
// These functions don't need access to variables,
// e.g. DECIMAL_PLACES, in the scope of the `clone` function above.
function bitFloor(n) {
    var i = n | 0;
    return n > 0 || n === i ? i : i - 1;
}
// Return a coefficient array as a string of base 10 digits.
function coeffToString(a) {
    var s, z, i = 1, j = a.length, r = a[0] + '';
    for(; i < j;){
        s = a[i++] + '';
        z = LOG_BASE - s.length;
        for(; z--; s = '0' + s);
        r += s;
    }
    // Determine trailing zeros.
    for(j = r.length; r.charCodeAt(--j) === 48;);
    return r.slice(0, j + 1 || 1);
}
// Compare the value of BigNumbers x and y.
function compare(x, y) {
    var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
    // Either NaN?
    if (!i || !j) return null;
    a = xc && !xc[0];
    b = yc && !yc[0];
    // Either zero?
    if (a || b) return a ? b ? 0 : -j : i;
    // Signs differ?
    if (i != j) return i;
    a = i < 0;
    b = k == l;
    // Either Infinity?
    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;
    // Compare exponents.
    if (!b) return k > l ^ a ? 1 : -1;
    j = (k = xc.length) < (l = yc.length) ? k : l;
    // Compare digit by digit.
    for(i = 0; i < j; i++)if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;
    // Compare lengths.
    return k == l ? 0 : k > l ^ a ? 1 : -1;
}
/*
 * Check that n is a primitive number, an integer, and in range, otherwise throw.
 */ function intCheck(n, min, max, name) {
    if (n < min || n > max || n !== mathfloor(n)) {
        throw Error(bignumberError + (name || 'Argument') + (typeof n == 'number' ? n < min || n > max ? ' out of range: ' : ' not an integer: ' : ' not a primitive number: ') + String(n));
    }
}
// Assumes finite n.
function isOdd(n) {
    var k = n.c.length - 1;
    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
}
function toExponential(str, e) {
    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) + (e < 0 ? 'e' : 'e+') + e;
}
function toFixedPoint(str, e, z) {
    var len, zs;
    // Negative exponent?
    if (e < 0) {
        // Prepend zeros.
        for(zs = z + '.'; ++e; zs += z);
        str = zs + str;
    // Positive exponent
    } else {
        len = str.length;
        // Append zeros.
        if (++e > len) {
            for(zs = z, e -= len; --e; zs += z);
            str += zs;
        } else if (e < len) {
            str = str.slice(0, e) + '.' + str.slice(e);
        }
    }
    return str;
}
var BigNumber = clone();
const __TURBOPACK__default__export__ = BigNumber;
}}),
"[project]/node_modules/splaytree-ts/dist/esm/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// src/index.ts
__turbopack_context__.s({
    "SplayTreeMap": (()=>SplayTreeMap),
    "SplayTreeSet": (()=>SplayTreeSet)
});
var SplayTreeNode = class {
    key;
    left = null;
    right = null;
    constructor(key){
        this.key = key;
    }
};
var SplayTreeSetNode = class extends SplayTreeNode {
    constructor(key){
        super(key);
    }
};
var SplayTreeMapNode = class _SplayTreeMapNode extends SplayTreeNode {
    value;
    constructor(key, value){
        super(key);
        this.value = value;
    }
    replaceValue(value) {
        const node = new _SplayTreeMapNode(this.key, value);
        node.left = this.left;
        node.right = this.right;
        return node;
    }
};
var SplayTree = class {
    size = 0;
    modificationCount = 0;
    splayCount = 0;
    splay(key) {
        const root = this.root;
        if (root == null) {
            this.compare(key, key);
            return -1;
        }
        let right = null;
        let newTreeRight = null;
        let left = null;
        let newTreeLeft = null;
        let current = root;
        const compare = this.compare;
        let comp;
        while(true){
            comp = compare(current.key, key);
            if (comp > 0) {
                let currentLeft = current.left;
                if (currentLeft == null) break;
                comp = compare(currentLeft.key, key);
                if (comp > 0) {
                    current.left = currentLeft.right;
                    currentLeft.right = current;
                    current = currentLeft;
                    currentLeft = current.left;
                    if (currentLeft == null) break;
                }
                if (right == null) {
                    newTreeRight = current;
                } else {
                    right.left = current;
                }
                right = current;
                current = currentLeft;
            } else if (comp < 0) {
                let currentRight = current.right;
                if (currentRight == null) break;
                comp = compare(currentRight.key, key);
                if (comp < 0) {
                    current.right = currentRight.left;
                    currentRight.left = current;
                    current = currentRight;
                    currentRight = current.right;
                    if (currentRight == null) break;
                }
                if (left == null) {
                    newTreeLeft = current;
                } else {
                    left.right = current;
                }
                left = current;
                current = currentRight;
            } else {
                break;
            }
        }
        if (left != null) {
            left.right = current.left;
            current.left = newTreeLeft;
        }
        if (right != null) {
            right.left = current.right;
            current.right = newTreeRight;
        }
        if (this.root !== current) {
            this.root = current;
            this.splayCount++;
        }
        return comp;
    }
    splayMin(node) {
        let current = node;
        let nextLeft = current.left;
        while(nextLeft != null){
            const left = nextLeft;
            current.left = left.right;
            left.right = current;
            current = left;
            nextLeft = current.left;
        }
        return current;
    }
    splayMax(node) {
        let current = node;
        let nextRight = current.right;
        while(nextRight != null){
            const right = nextRight;
            current.right = right.left;
            right.left = current;
            current = right;
            nextRight = current.right;
        }
        return current;
    }
    _delete(key) {
        if (this.root == null) return null;
        const comp = this.splay(key);
        if (comp != 0) return null;
        let root = this.root;
        const result = root;
        const left = root.left;
        this.size--;
        if (left == null) {
            this.root = root.right;
        } else {
            const right = root.right;
            root = this.splayMax(left);
            root.right = right;
            this.root = root;
        }
        this.modificationCount++;
        return result;
    }
    addNewRoot(node, comp) {
        this.size++;
        this.modificationCount++;
        const root = this.root;
        if (root == null) {
            this.root = node;
            return;
        }
        if (comp < 0) {
            node.left = root;
            node.right = root.right;
            root.right = null;
        } else {
            node.right = root;
            node.left = root.left;
            root.left = null;
        }
        this.root = node;
    }
    _first() {
        const root = this.root;
        if (root == null) return null;
        this.root = this.splayMin(root);
        return this.root;
    }
    _last() {
        const root = this.root;
        if (root == null) return null;
        this.root = this.splayMax(root);
        return this.root;
    }
    clear() {
        this.root = null;
        this.size = 0;
        this.modificationCount++;
    }
    has(key) {
        return this.validKey(key) && this.splay(key) == 0;
    }
    defaultCompare() {
        return (a, b)=>a < b ? -1 : a > b ? 1 : 0;
    }
    wrap() {
        return {
            getRoot: ()=>{
                return this.root;
            },
            setRoot: (root)=>{
                this.root = root;
            },
            getSize: ()=>{
                return this.size;
            },
            getModificationCount: ()=>{
                return this.modificationCount;
            },
            getSplayCount: ()=>{
                return this.splayCount;
            },
            setSplayCount: (count)=>{
                this.splayCount = count;
            },
            splay: (key)=>{
                return this.splay(key);
            },
            has: (key)=>{
                return this.has(key);
            }
        };
    }
};
var SplayTreeMap = class extends SplayTree {
    root = null;
    compare;
    validKey;
    constructor(compare, isValidKey){
        super();
        this.compare = compare ?? this.defaultCompare();
        this.validKey = isValidKey ?? ((a)=>a != null && a != void 0);
    }
    delete(key) {
        if (!this.validKey(key)) return false;
        return this._delete(key) != null;
    }
    forEach(f) {
        const nodes = new SplayTreeMapEntryIterableIterator(this.wrap());
        let result;
        while(result = nodes.next(), !result.done){
            f(result.value[1], result.value[0], this);
        }
    }
    get(key) {
        if (!this.validKey(key)) return void 0;
        if (this.root != null) {
            const comp = this.splay(key);
            if (comp == 0) {
                return this.root.value;
            }
        }
        return void 0;
    }
    hasValue(value) {
        const initialSplayCount = this.splayCount;
        const visit = (node)=>{
            while(node != null){
                if (node.value == value) return true;
                if (initialSplayCount != this.splayCount) {
                    throw "Concurrent modification during iteration.";
                }
                if (node.right != null && visit(node.right)) {
                    return true;
                }
                node = node.left;
            }
            return false;
        };
        return visit(this.root);
    }
    set(key, value) {
        const comp = this.splay(key);
        if (comp == 0) {
            this.root = this.root.replaceValue(value);
            this.splayCount += 1;
            return this;
        }
        this.addNewRoot(new SplayTreeMapNode(key, value), comp);
        return this;
    }
    setAll(other) {
        other.forEach((value, key)=>{
            this.set(key, value);
        });
    }
    setIfAbsent(key, ifAbsent) {
        let comp = this.splay(key);
        if (comp == 0) {
            return this.root.value;
        }
        const modificationCount = this.modificationCount;
        const splayCount = this.splayCount;
        const value = ifAbsent();
        if (modificationCount != this.modificationCount) {
            throw "Concurrent modification during iteration.";
        }
        if (splayCount != this.splayCount) {
            comp = this.splay(key);
        }
        this.addNewRoot(new SplayTreeMapNode(key, value), comp);
        return value;
    }
    isEmpty() {
        return this.root == null;
    }
    isNotEmpty() {
        return !this.isEmpty();
    }
    firstKey() {
        if (this.root == null) return null;
        return this._first().key;
    }
    lastKey() {
        if (this.root == null) return null;
        return this._last().key;
    }
    lastKeyBefore(key) {
        if (key == null) throw "Invalid arguments(s)";
        if (this.root == null) return null;
        const comp = this.splay(key);
        if (comp < 0) return this.root.key;
        let node = this.root.left;
        if (node == null) return null;
        let nodeRight = node.right;
        while(nodeRight != null){
            node = nodeRight;
            nodeRight = node.right;
        }
        return node.key;
    }
    firstKeyAfter(key) {
        if (key == null) throw "Invalid arguments(s)";
        if (this.root == null) return null;
        const comp = this.splay(key);
        if (comp > 0) return this.root.key;
        let node = this.root.right;
        if (node == null) return null;
        let nodeLeft = node.left;
        while(nodeLeft != null){
            node = nodeLeft;
            nodeLeft = node.left;
        }
        return node.key;
    }
    update(key, update, ifAbsent) {
        let comp = this.splay(key);
        if (comp == 0) {
            const modificationCount = this.modificationCount;
            const splayCount = this.splayCount;
            const newValue = update(this.root.value);
            if (modificationCount != this.modificationCount) {
                throw "Concurrent modification during iteration.";
            }
            if (splayCount != this.splayCount) {
                this.splay(key);
            }
            this.root = this.root.replaceValue(newValue);
            this.splayCount += 1;
            return newValue;
        }
        if (ifAbsent != null) {
            const modificationCount = this.modificationCount;
            const splayCount = this.splayCount;
            const newValue = ifAbsent();
            if (modificationCount != this.modificationCount) {
                throw "Concurrent modification during iteration.";
            }
            if (splayCount != this.splayCount) {
                comp = this.splay(key);
            }
            this.addNewRoot(new SplayTreeMapNode(key, newValue), comp);
            return newValue;
        }
        throw "Invalid argument (key): Key not in map.";
    }
    updateAll(update) {
        const root = this.root;
        if (root == null) return;
        const iterator = new SplayTreeMapEntryIterableIterator(this.wrap());
        let node;
        while(node = iterator.next(), !node.done){
            const newValue = update(...node.value);
            iterator.replaceValue(newValue);
        }
    }
    keys() {
        return new SplayTreeKeyIterableIterator(this.wrap());
    }
    values() {
        return new SplayTreeValueIterableIterator(this.wrap());
    }
    entries() {
        return this[Symbol.iterator]();
    }
    [Symbol.iterator]() {
        return new SplayTreeMapEntryIterableIterator(this.wrap());
    }
    [Symbol.toStringTag] = "[object Map]";
};
var SplayTreeSet = class _SplayTreeSet extends SplayTree {
    root = null;
    compare;
    validKey;
    constructor(compare, isValidKey){
        super();
        this.compare = compare ?? this.defaultCompare();
        this.validKey = isValidKey ?? ((v)=>v != null && v != void 0);
    }
    delete(element) {
        if (!this.validKey(element)) return false;
        return this._delete(element) != null;
    }
    deleteAll(elements) {
        for (const element of elements){
            this.delete(element);
        }
    }
    forEach(f) {
        const nodes = this[Symbol.iterator]();
        let result;
        while(result = nodes.next(), !result.done){
            f(result.value, result.value, this);
        }
    }
    add(element) {
        const compare = this.splay(element);
        if (compare != 0) this.addNewRoot(new SplayTreeSetNode(element), compare);
        return this;
    }
    addAndReturn(element) {
        const compare = this.splay(element);
        if (compare != 0) this.addNewRoot(new SplayTreeSetNode(element), compare);
        return this.root.key;
    }
    addAll(elements) {
        for (const element of elements){
            this.add(element);
        }
    }
    isEmpty() {
        return this.root == null;
    }
    isNotEmpty() {
        return this.root != null;
    }
    single() {
        if (this.size == 0) throw "Bad state: No element";
        if (this.size > 1) throw "Bad state: Too many element";
        return this.root.key;
    }
    first() {
        if (this.size == 0) throw "Bad state: No element";
        return this._first().key;
    }
    last() {
        if (this.size == 0) throw "Bad state: No element";
        return this._last().key;
    }
    lastBefore(element) {
        if (element == null) throw "Invalid arguments(s)";
        if (this.root == null) return null;
        const comp = this.splay(element);
        if (comp < 0) return this.root.key;
        let node = this.root.left;
        if (node == null) return null;
        let nodeRight = node.right;
        while(nodeRight != null){
            node = nodeRight;
            nodeRight = node.right;
        }
        return node.key;
    }
    firstAfter(element) {
        if (element == null) throw "Invalid arguments(s)";
        if (this.root == null) return null;
        const comp = this.splay(element);
        if (comp > 0) return this.root.key;
        let node = this.root.right;
        if (node == null) return null;
        let nodeLeft = node.left;
        while(nodeLeft != null){
            node = nodeLeft;
            nodeLeft = node.left;
        }
        return node.key;
    }
    retainAll(elements) {
        const retainSet = new _SplayTreeSet(this.compare, this.validKey);
        const modificationCount = this.modificationCount;
        for (const object of elements){
            if (modificationCount != this.modificationCount) {
                throw "Concurrent modification during iteration.";
            }
            if (this.validKey(object) && this.splay(object) == 0) {
                retainSet.add(this.root.key);
            }
        }
        if (retainSet.size != this.size) {
            this.root = retainSet.root;
            this.size = retainSet.size;
            this.modificationCount++;
        }
    }
    lookup(object) {
        if (!this.validKey(object)) return null;
        const comp = this.splay(object);
        if (comp != 0) return null;
        return this.root.key;
    }
    intersection(other) {
        const result = new _SplayTreeSet(this.compare, this.validKey);
        for (const element of this){
            if (other.has(element)) result.add(element);
        }
        return result;
    }
    difference(other) {
        const result = new _SplayTreeSet(this.compare, this.validKey);
        for (const element of this){
            if (!other.has(element)) result.add(element);
        }
        return result;
    }
    union(other) {
        const u = this.clone();
        u.addAll(other);
        return u;
    }
    clone() {
        const set = new _SplayTreeSet(this.compare, this.validKey);
        set.size = this.size;
        set.root = this.copyNode(this.root);
        return set;
    }
    copyNode(node) {
        if (node == null) return null;
        function copyChildren(node2, dest) {
            let left;
            let right;
            do {
                left = node2.left;
                right = node2.right;
                if (left != null) {
                    const newLeft = new SplayTreeSetNode(left.key);
                    dest.left = newLeft;
                    copyChildren(left, newLeft);
                }
                if (right != null) {
                    const newRight = new SplayTreeSetNode(right.key);
                    dest.right = newRight;
                    node2 = right;
                    dest = newRight;
                }
            }while (right != null)
        }
        const result = new SplayTreeSetNode(node.key);
        copyChildren(node, result);
        return result;
    }
    toSet() {
        return this.clone();
    }
    entries() {
        return new SplayTreeSetEntryIterableIterator(this.wrap());
    }
    keys() {
        return this[Symbol.iterator]();
    }
    values() {
        return this[Symbol.iterator]();
    }
    [Symbol.iterator]() {
        return new SplayTreeKeyIterableIterator(this.wrap());
    }
    [Symbol.toStringTag] = "[object Set]";
};
var SplayTreeIterableIterator = class {
    tree;
    path = new Array();
    modificationCount = null;
    splayCount;
    constructor(tree){
        this.tree = tree;
        this.splayCount = tree.getSplayCount();
    }
    [Symbol.iterator]() {
        return this;
    }
    next() {
        if (this.moveNext()) return {
            done: false,
            value: this.current()
        };
        return {
            done: true,
            value: null
        };
    }
    current() {
        if (!this.path.length) return null;
        const node = this.path[this.path.length - 1];
        return this.getValue(node);
    }
    rebuildPath(key) {
        this.path.splice(0, this.path.length);
        this.tree.splay(key);
        this.path.push(this.tree.getRoot());
        this.splayCount = this.tree.getSplayCount();
    }
    findLeftMostDescendent(node) {
        while(node != null){
            this.path.push(node);
            node = node.left;
        }
    }
    moveNext() {
        if (this.modificationCount != this.tree.getModificationCount()) {
            if (this.modificationCount == null) {
                this.modificationCount = this.tree.getModificationCount();
                let node2 = this.tree.getRoot();
                while(node2 != null){
                    this.path.push(node2);
                    node2 = node2.left;
                }
                return this.path.length > 0;
            }
            throw "Concurrent modification during iteration.";
        }
        if (!this.path.length) return false;
        if (this.splayCount != this.tree.getSplayCount()) {
            this.rebuildPath(this.path[this.path.length - 1].key);
        }
        let node = this.path[this.path.length - 1];
        let next = node.right;
        if (next != null) {
            while(next != null){
                this.path.push(next);
                next = next.left;
            }
            return true;
        }
        this.path.pop();
        while(this.path.length && this.path[this.path.length - 1].right === node){
            node = this.path.pop();
        }
        return this.path.length > 0;
    }
};
var SplayTreeKeyIterableIterator = class extends SplayTreeIterableIterator {
    getValue(node) {
        return node.key;
    }
};
var SplayTreeSetEntryIterableIterator = class extends SplayTreeIterableIterator {
    getValue(node) {
        return [
            node.key,
            node.key
        ];
    }
};
var SplayTreeValueIterableIterator = class extends SplayTreeIterableIterator {
    constructor(map){
        super(map);
    }
    getValue(node) {
        return node.value;
    }
};
var SplayTreeMapEntryIterableIterator = class extends SplayTreeIterableIterator {
    constructor(map){
        super(map);
    }
    getValue(node) {
        return [
            node.key,
            node.value
        ];
    }
    replaceValue(value) {
        if (this.modificationCount != this.tree.getModificationCount()) {
            throw "Concurrent modification during iteration.";
        }
        if (this.splayCount != this.tree.getSplayCount()) {
            this.rebuildPath(this.path[this.path.length - 1].key);
        }
        const last = this.path.pop();
        const newLast = last.replaceValue(value);
        if (!this.path.length) {
            this.tree.setRoot(newLast);
        } else {
            const parent = this.path[this.path.length - 1];
            if (last === parent.left) {
                parent.left = newLast;
            } else {
                parent.right = newLast;
            }
        }
        this.path.push(newLast);
        const count = this.tree.getSplayCount() + 1;
        this.tree.setSplayCount(count);
        this.splayCount = count;
    }
};
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/polyclip-ts/dist/esm/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// src/geom-in.ts
__turbopack_context__.s({
    "difference": (()=>difference),
    "intersection": (()=>intersection2),
    "setPrecision": (()=>setPrecision),
    "union": (()=>union),
    "xor": (()=>xor)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/bignumber.js/bignumber.mjs [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$splaytree$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/splaytree-ts/dist/esm/index.js [client] (ecmascript)");
;
// src/constant.ts
var constant_default = (x)=>{
    return ()=>{
        return x;
    };
};
// src/compare.ts
var compare_default = (eps)=>{
    const almostEqual = eps ? (a, b)=>b.minus(a).abs().isLessThanOrEqualTo(eps) : constant_default(false);
    return (a, b)=>{
        if (almostEqual(a, b)) return 0;
        return a.comparedTo(b);
    };
};
// src/orient.ts
function orient_default(eps) {
    const almostCollinear = eps ? (area2, ax, ay, cx, cy)=>area2.exponentiatedBy(2).isLessThanOrEqualTo(cx.minus(ax).exponentiatedBy(2).plus(cy.minus(ay).exponentiatedBy(2)).times(eps)) : constant_default(false);
    return (a, b, c)=>{
        const ax = a.x, ay = a.y, cx = c.x, cy = c.y;
        const area2 = ay.minus(cy).times(b.x.minus(cx)).minus(ax.minus(cx).times(b.y.minus(cy)));
        if (almostCollinear(area2, ax, ay, cx, cy)) return 0;
        return area2.comparedTo(0);
    };
}
;
;
// src/identity.ts
var identity_default = (x)=>{
    return x;
};
// src/snap.ts
var snap_default = (eps)=>{
    if (eps) {
        const xTree = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$splaytree$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["SplayTreeSet"](compare_default(eps));
        const yTree = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$splaytree$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["SplayTreeSet"](compare_default(eps));
        const snapCoord = (coord, tree)=>{
            return tree.addAndReturn(coord);
        };
        const snap = (v)=>{
            return {
                x: snapCoord(v.x, xTree),
                y: snapCoord(v.y, yTree)
            };
        };
        snap({
            x: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["default"](0),
            y: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["default"](0)
        });
        return snap;
    }
    return identity_default;
};
// src/precision.ts
var set = (eps)=>{
    return {
        set: (eps2)=>{
            precision = set(eps2);
        },
        reset: ()=>set(eps),
        compare: compare_default(eps),
        snap: snap_default(eps),
        orient: orient_default(eps)
    };
};
var precision = set();
// src/bbox.ts
var isInBbox = (bbox, point)=>{
    return bbox.ll.x.isLessThanOrEqualTo(point.x) && point.x.isLessThanOrEqualTo(bbox.ur.x) && bbox.ll.y.isLessThanOrEqualTo(point.y) && point.y.isLessThanOrEqualTo(bbox.ur.y);
};
var getBboxOverlap = (b1, b2)=>{
    if (b2.ur.x.isLessThan(b1.ll.x) || b1.ur.x.isLessThan(b2.ll.x) || b2.ur.y.isLessThan(b1.ll.y) || b1.ur.y.isLessThan(b2.ll.y)) return null;
    const lowerX = b1.ll.x.isLessThan(b2.ll.x) ? b2.ll.x : b1.ll.x;
    const upperX = b1.ur.x.isLessThan(b2.ur.x) ? b1.ur.x : b2.ur.x;
    const lowerY = b1.ll.y.isLessThan(b2.ll.y) ? b2.ll.y : b1.ll.y;
    const upperY = b1.ur.y.isLessThan(b2.ur.y) ? b1.ur.y : b2.ur.y;
    return {
        ll: {
            x: lowerX,
            y: lowerY
        },
        ur: {
            x: upperX,
            y: upperY
        }
    };
};
;
// src/vector.ts
var crossProduct = (a, b)=>a.x.times(b.y).minus(a.y.times(b.x));
var dotProduct = (a, b)=>a.x.times(b.x).plus(a.y.times(b.y));
var length = (v)=>dotProduct(v, v).sqrt();
var sineOfAngle = (pShared, pBase, pAngle)=>{
    const vBase = {
        x: pBase.x.minus(pShared.x),
        y: pBase.y.minus(pShared.y)
    };
    const vAngle = {
        x: pAngle.x.minus(pShared.x),
        y: pAngle.y.minus(pShared.y)
    };
    return crossProduct(vAngle, vBase).div(length(vAngle)).div(length(vBase));
};
var cosineOfAngle = (pShared, pBase, pAngle)=>{
    const vBase = {
        x: pBase.x.minus(pShared.x),
        y: pBase.y.minus(pShared.y)
    };
    const vAngle = {
        x: pAngle.x.minus(pShared.x),
        y: pAngle.y.minus(pShared.y)
    };
    return dotProduct(vAngle, vBase).div(length(vAngle)).div(length(vBase));
};
var horizontalIntersection = (pt, v, y)=>{
    if (v.y.isZero()) return null;
    return {
        x: pt.x.plus(v.x.div(v.y).times(y.minus(pt.y))),
        y
    };
};
var verticalIntersection = (pt, v, x)=>{
    if (v.x.isZero()) return null;
    return {
        x,
        y: pt.y.plus(v.y.div(v.x).times(x.minus(pt.x)))
    };
};
var intersection = (pt1, v1, pt2, v2)=>{
    if (v1.x.isZero()) return verticalIntersection(pt2, v2, pt1.x);
    if (v2.x.isZero()) return verticalIntersection(pt1, v1, pt2.x);
    if (v1.y.isZero()) return horizontalIntersection(pt2, v2, pt1.y);
    if (v2.y.isZero()) return horizontalIntersection(pt1, v1, pt2.y);
    const kross = crossProduct(v1, v2);
    if (kross.isZero()) return null;
    const ve = {
        x: pt2.x.minus(pt1.x),
        y: pt2.y.minus(pt1.y)
    };
    const d1 = crossProduct(ve, v1).div(kross);
    const d2 = crossProduct(ve, v2).div(kross);
    const x1 = pt1.x.plus(d2.times(v1.x)), x2 = pt2.x.plus(d1.times(v2.x));
    const y1 = pt1.y.plus(d2.times(v1.y)), y2 = pt2.y.plus(d1.times(v2.y));
    const x = x1.plus(x2).div(2);
    const y = y1.plus(y2).div(2);
    return {
        x,
        y
    };
};
// src/sweep-event.ts
var SweepEvent = class _SweepEvent {
    point;
    isLeft;
    segment;
    otherSE;
    consumedBy;
    // for ordering sweep events in the sweep event queue
    static compare(a, b) {
        const ptCmp = _SweepEvent.comparePoints(a.point, b.point);
        if (ptCmp !== 0) return ptCmp;
        if (a.point !== b.point) a.link(b);
        if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1;
        return Segment.compare(a.segment, b.segment);
    }
    // for ordering points in sweep line order
    static comparePoints(aPt, bPt) {
        if (aPt.x.isLessThan(bPt.x)) return -1;
        if (aPt.x.isGreaterThan(bPt.x)) return 1;
        if (aPt.y.isLessThan(bPt.y)) return -1;
        if (aPt.y.isGreaterThan(bPt.y)) return 1;
        return 0;
    }
    // Warning: 'point' input will be modified and re-used (for performance)
    constructor(point, isLeft){
        if (point.events === void 0) point.events = [
            this
        ];
        else point.events.push(this);
        this.point = point;
        this.isLeft = isLeft;
    }
    link(other) {
        if (other.point === this.point) {
            throw new Error("Tried to link already linked events");
        }
        const otherEvents = other.point.events;
        for(let i = 0, iMax = otherEvents.length; i < iMax; i++){
            const evt = otherEvents[i];
            this.point.events.push(evt);
            evt.point = this.point;
        }
        this.checkForConsuming();
    }
    /* Do a pass over our linked events and check to see if any pair
   * of segments match, and should be consumed. */ checkForConsuming() {
        const numEvents = this.point.events.length;
        for(let i = 0; i < numEvents; i++){
            const evt1 = this.point.events[i];
            if (evt1.segment.consumedBy !== void 0) continue;
            for(let j = i + 1; j < numEvents; j++){
                const evt2 = this.point.events[j];
                if (evt2.consumedBy !== void 0) continue;
                if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue;
                evt1.segment.consume(evt2.segment);
            }
        }
    }
    getAvailableLinkedEvents() {
        const events = [];
        for(let i = 0, iMax = this.point.events.length; i < iMax; i++){
            const evt = this.point.events[i];
            if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {
                events.push(evt);
            }
        }
        return events;
    }
    /**
   * Returns a comparator function for sorting linked events that will
   * favor the event that will give us the smallest left-side angle.
   * All ring construction starts as low as possible heading to the right,
   * so by always turning left as sharp as possible we'll get polygons
   * without uncessary loops & holes.
   *
   * The comparator function has a compute cache such that it avoids
   * re-computing already-computed values.
   */ getLeftmostComparator(baseEvent) {
        const cache = /* @__PURE__ */ new Map();
        const fillCache = (linkedEvent)=>{
            const nextEvent = linkedEvent.otherSE;
            cache.set(linkedEvent, {
                sine: sineOfAngle(this.point, baseEvent.point, nextEvent.point),
                cosine: cosineOfAngle(this.point, baseEvent.point, nextEvent.point)
            });
        };
        return (a, b)=>{
            if (!cache.has(a)) fillCache(a);
            if (!cache.has(b)) fillCache(b);
            const { sine: asine, cosine: acosine } = cache.get(a);
            const { sine: bsine, cosine: bcosine } = cache.get(b);
            if (asine.isGreaterThanOrEqualTo(0) && bsine.isGreaterThanOrEqualTo(0)) {
                if (acosine.isLessThan(bcosine)) return 1;
                if (acosine.isGreaterThan(bcosine)) return -1;
                return 0;
            }
            if (asine.isLessThan(0) && bsine.isLessThan(0)) {
                if (acosine.isLessThan(bcosine)) return -1;
                if (acosine.isGreaterThan(bcosine)) return 1;
                return 0;
            }
            if (bsine.isLessThan(asine)) return -1;
            if (bsine.isGreaterThan(asine)) return 1;
            return 0;
        };
    }
};
// src/geom-out.ts
var RingOut = class _RingOut {
    events;
    poly;
    _isExteriorRing;
    _enclosingRing;
    /* Given the segments from the sweep line pass, compute & return a series
   * of closed rings from all the segments marked to be part of the result */ static factory(allSegments) {
        const ringsOut = [];
        for(let i = 0, iMax = allSegments.length; i < iMax; i++){
            const segment = allSegments[i];
            if (!segment.isInResult() || segment.ringOut) continue;
            let prevEvent = null;
            let event = segment.leftSE;
            let nextEvent = segment.rightSE;
            const events = [
                event
            ];
            const startingPoint = event.point;
            const intersectionLEs = [];
            while(true){
                prevEvent = event;
                event = nextEvent;
                events.push(event);
                if (event.point === startingPoint) break;
                while(true){
                    const availableLEs = event.getAvailableLinkedEvents();
                    if (availableLEs.length === 0) {
                        const firstPt = events[0].point;
                        const lastPt = events[events.length - 1].point;
                        throw new Error(`Unable to complete output ring starting at [${firstPt.x}, ${firstPt.y}]. Last matching segment found ends at [${lastPt.x}, ${lastPt.y}].`);
                    }
                    if (availableLEs.length === 1) {
                        nextEvent = availableLEs[0].otherSE;
                        break;
                    }
                    let indexLE = null;
                    for(let j = 0, jMax = intersectionLEs.length; j < jMax; j++){
                        if (intersectionLEs[j].point === event.point) {
                            indexLE = j;
                            break;
                        }
                    }
                    if (indexLE !== null) {
                        const intersectionLE = intersectionLEs.splice(indexLE)[0];
                        const ringEvents = events.splice(intersectionLE.index);
                        ringEvents.unshift(ringEvents[0].otherSE);
                        ringsOut.push(new _RingOut(ringEvents.reverse()));
                        continue;
                    }
                    intersectionLEs.push({
                        index: events.length,
                        point: event.point
                    });
                    const comparator = event.getLeftmostComparator(prevEvent);
                    nextEvent = availableLEs.sort(comparator)[0].otherSE;
                    break;
                }
            }
            ringsOut.push(new _RingOut(events));
        }
        return ringsOut;
    }
    constructor(events){
        this.events = events;
        for(let i = 0, iMax = events.length; i < iMax; i++){
            events[i].segment.ringOut = this;
        }
        this.poly = null;
    }
    getGeom() {
        let prevPt = this.events[0].point;
        const points = [
            prevPt
        ];
        for(let i = 1, iMax = this.events.length - 1; i < iMax; i++){
            const pt2 = this.events[i].point;
            const nextPt2 = this.events[i + 1].point;
            if (precision.orient(pt2, prevPt, nextPt2) === 0) continue;
            points.push(pt2);
            prevPt = pt2;
        }
        if (points.length === 1) return null;
        const pt = points[0];
        const nextPt = points[1];
        if (precision.orient(pt, prevPt, nextPt) === 0) points.shift();
        points.push(points[0]);
        const step = this.isExteriorRing() ? 1 : -1;
        const iStart = this.isExteriorRing() ? 0 : points.length - 1;
        const iEnd = this.isExteriorRing() ? points.length : -1;
        const orderedPoints = [];
        for(let i = iStart; i != iEnd; i += step)orderedPoints.push([
            points[i].x.toNumber(),
            points[i].y.toNumber()
        ]);
        return orderedPoints;
    }
    isExteriorRing() {
        if (this._isExteriorRing === void 0) {
            const enclosing = this.enclosingRing();
            this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;
        }
        return this._isExteriorRing;
    }
    enclosingRing() {
        if (this._enclosingRing === void 0) {
            this._enclosingRing = this._calcEnclosingRing();
        }
        return this._enclosingRing;
    }
    /* Returns the ring that encloses this one, if any */ _calcEnclosingRing() {
        let leftMostEvt = this.events[0];
        for(let i = 1, iMax = this.events.length; i < iMax; i++){
            const evt = this.events[i];
            if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt;
        }
        let prevSeg = leftMostEvt.segment.prevInResult();
        let prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
        while(true){
            if (!prevSeg) return null;
            if (!prevPrevSeg) return prevSeg.ringOut;
            if (prevPrevSeg.ringOut !== prevSeg.ringOut) {
                if (prevPrevSeg.ringOut?.enclosingRing() !== prevSeg.ringOut) {
                    return prevSeg.ringOut;
                } else return prevSeg.ringOut?.enclosingRing();
            }
            prevSeg = prevPrevSeg.prevInResult();
            prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
        }
    }
};
var PolyOut = class {
    exteriorRing;
    interiorRings;
    constructor(exteriorRing){
        this.exteriorRing = exteriorRing;
        exteriorRing.poly = this;
        this.interiorRings = [];
    }
    addInterior(ring) {
        this.interiorRings.push(ring);
        ring.poly = this;
    }
    getGeom() {
        const geom0 = this.exteriorRing.getGeom();
        if (geom0 === null) return null;
        const geom = [
            geom0
        ];
        for(let i = 0, iMax = this.interiorRings.length; i < iMax; i++){
            const ringGeom = this.interiorRings[i].getGeom();
            if (ringGeom === null) continue;
            geom.push(ringGeom);
        }
        return geom;
    }
};
var MultiPolyOut = class {
    rings;
    polys;
    constructor(rings){
        this.rings = rings;
        this.polys = this._composePolys(rings);
    }
    getGeom() {
        const geom = [];
        for(let i = 0, iMax = this.polys.length; i < iMax; i++){
            const polyGeom = this.polys[i].getGeom();
            if (polyGeom === null) continue;
            geom.push(polyGeom);
        }
        return geom;
    }
    _composePolys(rings) {
        const polys = [];
        for(let i = 0, iMax = rings.length; i < iMax; i++){
            const ring = rings[i];
            if (ring.poly) continue;
            if (ring.isExteriorRing()) polys.push(new PolyOut(ring));
            else {
                const enclosingRing = ring.enclosingRing();
                if (!enclosingRing?.poly) polys.push(new PolyOut(enclosingRing));
                enclosingRing?.poly?.addInterior(ring);
            }
        }
        return polys;
    }
};
;
var SweepLine = class {
    queue;
    tree;
    segments;
    constructor(queue, comparator = Segment.compare){
        this.queue = queue;
        this.tree = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$splaytree$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["SplayTreeSet"](comparator);
        this.segments = [];
    }
    process(event) {
        const segment = event.segment;
        const newEvents = [];
        if (event.consumedBy) {
            if (event.isLeft) this.queue.delete(event.otherSE);
            else this.tree.delete(segment);
            return newEvents;
        }
        if (event.isLeft) this.tree.add(segment);
        let prevSeg = segment;
        let nextSeg = segment;
        do {
            prevSeg = this.tree.lastBefore(prevSeg);
        }while (prevSeg != null && prevSeg.consumedBy != void 0)
        do {
            nextSeg = this.tree.firstAfter(nextSeg);
        }while (nextSeg != null && nextSeg.consumedBy != void 0)
        if (event.isLeft) {
            let prevMySplitter = null;
            if (prevSeg) {
                const prevInter = prevSeg.getIntersection(segment);
                if (prevInter !== null) {
                    if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter;
                    if (!prevSeg.isAnEndpoint(prevInter)) {
                        const newEventsFromSplit = this._splitSafely(prevSeg, prevInter);
                        for(let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++){
                            newEvents.push(newEventsFromSplit[i]);
                        }
                    }
                }
            }
            let nextMySplitter = null;
            if (nextSeg) {
                const nextInter = nextSeg.getIntersection(segment);
                if (nextInter !== null) {
                    if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter;
                    if (!nextSeg.isAnEndpoint(nextInter)) {
                        const newEventsFromSplit = this._splitSafely(nextSeg, nextInter);
                        for(let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++){
                            newEvents.push(newEventsFromSplit[i]);
                        }
                    }
                }
            }
            if (prevMySplitter !== null || nextMySplitter !== null) {
                let mySplitter = null;
                if (prevMySplitter === null) mySplitter = nextMySplitter;
                else if (nextMySplitter === null) mySplitter = prevMySplitter;
                else {
                    const cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);
                    mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;
                }
                this.queue.delete(segment.rightSE);
                newEvents.push(segment.rightSE);
                const newEventsFromSplit = segment.split(mySplitter);
                for(let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++){
                    newEvents.push(newEventsFromSplit[i]);
                }
            }
            if (newEvents.length > 0) {
                this.tree.delete(segment);
                newEvents.push(event);
            } else {
                this.segments.push(segment);
                segment.prev = prevSeg;
            }
        } else {
            if (prevSeg && nextSeg) {
                const inter = prevSeg.getIntersection(nextSeg);
                if (inter !== null) {
                    if (!prevSeg.isAnEndpoint(inter)) {
                        const newEventsFromSplit = this._splitSafely(prevSeg, inter);
                        for(let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++){
                            newEvents.push(newEventsFromSplit[i]);
                        }
                    }
                    if (!nextSeg.isAnEndpoint(inter)) {
                        const newEventsFromSplit = this._splitSafely(nextSeg, inter);
                        for(let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++){
                            newEvents.push(newEventsFromSplit[i]);
                        }
                    }
                }
            }
            this.tree.delete(segment);
        }
        return newEvents;
    }
    /* Safely split a segment that is currently in the datastructures
   * IE - a segment other than the one that is currently being processed. */ _splitSafely(seg, pt) {
        this.tree.delete(seg);
        const rightSE = seg.rightSE;
        this.queue.delete(rightSE);
        const newEvents = seg.split(pt);
        newEvents.push(rightSE);
        if (seg.consumedBy === void 0) this.tree.add(seg);
        return newEvents;
    }
};
// src/operation.ts
var Operation = class {
    type;
    numMultiPolys;
    run(type, geom, moreGeoms) {
        operation.type = type;
        const multipolys = [
            new MultiPolyIn(geom, true)
        ];
        for(let i = 0, iMax = moreGeoms.length; i < iMax; i++){
            multipolys.push(new MultiPolyIn(moreGeoms[i], false));
        }
        operation.numMultiPolys = multipolys.length;
        if (operation.type === "difference") {
            const subject = multipolys[0];
            let i = 1;
            while(i < multipolys.length){
                if (getBboxOverlap(multipolys[i].bbox, subject.bbox) !== null) i++;
                else multipolys.splice(i, 1);
            }
        }
        if (operation.type === "intersection") {
            for(let i = 0, iMax = multipolys.length; i < iMax; i++){
                const mpA = multipolys[i];
                for(let j = i + 1, jMax = multipolys.length; j < jMax; j++){
                    if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return [];
                }
            }
        }
        const queue = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$splaytree$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["SplayTreeSet"](SweepEvent.compare);
        for(let i = 0, iMax = multipolys.length; i < iMax; i++){
            const sweepEvents = multipolys[i].getSweepEvents();
            for(let j = 0, jMax = sweepEvents.length; j < jMax; j++){
                queue.add(sweepEvents[j]);
            }
        }
        const sweepLine = new SweepLine(queue);
        let evt = null;
        if (queue.size != 0) {
            evt = queue.first();
            queue.delete(evt);
        }
        while(evt){
            const newEvents = sweepLine.process(evt);
            for(let i = 0, iMax = newEvents.length; i < iMax; i++){
                const evt2 = newEvents[i];
                if (evt2.consumedBy === void 0) queue.add(evt2);
            }
            if (queue.size != 0) {
                evt = queue.first();
                queue.delete(evt);
            } else {
                evt = null;
            }
        }
        precision.reset();
        const ringsOut = RingOut.factory(sweepLine.segments);
        const result = new MultiPolyOut(ringsOut);
        return result.getGeom();
    }
};
var operation = new Operation();
var operation_default = operation;
// src/segment.ts
var segmentId = 0;
var Segment = class _Segment {
    id;
    leftSE;
    rightSE;
    rings;
    windings;
    ringOut;
    consumedBy;
    prev;
    _prevInResult;
    _beforeState;
    _afterState;
    _isInResult;
    /* This compare() function is for ordering segments in the sweep
   * line tree, and does so according to the following criteria:
   *
   * Consider the vertical line that lies an infinestimal step to the
   * right of the right-more of the two left endpoints of the input
   * segments. Imagine slowly moving a point up from negative infinity
   * in the increasing y direction. Which of the two segments will that
   * point intersect first? That segment comes 'before' the other one.
   *
   * If neither segment would be intersected by such a line, (if one
   * or more of the segments are vertical) then the line to be considered
   * is directly on the right-more of the two left inputs.
   */ static compare(a, b) {
        const alx = a.leftSE.point.x;
        const blx = b.leftSE.point.x;
        const arx = a.rightSE.point.x;
        const brx = b.rightSE.point.x;
        if (brx.isLessThan(alx)) return 1;
        if (arx.isLessThan(blx)) return -1;
        const aly = a.leftSE.point.y;
        const bly = b.leftSE.point.y;
        const ary = a.rightSE.point.y;
        const bry = b.rightSE.point.y;
        if (alx.isLessThan(blx)) {
            if (bly.isLessThan(aly) && bly.isLessThan(ary)) return 1;
            if (bly.isGreaterThan(aly) && bly.isGreaterThan(ary)) return -1;
            const aCmpBLeft = a.comparePoint(b.leftSE.point);
            if (aCmpBLeft < 0) return 1;
            if (aCmpBLeft > 0) return -1;
            const bCmpARight = b.comparePoint(a.rightSE.point);
            if (bCmpARight !== 0) return bCmpARight;
            return -1;
        }
        if (alx.isGreaterThan(blx)) {
            if (aly.isLessThan(bly) && aly.isLessThan(bry)) return -1;
            if (aly.isGreaterThan(bly) && aly.isGreaterThan(bry)) return 1;
            const bCmpALeft = b.comparePoint(a.leftSE.point);
            if (bCmpALeft !== 0) return bCmpALeft;
            const aCmpBRight = a.comparePoint(b.rightSE.point);
            if (aCmpBRight < 0) return 1;
            if (aCmpBRight > 0) return -1;
            return 1;
        }
        if (aly.isLessThan(bly)) return -1;
        if (aly.isGreaterThan(bly)) return 1;
        if (arx.isLessThan(brx)) {
            const bCmpARight = b.comparePoint(a.rightSE.point);
            if (bCmpARight !== 0) return bCmpARight;
        }
        if (arx.isGreaterThan(brx)) {
            const aCmpBRight = a.comparePoint(b.rightSE.point);
            if (aCmpBRight < 0) return 1;
            if (aCmpBRight > 0) return -1;
        }
        if (!arx.eq(brx)) {
            const ay = ary.minus(aly);
            const ax = arx.minus(alx);
            const by = bry.minus(bly);
            const bx = brx.minus(blx);
            if (ay.isGreaterThan(ax) && by.isLessThan(bx)) return 1;
            if (ay.isLessThan(ax) && by.isGreaterThan(bx)) return -1;
        }
        if (arx.isGreaterThan(brx)) return 1;
        if (arx.isLessThan(brx)) return -1;
        if (ary.isLessThan(bry)) return -1;
        if (ary.isGreaterThan(bry)) return 1;
        if (a.id < b.id) return -1;
        if (a.id > b.id) return 1;
        return 0;
    }
    /* Warning: a reference to ringWindings input will be stored,
   *  and possibly will be later modified */ constructor(leftSE, rightSE, rings, windings){
        this.id = ++segmentId;
        this.leftSE = leftSE;
        leftSE.segment = this;
        leftSE.otherSE = rightSE;
        this.rightSE = rightSE;
        rightSE.segment = this;
        rightSE.otherSE = leftSE;
        this.rings = rings;
        this.windings = windings;
    }
    static fromRing(pt1, pt2, ring) {
        let leftPt, rightPt, winding;
        const cmpPts = SweepEvent.comparePoints(pt1, pt2);
        if (cmpPts < 0) {
            leftPt = pt1;
            rightPt = pt2;
            winding = 1;
        } else if (cmpPts > 0) {
            leftPt = pt2;
            rightPt = pt1;
            winding = -1;
        } else throw new Error(`Tried to create degenerate segment at [${pt1.x}, ${pt1.y}]`);
        const leftSE = new SweepEvent(leftPt, true);
        const rightSE = new SweepEvent(rightPt, false);
        return new _Segment(leftSE, rightSE, [
            ring
        ], [
            winding
        ]);
    }
    /* When a segment is split, the rightSE is replaced with a new sweep event */ replaceRightSE(newRightSE) {
        this.rightSE = newRightSE;
        this.rightSE.segment = this;
        this.rightSE.otherSE = this.leftSE;
        this.leftSE.otherSE = this.rightSE;
    }
    bbox() {
        const y1 = this.leftSE.point.y;
        const y2 = this.rightSE.point.y;
        return {
            ll: {
                x: this.leftSE.point.x,
                y: y1.isLessThan(y2) ? y1 : y2
            },
            ur: {
                x: this.rightSE.point.x,
                y: y1.isGreaterThan(y2) ? y1 : y2
            }
        };
    }
    /* A vector from the left point to the right */ vector() {
        return {
            x: this.rightSE.point.x.minus(this.leftSE.point.x),
            y: this.rightSE.point.y.minus(this.leftSE.point.y)
        };
    }
    isAnEndpoint(pt) {
        return pt.x.eq(this.leftSE.point.x) && pt.y.eq(this.leftSE.point.y) || pt.x.eq(this.rightSE.point.x) && pt.y.eq(this.rightSE.point.y);
    }
    /* Compare this segment with a point.
   *
   * A point P is considered to be colinear to a segment if there
   * exists a distance D such that if we travel along the segment
   * from one * endpoint towards the other a distance D, we find
   * ourselves at point P.
   *
   * Return value indicates:
   *
   *   1: point lies above the segment (to the left of vertical)
   *   0: point is colinear to segment
   *  -1: point lies below the segment (to the right of vertical)
   */ comparePoint(point) {
        return precision.orient(this.leftSE.point, point, this.rightSE.point);
    }
    /**
   * Given another segment, returns the first non-trivial intersection
   * between the two segments (in terms of sweep line ordering), if it exists.
   *
   * A 'non-trivial' intersection is one that will cause one or both of the
   * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:
   *
   *   * endpoint of segA with endpoint of segB --> trivial
   *   * endpoint of segA with point along segB --> non-trivial
   *   * endpoint of segB with point along segA --> non-trivial
   *   * point along segA with point along segB --> non-trivial
   *
   * If no non-trivial intersection exists, return null
   * Else, return null.
   */ getIntersection(other) {
        const tBbox = this.bbox();
        const oBbox = other.bbox();
        const bboxOverlap = getBboxOverlap(tBbox, oBbox);
        if (bboxOverlap === null) return null;
        const tlp = this.leftSE.point;
        const trp = this.rightSE.point;
        const olp = other.leftSE.point;
        const orp = other.rightSE.point;
        const touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;
        const touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;
        const touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;
        const touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0;
        if (touchesThisLSE && touchesOtherLSE) {
            if (touchesThisRSE && !touchesOtherRSE) return trp;
            if (!touchesThisRSE && touchesOtherRSE) return orp;
            return null;
        }
        if (touchesThisLSE) {
            if (touchesOtherRSE) {
                if (tlp.x.eq(orp.x) && tlp.y.eq(orp.y)) return null;
            }
            return tlp;
        }
        if (touchesOtherLSE) {
            if (touchesThisRSE) {
                if (trp.x.eq(olp.x) && trp.y.eq(olp.y)) return null;
            }
            return olp;
        }
        if (touchesThisRSE && touchesOtherRSE) return null;
        if (touchesThisRSE) return trp;
        if (touchesOtherRSE) return orp;
        const pt = intersection(tlp, this.vector(), olp, other.vector());
        if (pt === null) return null;
        if (!isInBbox(bboxOverlap, pt)) return null;
        return precision.snap(pt);
    }
    /**
   * Split the given segment into multiple segments on the given points.
   *  * Each existing segment will retain its leftSE and a new rightSE will be
   *    generated for it.
   *  * A new segment will be generated which will adopt the original segment's
   *    rightSE, and a new leftSE will be generated for it.
   *  * If there are more than two points given to split on, new segments
   *    in the middle will be generated with new leftSE and rightSE's.
   *  * An array of the newly generated SweepEvents will be returned.
   *
   * Warning: input array of points is modified
   */ split(point) {
        const newEvents = [];
        const alreadyLinked = point.events !== void 0;
        const newLeftSE = new SweepEvent(point, true);
        const newRightSE = new SweepEvent(point, false);
        const oldRightSE = this.rightSE;
        this.replaceRightSE(newRightSE);
        newEvents.push(newRightSE);
        newEvents.push(newLeftSE);
        const newSeg = new _Segment(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice());
        if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {
            newSeg.swapEvents();
        }
        if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {
            this.swapEvents();
        }
        if (alreadyLinked) {
            newLeftSE.checkForConsuming();
            newRightSE.checkForConsuming();
        }
        return newEvents;
    }
    /* Swap which event is left and right */ swapEvents() {
        const tmpEvt = this.rightSE;
        this.rightSE = this.leftSE;
        this.leftSE = tmpEvt;
        this.leftSE.isLeft = true;
        this.rightSE.isLeft = false;
        for(let i = 0, iMax = this.windings.length; i < iMax; i++){
            this.windings[i] *= -1;
        }
    }
    /* Consume another segment. We take their rings under our wing
   * and mark them as consumed. Use for perfectly overlapping segments */ consume(other) {
        let consumer = this;
        let consumee = other;
        while(consumer.consumedBy)consumer = consumer.consumedBy;
        while(consumee.consumedBy)consumee = consumee.consumedBy;
        const cmp = _Segment.compare(consumer, consumee);
        if (cmp === 0) return;
        if (cmp > 0) {
            const tmp = consumer;
            consumer = consumee;
            consumee = tmp;
        }
        if (consumer.prev === consumee) {
            const tmp = consumer;
            consumer = consumee;
            consumee = tmp;
        }
        for(let i = 0, iMax = consumee.rings.length; i < iMax; i++){
            const ring = consumee.rings[i];
            const winding = consumee.windings[i];
            const index = consumer.rings.indexOf(ring);
            if (index === -1) {
                consumer.rings.push(ring);
                consumer.windings.push(winding);
            } else consumer.windings[index] += winding;
        }
        consumee.rings = null;
        consumee.windings = null;
        consumee.consumedBy = consumer;
        consumee.leftSE.consumedBy = consumer.leftSE;
        consumee.rightSE.consumedBy = consumer.rightSE;
    }
    /* The first segment previous segment chain that is in the result */ prevInResult() {
        if (this._prevInResult !== void 0) return this._prevInResult;
        if (!this.prev) this._prevInResult = null;
        else if (this.prev.isInResult()) this._prevInResult = this.prev;
        else this._prevInResult = this.prev.prevInResult();
        return this._prevInResult;
    }
    beforeState() {
        if (this._beforeState !== void 0) return this._beforeState;
        if (!this.prev) this._beforeState = {
            rings: [],
            windings: [],
            multiPolys: []
        };
        else {
            const seg = this.prev.consumedBy || this.prev;
            this._beforeState = seg.afterState();
        }
        return this._beforeState;
    }
    afterState() {
        if (this._afterState !== void 0) return this._afterState;
        const beforeState = this.beforeState();
        this._afterState = {
            rings: beforeState.rings.slice(0),
            windings: beforeState.windings.slice(0),
            multiPolys: []
        };
        const ringsAfter = this._afterState.rings;
        const windingsAfter = this._afterState.windings;
        const mpsAfter = this._afterState.multiPolys;
        for(let i = 0, iMax = this.rings.length; i < iMax; i++){
            const ring = this.rings[i];
            const winding = this.windings[i];
            const index = ringsAfter.indexOf(ring);
            if (index === -1) {
                ringsAfter.push(ring);
                windingsAfter.push(winding);
            } else windingsAfter[index] += winding;
        }
        const polysAfter = [];
        const polysExclude = [];
        for(let i = 0, iMax = ringsAfter.length; i < iMax; i++){
            if (windingsAfter[i] === 0) continue;
            const ring = ringsAfter[i];
            const poly = ring.poly;
            if (polysExclude.indexOf(poly) !== -1) continue;
            if (ring.isExterior) polysAfter.push(poly);
            else {
                if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly);
                const index = polysAfter.indexOf(ring.poly);
                if (index !== -1) polysAfter.splice(index, 1);
            }
        }
        for(let i = 0, iMax = polysAfter.length; i < iMax; i++){
            const mp = polysAfter[i].multiPoly;
            if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp);
        }
        return this._afterState;
    }
    /* Is this segment part of the final result? */ isInResult() {
        if (this.consumedBy) return false;
        if (this._isInResult !== void 0) return this._isInResult;
        const mpsBefore = this.beforeState().multiPolys;
        const mpsAfter = this.afterState().multiPolys;
        switch(operation_default.type){
            case "union":
                {
                    const noBefores = mpsBefore.length === 0;
                    const noAfters = mpsAfter.length === 0;
                    this._isInResult = noBefores !== noAfters;
                    break;
                }
            case "intersection":
                {
                    let least;
                    let most;
                    if (mpsBefore.length < mpsAfter.length) {
                        least = mpsBefore.length;
                        most = mpsAfter.length;
                    } else {
                        least = mpsAfter.length;
                        most = mpsBefore.length;
                    }
                    this._isInResult = most === operation_default.numMultiPolys && least < most;
                    break;
                }
            case "xor":
                {
                    const diff = Math.abs(mpsBefore.length - mpsAfter.length);
                    this._isInResult = diff % 2 === 1;
                    break;
                }
            case "difference":
                {
                    const isJustSubject = (mps)=>mps.length === 1 && mps[0].isSubject;
                    this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);
                    break;
                }
        }
        return this._isInResult;
    }
};
// src/geom-in.ts
var RingIn = class {
    poly;
    isExterior;
    segments;
    bbox;
    constructor(geomRing, poly, isExterior){
        if (!Array.isArray(geomRing) || geomRing.length === 0) {
            throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
        }
        this.poly = poly;
        this.isExterior = isExterior;
        this.segments = [];
        if (typeof geomRing[0][0] !== "number" || typeof geomRing[0][1] !== "number") {
            throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
        }
        const firstPoint = precision.snap({
            x: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["default"](geomRing[0][0]),
            y: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["default"](geomRing[0][1])
        });
        this.bbox = {
            ll: {
                x: firstPoint.x,
                y: firstPoint.y
            },
            ur: {
                x: firstPoint.x,
                y: firstPoint.y
            }
        };
        let prevPoint = firstPoint;
        for(let i = 1, iMax = geomRing.length; i < iMax; i++){
            if (typeof geomRing[i][0] !== "number" || typeof geomRing[i][1] !== "number") {
                throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
            }
            const point = precision.snap({
                x: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["default"](geomRing[i][0]),
                y: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["default"](geomRing[i][1])
            });
            if (point.x.eq(prevPoint.x) && point.y.eq(prevPoint.y)) continue;
            this.segments.push(Segment.fromRing(prevPoint, point, this));
            if (point.x.isLessThan(this.bbox.ll.x)) this.bbox.ll.x = point.x;
            if (point.y.isLessThan(this.bbox.ll.y)) this.bbox.ll.y = point.y;
            if (point.x.isGreaterThan(this.bbox.ur.x)) this.bbox.ur.x = point.x;
            if (point.y.isGreaterThan(this.bbox.ur.y)) this.bbox.ur.y = point.y;
            prevPoint = point;
        }
        if (!firstPoint.x.eq(prevPoint.x) || !firstPoint.y.eq(prevPoint.y)) {
            this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));
        }
    }
    getSweepEvents() {
        const sweepEvents = [];
        for(let i = 0, iMax = this.segments.length; i < iMax; i++){
            const segment = this.segments[i];
            sweepEvents.push(segment.leftSE);
            sweepEvents.push(segment.rightSE);
        }
        return sweepEvents;
    }
};
var PolyIn = class {
    multiPoly;
    exteriorRing;
    interiorRings;
    bbox;
    constructor(geomPoly, multiPoly){
        if (!Array.isArray(geomPoly)) {
            throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
        }
        this.exteriorRing = new RingIn(geomPoly[0], this, true);
        this.bbox = {
            ll: {
                x: this.exteriorRing.bbox.ll.x,
                y: this.exteriorRing.bbox.ll.y
            },
            ur: {
                x: this.exteriorRing.bbox.ur.x,
                y: this.exteriorRing.bbox.ur.y
            }
        };
        this.interiorRings = [];
        for(let i = 1, iMax = geomPoly.length; i < iMax; i++){
            const ring = new RingIn(geomPoly[i], this, false);
            if (ring.bbox.ll.x.isLessThan(this.bbox.ll.x)) this.bbox.ll.x = ring.bbox.ll.x;
            if (ring.bbox.ll.y.isLessThan(this.bbox.ll.y)) this.bbox.ll.y = ring.bbox.ll.y;
            if (ring.bbox.ur.x.isGreaterThan(this.bbox.ur.x)) this.bbox.ur.x = ring.bbox.ur.x;
            if (ring.bbox.ur.y.isGreaterThan(this.bbox.ur.y)) this.bbox.ur.y = ring.bbox.ur.y;
            this.interiorRings.push(ring);
        }
        this.multiPoly = multiPoly;
    }
    getSweepEvents() {
        const sweepEvents = this.exteriorRing.getSweepEvents();
        for(let i = 0, iMax = this.interiorRings.length; i < iMax; i++){
            const ringSweepEvents = this.interiorRings[i].getSweepEvents();
            for(let j = 0, jMax = ringSweepEvents.length; j < jMax; j++){
                sweepEvents.push(ringSweepEvents[j]);
            }
        }
        return sweepEvents;
    }
};
var MultiPolyIn = class {
    isSubject;
    polys;
    bbox;
    constructor(geom, isSubject){
        if (!Array.isArray(geom)) {
            throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
        }
        try {
            if (typeof geom[0][0][0] === "number") geom = [
                geom
            ];
        } catch (ex) {}
        this.polys = [];
        this.bbox = {
            ll: {
                x: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["default"](Number.POSITIVE_INFINITY),
                y: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["default"](Number.POSITIVE_INFINITY)
            },
            ur: {
                x: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["default"](Number.NEGATIVE_INFINITY),
                y: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["default"](Number.NEGATIVE_INFINITY)
            }
        };
        for(let i = 0, iMax = geom.length; i < iMax; i++){
            const poly = new PolyIn(geom[i], this);
            if (poly.bbox.ll.x.isLessThan(this.bbox.ll.x)) this.bbox.ll.x = poly.bbox.ll.x;
            if (poly.bbox.ll.y.isLessThan(this.bbox.ll.y)) this.bbox.ll.y = poly.bbox.ll.y;
            if (poly.bbox.ur.x.isGreaterThan(this.bbox.ur.x)) this.bbox.ur.x = poly.bbox.ur.x;
            if (poly.bbox.ur.y.isGreaterThan(this.bbox.ur.y)) this.bbox.ur.y = poly.bbox.ur.y;
            this.polys.push(poly);
        }
        this.isSubject = isSubject;
    }
    getSweepEvents() {
        const sweepEvents = [];
        for(let i = 0, iMax = this.polys.length; i < iMax; i++){
            const polySweepEvents = this.polys[i].getSweepEvents();
            for(let j = 0, jMax = polySweepEvents.length; j < jMax; j++){
                sweepEvents.push(polySweepEvents[j]);
            }
        }
        return sweepEvents;
    }
};
// src/index.ts
var union = (geom, ...moreGeoms)=>operation_default.run("union", geom, moreGeoms);
var intersection2 = (geom, ...moreGeoms)=>operation_default.run("intersection", geom, moreGeoms);
var xor = (geom, ...moreGeoms)=>operation_default.run("xor", geom, moreGeoms);
var difference = (geom, ...moreGeoms)=>operation_default.run("difference", geom, moreGeoms);
var setPrecision = precision.set;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/geojson-equality-ts/dist/esm/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "GeojsonEquality": (()=>GeojsonEquality),
    "default": (()=>geojson_equality_ts_default),
    "geojsonEquality": (()=>geojsonEquality)
});
var __defProp = Object.defineProperty;
var __name = (target, value)=>__defProp(target, "name", {
        value,
        configurable: true
    });
// index.ts
var _GeojsonEquality = class _GeojsonEquality {
    constructor(opts){
        this.direction = false;
        this.compareProperties = true;
        var _a, _b, _c;
        this.precision = 10 ** -((_a = opts == null ? void 0 : opts.precision) != null ? _a : 17);
        this.direction = (_b = opts == null ? void 0 : opts.direction) != null ? _b : false;
        this.compareProperties = (_c = opts == null ? void 0 : opts.compareProperties) != null ? _c : true;
    }
    compare(g1, g2) {
        if (g1.type !== g2.type) {
            return false;
        }
        if (!sameLength(g1, g2)) {
            return false;
        }
        switch(g1.type){
            case "Point":
                return this.compareCoord(g1.coordinates, g2.coordinates);
            case "LineString":
                return this.compareLine(g1.coordinates, g2.coordinates);
            case "Polygon":
                return this.comparePolygon(g1, g2);
            case "GeometryCollection":
                return this.compareGeometryCollection(g1, g2);
            case "Feature":
                return this.compareFeature(g1, g2);
            case "FeatureCollection":
                return this.compareFeatureCollection(g1, g2);
            default:
                if (g1.type.startsWith("Multi")) {
                    const g1s = explode(g1);
                    const g2s = explode(g2);
                    return g1s.every((g1part)=>g2s.some((g2part)=>this.compare(g1part, g2part)));
                }
        }
        return false;
    }
    compareCoord(c1, c2) {
        return c1.length === c2.length && c1.every((c, i)=>Math.abs(c - c2[i]) < this.precision);
    }
    compareLine(path1, path2, ind = 0, isPoly = false) {
        if (!sameLength(path1, path2)) {
            return false;
        }
        const p1 = path1;
        let p2 = path2;
        if (isPoly && !this.compareCoord(p1[0], p2[0])) {
            const startIndex = this.fixStartIndex(p2, p1);
            if (!startIndex) {
                return false;
            } else {
                p2 = startIndex;
            }
        }
        const sameDirection = this.compareCoord(p1[ind], p2[ind]);
        if (this.direction || sameDirection) {
            return this.comparePath(p1, p2);
        } else {
            if (this.compareCoord(p1[ind], p2[p2.length - (1 + ind)])) {
                return this.comparePath(p1.slice().reverse(), p2);
            }
            return false;
        }
    }
    fixStartIndex(sourcePath, targetPath) {
        let correctPath, ind = -1;
        for(let i = 0; i < sourcePath.length; i++){
            if (this.compareCoord(sourcePath[i], targetPath[0])) {
                ind = i;
                break;
            }
        }
        if (ind >= 0) {
            correctPath = [].concat(sourcePath.slice(ind, sourcePath.length), sourcePath.slice(1, ind + 1));
        }
        return correctPath;
    }
    comparePath(p1, p2) {
        return p1.every((c, i)=>this.compareCoord(c, p2[i]));
    }
    comparePolygon(g1, g2) {
        if (this.compareLine(g1.coordinates[0], g2.coordinates[0], 1, true)) {
            const holes1 = g1.coordinates.slice(1, g1.coordinates.length);
            const holes2 = g2.coordinates.slice(1, g2.coordinates.length);
            return holes1.every((h1)=>holes2.some((h2)=>this.compareLine(h1, h2, 1, true)));
        }
        return false;
    }
    compareGeometryCollection(g1, g2) {
        return sameLength(g1.geometries, g2.geometries) && this.compareBBox(g1, g2) && g1.geometries.every((g, i)=>this.compare(g, g2.geometries[i]));
    }
    compareFeature(g1, g2) {
        return g1.id === g2.id && (this.compareProperties ? equal(g1.properties, g2.properties) : true) && this.compareBBox(g1, g2) && this.compare(g1.geometry, g2.geometry);
    }
    compareFeatureCollection(g1, g2) {
        return sameLength(g1.features, g2.features) && this.compareBBox(g1, g2) && g1.features.every((f, i)=>this.compare(f, g2.features[i]));
    }
    compareBBox(g1, g2) {
        return Boolean(!g1.bbox && !g2.bbox) || (g1.bbox && g2.bbox ? this.compareCoord(g1.bbox, g2.bbox) : false);
    }
};
__name(_GeojsonEquality, "GeojsonEquality");
var GeojsonEquality = _GeojsonEquality;
function sameLength(g1, g2) {
    return g1.coordinates ? g1.coordinates.length === g2.coordinates.length : g1.length === g2.length;
}
__name(sameLength, "sameLength");
function explode(g) {
    return g.coordinates.map((part)=>({
            type: g.type.replace("Multi", ""),
            coordinates: part
        }));
}
__name(explode, "explode");
function geojsonEquality(g1, g2, opts) {
    const eq = new GeojsonEquality(opts);
    return eq.compare(g1, g2);
}
__name(geojsonEquality, "geojsonEquality");
function equal(object1, object2) {
    if (object1 === null && object2 === null) {
        return true;
    }
    if (object1 === null || object2 === null) {
        return false;
    }
    const objKeys1 = Object.keys(object1);
    const objKeys2 = Object.keys(object2);
    if (objKeys1.length !== objKeys2.length) return false;
    for (var key of objKeys1){
        const value1 = object1[key];
        const value2 = object2[key];
        const isObjects = isObject(value1) && isObject(value2);
        if (isObjects && !equal(value1, value2) || !isObjects && value1 !== value2) {
            return false;
        }
    }
    return true;
}
__name(equal, "equal");
var isObject = /* @__PURE__ */ __name((object)=>{
    return object != null && typeof object === "object";
}, "isObject");
var geojson_equality_ts_default = GeojsonEquality;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/d3-array/src/ascending.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>ascending)
});
function ascending(a, b) {
    return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}
}}),
"[project]/node_modules/d3-array/src/descending.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>descending)
});
function descending(a, b) {
    return a == null || b == null ? NaN : b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}
}}),
"[project]/node_modules/d3-array/src/bisector.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>bisector)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ascending$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/ascending.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$descending$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/descending.js [client] (ecmascript)");
;
;
function bisector(f) {
    let compare1, compare2, delta;
    // If an accessor is specified, promote it to a comparator. In this case we
    // can test whether the search value is (self-) comparable. We can’t do this
    // for a comparator (except for specific, known comparators) because we can’t
    // tell if the comparator is symmetric, and an asymmetric comparator can’t be
    // used to test whether a single value is comparable.
    if (f.length !== 2) {
        compare1 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ascending$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"];
        compare2 = (d, x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ascending$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(f(d), x);
        delta = (d, x)=>f(d) - x;
    } else {
        compare1 = f === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ascending$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"] || f === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$descending$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"] ? f : zero;
        compare2 = f;
        delta = f;
    }
    function left(a, x, lo = 0, hi = a.length) {
        if (lo < hi) {
            if (compare1(x, x) !== 0) return hi;
            do {
                const mid = lo + hi >>> 1;
                if (compare2(a[mid], x) < 0) lo = mid + 1;
                else hi = mid;
            }while (lo < hi)
        }
        return lo;
    }
    function right(a, x, lo = 0, hi = a.length) {
        if (lo < hi) {
            if (compare1(x, x) !== 0) return hi;
            do {
                const mid = lo + hi >>> 1;
                if (compare2(a[mid], x) <= 0) lo = mid + 1;
                else hi = mid;
            }while (lo < hi)
        }
        return lo;
    }
    function center(a, x, lo = 0, hi = a.length) {
        const i = left(a, x, lo, hi - 1);
        return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
    }
    return {
        left,
        center,
        right
    };
}
function zero() {
    return 0;
}
}}),
"[project]/node_modules/d3-array/src/number.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>number),
    "numbers": (()=>numbers)
});
function number(x) {
    return x === null ? NaN : +x;
}
function* numbers(values, valueof) {
    if (valueof === undefined) {
        for (let value of values){
            if (value != null && (value = +value) >= value) {
                yield value;
            }
        }
    } else {
        let index = -1;
        for (let value of values){
            if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
                yield value;
            }
        }
    }
}
}}),
"[project]/node_modules/d3-array/src/bisect.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "bisectCenter": (()=>bisectCenter),
    "bisectLeft": (()=>bisectLeft),
    "bisectRight": (()=>bisectRight),
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ascending$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/ascending.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$bisector$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/bisector.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$number$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/number.js [client] (ecmascript)");
;
;
;
const ascendingBisect = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$bisector$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ascending$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"]);
const bisectRight = ascendingBisect.right;
const bisectLeft = ascendingBisect.left;
const bisectCenter = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$bisector$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$number$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"]).center;
const __TURBOPACK__default__export__ = bisectRight;
}}),
"[project]/node_modules/d3-array/src/bisect.js [client] (ecmascript) <export default as bisect>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "bisect": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$bisect$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$bisect$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/bisect.js [client] (ecmascript)");
}}),
"[project]/node_modules/d3-array/src/ticks.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>ticks),
    "tickIncrement": (()=>tickIncrement),
    "tickStep": (()=>tickStep)
});
const e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);
function tickSpec(start, stop, count) {
    const step = (stop - start) / Math.max(0, count), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
    let i1, i2, inc;
    if (power < 0) {
        inc = Math.pow(10, -power) / factor;
        i1 = Math.round(start * inc);
        i2 = Math.round(stop * inc);
        if (i1 / inc < start) ++i1;
        if (i2 / inc > stop) --i2;
        inc = -inc;
    } else {
        inc = Math.pow(10, power) * factor;
        i1 = Math.round(start / inc);
        i2 = Math.round(stop / inc);
        if (i1 * inc < start) ++i1;
        if (i2 * inc > stop) --i2;
    }
    if (i2 < i1 && 0.5 <= count && count < 2) return tickSpec(start, stop, count * 2);
    return [
        i1,
        i2,
        inc
    ];
}
function ticks(start, stop, count) {
    stop = +stop, start = +start, count = +count;
    if (!(count > 0)) return [];
    if (start === stop) return [
        start
    ];
    const reverse = stop < start, [i1, i2, inc] = reverse ? tickSpec(stop, start, count) : tickSpec(start, stop, count);
    if (!(i2 >= i1)) return [];
    const n = i2 - i1 + 1, ticks = new Array(n);
    if (reverse) {
        if (inc < 0) for(let i = 0; i < n; ++i)ticks[i] = (i2 - i) / -inc;
        else for(let i = 0; i < n; ++i)ticks[i] = (i2 - i) * inc;
    } else {
        if (inc < 0) for(let i = 0; i < n; ++i)ticks[i] = (i1 + i) / -inc;
        else for(let i = 0; i < n; ++i)ticks[i] = (i1 + i) * inc;
    }
    return ticks;
}
function tickIncrement(start, stop, count) {
    stop = +stop, start = +start, count = +count;
    return tickSpec(start, stop, count)[2];
}
function tickStep(start, stop, count) {
    stop = +stop, start = +start, count = +count;
    const reverse = stop < start, inc = reverse ? tickIncrement(stop, start, count) : tickIncrement(start, stop, count);
    return (reverse ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}
}}),
"[project]/node_modules/d3-array/src/ticks.js [client] (ecmascript) <export default as ticks>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "ticks": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ticks$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ticks$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/ticks.js [client] (ecmascript)");
}}),
"[project]/node_modules/d3-array/src/variance.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>variance)
});
function variance(values, valueof) {
    let count = 0;
    let delta;
    let mean = 0;
    let sum = 0;
    if (valueof === undefined) {
        for (let value of values){
            if (value != null && (value = +value) >= value) {
                delta = value - mean;
                mean += delta / ++count;
                sum += delta * (value - mean);
            }
        }
    } else {
        let index = -1;
        for (let value of values){
            if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
                delta = value - mean;
                mean += delta / ++count;
                sum += delta * (value - mean);
            }
        }
    }
    if (count > 1) return sum / (count - 1);
}
}}),
"[project]/node_modules/d3-array/src/deviation.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>deviation)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$variance$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/variance.js [client] (ecmascript)");
;
function deviation(values, valueof) {
    const v = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$variance$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(values, valueof);
    return v ? Math.sqrt(v) : v;
}
}}),
"[project]/node_modules/d3-array/src/deviation.js [client] (ecmascript) <export default as deviation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "deviation": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$deviation$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$deviation$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/deviation.js [client] (ecmascript)");
}}),
"[project]/node_modules/d3-array/src/extent.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>extent)
});
function extent(values, valueof) {
    let min;
    let max;
    if (valueof === undefined) {
        for (const value of values){
            if (value != null) {
                if (min === undefined) {
                    if (value >= value) min = max = value;
                } else {
                    if (min > value) min = value;
                    if (max < value) max = value;
                }
            }
        }
    } else {
        let index = -1;
        for (let value of values){
            if ((value = valueof(value, ++index, values)) != null) {
                if (min === undefined) {
                    if (value >= value) min = max = value;
                } else {
                    if (min > value) min = value;
                    if (max < value) max = value;
                }
            }
        }
    }
    return [
        min,
        max
    ];
}
}}),
"[project]/node_modules/d3-array/src/extent.js [client] (ecmascript) <export default as extent>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "extent": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$extent$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$extent$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/extent.js [client] (ecmascript)");
}}),
"[project]/node_modules/d3-array/src/identity.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>identity)
});
function identity(x) {
    return x;
}
}}),
"[project]/node_modules/d3-array/src/group.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>group),
    "flatGroup": (()=>flatGroup),
    "flatRollup": (()=>flatRollup),
    "groups": (()=>groups),
    "index": (()=>index),
    "indexes": (()=>indexes),
    "rollup": (()=>rollup),
    "rollups": (()=>rollups)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$internmap$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/internmap/src/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$identity$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/identity.js [client] (ecmascript)");
;
;
function group(values, ...keys) {
    return nest(values, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$identity$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$identity$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"], keys);
}
function groups(values, ...keys) {
    return nest(values, Array.from, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$identity$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"], keys);
}
function flatten(groups, keys) {
    for(let i = 1, n = keys.length; i < n; ++i){
        groups = groups.flatMap((g)=>g.pop().map(([key, value])=>[
                    ...g,
                    key,
                    value
                ]));
    }
    return groups;
}
function flatGroup(values, ...keys) {
    return flatten(groups(values, ...keys), keys);
}
function flatRollup(values, reduce, ...keys) {
    return flatten(rollups(values, reduce, ...keys), keys);
}
function rollup(values, reduce, ...keys) {
    return nest(values, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$identity$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"], reduce, keys);
}
function rollups(values, reduce, ...keys) {
    return nest(values, Array.from, reduce, keys);
}
function index(values, ...keys) {
    return nest(values, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$identity$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"], unique, keys);
}
function indexes(values, ...keys) {
    return nest(values, Array.from, unique, keys);
}
function unique(values) {
    if (values.length !== 1) throw new Error("duplicate key");
    return values[0];
}
function nest(values, map, reduce, keys) {
    return function regroup(values, i) {
        if (i >= keys.length) return reduce(values);
        const groups = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$internmap$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["InternMap"]();
        const keyof = keys[i++];
        let index = -1;
        for (const value of values){
            const key = keyof(value, ++index, values);
            const group = groups.get(key);
            if (group) group.push(value);
            else groups.set(key, [
                value
            ]);
        }
        for (const [key, values] of groups){
            groups.set(key, regroup(values, i));
        }
        return map(groups);
    }(values, 0);
}
}}),
"[project]/node_modules/d3-array/src/permute.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>permute)
});
function permute(source, keys) {
    return Array.from(keys, (key)=>source[key]);
}
}}),
"[project]/node_modules/d3-array/src/sort.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "ascendingDefined": (()=>ascendingDefined),
    "compareDefined": (()=>compareDefined),
    "default": (()=>sort)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ascending$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/ascending.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$permute$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/permute.js [client] (ecmascript)");
;
;
function sort(values, ...F) {
    if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
    values = Array.from(values);
    let [f] = F;
    if (f && f.length !== 2 || F.length > 1) {
        const index = Uint32Array.from(values, (d, i)=>i);
        if (F.length > 1) {
            F = F.map((f)=>values.map(f));
            index.sort((i, j)=>{
                for (const f of F){
                    const c = ascendingDefined(f[i], f[j]);
                    if (c) return c;
                }
            });
        } else {
            f = values.map(f);
            index.sort((i, j)=>ascendingDefined(f[i], f[j]));
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$permute$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(values, index);
    }
    return values.sort(compareDefined(f));
}
function compareDefined(compare = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ascending$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"]) {
    if (compare === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ascending$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"]) return ascendingDefined;
    if (typeof compare !== "function") throw new TypeError("compare is not a function");
    return (a, b)=>{
        const x = compare(a, b);
        if (x || x === 0) return x;
        return (compare(b, b) === 0) - (compare(a, a) === 0);
    };
}
function ascendingDefined(a, b) {
    return (a == null || !(a >= a)) - (b == null || !(b >= b)) || (a < b ? -1 : a > b ? 1 : 0);
}
}}),
"[project]/node_modules/d3-array/src/groupSort.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>groupSort)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ascending$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/ascending.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/group.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$sort$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/sort.js [client] (ecmascript)");
;
;
;
function groupSort(values, reduce, key) {
    return (reduce.length !== 2 ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$sort$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$client$5d$__$28$ecmascript$29$__["rollup"])(values, reduce, key), ([ak, av], [bk, bv])=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ascending$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(av, bv) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ascending$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(ak, bk)) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$sort$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(values, key), ([ak, av], [bk, bv])=>reduce(av, bv) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ascending$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(ak, bk))).map(([key])=>key);
}
}}),
"[project]/node_modules/d3-array/src/groupSort.js [client] (ecmascript) <export default as groupSort>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "groupSort": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$groupSort$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$groupSort$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/groupSort.js [client] (ecmascript)");
}}),
"[project]/node_modules/d3-array/src/max.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>max)
});
function max(values, valueof) {
    let max;
    if (valueof === undefined) {
        for (const value of values){
            if (value != null && (max < value || max === undefined && value >= value)) {
                max = value;
            }
        }
    } else {
        let index = -1;
        for (let value of values){
            if ((value = valueof(value, ++index, values)) != null && (max < value || max === undefined && value >= value)) {
                max = value;
            }
        }
    }
    return max;
}
}}),
"[project]/node_modules/d3-array/src/maxIndex.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>maxIndex)
});
function maxIndex(values, valueof) {
    let max;
    let maxIndex = -1;
    let index = -1;
    if (valueof === undefined) {
        for (const value of values){
            ++index;
            if (value != null && (max < value || max === undefined && value >= value)) {
                max = value, maxIndex = index;
            }
        }
    } else {
        for (let value of values){
            if ((value = valueof(value, ++index, values)) != null && (max < value || max === undefined && value >= value)) {
                max = value, maxIndex = index;
            }
        }
    }
    return maxIndex;
}
}}),
"[project]/node_modules/d3-array/src/min.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>min)
});
function min(values, valueof) {
    let min;
    if (valueof === undefined) {
        for (const value of values){
            if (value != null && (min > value || min === undefined && value >= value)) {
                min = value;
            }
        }
    } else {
        let index = -1;
        for (let value of values){
            if ((value = valueof(value, ++index, values)) != null && (min > value || min === undefined && value >= value)) {
                min = value;
            }
        }
    }
    return min;
}
}}),
"[project]/node_modules/d3-array/src/minIndex.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>minIndex)
});
function minIndex(values, valueof) {
    let min;
    let minIndex = -1;
    let index = -1;
    if (valueof === undefined) {
        for (const value of values){
            ++index;
            if (value != null && (min > value || min === undefined && value >= value)) {
                min = value, minIndex = index;
            }
        }
    } else {
        for (let value of values){
            if ((value = valueof(value, ++index, values)) != null && (min > value || min === undefined && value >= value)) {
                min = value, minIndex = index;
            }
        }
    }
    return minIndex;
}
}}),
"[project]/node_modules/d3-array/src/quickselect.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>quickselect)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$sort$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/sort.js [client] (ecmascript)");
;
function quickselect(array, k, left = 0, right = Infinity, compare) {
    k = Math.floor(k);
    left = Math.floor(Math.max(0, left));
    right = Math.floor(Math.min(array.length - 1, right));
    if (!(left <= k && k <= right)) return array;
    compare = compare === undefined ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$sort$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ascendingDefined"] : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$sort$2e$js__$5b$client$5d$__$28$ecmascript$29$__["compareDefined"])(compare);
    while(right > left){
        if (right - left > 600) {
            const n = right - left + 1;
            const m = k - left + 1;
            const z = Math.log(n);
            const s = 0.5 * Math.exp(2 * z / 3);
            const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            quickselect(array, k, newLeft, newRight, compare);
        }
        const t = array[k];
        let i = left;
        let j = right;
        swap(array, left, k);
        if (compare(array[right], t) > 0) swap(array, left, right);
        while(i < j){
            swap(array, i, j), ++i, --j;
            while(compare(array[i], t) < 0)++i;
            while(compare(array[j], t) > 0)--j;
        }
        if (compare(array[left], t) === 0) swap(array, left, j);
        else ++j, swap(array, j, right);
        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
    }
    return array;
}
function swap(array, i, j) {
    const t = array[i];
    array[i] = array[j];
    array[j] = t;
}
}}),
"[project]/node_modules/d3-array/src/greatest.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>greatest)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ascending$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/ascending.js [client] (ecmascript)");
;
function greatest(values, compare = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ascending$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"]) {
    let max;
    let defined = false;
    if (compare.length === 1) {
        let maxValue;
        for (const element of values){
            const value = compare(element);
            if (defined ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ascending$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(value, maxValue) > 0 : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ascending$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(value, value) === 0) {
                max = element;
                maxValue = value;
                defined = true;
            }
        }
    } else {
        for (const value of values){
            if (defined ? compare(value, max) > 0 : compare(value, value) === 0) {
                max = value;
                defined = true;
            }
        }
    }
    return max;
}
}}),
"[project]/node_modules/d3-array/src/quantile.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>quantile),
    "quantileIndex": (()=>quantileIndex),
    "quantileSorted": (()=>quantileSorted)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$max$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/max.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$maxIndex$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/maxIndex.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$min$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/min.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$minIndex$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/minIndex.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$quickselect$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/quickselect.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$number$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/number.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$sort$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/sort.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$greatest$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/greatest.js [client] (ecmascript)");
;
;
;
;
;
;
;
;
function quantile(values, p, valueof) {
    values = Float64Array.from((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$number$2e$js__$5b$client$5d$__$28$ecmascript$29$__["numbers"])(values, valueof));
    if (!(n = values.length) || isNaN(p = +p)) return;
    if (p <= 0 || n < 2) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$min$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(values);
    if (p >= 1) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$max$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(values);
    var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$max$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$quickselect$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(values, i0).subarray(0, i0 + 1)), value1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$min$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(values.subarray(i0 + 1));
    return value0 + (value1 - value0) * (i - i0);
}
function quantileSorted(values, p, valueof = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$number$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"]) {
    if (!(n = values.length) || isNaN(p = +p)) return;
    if (p <= 0 || n < 2) return +valueof(values[0], 0, values);
    if (p >= 1) return +valueof(values[n - 1], n - 1, values);
    var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = +valueof(values[i0], i0, values), value1 = +valueof(values[i0 + 1], i0 + 1, values);
    return value0 + (value1 - value0) * (i - i0);
}
function quantileIndex(values, p, valueof = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$number$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"]) {
    if (isNaN(p = +p)) return;
    numbers = Float64Array.from(values, (_, i)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$number$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(valueof(values[i], i, values)));
    if (p <= 0) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$minIndex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(numbers);
    if (p >= 1) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$maxIndex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(numbers);
    var numbers, index = Uint32Array.from(values, (_, i)=>i), j = numbers.length - 1, i = Math.floor(j * p);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$quickselect$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(index, i, 0, j, (i, j)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$sort$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ascendingDefined"])(numbers[i], numbers[j]));
    i = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$greatest$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(index.subarray(0, i + 1), (i)=>numbers[i]);
    return i >= 0 ? i : -1;
}
}}),
"[project]/node_modules/d3-array/src/median.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>median),
    "medianIndex": (()=>medianIndex)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$quantile$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/quantile.js [client] (ecmascript)");
;
function median(values, valueof) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$quantile$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(values, 0.5, valueof);
}
function medianIndex(values, valueof) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$quantile$2e$js__$5b$client$5d$__$28$ecmascript$29$__["quantileIndex"])(values, 0.5, valueof);
}
}}),
"[project]/node_modules/d3-array/src/median.js [client] (ecmascript) <export default as median>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "median": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$median$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$median$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/median.js [client] (ecmascript)");
}}),
"[project]/node_modules/d3-array/src/variance.js [client] (ecmascript) <export default as variance>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "variance": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$variance$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$variance$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/variance.js [client] (ecmascript)");
}}),
"[project]/node_modules/d3-array/src/range.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>range)
});
function range(start, stop, step) {
    start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;
    var i = -1, n = Math.max(0, Math.ceil((stop - start) / step)) | 0, range = new Array(n);
    while(++i < n){
        range[i] = start + i * step;
    }
    return range;
}
}}),
"[project]/node_modules/d3-array/src/range.js [client] (ecmascript) <export default as range>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "range": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$range$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$range$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/range.js [client] (ecmascript)");
}}),
"[project]/node_modules/d3-array/src/ascending.js [client] (ecmascript) <export default as ascending>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "ascending": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ascending$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ascending$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/ascending.js [client] (ecmascript)");
}}),
"[project]/node_modules/d3-scale/src/init.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "initInterpolator": (()=>initInterpolator),
    "initRange": (()=>initRange)
});
function initRange(domain, range) {
    switch(arguments.length){
        case 0:
            break;
        case 1:
            this.range(domain);
            break;
        default:
            this.range(range).domain(domain);
            break;
    }
    return this;
}
function initInterpolator(domain, interpolator) {
    switch(arguments.length){
        case 0:
            break;
        case 1:
            {
                if (typeof domain === "function") this.interpolator(domain);
                else this.range(domain);
                break;
            }
        default:
            {
                this.domain(domain);
                if (typeof interpolator === "function") this.interpolator(interpolator);
                else this.range(interpolator);
                break;
            }
    }
    return this;
}
}}),
"[project]/node_modules/d3-scale/src/threshold.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>threshold)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$bisect$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__bisect$3e$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/bisect.js [client] (ecmascript) <export default as bisect>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$init$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-scale/src/init.js [client] (ecmascript)");
;
;
function threshold() {
    var domain = [
        0.5
    ], range = [
        0,
        1
    ], unknown, n = 1;
    function scale(x) {
        return x != null && x <= x ? range[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$bisect$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__bisect$3e$__["bisect"])(domain, x, 0, n)] : unknown;
    }
    scale.domain = function(_) {
        return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
    };
    scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
    };
    scale.invertExtent = function(y) {
        var i = range.indexOf(y);
        return [
            domain[i - 1],
            domain[i]
        ];
    };
    scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
    };
    scale.copy = function() {
        return threshold().domain(domain).range(range).unknown(unknown);
    };
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$init$2e$js__$5b$client$5d$__$28$ecmascript$29$__["initRange"].apply(scale, arguments);
}
}}),
"[project]/node_modules/d3-scale/src/threshold.js [client] (ecmascript) <export default as scaleThreshold>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "scaleThreshold": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$threshold$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$threshold$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-scale/src/threshold.js [client] (ecmascript)");
}}),
"[project]/node_modules/d3-scale/src/constant.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>constants)
});
function constants(x) {
    return function() {
        return x;
    };
}
}}),
"[project]/node_modules/d3-scale/src/number.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>number)
});
function number(x) {
    return +x;
}
}}),
"[project]/node_modules/d3-scale/src/continuous.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "copy": (()=>copy),
    "default": (()=>continuous),
    "identity": (()=>identity),
    "transformer": (()=>transformer)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$bisect$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__bisect$3e$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/bisect.js [client] (ecmascript) <export default as bisect>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$value$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__interpolate$3e$__ = __turbopack_context__.i("[project]/node_modules/d3-interpolate/src/value.js [client] (ecmascript) <export default as interpolate>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$number$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__interpolateNumber$3e$__ = __turbopack_context__.i("[project]/node_modules/d3-interpolate/src/number.js [client] (ecmascript) <export default as interpolateNumber>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$round$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__interpolateRound$3e$__ = __turbopack_context__.i("[project]/node_modules/d3-interpolate/src/round.js [client] (ecmascript) <export default as interpolateRound>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$constant$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-scale/src/constant.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$number$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-scale/src/number.js [client] (ecmascript)");
;
;
;
;
var unit = [
    0,
    1
];
function identity(x) {
    return x;
}
function normalize(a, b) {
    return (b -= a = +a) ? function(x) {
        return (x - a) / b;
    } : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$constant$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(isNaN(b) ? NaN : 0.5);
}
function clamper(a, b) {
    var t;
    if (a > b) t = a, a = b, b = t;
    return function(x) {
        return Math.max(a, Math.min(b, x));
    };
}
// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
function bimap(domain, range, interpolate) {
    var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
    if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
    else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
    return function(x) {
        return r0(d0(x));
    };
}
function polymap(domain, range, interpolate) {
    var j = Math.min(domain.length, range.length) - 1, d = new Array(j), r = new Array(j), i = -1;
    // Reverse descending domains.
    if (domain[j] < domain[0]) {
        domain = domain.slice().reverse();
        range = range.slice().reverse();
    }
    while(++i < j){
        d[i] = normalize(domain[i], domain[i + 1]);
        r[i] = interpolate(range[i], range[i + 1]);
    }
    return function(x) {
        var i = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$bisect$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__bisect$3e$__["bisect"])(domain, x, 1, j) - 1;
        return r[i](d[i](x));
    };
}
function copy(source, target) {
    return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer() {
    var domain = unit, range = unit, interpolate = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$value$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__interpolate$3e$__["interpolate"], transform, untransform, unknown, clamp = identity, piecewise, output, input;
    function rescale() {
        var n = Math.min(domain.length, range.length);
        if (clamp !== identity) clamp = clamper(domain[0], domain[n - 1]);
        piecewise = n > 2 ? polymap : bimap;
        output = input = null;
        return scale;
    }
    function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
    }
    scale.invert = function(y) {
        return clamp(untransform((input || (input = piecewise(range, domain.map(transform), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$number$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__interpolateNumber$3e$__["interpolateNumber"])))(y)));
    };
    scale.domain = function(_) {
        return arguments.length ? (domain = Array.from(_, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$number$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"]), rescale()) : domain.slice();
    };
    scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
    };
    scale.rangeRound = function(_) {
        return range = Array.from(_), interpolate = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$round$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__interpolateRound$3e$__["interpolateRound"], rescale();
    };
    scale.clamp = function(_) {
        return arguments.length ? (clamp = _ ? true : identity, rescale()) : clamp !== identity;
    };
    scale.interpolate = function(_) {
        return arguments.length ? (interpolate = _, rescale()) : interpolate;
    };
    scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
    };
    return function(t, u) {
        transform = t, untransform = u;
        return rescale();
    };
}
function continuous() {
    return transformer()(identity, identity);
}
}}),
"[project]/node_modules/d3-scale/src/tickFormat.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>tickFormat)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ticks$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/ticks.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$defaultLocale$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-format/src/defaultLocale.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$formatSpecifier$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__formatSpecifier$3e$__ = __turbopack_context__.i("[project]/node_modules/d3-format/src/formatSpecifier.js [client] (ecmascript) <export default as formatSpecifier>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$precisionFixed$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__precisionFixed$3e$__ = __turbopack_context__.i("[project]/node_modules/d3-format/src/precisionFixed.js [client] (ecmascript) <export default as precisionFixed>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$precisionPrefix$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__precisionPrefix$3e$__ = __turbopack_context__.i("[project]/node_modules/d3-format/src/precisionPrefix.js [client] (ecmascript) <export default as precisionPrefix>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$precisionRound$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__precisionRound$3e$__ = __turbopack_context__.i("[project]/node_modules/d3-format/src/precisionRound.js [client] (ecmascript) <export default as precisionRound>");
;
;
function tickFormat(start, stop, count, specifier) {
    var step = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ticks$2e$js__$5b$client$5d$__$28$ecmascript$29$__["tickStep"])(start, stop, count), precision;
    specifier = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$formatSpecifier$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__formatSpecifier$3e$__["formatSpecifier"])(specifier == null ? ",f" : specifier);
    switch(specifier.type){
        case "s":
            {
                var value = Math.max(Math.abs(start), Math.abs(stop));
                if (specifier.precision == null && !isNaN(precision = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$precisionPrefix$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__precisionPrefix$3e$__["precisionPrefix"])(step, value))) specifier.precision = precision;
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$defaultLocale$2e$js__$5b$client$5d$__$28$ecmascript$29$__["formatPrefix"])(specifier, value);
            }
        case "":
        case "e":
        case "g":
        case "p":
        case "r":
            {
                if (specifier.precision == null && !isNaN(precision = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$precisionRound$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__precisionRound$3e$__["precisionRound"])(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
                break;
            }
        case "f":
        case "%":
            {
                if (specifier.precision == null && !isNaN(precision = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$precisionFixed$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__precisionFixed$3e$__["precisionFixed"])(step))) specifier.precision = precision - (specifier.type === "%") * 2;
                break;
            }
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$defaultLocale$2e$js__$5b$client$5d$__$28$ecmascript$29$__["format"])(specifier);
}
}}),
"[project]/node_modules/d3-scale/src/linear.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>linear),
    "linearish": (()=>linearish)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ticks$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ticks$3e$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/ticks.js [client] (ecmascript) <export default as ticks>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ticks$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/ticks.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$continuous$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-scale/src/continuous.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$init$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-scale/src/init.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$tickFormat$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-scale/src/tickFormat.js [client] (ecmascript)");
;
;
;
;
function linearish(scale) {
    var domain = scale.domain;
    scale.ticks = function(count) {
        var d = domain();
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ticks$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ticks$3e$__["ticks"])(d[0], d[d.length - 1], count == null ? 10 : count);
    };
    scale.tickFormat = function(count, specifier) {
        var d = domain();
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$tickFormat$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
    };
    scale.nice = function(count) {
        if (count == null) count = 10;
        var d = domain();
        var i0 = 0;
        var i1 = d.length - 1;
        var start = d[i0];
        var stop = d[i1];
        var prestep;
        var step;
        var maxIter = 10;
        if (stop < start) {
            step = start, start = stop, stop = step;
            step = i0, i0 = i1, i1 = step;
        }
        while(maxIter-- > 0){
            step = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ticks$2e$js__$5b$client$5d$__$28$ecmascript$29$__["tickIncrement"])(start, stop, count);
            if (step === prestep) {
                d[i0] = start;
                d[i1] = stop;
                return domain(d);
            } else if (step > 0) {
                start = Math.floor(start / step) * step;
                stop = Math.ceil(stop / step) * step;
            } else if (step < 0) {
                start = Math.ceil(start * step) / step;
                stop = Math.floor(stop * step) / step;
            } else {
                break;
            }
            prestep = step;
        }
        return scale;
    };
    return scale;
}
function linear() {
    var scale = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$continuous$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])();
    scale.copy = function() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$continuous$2e$js__$5b$client$5d$__$28$ecmascript$29$__["copy"])(scale, linear());
    };
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$init$2e$js__$5b$client$5d$__$28$ecmascript$29$__["initRange"].apply(scale, arguments);
    return linearish(scale);
}
}}),
"[project]/node_modules/d3-scale/src/linear.js [client] (ecmascript) <export default as scaleLinear>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "scaleLinear": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$linear$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$linear$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-scale/src/linear.js [client] (ecmascript)");
}}),
"[project]/node_modules/d3-scale/src/ordinal.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>ordinal),
    "implicit": (()=>implicit)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$internmap$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/internmap/src/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$init$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-scale/src/init.js [client] (ecmascript)");
;
;
const implicit = Symbol("implicit");
function ordinal() {
    var index = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$internmap$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["InternMap"](), domain = [], range = [], unknown = implicit;
    function scale(d) {
        let i = index.get(d);
        if (i === undefined) {
            if (unknown !== implicit) return unknown;
            index.set(d, i = domain.push(d) - 1);
        }
        return range[i % range.length];
    }
    scale.domain = function(_) {
        if (!arguments.length) return domain.slice();
        domain = [], index = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$internmap$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["InternMap"]();
        for (const value of _){
            if (index.has(value)) continue;
            index.set(value, domain.push(value) - 1);
        }
        return scale;
    };
    scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), scale) : range.slice();
    };
    scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
    };
    scale.copy = function() {
        return ordinal(domain, range).unknown(unknown);
    };
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$init$2e$js__$5b$client$5d$__$28$ecmascript$29$__["initRange"].apply(scale, arguments);
    return scale;
}
}}),
"[project]/node_modules/d3-scale/src/ordinal.js [client] (ecmascript) <export default as scaleOrdinal>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "scaleOrdinal": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$ordinal$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$ordinal$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-scale/src/ordinal.js [client] (ecmascript)");
}}),
"[project]/node_modules/d3-scale/src/nice.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>nice)
});
function nice(domain, interval) {
    domain = domain.slice();
    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], t;
    if (x1 < x0) {
        t = i0, i0 = i1, i1 = t;
        t = x0, x0 = x1, x1 = t;
    }
    domain[i0] = interval.floor(x0);
    domain[i1] = interval.ceil(x1);
    return domain;
}
}}),
"[project]/node_modules/d3-scale/src/log.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>log),
    "loggish": (()=>loggish)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ticks$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ticks$3e$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/ticks.js [client] (ecmascript) <export default as ticks>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$defaultLocale$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-format/src/defaultLocale.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$formatSpecifier$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__formatSpecifier$3e$__ = __turbopack_context__.i("[project]/node_modules/d3-format/src/formatSpecifier.js [client] (ecmascript) <export default as formatSpecifier>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$nice$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-scale/src/nice.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$continuous$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-scale/src/continuous.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$init$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-scale/src/init.js [client] (ecmascript)");
;
;
;
;
;
function transformLog(x) {
    return Math.log(x);
}
function transformExp(x) {
    return Math.exp(x);
}
function transformLogn(x) {
    return -Math.log(-x);
}
function transformExpn(x) {
    return -Math.exp(-x);
}
function pow10(x) {
    return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}
function powp(base) {
    return base === 10 ? pow10 : base === Math.E ? Math.exp : (x)=>Math.pow(base, x);
}
function logp(base) {
    return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), (x)=>Math.log(x) / base);
}
function reflect(f) {
    return (x, k)=>-f(-x, k);
}
function loggish(transform) {
    const scale = transform(transformLog, transformExp);
    const domain = scale.domain;
    let base = 10;
    let logs;
    let pows;
    function rescale() {
        logs = logp(base), pows = powp(base);
        if (domain()[0] < 0) {
            logs = reflect(logs), pows = reflect(pows);
            transform(transformLogn, transformExpn);
        } else {
            transform(transformLog, transformExp);
        }
        return scale;
    }
    scale.base = function(_) {
        return arguments.length ? (base = +_, rescale()) : base;
    };
    scale.domain = function(_) {
        return arguments.length ? (domain(_), rescale()) : domain();
    };
    scale.ticks = (count)=>{
        const d = domain();
        let u = d[0];
        let v = d[d.length - 1];
        const r = v < u;
        if (r) [u, v] = [
            v,
            u
        ];
        let i = logs(u);
        let j = logs(v);
        let k;
        let t;
        const n = count == null ? 10 : +count;
        let z = [];
        if (!(base % 1) && j - i < n) {
            i = Math.floor(i), j = Math.ceil(j);
            if (u > 0) for(; i <= j; ++i){
                for(k = 1; k < base; ++k){
                    t = i < 0 ? k / pows(-i) : k * pows(i);
                    if (t < u) continue;
                    if (t > v) break;
                    z.push(t);
                }
            }
            else for(; i <= j; ++i){
                for(k = base - 1; k >= 1; --k){
                    t = i > 0 ? k / pows(-i) : k * pows(i);
                    if (t < u) continue;
                    if (t > v) break;
                    z.push(t);
                }
            }
            if (z.length * 2 < n) z = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ticks$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ticks$3e$__["ticks"])(u, v, n);
        } else {
            z = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ticks$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ticks$3e$__["ticks"])(i, j, Math.min(j - i, n)).map(pows);
        }
        return r ? z.reverse() : z;
    };
    scale.tickFormat = (count, specifier)=>{
        if (count == null) count = 10;
        if (specifier == null) specifier = base === 10 ? "s" : ",";
        if (typeof specifier !== "function") {
            if (!(base % 1) && (specifier = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$formatSpecifier$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__formatSpecifier$3e$__["formatSpecifier"])(specifier)).precision == null) specifier.trim = true;
            specifier = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$defaultLocale$2e$js__$5b$client$5d$__$28$ecmascript$29$__["format"])(specifier);
        }
        if (count === Infinity) return specifier;
        const k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
        return (d)=>{
            let i = d / pows(Math.round(logs(d)));
            if (i * base < base - 0.5) i *= base;
            return i <= k ? specifier(d) : "";
        };
    };
    scale.nice = ()=>{
        return domain((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$nice$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(domain(), {
            floor: (x)=>pows(Math.floor(logs(x))),
            ceil: (x)=>pows(Math.ceil(logs(x)))
        }));
    };
    return scale;
}
function log() {
    const scale = loggish((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$continuous$2e$js__$5b$client$5d$__$28$ecmascript$29$__["transformer"])()).domain([
        1,
        10
    ]);
    scale.copy = ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$continuous$2e$js__$5b$client$5d$__$28$ecmascript$29$__["copy"])(scale, log()).base(scale.base());
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$init$2e$js__$5b$client$5d$__$28$ecmascript$29$__["initRange"].apply(scale, arguments);
    return scale;
}
}}),
"[project]/node_modules/d3-scale/src/log.js [client] (ecmascript) <export default as scaleLog>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "scaleLog": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$log$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-scale/src/log.js [client] (ecmascript)");
}}),
"[project]/node_modules/d3-scale/src/band.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>band),
    "point": (()=>point)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$range$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__range$3e$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/range.js [client] (ecmascript) <export default as range>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$init$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-scale/src/init.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$ordinal$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-scale/src/ordinal.js [client] (ecmascript)");
;
;
;
function band() {
    var scale = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$ordinal$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])().unknown(undefined), domain = scale.domain, ordinalRange = scale.range, r0 = 0, r1 = 1, step, bandwidth, round = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
    delete scale.unknown;
    function rescale() {
        var n = domain().length, reverse = r1 < r0, start = reverse ? r1 : r0, stop = reverse ? r0 : r1;
        step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
        if (round) step = Math.floor(step);
        start += (stop - start - step * (n - paddingInner)) * align;
        bandwidth = step * (1 - paddingInner);
        if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
        var values = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$range$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__range$3e$__["range"])(n).map(function(i) {
            return start + step * i;
        });
        return ordinalRange(reverse ? values.reverse() : values);
    }
    scale.domain = function(_) {
        return arguments.length ? (domain(_), rescale()) : domain();
    };
    scale.range = function(_) {
        return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [
            r0,
            r1
        ];
    };
    scale.rangeRound = function(_) {
        return [r0, r1] = _, r0 = +r0, r1 = +r1, round = true, rescale();
    };
    scale.bandwidth = function() {
        return bandwidth;
    };
    scale.step = function() {
        return step;
    };
    scale.round = function(_) {
        return arguments.length ? (round = !!_, rescale()) : round;
    };
    scale.padding = function(_) {
        return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
    };
    scale.paddingInner = function(_) {
        return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
    };
    scale.paddingOuter = function(_) {
        return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
    };
    scale.align = function(_) {
        return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
    };
    scale.copy = function() {
        return band(domain(), [
            r0,
            r1
        ]).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
    };
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$init$2e$js__$5b$client$5d$__$28$ecmascript$29$__["initRange"].apply(rescale(), arguments);
}
function pointish(scale) {
    var copy = scale.copy;
    scale.padding = scale.paddingOuter;
    delete scale.paddingInner;
    delete scale.paddingOuter;
    scale.copy = function() {
        return pointish(copy());
    };
    return scale;
}
function point() {
    return pointish(band.apply(null, arguments).paddingInner(1));
}
}}),
"[project]/node_modules/d3-scale/src/band.js [client] (ecmascript) <export point as scalePoint>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "scalePoint": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$band$2e$js__$5b$client$5d$__$28$ecmascript$29$__["point"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$band$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-scale/src/band.js [client] (ecmascript)");
}}),
"[project]/node_modules/d3-scale/src/quantile.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>quantile)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ascending$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ascending$3e$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/ascending.js [client] (ecmascript) <export default as ascending>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$bisect$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__bisect$3e$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/bisect.js [client] (ecmascript) <export default as bisect>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$quantile$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/quantile.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$init$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-scale/src/init.js [client] (ecmascript)");
;
;
function quantile() {
    var domain = [], range = [], thresholds = [], unknown;
    function rescale() {
        var i = 0, n = Math.max(1, range.length);
        thresholds = new Array(n - 1);
        while(++i < n)thresholds[i - 1] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$quantile$2e$js__$5b$client$5d$__$28$ecmascript$29$__["quantileSorted"])(domain, i / n);
        return scale;
    }
    function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : range[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$bisect$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__bisect$3e$__["bisect"])(thresholds, x)];
    }
    scale.invertExtent = function(y) {
        var i = range.indexOf(y);
        return i < 0 ? [
            NaN,
            NaN
        ] : [
            i > 0 ? thresholds[i - 1] : domain[0],
            i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
        ];
    };
    scale.domain = function(_) {
        if (!arguments.length) return domain.slice();
        domain = [];
        for (let d of _)if (d != null && !isNaN(d = +d)) domain.push(d);
        domain.sort(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ascending$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ascending$3e$__["ascending"]);
        return rescale();
    };
    scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
    };
    scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
    };
    scale.quantiles = function() {
        return thresholds.slice();
    };
    scale.copy = function() {
        return quantile().domain(domain).range(range).unknown(unknown);
    };
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$init$2e$js__$5b$client$5d$__$28$ecmascript$29$__["initRange"].apply(scale, arguments);
}
}}),
"[project]/node_modules/d3-scale/src/quantile.js [client] (ecmascript) <export default as scaleQuantile>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "scaleQuantile": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$quantile$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$quantile$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-scale/src/quantile.js [client] (ecmascript)");
}}),
"[project]/node_modules/d3-scale/src/quantize.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>quantize)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$bisect$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__bisect$3e$__ = __turbopack_context__.i("[project]/node_modules/d3-array/src/bisect.js [client] (ecmascript) <export default as bisect>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$linear$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-scale/src/linear.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$init$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-scale/src/init.js [client] (ecmascript)");
;
;
;
function quantize() {
    var x0 = 0, x1 = 1, n = 1, domain = [
        0.5
    ], range = [
        0,
        1
    ], unknown;
    function scale(x) {
        return x != null && x <= x ? range[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$bisect$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__bisect$3e$__["bisect"])(domain, x, 0, n)] : unknown;
    }
    function rescale() {
        var i = -1;
        domain = new Array(n);
        while(++i < n)domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
        return scale;
    }
    scale.domain = function(_) {
        return arguments.length ? ([x0, x1] = _, x0 = +x0, x1 = +x1, rescale()) : [
            x0,
            x1
        ];
    };
    scale.range = function(_) {
        return arguments.length ? (n = (range = Array.from(_)).length - 1, rescale()) : range.slice();
    };
    scale.invertExtent = function(y) {
        var i = range.indexOf(y);
        return i < 0 ? [
            NaN,
            NaN
        ] : i < 1 ? [
            x0,
            domain[0]
        ] : i >= n ? [
            domain[n - 1],
            x1
        ] : [
            domain[i - 1],
            domain[i]
        ];
    };
    scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : scale;
    };
    scale.thresholds = function() {
        return domain.slice();
    };
    scale.copy = function() {
        return quantize().domain([
            x0,
            x1
        ]).range(range).unknown(unknown);
    };
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$init$2e$js__$5b$client$5d$__$28$ecmascript$29$__["initRange"].apply((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$linear$2e$js__$5b$client$5d$__$28$ecmascript$29$__["linearish"])(scale), arguments);
}
}}),
"[project]/node_modules/d3-scale/src/quantize.js [client] (ecmascript) <export default as scaleQuantize>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "scaleQuantize": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$quantize$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$quantize$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-scale/src/quantize.js [client] (ecmascript)");
}}),
"[project]/node_modules/d3-scale/src/pow.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>pow),
    "powish": (()=>powish),
    "sqrt": (()=>sqrt)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$linear$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-scale/src/linear.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$continuous$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-scale/src/continuous.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$init$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-scale/src/init.js [client] (ecmascript)");
;
;
;
function transformPow(exponent) {
    return function(x) {
        return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
    };
}
function transformSqrt(x) {
    return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
}
function transformSquare(x) {
    return x < 0 ? -x * x : x * x;
}
function powish(transform) {
    var scale = transform(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$continuous$2e$js__$5b$client$5d$__$28$ecmascript$29$__["identity"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$continuous$2e$js__$5b$client$5d$__$28$ecmascript$29$__["identity"]), exponent = 1;
    function rescale() {
        return exponent === 1 ? transform(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$continuous$2e$js__$5b$client$5d$__$28$ecmascript$29$__["identity"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$continuous$2e$js__$5b$client$5d$__$28$ecmascript$29$__["identity"]) : exponent === 0.5 ? transform(transformSqrt, transformSquare) : transform(transformPow(exponent), transformPow(1 / exponent));
    }
    scale.exponent = function(_) {
        return arguments.length ? (exponent = +_, rescale()) : exponent;
    };
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$linear$2e$js__$5b$client$5d$__$28$ecmascript$29$__["linearish"])(scale);
}
function pow() {
    var scale = powish((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$continuous$2e$js__$5b$client$5d$__$28$ecmascript$29$__["transformer"])());
    scale.copy = function() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$continuous$2e$js__$5b$client$5d$__$28$ecmascript$29$__["copy"])(scale, pow()).exponent(scale.exponent());
    };
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$init$2e$js__$5b$client$5d$__$28$ecmascript$29$__["initRange"].apply(scale, arguments);
    return scale;
}
function sqrt() {
    return pow.apply(null, arguments).exponent(0.5);
}
}}),
"[project]/node_modules/d3-scale/src/pow.js [client] (ecmascript) <export sqrt as scaleSqrt>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "scaleSqrt": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$pow$2e$js__$5b$client$5d$__$28$ecmascript$29$__["sqrt"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$scale$2f$src$2f$pow$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-scale/src/pow.js [client] (ecmascript)");
}}),
"[project]/node_modules/colorbrewer/index.es.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var index = {
    schemeGroups: {
        sequential: [
            "BuGn",
            "BuPu",
            "GnBu",
            "OrRd",
            "PuBu",
            "PuBuGn",
            "PuRd",
            "RdPu",
            "YlGn",
            "YlGnBu",
            "YlOrBr",
            "YlOrRd"
        ],
        singlehue: [
            "Blues",
            "Greens",
            "Greys",
            "Oranges",
            "Purples",
            "Reds"
        ],
        diverging: [
            "BrBG",
            "PiYG",
            "PRGn",
            "PuOr",
            "RdBu",
            "RdGy",
            "RdYlBu",
            "RdYlGn",
            "Spectral"
        ],
        qualitative: [
            "Accent",
            "Dark2",
            "Paired",
            "Pastel1",
            "Pastel2",
            "Set1",
            "Set2",
            "Set3"
        ]
    },
    YlGn: {
        3: [
            "#f7fcb9",
            "#addd8e",
            "#31a354"
        ],
        4: [
            "#ffffcc",
            "#c2e699",
            "#78c679",
            "#238443"
        ],
        5: [
            "#ffffcc",
            "#c2e699",
            "#78c679",
            "#31a354",
            "#006837"
        ],
        6: [
            "#ffffcc",
            "#d9f0a3",
            "#addd8e",
            "#78c679",
            "#31a354",
            "#006837"
        ],
        7: [
            "#ffffcc",
            "#d9f0a3",
            "#addd8e",
            "#78c679",
            "#41ab5d",
            "#238443",
            "#005a32"
        ],
        8: [
            "#ffffe5",
            "#f7fcb9",
            "#d9f0a3",
            "#addd8e",
            "#78c679",
            "#41ab5d",
            "#238443",
            "#005a32"
        ],
        9: [
            "#ffffe5",
            "#f7fcb9",
            "#d9f0a3",
            "#addd8e",
            "#78c679",
            "#41ab5d",
            "#238443",
            "#006837",
            "#004529"
        ]
    },
    YlGnBu: {
        3: [
            "#edf8b1",
            "#7fcdbb",
            "#2c7fb8"
        ],
        4: [
            "#ffffcc",
            "#a1dab4",
            "#41b6c4",
            "#225ea8"
        ],
        5: [
            "#ffffcc",
            "#a1dab4",
            "#41b6c4",
            "#2c7fb8",
            "#253494"
        ],
        6: [
            "#ffffcc",
            "#c7e9b4",
            "#7fcdbb",
            "#41b6c4",
            "#2c7fb8",
            "#253494"
        ],
        7: [
            "#ffffcc",
            "#c7e9b4",
            "#7fcdbb",
            "#41b6c4",
            "#1d91c0",
            "#225ea8",
            "#0c2c84"
        ],
        8: [
            "#ffffd9",
            "#edf8b1",
            "#c7e9b4",
            "#7fcdbb",
            "#41b6c4",
            "#1d91c0",
            "#225ea8",
            "#0c2c84"
        ],
        9: [
            "#ffffd9",
            "#edf8b1",
            "#c7e9b4",
            "#7fcdbb",
            "#41b6c4",
            "#1d91c0",
            "#225ea8",
            "#253494",
            "#081d58"
        ]
    },
    GnBu: {
        3: [
            "#e0f3db",
            "#a8ddb5",
            "#43a2ca"
        ],
        4: [
            "#f0f9e8",
            "#bae4bc",
            "#7bccc4",
            "#2b8cbe"
        ],
        5: [
            "#f0f9e8",
            "#bae4bc",
            "#7bccc4",
            "#43a2ca",
            "#0868ac"
        ],
        6: [
            "#f0f9e8",
            "#ccebc5",
            "#a8ddb5",
            "#7bccc4",
            "#43a2ca",
            "#0868ac"
        ],
        7: [
            "#f0f9e8",
            "#ccebc5",
            "#a8ddb5",
            "#7bccc4",
            "#4eb3d3",
            "#2b8cbe",
            "#08589e"
        ],
        8: [
            "#f7fcf0",
            "#e0f3db",
            "#ccebc5",
            "#a8ddb5",
            "#7bccc4",
            "#4eb3d3",
            "#2b8cbe",
            "#08589e"
        ],
        9: [
            "#f7fcf0",
            "#e0f3db",
            "#ccebc5",
            "#a8ddb5",
            "#7bccc4",
            "#4eb3d3",
            "#2b8cbe",
            "#0868ac",
            "#084081"
        ]
    },
    BuGn: {
        3: [
            "#e5f5f9",
            "#99d8c9",
            "#2ca25f"
        ],
        4: [
            "#edf8fb",
            "#b2e2e2",
            "#66c2a4",
            "#238b45"
        ],
        5: [
            "#edf8fb",
            "#b2e2e2",
            "#66c2a4",
            "#2ca25f",
            "#006d2c"
        ],
        6: [
            "#edf8fb",
            "#ccece6",
            "#99d8c9",
            "#66c2a4",
            "#2ca25f",
            "#006d2c"
        ],
        7: [
            "#edf8fb",
            "#ccece6",
            "#99d8c9",
            "#66c2a4",
            "#41ae76",
            "#238b45",
            "#005824"
        ],
        8: [
            "#f7fcfd",
            "#e5f5f9",
            "#ccece6",
            "#99d8c9",
            "#66c2a4",
            "#41ae76",
            "#238b45",
            "#005824"
        ],
        9: [
            "#f7fcfd",
            "#e5f5f9",
            "#ccece6",
            "#99d8c9",
            "#66c2a4",
            "#41ae76",
            "#238b45",
            "#006d2c",
            "#00441b"
        ]
    },
    PuBuGn: {
        3: [
            "#ece2f0",
            "#a6bddb",
            "#1c9099"
        ],
        4: [
            "#f6eff7",
            "#bdc9e1",
            "#67a9cf",
            "#02818a"
        ],
        5: [
            "#f6eff7",
            "#bdc9e1",
            "#67a9cf",
            "#1c9099",
            "#016c59"
        ],
        6: [
            "#f6eff7",
            "#d0d1e6",
            "#a6bddb",
            "#67a9cf",
            "#1c9099",
            "#016c59"
        ],
        7: [
            "#f6eff7",
            "#d0d1e6",
            "#a6bddb",
            "#67a9cf",
            "#3690c0",
            "#02818a",
            "#016450"
        ],
        8: [
            "#fff7fb",
            "#ece2f0",
            "#d0d1e6",
            "#a6bddb",
            "#67a9cf",
            "#3690c0",
            "#02818a",
            "#016450"
        ],
        9: [
            "#fff7fb",
            "#ece2f0",
            "#d0d1e6",
            "#a6bddb",
            "#67a9cf",
            "#3690c0",
            "#02818a",
            "#016c59",
            "#014636"
        ]
    },
    PuBu: {
        3: [
            "#ece7f2",
            "#a6bddb",
            "#2b8cbe"
        ],
        4: [
            "#f1eef6",
            "#bdc9e1",
            "#74a9cf",
            "#0570b0"
        ],
        5: [
            "#f1eef6",
            "#bdc9e1",
            "#74a9cf",
            "#2b8cbe",
            "#045a8d"
        ],
        6: [
            "#f1eef6",
            "#d0d1e6",
            "#a6bddb",
            "#74a9cf",
            "#2b8cbe",
            "#045a8d"
        ],
        7: [
            "#f1eef6",
            "#d0d1e6",
            "#a6bddb",
            "#74a9cf",
            "#3690c0",
            "#0570b0",
            "#034e7b"
        ],
        8: [
            "#fff7fb",
            "#ece7f2",
            "#d0d1e6",
            "#a6bddb",
            "#74a9cf",
            "#3690c0",
            "#0570b0",
            "#034e7b"
        ],
        9: [
            "#fff7fb",
            "#ece7f2",
            "#d0d1e6",
            "#a6bddb",
            "#74a9cf",
            "#3690c0",
            "#0570b0",
            "#045a8d",
            "#023858"
        ]
    },
    BuPu: {
        3: [
            "#e0ecf4",
            "#9ebcda",
            "#8856a7"
        ],
        4: [
            "#edf8fb",
            "#b3cde3",
            "#8c96c6",
            "#88419d"
        ],
        5: [
            "#edf8fb",
            "#b3cde3",
            "#8c96c6",
            "#8856a7",
            "#810f7c"
        ],
        6: [
            "#edf8fb",
            "#bfd3e6",
            "#9ebcda",
            "#8c96c6",
            "#8856a7",
            "#810f7c"
        ],
        7: [
            "#edf8fb",
            "#bfd3e6",
            "#9ebcda",
            "#8c96c6",
            "#8c6bb1",
            "#88419d",
            "#6e016b"
        ],
        8: [
            "#f7fcfd",
            "#e0ecf4",
            "#bfd3e6",
            "#9ebcda",
            "#8c96c6",
            "#8c6bb1",
            "#88419d",
            "#6e016b"
        ],
        9: [
            "#f7fcfd",
            "#e0ecf4",
            "#bfd3e6",
            "#9ebcda",
            "#8c96c6",
            "#8c6bb1",
            "#88419d",
            "#810f7c",
            "#4d004b"
        ]
    },
    RdPu: {
        3: [
            "#fde0dd",
            "#fa9fb5",
            "#c51b8a"
        ],
        4: [
            "#feebe2",
            "#fbb4b9",
            "#f768a1",
            "#ae017e"
        ],
        5: [
            "#feebe2",
            "#fbb4b9",
            "#f768a1",
            "#c51b8a",
            "#7a0177"
        ],
        6: [
            "#feebe2",
            "#fcc5c0",
            "#fa9fb5",
            "#f768a1",
            "#c51b8a",
            "#7a0177"
        ],
        7: [
            "#feebe2",
            "#fcc5c0",
            "#fa9fb5",
            "#f768a1",
            "#dd3497",
            "#ae017e",
            "#7a0177"
        ],
        8: [
            "#fff7f3",
            "#fde0dd",
            "#fcc5c0",
            "#fa9fb5",
            "#f768a1",
            "#dd3497",
            "#ae017e",
            "#7a0177"
        ],
        9: [
            "#fff7f3",
            "#fde0dd",
            "#fcc5c0",
            "#fa9fb5",
            "#f768a1",
            "#dd3497",
            "#ae017e",
            "#7a0177",
            "#49006a"
        ]
    },
    PuRd: {
        3: [
            "#e7e1ef",
            "#c994c7",
            "#dd1c77"
        ],
        4: [
            "#f1eef6",
            "#d7b5d8",
            "#df65b0",
            "#ce1256"
        ],
        5: [
            "#f1eef6",
            "#d7b5d8",
            "#df65b0",
            "#dd1c77",
            "#980043"
        ],
        6: [
            "#f1eef6",
            "#d4b9da",
            "#c994c7",
            "#df65b0",
            "#dd1c77",
            "#980043"
        ],
        7: [
            "#f1eef6",
            "#d4b9da",
            "#c994c7",
            "#df65b0",
            "#e7298a",
            "#ce1256",
            "#91003f"
        ],
        8: [
            "#f7f4f9",
            "#e7e1ef",
            "#d4b9da",
            "#c994c7",
            "#df65b0",
            "#e7298a",
            "#ce1256",
            "#91003f"
        ],
        9: [
            "#f7f4f9",
            "#e7e1ef",
            "#d4b9da",
            "#c994c7",
            "#df65b0",
            "#e7298a",
            "#ce1256",
            "#980043",
            "#67001f"
        ]
    },
    OrRd: {
        3: [
            "#fee8c8",
            "#fdbb84",
            "#e34a33"
        ],
        4: [
            "#fef0d9",
            "#fdcc8a",
            "#fc8d59",
            "#d7301f"
        ],
        5: [
            "#fef0d9",
            "#fdcc8a",
            "#fc8d59",
            "#e34a33",
            "#b30000"
        ],
        6: [
            "#fef0d9",
            "#fdd49e",
            "#fdbb84",
            "#fc8d59",
            "#e34a33",
            "#b30000"
        ],
        7: [
            "#fef0d9",
            "#fdd49e",
            "#fdbb84",
            "#fc8d59",
            "#ef6548",
            "#d7301f",
            "#990000"
        ],
        8: [
            "#fff7ec",
            "#fee8c8",
            "#fdd49e",
            "#fdbb84",
            "#fc8d59",
            "#ef6548",
            "#d7301f",
            "#990000"
        ],
        9: [
            "#fff7ec",
            "#fee8c8",
            "#fdd49e",
            "#fdbb84",
            "#fc8d59",
            "#ef6548",
            "#d7301f",
            "#b30000",
            "#7f0000"
        ]
    },
    YlOrRd: {
        3: [
            "#ffeda0",
            "#feb24c",
            "#f03b20"
        ],
        4: [
            "#ffffb2",
            "#fecc5c",
            "#fd8d3c",
            "#e31a1c"
        ],
        5: [
            "#ffffb2",
            "#fecc5c",
            "#fd8d3c",
            "#f03b20",
            "#bd0026"
        ],
        6: [
            "#ffffb2",
            "#fed976",
            "#feb24c",
            "#fd8d3c",
            "#f03b20",
            "#bd0026"
        ],
        7: [
            "#ffffb2",
            "#fed976",
            "#feb24c",
            "#fd8d3c",
            "#fc4e2a",
            "#e31a1c",
            "#b10026"
        ],
        8: [
            "#ffffcc",
            "#ffeda0",
            "#fed976",
            "#feb24c",
            "#fd8d3c",
            "#fc4e2a",
            "#e31a1c",
            "#b10026"
        ],
        9: [
            "#ffffcc",
            "#ffeda0",
            "#fed976",
            "#feb24c",
            "#fd8d3c",
            "#fc4e2a",
            "#e31a1c",
            "#bd0026",
            "#800026"
        ]
    },
    YlOrBr: {
        3: [
            "#fff7bc",
            "#fec44f",
            "#d95f0e"
        ],
        4: [
            "#ffffd4",
            "#fed98e",
            "#fe9929",
            "#cc4c02"
        ],
        5: [
            "#ffffd4",
            "#fed98e",
            "#fe9929",
            "#d95f0e",
            "#993404"
        ],
        6: [
            "#ffffd4",
            "#fee391",
            "#fec44f",
            "#fe9929",
            "#d95f0e",
            "#993404"
        ],
        7: [
            "#ffffd4",
            "#fee391",
            "#fec44f",
            "#fe9929",
            "#ec7014",
            "#cc4c02",
            "#8c2d04"
        ],
        8: [
            "#ffffe5",
            "#fff7bc",
            "#fee391",
            "#fec44f",
            "#fe9929",
            "#ec7014",
            "#cc4c02",
            "#8c2d04"
        ],
        9: [
            "#ffffe5",
            "#fff7bc",
            "#fee391",
            "#fec44f",
            "#fe9929",
            "#ec7014",
            "#cc4c02",
            "#993404",
            "#662506"
        ]
    },
    Purples: {
        3: [
            "#efedf5",
            "#bcbddc",
            "#756bb1"
        ],
        4: [
            "#f2f0f7",
            "#cbc9e2",
            "#9e9ac8",
            "#6a51a3"
        ],
        5: [
            "#f2f0f7",
            "#cbc9e2",
            "#9e9ac8",
            "#756bb1",
            "#54278f"
        ],
        6: [
            "#f2f0f7",
            "#dadaeb",
            "#bcbddc",
            "#9e9ac8",
            "#756bb1",
            "#54278f"
        ],
        7: [
            "#f2f0f7",
            "#dadaeb",
            "#bcbddc",
            "#9e9ac8",
            "#807dba",
            "#6a51a3",
            "#4a1486"
        ],
        8: [
            "#fcfbfd",
            "#efedf5",
            "#dadaeb",
            "#bcbddc",
            "#9e9ac8",
            "#807dba",
            "#6a51a3",
            "#4a1486"
        ],
        9: [
            "#fcfbfd",
            "#efedf5",
            "#dadaeb",
            "#bcbddc",
            "#9e9ac8",
            "#807dba",
            "#6a51a3",
            "#54278f",
            "#3f007d"
        ]
    },
    Blues: {
        3: [
            "#deebf7",
            "#9ecae1",
            "#3182bd"
        ],
        4: [
            "#eff3ff",
            "#bdd7e7",
            "#6baed6",
            "#2171b5"
        ],
        5: [
            "#eff3ff",
            "#bdd7e7",
            "#6baed6",
            "#3182bd",
            "#08519c"
        ],
        6: [
            "#eff3ff",
            "#c6dbef",
            "#9ecae1",
            "#6baed6",
            "#3182bd",
            "#08519c"
        ],
        7: [
            "#eff3ff",
            "#c6dbef",
            "#9ecae1",
            "#6baed6",
            "#4292c6",
            "#2171b5",
            "#084594"
        ],
        8: [
            "#f7fbff",
            "#deebf7",
            "#c6dbef",
            "#9ecae1",
            "#6baed6",
            "#4292c6",
            "#2171b5",
            "#084594"
        ],
        9: [
            "#f7fbff",
            "#deebf7",
            "#c6dbef",
            "#9ecae1",
            "#6baed6",
            "#4292c6",
            "#2171b5",
            "#08519c",
            "#08306b"
        ]
    },
    Greens: {
        3: [
            "#e5f5e0",
            "#a1d99b",
            "#31a354"
        ],
        4: [
            "#edf8e9",
            "#bae4b3",
            "#74c476",
            "#238b45"
        ],
        5: [
            "#edf8e9",
            "#bae4b3",
            "#74c476",
            "#31a354",
            "#006d2c"
        ],
        6: [
            "#edf8e9",
            "#c7e9c0",
            "#a1d99b",
            "#74c476",
            "#31a354",
            "#006d2c"
        ],
        7: [
            "#edf8e9",
            "#c7e9c0",
            "#a1d99b",
            "#74c476",
            "#41ab5d",
            "#238b45",
            "#005a32"
        ],
        8: [
            "#f7fcf5",
            "#e5f5e0",
            "#c7e9c0",
            "#a1d99b",
            "#74c476",
            "#41ab5d",
            "#238b45",
            "#005a32"
        ],
        9: [
            "#f7fcf5",
            "#e5f5e0",
            "#c7e9c0",
            "#a1d99b",
            "#74c476",
            "#41ab5d",
            "#238b45",
            "#006d2c",
            "#00441b"
        ]
    },
    Oranges: {
        3: [
            "#fee6ce",
            "#fdae6b",
            "#e6550d"
        ],
        4: [
            "#feedde",
            "#fdbe85",
            "#fd8d3c",
            "#d94701"
        ],
        5: [
            "#feedde",
            "#fdbe85",
            "#fd8d3c",
            "#e6550d",
            "#a63603"
        ],
        6: [
            "#feedde",
            "#fdd0a2",
            "#fdae6b",
            "#fd8d3c",
            "#e6550d",
            "#a63603"
        ],
        7: [
            "#feedde",
            "#fdd0a2",
            "#fdae6b",
            "#fd8d3c",
            "#f16913",
            "#d94801",
            "#8c2d04"
        ],
        8: [
            "#fff5eb",
            "#fee6ce",
            "#fdd0a2",
            "#fdae6b",
            "#fd8d3c",
            "#f16913",
            "#d94801",
            "#8c2d04"
        ],
        9: [
            "#fff5eb",
            "#fee6ce",
            "#fdd0a2",
            "#fdae6b",
            "#fd8d3c",
            "#f16913",
            "#d94801",
            "#a63603",
            "#7f2704"
        ]
    },
    Reds: {
        3: [
            "#fee0d2",
            "#fc9272",
            "#de2d26"
        ],
        4: [
            "#fee5d9",
            "#fcae91",
            "#fb6a4a",
            "#cb181d"
        ],
        5: [
            "#fee5d9",
            "#fcae91",
            "#fb6a4a",
            "#de2d26",
            "#a50f15"
        ],
        6: [
            "#fee5d9",
            "#fcbba1",
            "#fc9272",
            "#fb6a4a",
            "#de2d26",
            "#a50f15"
        ],
        7: [
            "#fee5d9",
            "#fcbba1",
            "#fc9272",
            "#fb6a4a",
            "#ef3b2c",
            "#cb181d",
            "#99000d"
        ],
        8: [
            "#fff5f0",
            "#fee0d2",
            "#fcbba1",
            "#fc9272",
            "#fb6a4a",
            "#ef3b2c",
            "#cb181d",
            "#99000d"
        ],
        9: [
            "#fff5f0",
            "#fee0d2",
            "#fcbba1",
            "#fc9272",
            "#fb6a4a",
            "#ef3b2c",
            "#cb181d",
            "#a50f15",
            "#67000d"
        ]
    },
    Greys: {
        3: [
            "#f0f0f0",
            "#bdbdbd",
            "#636363"
        ],
        4: [
            "#f7f7f7",
            "#cccccc",
            "#969696",
            "#525252"
        ],
        5: [
            "#f7f7f7",
            "#cccccc",
            "#969696",
            "#636363",
            "#252525"
        ],
        6: [
            "#f7f7f7",
            "#d9d9d9",
            "#bdbdbd",
            "#969696",
            "#636363",
            "#252525"
        ],
        7: [
            "#f7f7f7",
            "#d9d9d9",
            "#bdbdbd",
            "#969696",
            "#737373",
            "#525252",
            "#252525"
        ],
        8: [
            "#ffffff",
            "#f0f0f0",
            "#d9d9d9",
            "#bdbdbd",
            "#969696",
            "#737373",
            "#525252",
            "#252525"
        ],
        9: [
            "#ffffff",
            "#f0f0f0",
            "#d9d9d9",
            "#bdbdbd",
            "#969696",
            "#737373",
            "#525252",
            "#252525",
            "#000000"
        ]
    },
    PuOr: {
        3: [
            "#f1a340",
            "#f7f7f7",
            "#998ec3"
        ],
        4: [
            "#e66101",
            "#fdb863",
            "#b2abd2",
            "#5e3c99"
        ],
        5: [
            "#e66101",
            "#fdb863",
            "#f7f7f7",
            "#b2abd2",
            "#5e3c99"
        ],
        6: [
            "#b35806",
            "#f1a340",
            "#fee0b6",
            "#d8daeb",
            "#998ec3",
            "#542788"
        ],
        7: [
            "#b35806",
            "#f1a340",
            "#fee0b6",
            "#f7f7f7",
            "#d8daeb",
            "#998ec3",
            "#542788"
        ],
        8: [
            "#b35806",
            "#e08214",
            "#fdb863",
            "#fee0b6",
            "#d8daeb",
            "#b2abd2",
            "#8073ac",
            "#542788"
        ],
        9: [
            "#b35806",
            "#e08214",
            "#fdb863",
            "#fee0b6",
            "#f7f7f7",
            "#d8daeb",
            "#b2abd2",
            "#8073ac",
            "#542788"
        ],
        10: [
            "#7f3b08",
            "#b35806",
            "#e08214",
            "#fdb863",
            "#fee0b6",
            "#d8daeb",
            "#b2abd2",
            "#8073ac",
            "#542788",
            "#2d004b"
        ],
        11: [
            "#7f3b08",
            "#b35806",
            "#e08214",
            "#fdb863",
            "#fee0b6",
            "#f7f7f7",
            "#d8daeb",
            "#b2abd2",
            "#8073ac",
            "#542788",
            "#2d004b"
        ]
    },
    BrBG: {
        3: [
            "#d8b365",
            "#f5f5f5",
            "#5ab4ac"
        ],
        4: [
            "#a6611a",
            "#dfc27d",
            "#80cdc1",
            "#018571"
        ],
        5: [
            "#a6611a",
            "#dfc27d",
            "#f5f5f5",
            "#80cdc1",
            "#018571"
        ],
        6: [
            "#8c510a",
            "#d8b365",
            "#f6e8c3",
            "#c7eae5",
            "#5ab4ac",
            "#01665e"
        ],
        7: [
            "#8c510a",
            "#d8b365",
            "#f6e8c3",
            "#f5f5f5",
            "#c7eae5",
            "#5ab4ac",
            "#01665e"
        ],
        8: [
            "#8c510a",
            "#bf812d",
            "#dfc27d",
            "#f6e8c3",
            "#c7eae5",
            "#80cdc1",
            "#35978f",
            "#01665e"
        ],
        9: [
            "#8c510a",
            "#bf812d",
            "#dfc27d",
            "#f6e8c3",
            "#f5f5f5",
            "#c7eae5",
            "#80cdc1",
            "#35978f",
            "#01665e"
        ],
        10: [
            "#543005",
            "#8c510a",
            "#bf812d",
            "#dfc27d",
            "#f6e8c3",
            "#c7eae5",
            "#80cdc1",
            "#35978f",
            "#01665e",
            "#003c30"
        ],
        11: [
            "#543005",
            "#8c510a",
            "#bf812d",
            "#dfc27d",
            "#f6e8c3",
            "#f5f5f5",
            "#c7eae5",
            "#80cdc1",
            "#35978f",
            "#01665e",
            "#003c30"
        ]
    },
    PRGn: {
        3: [
            "#af8dc3",
            "#f7f7f7",
            "#7fbf7b"
        ],
        4: [
            "#7b3294",
            "#c2a5cf",
            "#a6dba0",
            "#008837"
        ],
        5: [
            "#7b3294",
            "#c2a5cf",
            "#f7f7f7",
            "#a6dba0",
            "#008837"
        ],
        6: [
            "#762a83",
            "#af8dc3",
            "#e7d4e8",
            "#d9f0d3",
            "#7fbf7b",
            "#1b7837"
        ],
        7: [
            "#762a83",
            "#af8dc3",
            "#e7d4e8",
            "#f7f7f7",
            "#d9f0d3",
            "#7fbf7b",
            "#1b7837"
        ],
        8: [
            "#762a83",
            "#9970ab",
            "#c2a5cf",
            "#e7d4e8",
            "#d9f0d3",
            "#a6dba0",
            "#5aae61",
            "#1b7837"
        ],
        9: [
            "#762a83",
            "#9970ab",
            "#c2a5cf",
            "#e7d4e8",
            "#f7f7f7",
            "#d9f0d3",
            "#a6dba0",
            "#5aae61",
            "#1b7837"
        ],
        10: [
            "#40004b",
            "#762a83",
            "#9970ab",
            "#c2a5cf",
            "#e7d4e8",
            "#d9f0d3",
            "#a6dba0",
            "#5aae61",
            "#1b7837",
            "#00441b"
        ],
        11: [
            "#40004b",
            "#762a83",
            "#9970ab",
            "#c2a5cf",
            "#e7d4e8",
            "#f7f7f7",
            "#d9f0d3",
            "#a6dba0",
            "#5aae61",
            "#1b7837",
            "#00441b"
        ]
    },
    PiYG: {
        3: [
            "#e9a3c9",
            "#f7f7f7",
            "#a1d76a"
        ],
        4: [
            "#d01c8b",
            "#f1b6da",
            "#b8e186",
            "#4dac26"
        ],
        5: [
            "#d01c8b",
            "#f1b6da",
            "#f7f7f7",
            "#b8e186",
            "#4dac26"
        ],
        6: [
            "#c51b7d",
            "#e9a3c9",
            "#fde0ef",
            "#e6f5d0",
            "#a1d76a",
            "#4d9221"
        ],
        7: [
            "#c51b7d",
            "#e9a3c9",
            "#fde0ef",
            "#f7f7f7",
            "#e6f5d0",
            "#a1d76a",
            "#4d9221"
        ],
        8: [
            "#c51b7d",
            "#de77ae",
            "#f1b6da",
            "#fde0ef",
            "#e6f5d0",
            "#b8e186",
            "#7fbc41",
            "#4d9221"
        ],
        9: [
            "#c51b7d",
            "#de77ae",
            "#f1b6da",
            "#fde0ef",
            "#f7f7f7",
            "#e6f5d0",
            "#b8e186",
            "#7fbc41",
            "#4d9221"
        ],
        10: [
            "#8e0152",
            "#c51b7d",
            "#de77ae",
            "#f1b6da",
            "#fde0ef",
            "#e6f5d0",
            "#b8e186",
            "#7fbc41",
            "#4d9221",
            "#276419"
        ],
        11: [
            "#8e0152",
            "#c51b7d",
            "#de77ae",
            "#f1b6da",
            "#fde0ef",
            "#f7f7f7",
            "#e6f5d0",
            "#b8e186",
            "#7fbc41",
            "#4d9221",
            "#276419"
        ]
    },
    RdBu: {
        3: [
            "#ef8a62",
            "#f7f7f7",
            "#67a9cf"
        ],
        4: [
            "#ca0020",
            "#f4a582",
            "#92c5de",
            "#0571b0"
        ],
        5: [
            "#ca0020",
            "#f4a582",
            "#f7f7f7",
            "#92c5de",
            "#0571b0"
        ],
        6: [
            "#b2182b",
            "#ef8a62",
            "#fddbc7",
            "#d1e5f0",
            "#67a9cf",
            "#2166ac"
        ],
        7: [
            "#b2182b",
            "#ef8a62",
            "#fddbc7",
            "#f7f7f7",
            "#d1e5f0",
            "#67a9cf",
            "#2166ac"
        ],
        8: [
            "#b2182b",
            "#d6604d",
            "#f4a582",
            "#fddbc7",
            "#d1e5f0",
            "#92c5de",
            "#4393c3",
            "#2166ac"
        ],
        9: [
            "#b2182b",
            "#d6604d",
            "#f4a582",
            "#fddbc7",
            "#f7f7f7",
            "#d1e5f0",
            "#92c5de",
            "#4393c3",
            "#2166ac"
        ],
        10: [
            "#67001f",
            "#b2182b",
            "#d6604d",
            "#f4a582",
            "#fddbc7",
            "#d1e5f0",
            "#92c5de",
            "#4393c3",
            "#2166ac",
            "#053061"
        ],
        11: [
            "#67001f",
            "#b2182b",
            "#d6604d",
            "#f4a582",
            "#fddbc7",
            "#f7f7f7",
            "#d1e5f0",
            "#92c5de",
            "#4393c3",
            "#2166ac",
            "#053061"
        ]
    },
    RdGy: {
        3: [
            "#ef8a62",
            "#ffffff",
            "#999999"
        ],
        4: [
            "#ca0020",
            "#f4a582",
            "#bababa",
            "#404040"
        ],
        5: [
            "#ca0020",
            "#f4a582",
            "#ffffff",
            "#bababa",
            "#404040"
        ],
        6: [
            "#b2182b",
            "#ef8a62",
            "#fddbc7",
            "#e0e0e0",
            "#999999",
            "#4d4d4d"
        ],
        7: [
            "#b2182b",
            "#ef8a62",
            "#fddbc7",
            "#ffffff",
            "#e0e0e0",
            "#999999",
            "#4d4d4d"
        ],
        8: [
            "#b2182b",
            "#d6604d",
            "#f4a582",
            "#fddbc7",
            "#e0e0e0",
            "#bababa",
            "#878787",
            "#4d4d4d"
        ],
        9: [
            "#b2182b",
            "#d6604d",
            "#f4a582",
            "#fddbc7",
            "#ffffff",
            "#e0e0e0",
            "#bababa",
            "#878787",
            "#4d4d4d"
        ],
        10: [
            "#67001f",
            "#b2182b",
            "#d6604d",
            "#f4a582",
            "#fddbc7",
            "#e0e0e0",
            "#bababa",
            "#878787",
            "#4d4d4d",
            "#1a1a1a"
        ],
        11: [
            "#67001f",
            "#b2182b",
            "#d6604d",
            "#f4a582",
            "#fddbc7",
            "#ffffff",
            "#e0e0e0",
            "#bababa",
            "#878787",
            "#4d4d4d",
            "#1a1a1a"
        ]
    },
    RdYlBu: {
        3: [
            "#fc8d59",
            "#ffffbf",
            "#91bfdb"
        ],
        4: [
            "#d7191c",
            "#fdae61",
            "#abd9e9",
            "#2c7bb6"
        ],
        5: [
            "#d7191c",
            "#fdae61",
            "#ffffbf",
            "#abd9e9",
            "#2c7bb6"
        ],
        6: [
            "#d73027",
            "#fc8d59",
            "#fee090",
            "#e0f3f8",
            "#91bfdb",
            "#4575b4"
        ],
        7: [
            "#d73027",
            "#fc8d59",
            "#fee090",
            "#ffffbf",
            "#e0f3f8",
            "#91bfdb",
            "#4575b4"
        ],
        8: [
            "#d73027",
            "#f46d43",
            "#fdae61",
            "#fee090",
            "#e0f3f8",
            "#abd9e9",
            "#74add1",
            "#4575b4"
        ],
        9: [
            "#d73027",
            "#f46d43",
            "#fdae61",
            "#fee090",
            "#ffffbf",
            "#e0f3f8",
            "#abd9e9",
            "#74add1",
            "#4575b4"
        ],
        10: [
            "#a50026",
            "#d73027",
            "#f46d43",
            "#fdae61",
            "#fee090",
            "#e0f3f8",
            "#abd9e9",
            "#74add1",
            "#4575b4",
            "#313695"
        ],
        11: [
            "#a50026",
            "#d73027",
            "#f46d43",
            "#fdae61",
            "#fee090",
            "#ffffbf",
            "#e0f3f8",
            "#abd9e9",
            "#74add1",
            "#4575b4",
            "#313695"
        ]
    },
    Spectral: {
        3: [
            "#fc8d59",
            "#ffffbf",
            "#99d594"
        ],
        4: [
            "#d7191c",
            "#fdae61",
            "#abdda4",
            "#2b83ba"
        ],
        5: [
            "#d7191c",
            "#fdae61",
            "#ffffbf",
            "#abdda4",
            "#2b83ba"
        ],
        6: [
            "#d53e4f",
            "#fc8d59",
            "#fee08b",
            "#e6f598",
            "#99d594",
            "#3288bd"
        ],
        7: [
            "#d53e4f",
            "#fc8d59",
            "#fee08b",
            "#ffffbf",
            "#e6f598",
            "#99d594",
            "#3288bd"
        ],
        8: [
            "#d53e4f",
            "#f46d43",
            "#fdae61",
            "#fee08b",
            "#e6f598",
            "#abdda4",
            "#66c2a5",
            "#3288bd"
        ],
        9: [
            "#d53e4f",
            "#f46d43",
            "#fdae61",
            "#fee08b",
            "#ffffbf",
            "#e6f598",
            "#abdda4",
            "#66c2a5",
            "#3288bd"
        ],
        10: [
            "#9e0142",
            "#d53e4f",
            "#f46d43",
            "#fdae61",
            "#fee08b",
            "#e6f598",
            "#abdda4",
            "#66c2a5",
            "#3288bd",
            "#5e4fa2"
        ],
        11: [
            "#9e0142",
            "#d53e4f",
            "#f46d43",
            "#fdae61",
            "#fee08b",
            "#ffffbf",
            "#e6f598",
            "#abdda4",
            "#66c2a5",
            "#3288bd",
            "#5e4fa2"
        ]
    },
    RdYlGn: {
        3: [
            "#fc8d59",
            "#ffffbf",
            "#91cf60"
        ],
        4: [
            "#d7191c",
            "#fdae61",
            "#a6d96a",
            "#1a9641"
        ],
        5: [
            "#d7191c",
            "#fdae61",
            "#ffffbf",
            "#a6d96a",
            "#1a9641"
        ],
        6: [
            "#d73027",
            "#fc8d59",
            "#fee08b",
            "#d9ef8b",
            "#91cf60",
            "#1a9850"
        ],
        7: [
            "#d73027",
            "#fc8d59",
            "#fee08b",
            "#ffffbf",
            "#d9ef8b",
            "#91cf60",
            "#1a9850"
        ],
        8: [
            "#d73027",
            "#f46d43",
            "#fdae61",
            "#fee08b",
            "#d9ef8b",
            "#a6d96a",
            "#66bd63",
            "#1a9850"
        ],
        9: [
            "#d73027",
            "#f46d43",
            "#fdae61",
            "#fee08b",
            "#ffffbf",
            "#d9ef8b",
            "#a6d96a",
            "#66bd63",
            "#1a9850"
        ],
        10: [
            "#a50026",
            "#d73027",
            "#f46d43",
            "#fdae61",
            "#fee08b",
            "#d9ef8b",
            "#a6d96a",
            "#66bd63",
            "#1a9850",
            "#006837"
        ],
        11: [
            "#a50026",
            "#d73027",
            "#f46d43",
            "#fdae61",
            "#fee08b",
            "#ffffbf",
            "#d9ef8b",
            "#a6d96a",
            "#66bd63",
            "#1a9850",
            "#006837"
        ]
    },
    Accent: {
        3: [
            "#7fc97f",
            "#beaed4",
            "#fdc086"
        ],
        4: [
            "#7fc97f",
            "#beaed4",
            "#fdc086",
            "#ffff99"
        ],
        5: [
            "#7fc97f",
            "#beaed4",
            "#fdc086",
            "#ffff99",
            "#386cb0"
        ],
        6: [
            "#7fc97f",
            "#beaed4",
            "#fdc086",
            "#ffff99",
            "#386cb0",
            "#f0027f"
        ],
        7: [
            "#7fc97f",
            "#beaed4",
            "#fdc086",
            "#ffff99",
            "#386cb0",
            "#f0027f",
            "#bf5b17"
        ],
        8: [
            "#7fc97f",
            "#beaed4",
            "#fdc086",
            "#ffff99",
            "#386cb0",
            "#f0027f",
            "#bf5b17",
            "#666666"
        ]
    },
    Dark2: {
        3: [
            "#1b9e77",
            "#d95f02",
            "#7570b3"
        ],
        4: [
            "#1b9e77",
            "#d95f02",
            "#7570b3",
            "#e7298a"
        ],
        5: [
            "#1b9e77",
            "#d95f02",
            "#7570b3",
            "#e7298a",
            "#66a61e"
        ],
        6: [
            "#1b9e77",
            "#d95f02",
            "#7570b3",
            "#e7298a",
            "#66a61e",
            "#e6ab02"
        ],
        7: [
            "#1b9e77",
            "#d95f02",
            "#7570b3",
            "#e7298a",
            "#66a61e",
            "#e6ab02",
            "#a6761d"
        ],
        8: [
            "#1b9e77",
            "#d95f02",
            "#7570b3",
            "#e7298a",
            "#66a61e",
            "#e6ab02",
            "#a6761d",
            "#666666"
        ]
    },
    Paired: {
        3: [
            "#a6cee3",
            "#1f78b4",
            "#b2df8a"
        ],
        4: [
            "#a6cee3",
            "#1f78b4",
            "#b2df8a",
            "#33a02c"
        ],
        5: [
            "#a6cee3",
            "#1f78b4",
            "#b2df8a",
            "#33a02c",
            "#fb9a99"
        ],
        6: [
            "#a6cee3",
            "#1f78b4",
            "#b2df8a",
            "#33a02c",
            "#fb9a99",
            "#e31a1c"
        ],
        7: [
            "#a6cee3",
            "#1f78b4",
            "#b2df8a",
            "#33a02c",
            "#fb9a99",
            "#e31a1c",
            "#fdbf6f"
        ],
        8: [
            "#a6cee3",
            "#1f78b4",
            "#b2df8a",
            "#33a02c",
            "#fb9a99",
            "#e31a1c",
            "#fdbf6f",
            "#ff7f00"
        ],
        9: [
            "#a6cee3",
            "#1f78b4",
            "#b2df8a",
            "#33a02c",
            "#fb9a99",
            "#e31a1c",
            "#fdbf6f",
            "#ff7f00",
            "#cab2d6"
        ],
        10: [
            "#a6cee3",
            "#1f78b4",
            "#b2df8a",
            "#33a02c",
            "#fb9a99",
            "#e31a1c",
            "#fdbf6f",
            "#ff7f00",
            "#cab2d6",
            "#6a3d9a"
        ],
        11: [
            "#a6cee3",
            "#1f78b4",
            "#b2df8a",
            "#33a02c",
            "#fb9a99",
            "#e31a1c",
            "#fdbf6f",
            "#ff7f00",
            "#cab2d6",
            "#6a3d9a",
            "#ffff99"
        ],
        12: [
            "#a6cee3",
            "#1f78b4",
            "#b2df8a",
            "#33a02c",
            "#fb9a99",
            "#e31a1c",
            "#fdbf6f",
            "#ff7f00",
            "#cab2d6",
            "#6a3d9a",
            "#ffff99",
            "#b15928"
        ]
    },
    Pastel1: {
        3: [
            "#fbb4ae",
            "#b3cde3",
            "#ccebc5"
        ],
        4: [
            "#fbb4ae",
            "#b3cde3",
            "#ccebc5",
            "#decbe4"
        ],
        5: [
            "#fbb4ae",
            "#b3cde3",
            "#ccebc5",
            "#decbe4",
            "#fed9a6"
        ],
        6: [
            "#fbb4ae",
            "#b3cde3",
            "#ccebc5",
            "#decbe4",
            "#fed9a6",
            "#ffffcc"
        ],
        7: [
            "#fbb4ae",
            "#b3cde3",
            "#ccebc5",
            "#decbe4",
            "#fed9a6",
            "#ffffcc",
            "#e5d8bd"
        ],
        8: [
            "#fbb4ae",
            "#b3cde3",
            "#ccebc5",
            "#decbe4",
            "#fed9a6",
            "#ffffcc",
            "#e5d8bd",
            "#fddaec"
        ],
        9: [
            "#fbb4ae",
            "#b3cde3",
            "#ccebc5",
            "#decbe4",
            "#fed9a6",
            "#ffffcc",
            "#e5d8bd",
            "#fddaec",
            "#f2f2f2"
        ]
    },
    Pastel2: {
        3: [
            "#b3e2cd",
            "#fdcdac",
            "#cbd5e8"
        ],
        4: [
            "#b3e2cd",
            "#fdcdac",
            "#cbd5e8",
            "#f4cae4"
        ],
        5: [
            "#b3e2cd",
            "#fdcdac",
            "#cbd5e8",
            "#f4cae4",
            "#e6f5c9"
        ],
        6: [
            "#b3e2cd",
            "#fdcdac",
            "#cbd5e8",
            "#f4cae4",
            "#e6f5c9",
            "#fff2ae"
        ],
        7: [
            "#b3e2cd",
            "#fdcdac",
            "#cbd5e8",
            "#f4cae4",
            "#e6f5c9",
            "#fff2ae",
            "#f1e2cc"
        ],
        8: [
            "#b3e2cd",
            "#fdcdac",
            "#cbd5e8",
            "#f4cae4",
            "#e6f5c9",
            "#fff2ae",
            "#f1e2cc",
            "#cccccc"
        ]
    },
    Set1: {
        3: [
            "#e41a1c",
            "#377eb8",
            "#4daf4a"
        ],
        4: [
            "#e41a1c",
            "#377eb8",
            "#4daf4a",
            "#984ea3"
        ],
        5: [
            "#e41a1c",
            "#377eb8",
            "#4daf4a",
            "#984ea3",
            "#ff7f00"
        ],
        6: [
            "#e41a1c",
            "#377eb8",
            "#4daf4a",
            "#984ea3",
            "#ff7f00",
            "#ffff33"
        ],
        7: [
            "#e41a1c",
            "#377eb8",
            "#4daf4a",
            "#984ea3",
            "#ff7f00",
            "#ffff33",
            "#a65628"
        ],
        8: [
            "#e41a1c",
            "#377eb8",
            "#4daf4a",
            "#984ea3",
            "#ff7f00",
            "#ffff33",
            "#a65628",
            "#f781bf"
        ],
        9: [
            "#e41a1c",
            "#377eb8",
            "#4daf4a",
            "#984ea3",
            "#ff7f00",
            "#ffff33",
            "#a65628",
            "#f781bf",
            "#999999"
        ]
    },
    Set2: {
        3: [
            "#66c2a5",
            "#fc8d62",
            "#8da0cb"
        ],
        4: [
            "#66c2a5",
            "#fc8d62",
            "#8da0cb",
            "#e78ac3"
        ],
        5: [
            "#66c2a5",
            "#fc8d62",
            "#8da0cb",
            "#e78ac3",
            "#a6d854"
        ],
        6: [
            "#66c2a5",
            "#fc8d62",
            "#8da0cb",
            "#e78ac3",
            "#a6d854",
            "#ffd92f"
        ],
        7: [
            "#66c2a5",
            "#fc8d62",
            "#8da0cb",
            "#e78ac3",
            "#a6d854",
            "#ffd92f",
            "#e5c494"
        ],
        8: [
            "#66c2a5",
            "#fc8d62",
            "#8da0cb",
            "#e78ac3",
            "#a6d854",
            "#ffd92f",
            "#e5c494",
            "#b3b3b3"
        ]
    },
    Set3: {
        3: [
            "#8dd3c7",
            "#ffffb3",
            "#bebada"
        ],
        4: [
            "#8dd3c7",
            "#ffffb3",
            "#bebada",
            "#fb8072"
        ],
        5: [
            "#8dd3c7",
            "#ffffb3",
            "#bebada",
            "#fb8072",
            "#80b1d3"
        ],
        6: [
            "#8dd3c7",
            "#ffffb3",
            "#bebada",
            "#fb8072",
            "#80b1d3",
            "#fdb462"
        ],
        7: [
            "#8dd3c7",
            "#ffffb3",
            "#bebada",
            "#fb8072",
            "#80b1d3",
            "#fdb462",
            "#b3de69"
        ],
        8: [
            "#8dd3c7",
            "#ffffb3",
            "#bebada",
            "#fb8072",
            "#80b1d3",
            "#fdb462",
            "#b3de69",
            "#fccde5"
        ],
        9: [
            "#8dd3c7",
            "#ffffb3",
            "#bebada",
            "#fb8072",
            "#80b1d3",
            "#fdb462",
            "#b3de69",
            "#fccde5",
            "#d9d9d9"
        ],
        10: [
            "#8dd3c7",
            "#ffffb3",
            "#bebada",
            "#fb8072",
            "#80b1d3",
            "#fdb462",
            "#b3de69",
            "#fccde5",
            "#d9d9d9",
            "#bc80bd"
        ],
        11: [
            "#8dd3c7",
            "#ffffb3",
            "#bebada",
            "#fb8072",
            "#80b1d3",
            "#fdb462",
            "#b3de69",
            "#fccde5",
            "#d9d9d9",
            "#bc80bd",
            "#ccebc5"
        ],
        12: [
            "#8dd3c7",
            "#ffffb3",
            "#bebada",
            "#fb8072",
            "#80b1d3",
            "#fdb462",
            "#b3de69",
            "#fccde5",
            "#d9d9d9",
            "#bc80bd",
            "#ccebc5",
            "#ffed6f"
        ]
    }
};
const __TURBOPACK__default__export__ = index;
}}),
"[project]/node_modules/cartocolor/dist/cartocolor.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// src/carto.js
__turbopack_context__.s({
    "Antique": (()=>Antique),
    "ArmyRose": (()=>ArmyRose),
    "BluGrn": (()=>BluGrn),
    "BluYl": (()=>BluYl),
    "Bold": (()=>Bold),
    "BrwnYl": (()=>BrwnYl),
    "Burg": (()=>Burg),
    "BurgYl": (()=>BurgYl),
    "DarkMint": (()=>DarkMint),
    "Earth": (()=>Earth),
    "Emrld": (()=>Emrld),
    "Fall": (()=>Fall),
    "Geyser": (()=>Geyser),
    "Magenta": (()=>Magenta),
    "Mint": (()=>Mint),
    "OrYel": (()=>OrYel),
    "Pastel": (()=>Pastel),
    "Peach": (()=>Peach),
    "PinkYl": (()=>PinkYl),
    "Prism": (()=>Prism),
    "Purp": (()=>Purp),
    "PurpOr": (()=>PurpOr),
    "RedOr": (()=>RedOr),
    "Safe": (()=>Safe),
    "Sunset": (()=>Sunset),
    "SunsetDark": (()=>SunsetDark),
    "Teal": (()=>Teal),
    "TealGrn": (()=>TealGrn),
    "TealRose": (()=>TealRose),
    "Temps": (()=>Temps),
    "Tropic": (()=>Tropic),
    "Vivid": (()=>Vivid),
    "ag_GrnYl": (()=>ag_GrnYl),
    "ag_Sunset": (()=>ag_Sunset),
    "cb_Accent": (()=>cb_Accent),
    "cb_Blues": (()=>cb_Blues),
    "cb_BrBG": (()=>cb_BrBG),
    "cb_BuGn": (()=>cb_BuGn),
    "cb_BuPu": (()=>cb_BuPu),
    "cb_Dark2": (()=>cb_Dark2),
    "cb_GnBu": (()=>cb_GnBu),
    "cb_Greens": (()=>cb_Greens),
    "cb_Greys": (()=>cb_Greys),
    "cb_OrRd": (()=>cb_OrRd),
    "cb_Oranges": (()=>cb_Oranges),
    "cb_PRGn": (()=>cb_PRGn),
    "cb_Paired": (()=>cb_Paired),
    "cb_Pastel1": (()=>cb_Pastel1),
    "cb_Pastel2": (()=>cb_Pastel2),
    "cb_PiYG": (()=>cb_PiYG),
    "cb_PuBu": (()=>cb_PuBu),
    "cb_PuBuGn": (()=>cb_PuBuGn),
    "cb_PuOr": (()=>cb_PuOr),
    "cb_PuRd": (()=>cb_PuRd),
    "cb_Purples": (()=>cb_Purples),
    "cb_RdBu": (()=>cb_RdBu),
    "cb_RdGy": (()=>cb_RdGy),
    "cb_RdPu": (()=>cb_RdPu),
    "cb_RdYlBu": (()=>cb_RdYlBu),
    "cb_RdYlGn": (()=>cb_RdYlGn),
    "cb_Reds": (()=>cb_Reds),
    "cb_Set1": (()=>cb_Set1),
    "cb_Set2": (()=>cb_Set2),
    "cb_Set3": (()=>cb_Set3),
    "cb_Spectral": (()=>cb_Spectral),
    "cb_YlGn": (()=>cb_YlGn),
    "cb_YlGnBu": (()=>cb_YlGnBu),
    "cb_YlOrBr": (()=>cb_YlOrBr),
    "cb_YlOrRd": (()=>cb_YlOrRd)
});
// src/colorbrewer.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorbrewer$2f$index$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/colorbrewer/index.es.js [client] (ecmascript)");
var Burg = {
    2: [
        "#ffc6c4",
        "#672044"
    ],
    3: [
        "#ffc6c4",
        "#cc607d",
        "#672044"
    ],
    4: [
        "#ffc6c4",
        "#e38191",
        "#ad466c",
        "#672044"
    ],
    5: [
        "#ffc6c4",
        "#ee919b",
        "#cc607d",
        "#9e3963",
        "#672044"
    ],
    6: [
        "#ffc6c4",
        "#f29ca3",
        "#da7489",
        "#b95073",
        "#93345d",
        "#672044"
    ],
    7: [
        "#ffc6c4",
        "#f4a3a8",
        "#e38191",
        "#cc607d",
        "#ad466c",
        "#8b3058",
        "#672044"
    ],
    tags: [
        "quantitative"
    ]
};
var BurgYl = {
    2: [
        "#fbe6c5",
        "#70284a"
    ],
    3: [
        "#fbe6c5",
        "#dc7176",
        "#70284a"
    ],
    4: [
        "#fbe6c5",
        "#ee8a82",
        "#c8586c",
        "#70284a"
    ],
    5: [
        "#fbe6c5",
        "#f2a28a",
        "#dc7176",
        "#b24b65",
        "#70284a"
    ],
    6: [
        "#fbe6c5",
        "#f4b191",
        "#e7807d",
        "#d06270",
        "#a44360",
        "#70284a"
    ],
    7: [
        "#fbe6c5",
        "#f5ba98",
        "#ee8a82",
        "#dc7176",
        "#c8586c",
        "#9c3f5d",
        "#70284a"
    ],
    tags: [
        "quantitative"
    ]
};
var RedOr = {
    2: [
        "#f6d2a9",
        "#b13f64"
    ],
    3: [
        "#f6d2a9",
        "#ea8171",
        "#b13f64"
    ],
    4: [
        "#f6d2a9",
        "#f19c7c",
        "#dd686c",
        "#b13f64"
    ],
    5: [
        "#f6d2a9",
        "#f3aa84",
        "#ea8171",
        "#d55d6a",
        "#b13f64"
    ],
    6: [
        "#f6d2a9",
        "#f4b28a",
        "#ef9177",
        "#e3726d",
        "#cf5669",
        "#b13f64"
    ],
    7: [
        "#f6d2a9",
        "#f5b78e",
        "#f19c7c",
        "#ea8171",
        "#dd686c",
        "#ca5268",
        "#b13f64"
    ],
    tags: [
        "quantitative"
    ]
};
var OrYel = {
    2: [
        "#ecda9a",
        "#ee4d5a"
    ],
    3: [
        "#ecda9a",
        "#f7945d",
        "#ee4d5a"
    ],
    4: [
        "#ecda9a",
        "#f3ad6a",
        "#f97b57",
        "#ee4d5a"
    ],
    5: [
        "#ecda9a",
        "#f1b973",
        "#f7945d",
        "#f86f56",
        "#ee4d5a"
    ],
    6: [
        "#ecda9a",
        "#f0c079",
        "#f5a363",
        "#f98558",
        "#f76856",
        "#ee4d5a"
    ],
    7: [
        "#ecda9a",
        "#efc47e",
        "#f3ad6a",
        "#f7945d",
        "#f97b57",
        "#f66356",
        "#ee4d5a"
    ],
    tags: [
        "quantitative"
    ]
};
var Peach = {
    2: [
        "#fde0c5",
        "#eb4a40"
    ],
    3: [
        "#fde0c5",
        "#f59e72",
        "#eb4a40"
    ],
    4: [
        "#fde0c5",
        "#f8b58b",
        "#f2855d",
        "#eb4a40"
    ],
    5: [
        "#fde0c5",
        "#f9c098",
        "#f59e72",
        "#f17854",
        "#eb4a40"
    ],
    6: [
        "#fde0c5",
        "#fac7a1",
        "#f7ac80",
        "#f38f65",
        "#f0704f",
        "#eb4a40"
    ],
    7: [
        "#fde0c5",
        "#facba6",
        "#f8b58b",
        "#f59e72",
        "#f2855d",
        "#ef6a4c",
        "#eb4a40"
    ],
    tags: [
        "quantitative"
    ]
};
var PinkYl = {
    2: [
        "#fef6b5",
        "#e15383"
    ],
    3: [
        "#fef6b5",
        "#ffa679",
        "#e15383"
    ],
    4: [
        "#fef6b5",
        "#ffc285",
        "#fa8a76",
        "#e15383"
    ],
    5: [
        "#fef6b5",
        "#ffd08e",
        "#ffa679",
        "#f67b77",
        "#e15383"
    ],
    6: [
        "#fef6b5",
        "#ffd795",
        "#ffb77f",
        "#fd9576",
        "#f37378",
        "#e15383"
    ],
    7: [
        "#fef6b5",
        "#ffdd9a",
        "#ffc285",
        "#ffa679",
        "#fa8a76",
        "#f16d7a",
        "#e15383"
    ],
    tags: [
        "quantitative"
    ]
};
var Mint = {
    2: [
        "#e4f1e1",
        "#0d585f"
    ],
    3: [
        "#e4f1e1",
        "#63a6a0",
        "#0d585f"
    ],
    4: [
        "#e4f1e1",
        "#89c0b6",
        "#448c8a",
        "#0d585f"
    ],
    5: [
        "#E4F1E1",
        "#9CCDC1",
        "#63A6A0",
        "#337F7F",
        "#0D585F"
    ],
    6: [
        "#e4f1e1",
        "#abd4c7",
        "#7ab5ad",
        "#509693",
        "#2c7778",
        "#0d585f"
    ],
    7: [
        "#e4f1e1",
        "#b4d9cc",
        "#89c0b6",
        "#63a6a0",
        "#448c8a",
        "#287274",
        "#0d585f"
    ],
    tags: [
        "quantitative"
    ]
};
var BluGrn = {
    2: [
        "#c4e6c3",
        "#1d4f60"
    ],
    3: [
        "#c4e6c3",
        "#4da284",
        "#1d4f60"
    ],
    4: [
        "#c4e6c3",
        "#6dbc90",
        "#36877a",
        "#1d4f60"
    ],
    5: [
        "#c4e6c3",
        "#80c799",
        "#4da284",
        "#2d7974",
        "#1d4f60"
    ],
    6: [
        "#c4e6c3",
        "#8dce9f",
        "#5fb28b",
        "#3e927e",
        "#297071",
        "#1d4f60"
    ],
    7: [
        "#c4e6c3",
        "#96d2a4",
        "#6dbc90",
        "#4da284",
        "#36877a",
        "#266b6e",
        "#1d4f60"
    ],
    tags: [
        "quantitative"
    ]
};
var DarkMint = {
    2: [
        "#d2fbd4",
        "#123f5a"
    ],
    3: [
        "#d2fbd4",
        "#559c9e",
        "#123f5a"
    ],
    4: [
        "#d2fbd4",
        "#7bbcb0",
        "#3a7c89",
        "#123f5a"
    ],
    5: [
        "#d2fbd4",
        "#8eccb9",
        "#559c9e",
        "#2b6c7f",
        "#123f5a"
    ],
    6: [
        "#d2fbd4",
        "#9cd5be",
        "#6cafa9",
        "#458892",
        "#266377",
        "#123f5a"
    ],
    7: [
        "#d2fbd4",
        "#a5dbc2",
        "#7bbcb0",
        "#559c9e",
        "#3a7c89",
        "#235d72",
        "#123f5a"
    ],
    tags: [
        "quantitative"
    ]
};
var Emrld = {
    2: [
        "#d3f2a3",
        "#074050"
    ],
    3: [
        "#d3f2a3",
        "#4c9b82",
        "#074050"
    ],
    4: [
        "#d3f2a3",
        "#6cc08b",
        "#217a79",
        "#074050"
    ],
    5: [
        "#d3f2a3",
        "#82d091",
        "#4c9b82",
        "#19696f",
        "#074050"
    ],
    6: [
        "#d3f2a3",
        "#8fda94",
        "#60b187",
        "#35877d",
        "#145f69",
        "#074050"
    ],
    7: [
        "#d3f2a3",
        "#97e196",
        "#6cc08b",
        "#4c9b82",
        "#217a79",
        "#105965",
        "#074050"
    ],
    tags: [
        "quantitative"
    ]
};
var ag_GrnYl = {
    2: [
        "#245668",
        "#EDEF5D"
    ],
    3: [
        "#245668",
        "#39AB7E",
        "#EDEF5D"
    ],
    4: [
        "#245668",
        "#0D8F81",
        "#6EC574",
        "#EDEF5D"
    ],
    5: [
        "#245668",
        "#04817E",
        "#39AB7E",
        "#8BD16D",
        "#EDEF5D"
    ],
    6: [
        "#245668",
        "#09787C",
        "#1D9A81",
        "#58BB79",
        "#9DD869",
        "#EDEF5D"
    ],
    7: [
        "#245668",
        "#0F7279",
        "#0D8F81",
        "#39AB7E",
        "#6EC574",
        "#A9DC67",
        "#EDEF5D"
    ],
    tags: [
        "aggregation"
    ]
};
var BluYl = {
    2: [
        "#f7feae",
        "#045275"
    ],
    3: [
        "#f7feae",
        "#46aea0",
        "#045275"
    ],
    4: [
        "#f7feae",
        "#7ccba2",
        "#089099",
        "#045275"
    ],
    5: [
        "#f7feae",
        "#9bd8a4",
        "#46aea0",
        "#058092",
        "#045275"
    ],
    6: [
        "#f7feae",
        "#ace1a4",
        "#68bfa1",
        "#2a9c9c",
        "#02778e",
        "#045275"
    ],
    7: [
        "#f7feae",
        "#b7e6a5",
        "#7ccba2",
        "#46aea0",
        "#089099",
        "#00718b",
        "#045275"
    ],
    tags: [
        "quantitative"
    ]
};
var Teal = {
    2: [
        "#d1eeea",
        "#2a5674"
    ],
    3: [
        "#d1eeea",
        "#68abb8",
        "#2a5674"
    ],
    4: [
        "#d1eeea",
        "#85c4c9",
        "#4f90a6",
        "#2a5674"
    ],
    5: [
        "#d1eeea",
        "#96d0d1",
        "#68abb8",
        "#45829b",
        "#2a5674"
    ],
    6: [
        "#d1eeea",
        "#a1d7d6",
        "#79bbc3",
        "#599bae",
        "#3f7994",
        "#2a5674"
    ],
    7: [
        "#d1eeea",
        "#a8dbd9",
        "#85c4c9",
        "#68abb8",
        "#4f90a6",
        "#3b738f",
        "#2a5674"
    ],
    tags: [
        "quantitative"
    ]
};
var TealGrn = {
    2: [
        "#b0f2bc",
        "#257d98"
    ],
    3: [
        "#b0f2bc",
        "#4cc8a3",
        "#257d98"
    ],
    4: [
        "#b0f2bc",
        "#67dba5",
        "#38b2a3",
        "#257d98"
    ],
    5: [
        "#b0f2bc",
        "#77e2a8",
        "#4cc8a3",
        "#31a6a2",
        "#257d98"
    ],
    6: [
        "#b0f2bc",
        "#82e6aa",
        "#5bd4a4",
        "#3fbba3",
        "#2e9ea1",
        "#257d98"
    ],
    7: [
        "#b0f2bc",
        "#89e8ac",
        "#67dba5",
        "#4cc8a3",
        "#38b2a3",
        "#2c98a0",
        "#257d98"
    ],
    tags: [
        "quantitative"
    ]
};
var Purp = {
    2: [
        "#f3e0f7",
        "#63589f"
    ],
    3: [
        "#f3e0f7",
        "#b998dd",
        "#63589f"
    ],
    4: [
        "#f3e0f7",
        "#d1afe8",
        "#9f82ce",
        "#63589f"
    ],
    5: [
        "#f3e0f7",
        "#dbbaed",
        "#b998dd",
        "#9178c4",
        "#63589f"
    ],
    6: [
        "#f3e0f7",
        "#e0c2ef",
        "#c8a5e4",
        "#aa8bd4",
        "#8871be",
        "#63589f"
    ],
    7: [
        "#f3e0f7",
        "#e4c7f1",
        "#d1afe8",
        "#b998dd",
        "#9f82ce",
        "#826dba",
        "#63589f"
    ],
    tags: [
        "quantitative"
    ]
};
var PurpOr = {
    2: [
        "#f9ddda",
        "#573b88"
    ],
    3: [
        "#f9ddda",
        "#ce78b3",
        "#573b88"
    ],
    4: [
        "#f9ddda",
        "#e597b9",
        "#ad5fad",
        "#573b88"
    ],
    5: [
        "#f9ddda",
        "#eda8bd",
        "#ce78b3",
        "#9955a8",
        "#573b88"
    ],
    6: [
        "#f9ddda",
        "#f0b2c1",
        "#dd8ab6",
        "#bb69b0",
        "#8c4fa4",
        "#573b88"
    ],
    7: [
        "#f9ddda",
        "#f2b9c4",
        "#e597b9",
        "#ce78b3",
        "#ad5fad",
        "#834ba0",
        "#573b88"
    ],
    tags: [
        "quantitative"
    ]
};
var Sunset = {
    2: [
        "#f3e79b",
        "#5c53a5"
    ],
    3: [
        "#f3e79b",
        "#eb7f86",
        "#5c53a5"
    ],
    4: [
        "#f3e79b",
        "#f8a07e",
        "#ce6693",
        "#5c53a5"
    ],
    5: [
        "#f3e79b",
        "#fab27f",
        "#eb7f86",
        "#b95e9a",
        "#5c53a5"
    ],
    6: [
        "#f3e79b",
        "#fabc82",
        "#f59280",
        "#dc6f8e",
        "#ab5b9e",
        "#5c53a5"
    ],
    7: [
        "#f3e79b",
        "#fac484",
        "#f8a07e",
        "#eb7f86",
        "#ce6693",
        "#a059a0",
        "#5c53a5"
    ],
    tags: [
        "quantitative"
    ]
};
var Magenta = {
    2: [
        "#f3cbd3",
        "#6c2167"
    ],
    3: [
        "#f3cbd3",
        "#ca699d",
        "#6c2167"
    ],
    4: [
        "#f3cbd3",
        "#dd88ac",
        "#b14d8e",
        "#6c2167"
    ],
    5: [
        "#f3cbd3",
        "#e498b4",
        "#ca699d",
        "#a24186",
        "#6c2167"
    ],
    6: [
        "#f3cbd3",
        "#e7a2b9",
        "#d67ba5",
        "#bc5894",
        "#983a81",
        "#6c2167"
    ],
    7: [
        "#f3cbd3",
        "#eaa9bd",
        "#dd88ac",
        "#ca699d",
        "#b14d8e",
        "#91357d",
        "#6c2167"
    ],
    tags: [
        "quantitative"
    ]
};
var SunsetDark = {
    2: [
        "#fcde9c",
        "#7c1d6f"
    ],
    3: [
        "#fcde9c",
        "#e34f6f",
        "#7c1d6f"
    ],
    4: [
        "#fcde9c",
        "#f0746e",
        "#dc3977",
        "#7c1d6f"
    ],
    5: [
        "#fcde9c",
        "#f58670",
        "#e34f6f",
        "#d72d7c",
        "#7c1d6f"
    ],
    6: [
        "#fcde9c",
        "#f89872",
        "#ec666d",
        "#df4273",
        "#c5287b",
        "#7c1d6f"
    ],
    7: [
        "#fcde9c",
        "#faa476",
        "#f0746e",
        "#e34f6f",
        "#dc3977",
        "#b9257a",
        "#7c1d6f"
    ],
    tags: [
        "quantitative"
    ]
};
var ag_Sunset = {
    2: [
        "#4b2991",
        "#edd9a3"
    ],
    3: [
        "#4b2991",
        "#ea4f88",
        "#edd9a3"
    ],
    4: [
        "#4b2991",
        "#c0369d",
        "#fa7876",
        "#edd9a3"
    ],
    5: [
        "#4b2991",
        "#a52fa2",
        "#ea4f88",
        "#fa9074",
        "#edd9a3"
    ],
    6: [
        "#4b2991",
        "#932da3",
        "#d43f96",
        "#f7667c",
        "#f89f77",
        "#edd9a3"
    ],
    7: [
        "#4b2991",
        "#872ca2",
        "#c0369d",
        "#ea4f88",
        "#fa7876",
        "#f6a97a",
        "#edd9a3"
    ],
    tags: [
        "aggregation"
    ]
};
var BrwnYl = {
    2: [
        "#ede5cf",
        "#541f3f"
    ],
    3: [
        "#ede5cf",
        "#c1766f",
        "#541f3f"
    ],
    4: [
        "#ede5cf",
        "#d39c83",
        "#a65461",
        "#541f3f"
    ],
    5: [
        "#ede5cf",
        "#daaf91",
        "#c1766f",
        "#95455a",
        "#541f3f"
    ],
    6: [
        "#ede5cf",
        "#ddba9b",
        "#cd8c7a",
        "#b26166",
        "#8a3c56",
        "#541f3f"
    ],
    7: [
        "#ede5cf",
        "#e0c2a2",
        "#d39c83",
        "#c1766f",
        "#a65461",
        "#813753",
        "#541f3f"
    ],
    tags: [
        "quantitative"
    ]
};
var ArmyRose = {
    2: [
        "#929b4f",
        "#db8195"
    ],
    3: [
        "#a3ad62",
        "#fdfbe4",
        "#df91a3"
    ],
    4: [
        "#929b4f",
        "#d9dbaf",
        "#f3d1ca",
        "#db8195"
    ],
    5: [
        "#879043",
        "#c1c68c",
        "#fdfbe4",
        "#ebb4b8",
        "#d8758b"
    ],
    6: [
        "#7f883b",
        "#b0b874",
        "#e3e4be",
        "#f6ddd1",
        "#e4a0ac",
        "#d66d85"
    ],
    7: [
        "#798234",
        "#a3ad62",
        "#d0d3a2",
        "#fdfbe4",
        "#f0c6c3",
        "#df91a3",
        "#d46780"
    ],
    tags: [
        "diverging"
    ]
};
var Fall = {
    2: [
        "#3d5941",
        "#ca562c"
    ],
    3: [
        "#3d5941",
        "#f6edbd",
        "#ca562c"
    ],
    4: [
        "#3d5941",
        "#b5b991",
        "#edbb8a",
        "#ca562c"
    ],
    5: [
        "#3d5941",
        "#96a07c",
        "#f6edbd",
        "#e6a272",
        "#ca562c"
    ],
    6: [
        "#3d5941",
        "#839170",
        "#cecea2",
        "#f1cf9e",
        "#e19464",
        "#ca562c"
    ],
    7: [
        "#3d5941",
        "#778868",
        "#b5b991",
        "#f6edbd",
        "#edbb8a",
        "#de8a5a",
        "#ca562c"
    ],
    tags: [
        "diverging"
    ]
};
var Geyser = {
    2: [
        "#008080",
        "#ca562c"
    ],
    3: [
        "#008080",
        "#f6edbd",
        "#ca562c"
    ],
    4: [
        "#008080",
        "#b4c8a8",
        "#edbb8a",
        "#ca562c"
    ],
    5: [
        "#008080",
        "#92b69e",
        "#f6edbd",
        "#e6a272",
        "#ca562c"
    ],
    6: [
        "#008080",
        "#7eab98",
        "#ced7b1",
        "#f1cf9e",
        "#e19464",
        "#ca562c"
    ],
    7: [
        "#008080",
        "#70a494",
        "#b4c8a8",
        "#f6edbd",
        "#edbb8a",
        "#de8a5a",
        "#ca562c"
    ],
    tags: [
        "diverging"
    ]
};
var Temps = {
    2: [
        "#009392",
        "#cf597e"
    ],
    3: [
        "#009392",
        "#e9e29c",
        "#cf597e"
    ],
    4: [
        "#009392",
        "#9ccb86",
        "#eeb479",
        "#cf597e"
    ],
    5: [
        "#009392",
        "#71be83",
        "#e9e29c",
        "#ed9c72",
        "#cf597e"
    ],
    6: [
        "#009392",
        "#52b684",
        "#bcd48c",
        "#edc783",
        "#eb8d71",
        "#cf597e"
    ],
    7: [
        "#009392",
        "#39b185",
        "#9ccb86",
        "#e9e29c",
        "#eeb479",
        "#e88471",
        "#cf597e"
    ],
    tags: [
        "diverging"
    ]
};
var TealRose = {
    2: [
        "#009392",
        "#d0587e"
    ],
    3: [
        "#009392",
        "#f1eac8",
        "#d0587e"
    ],
    4: [
        "#009392",
        "#91b8aa",
        "#f1eac8",
        "#dfa0a0",
        "#d0587e"
    ],
    5: [
        "#009392",
        "#91b8aa",
        "#f1eac8",
        "#dfa0a0",
        "#d0587e"
    ],
    6: [
        "#009392",
        "#72aaa1",
        "#b1c7b3",
        "#e5b9ad",
        "#d98994",
        "#d0587e"
    ],
    7: [
        "#009392",
        "#72aaa1",
        "#b1c7b3",
        "#f1eac8",
        "#e5b9ad",
        "#d98994",
        "#d0587e"
    ],
    tags: [
        "diverging"
    ]
};
var Tropic = {
    2: [
        "#009B9E",
        "#C75DAB"
    ],
    3: [
        "#009B9E",
        "#F1F1F1",
        "#C75DAB"
    ],
    4: [
        "#009B9E",
        "#A7D3D4",
        "#E4C1D9",
        "#C75DAB"
    ],
    5: [
        "#009B9E",
        "#7CC5C6",
        "#F1F1F1",
        "#DDA9CD",
        "#C75DAB"
    ],
    6: [
        "#009B9E",
        "#5DBCBE",
        "#C6DFDF",
        "#E9D4E2",
        "#D99BC6",
        "#C75DAB"
    ],
    7: [
        "#009B9E",
        "#42B7B9",
        "#A7D3D4",
        "#F1F1F1",
        "#E4C1D9",
        "#D691C1",
        "#C75DAB"
    ],
    tags: [
        "diverging"
    ]
};
var Earth = {
    2: [
        "#A16928",
        "#2887a1"
    ],
    3: [
        "#A16928",
        "#edeac2",
        "#2887a1"
    ],
    4: [
        "#A16928",
        "#d6bd8d",
        "#b5c8b8",
        "#2887a1"
    ],
    5: [
        "#A16928",
        "#caa873",
        "#edeac2",
        "#98b7b2",
        "#2887a1"
    ],
    6: [
        "#A16928",
        "#c29b64",
        "#e0cfa2",
        "#cbd5bc",
        "#85adaf",
        "#2887a1"
    ],
    7: [
        "#A16928",
        "#bd925a",
        "#d6bd8d",
        "#edeac2",
        "#b5c8b8",
        "#79a7ac",
        "#2887a1"
    ],
    tags: [
        "diverging"
    ]
};
var Antique = {
    2: [
        "#855C75",
        "#D9AF6B",
        "#7C7C7C"
    ],
    3: [
        "#855C75",
        "#D9AF6B",
        "#AF6458",
        "#7C7C7C"
    ],
    4: [
        "#855C75",
        "#D9AF6B",
        "#AF6458",
        "#736F4C",
        "#7C7C7C"
    ],
    5: [
        "#855C75",
        "#D9AF6B",
        "#AF6458",
        "#736F4C",
        "#526A83",
        "#7C7C7C"
    ],
    6: [
        "#855C75",
        "#D9AF6B",
        "#AF6458",
        "#736F4C",
        "#526A83",
        "#625377",
        "#7C7C7C"
    ],
    7: [
        "#855C75",
        "#D9AF6B",
        "#AF6458",
        "#736F4C",
        "#526A83",
        "#625377",
        "#68855C",
        "#7C7C7C"
    ],
    8: [
        "#855C75",
        "#D9AF6B",
        "#AF6458",
        "#736F4C",
        "#526A83",
        "#625377",
        "#68855C",
        "#9C9C5E",
        "#7C7C7C"
    ],
    9: [
        "#855C75",
        "#D9AF6B",
        "#AF6458",
        "#736F4C",
        "#526A83",
        "#625377",
        "#68855C",
        "#9C9C5E",
        "#A06177",
        "#7C7C7C"
    ],
    10: [
        "#855C75",
        "#D9AF6B",
        "#AF6458",
        "#736F4C",
        "#526A83",
        "#625377",
        "#68855C",
        "#9C9C5E",
        "#A06177",
        "#8C785D",
        "#7C7C7C"
    ],
    11: [
        "#855C75",
        "#D9AF6B",
        "#AF6458",
        "#736F4C",
        "#526A83",
        "#625377",
        "#68855C",
        "#9C9C5E",
        "#A06177",
        "#8C785D",
        "#467378",
        "#7C7C7C"
    ],
    tags: [
        "qualitative"
    ]
};
var Bold = {
    2: [
        "#7F3C8D",
        "#11A579",
        "#A5AA99"
    ],
    3: [
        "#7F3C8D",
        "#11A579",
        "#3969AC",
        "#A5AA99"
    ],
    4: [
        "#7F3C8D",
        "#11A579",
        "#3969AC",
        "#F2B701",
        "#A5AA99"
    ],
    5: [
        "#7F3C8D",
        "#11A579",
        "#3969AC",
        "#F2B701",
        "#E73F74",
        "#A5AA99"
    ],
    6: [
        "#7F3C8D",
        "#11A579",
        "#3969AC",
        "#F2B701",
        "#E73F74",
        "#80BA5A",
        "#A5AA99"
    ],
    7: [
        "#7F3C8D",
        "#11A579",
        "#3969AC",
        "#F2B701",
        "#E73F74",
        "#80BA5A",
        "#E68310",
        "#A5AA99"
    ],
    8: [
        "#7F3C8D",
        "#11A579",
        "#3969AC",
        "#F2B701",
        "#E73F74",
        "#80BA5A",
        "#E68310",
        "#008695",
        "#A5AA99"
    ],
    9: [
        "#7F3C8D",
        "#11A579",
        "#3969AC",
        "#F2B701",
        "#E73F74",
        "#80BA5A",
        "#E68310",
        "#008695",
        "#CF1C90",
        "#A5AA99"
    ],
    10: [
        "#7F3C8D",
        "#11A579",
        "#3969AC",
        "#F2B701",
        "#E73F74",
        "#80BA5A",
        "#E68310",
        "#008695",
        "#CF1C90",
        "#f97b72",
        "#A5AA99"
    ],
    11: [
        "#7F3C8D",
        "#11A579",
        "#3969AC",
        "#F2B701",
        "#E73F74",
        "#80BA5A",
        "#E68310",
        "#008695",
        "#CF1C90",
        "#f97b72",
        "#4b4b8f",
        "#A5AA99"
    ],
    tags: [
        "qualitative"
    ]
};
var Pastel = {
    2: [
        "#66C5CC",
        "#F6CF71",
        "#B3B3B3"
    ],
    3: [
        "#66C5CC",
        "#F6CF71",
        "#F89C74",
        "#B3B3B3"
    ],
    4: [
        "#66C5CC",
        "#F6CF71",
        "#F89C74",
        "#DCB0F2",
        "#B3B3B3"
    ],
    5: [
        "#66C5CC",
        "#F6CF71",
        "#F89C74",
        "#DCB0F2",
        "#87C55F",
        "#B3B3B3"
    ],
    6: [
        "#66C5CC",
        "#F6CF71",
        "#F89C74",
        "#DCB0F2",
        "#87C55F",
        "#9EB9F3",
        "#B3B3B3"
    ],
    7: [
        "#66C5CC",
        "#F6CF71",
        "#F89C74",
        "#DCB0F2",
        "#87C55F",
        "#9EB9F3",
        "#FE88B1",
        "#B3B3B3"
    ],
    8: [
        "#66C5CC",
        "#F6CF71",
        "#F89C74",
        "#DCB0F2",
        "#87C55F",
        "#9EB9F3",
        "#FE88B1",
        "#C9DB74",
        "#B3B3B3"
    ],
    9: [
        "#66C5CC",
        "#F6CF71",
        "#F89C74",
        "#DCB0F2",
        "#87C55F",
        "#9EB9F3",
        "#FE88B1",
        "#C9DB74",
        "#8BE0A4",
        "#B3B3B3"
    ],
    10: [
        "#66C5CC",
        "#F6CF71",
        "#F89C74",
        "#DCB0F2",
        "#87C55F",
        "#9EB9F3",
        "#FE88B1",
        "#C9DB74",
        "#8BE0A4",
        "#B497E7",
        "#B3B3B3"
    ],
    11: [
        "#66C5CC",
        "#F6CF71",
        "#F89C74",
        "#DCB0F2",
        "#87C55F",
        "#9EB9F3",
        "#FE88B1",
        "#C9DB74",
        "#8BE0A4",
        "#B497E7",
        "#D3B484",
        "#B3B3B3"
    ],
    tags: [
        "qualitative"
    ]
};
var Prism = {
    2: [
        "#5F4690",
        "#1D6996",
        "#666666"
    ],
    3: [
        "#5F4690",
        "#1D6996",
        "#38A6A5",
        "#666666"
    ],
    4: [
        "#5F4690",
        "#1D6996",
        "#38A6A5",
        "#0F8554",
        "#666666"
    ],
    5: [
        "#5F4690",
        "#1D6996",
        "#38A6A5",
        "#0F8554",
        "#73AF48",
        "#666666"
    ],
    6: [
        "#5F4690",
        "#1D6996",
        "#38A6A5",
        "#0F8554",
        "#73AF48",
        "#EDAD08",
        "#666666"
    ],
    7: [
        "#5F4690",
        "#1D6996",
        "#38A6A5",
        "#0F8554",
        "#73AF48",
        "#EDAD08",
        "#E17C05",
        "#666666"
    ],
    8: [
        "#5F4690",
        "#1D6996",
        "#38A6A5",
        "#0F8554",
        "#73AF48",
        "#EDAD08",
        "#E17C05",
        "#CC503E",
        "#666666"
    ],
    9: [
        "#5F4690",
        "#1D6996",
        "#38A6A5",
        "#0F8554",
        "#73AF48",
        "#EDAD08",
        "#E17C05",
        "#CC503E",
        "#94346E",
        "#666666"
    ],
    10: [
        "#5F4690",
        "#1D6996",
        "#38A6A5",
        "#0F8554",
        "#73AF48",
        "#EDAD08",
        "#E17C05",
        "#CC503E",
        "#94346E",
        "#6F4070",
        "#666666"
    ],
    11: [
        "#5F4690",
        "#1D6996",
        "#38A6A5",
        "#0F8554",
        "#73AF48",
        "#EDAD08",
        "#E17C05",
        "#CC503E",
        "#94346E",
        "#6F4070",
        "#994E95",
        "#666666"
    ],
    tags: [
        "qualitative"
    ]
};
var Safe = {
    2: [
        "#88CCEE",
        "#CC6677",
        "#888888"
    ],
    3: [
        "#88CCEE",
        "#CC6677",
        "#DDCC77",
        "#888888"
    ],
    4: [
        "#88CCEE",
        "#CC6677",
        "#DDCC77",
        "#117733",
        "#888888"
    ],
    5: [
        "#88CCEE",
        "#CC6677",
        "#DDCC77",
        "#117733",
        "#332288",
        "#888888"
    ],
    6: [
        "#88CCEE",
        "#CC6677",
        "#DDCC77",
        "#117733",
        "#332288",
        "#AA4499",
        "#888888"
    ],
    7: [
        "#88CCEE",
        "#CC6677",
        "#DDCC77",
        "#117733",
        "#332288",
        "#AA4499",
        "#44AA99",
        "#888888"
    ],
    8: [
        "#88CCEE",
        "#CC6677",
        "#DDCC77",
        "#117733",
        "#332288",
        "#AA4499",
        "#44AA99",
        "#999933",
        "#888888"
    ],
    9: [
        "#88CCEE",
        "#CC6677",
        "#DDCC77",
        "#117733",
        "#332288",
        "#AA4499",
        "#44AA99",
        "#999933",
        "#882255",
        "#888888"
    ],
    10: [
        "#88CCEE",
        "#CC6677",
        "#DDCC77",
        "#117733",
        "#332288",
        "#AA4499",
        "#44AA99",
        "#999933",
        "#882255",
        "#661100",
        "#888888"
    ],
    11: [
        "#88CCEE",
        "#CC6677",
        "#DDCC77",
        "#117733",
        "#332288",
        "#AA4499",
        "#44AA99",
        "#999933",
        "#882255",
        "#661100",
        "#6699CC",
        "#888888"
    ],
    tags: [
        "qualitative",
        "colorblind"
    ]
};
var Vivid = {
    2: [
        "#E58606",
        "#5D69B1",
        "#A5AA99"
    ],
    3: [
        "#E58606",
        "#5D69B1",
        "#52BCA3",
        "#A5AA99"
    ],
    4: [
        "#E58606",
        "#5D69B1",
        "#52BCA3",
        "#99C945",
        "#A5AA99"
    ],
    5: [
        "#E58606",
        "#5D69B1",
        "#52BCA3",
        "#99C945",
        "#CC61B0",
        "#A5AA99"
    ],
    6: [
        "#E58606",
        "#5D69B1",
        "#52BCA3",
        "#99C945",
        "#CC61B0",
        "#24796C",
        "#A5AA99"
    ],
    7: [
        "#E58606",
        "#5D69B1",
        "#52BCA3",
        "#99C945",
        "#CC61B0",
        "#24796C",
        "#DAA51B",
        "#A5AA99"
    ],
    8: [
        "#E58606",
        "#5D69B1",
        "#52BCA3",
        "#99C945",
        "#CC61B0",
        "#24796C",
        "#DAA51B",
        "#2F8AC4",
        "#A5AA99"
    ],
    9: [
        "#E58606",
        "#5D69B1",
        "#52BCA3",
        "#99C945",
        "#CC61B0",
        "#24796C",
        "#DAA51B",
        "#2F8AC4",
        "#764E9F",
        "#A5AA99"
    ],
    10: [
        "#E58606",
        "#5D69B1",
        "#52BCA3",
        "#99C945",
        "#CC61B0",
        "#24796C",
        "#DAA51B",
        "#2F8AC4",
        "#764E9F",
        "#ED645A",
        "#A5AA99"
    ],
    11: [
        "#E58606",
        "#5D69B1",
        "#52BCA3",
        "#99C945",
        "#CC61B0",
        "#24796C",
        "#DAA51B",
        "#2F8AC4",
        "#764E9F",
        "#ED645A",
        "#CC3A8E",
        "#A5AA99"
    ],
    tags: [
        "qualitative"
    ]
};
;
var cb_BuGn = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorbrewer$2f$index$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].BuGn,
    tags: [
        "quantitative"
    ]
};
var cb_BuPu = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorbrewer$2f$index$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].BuPu,
    tags: [
        "quantitative"
    ]
};
var cb_GnBu = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorbrewer$2f$index$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].GnBu,
    tags: [
        "quantitative"
    ]
};
var cb_OrRd = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorbrewer$2f$index$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].OrRd,
    tags: [
        "quantitative"
    ]
};
var cb_PuBu = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorbrewer$2f$index$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].PuBu,
    tags: [
        "quantitative"
    ]
};
var cb_PuBuGn = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorbrewer$2f$index$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].PuBuGn,
    tags: [
        "quantitative"
    ]
};
var cb_PuRd = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorbrewer$2f$index$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].PuRd,
    tags: [
        "quantitative"
    ]
};
var cb_RdPu = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorbrewer$2f$index$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].RdPu,
    tags: [
        "quantitative"
    ]
};
var cb_YlGn = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorbrewer$2f$index$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].YlGn,
    tags: [
        "quantitative"
    ]
};
var cb_YlGnBu = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorbrewer$2f$index$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].YlGnBu,
    tags: [
        "quantitative"
    ]
};
var cb_YlOrBr = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorbrewer$2f$index$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].YlOrBr,
    tags: [
        "quantitative"
    ]
};
var cb_YlOrRd = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorbrewer$2f$index$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].YlOrRd,
    tags: [
        "quantitative"
    ]
};
var cb_Accent = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorbrewer$2f$index$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].Accent,
    tags: [
        "qualitative"
    ]
};
var cb_Dark2 = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorbrewer$2f$index$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].Dark2,
    tags: [
        "qualitative"
    ]
};
var cb_Paired = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorbrewer$2f$index$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].Paired,
    tags: [
        "qualitative"
    ]
};
var cb_Pastel1 = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorbrewer$2f$index$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].Pastel1,
    tags: [
        "qualitative"
    ]
};
var cb_Pastel2 = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorbrewer$2f$index$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].Pastel2,
    tags: [
        "qualitative"
    ]
};
var cb_Set1 = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorbrewer$2f$index$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].Set1,
    tags: [
        "qualitative"
    ]
};
var cb_Set2 = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorbrewer$2f$index$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].Set2,
    tags: [
        "qualitative"
    ]
};
var cb_Set3 = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorbrewer$2f$index$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].Set3,
    tags: [
        "qualitative"
    ]
};
var cb_Blues = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorbrewer$2f$index$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].Blues,
    tags: [
        "quantitative"
    ]
};
var cb_Greens = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorbrewer$2f$index$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].Greens,
    tags: [
        "quantitative"
    ]
};
var cb_Greys = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorbrewer$2f$index$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].Greys,
    tags: [
        "quantitative"
    ]
};
var cb_Oranges = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorbrewer$2f$index$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].Oranges,
    tags: [
        "quantitative"
    ]
};
var cb_Purples = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorbrewer$2f$index$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].Purples,
    tags: [
        "quantitative"
    ]
};
var cb_Reds = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorbrewer$2f$index$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].Reds,
    tags: [
        "quantitative"
    ]
};
var cb_BrBG = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorbrewer$2f$index$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].BrBG,
    tags: [
        "diverging"
    ]
};
var cb_PiYG = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorbrewer$2f$index$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].PiYG,
    tags: [
        "diverging"
    ]
};
var cb_PRGn = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorbrewer$2f$index$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].PRGn,
    tags: [
        "diverging"
    ]
};
var cb_PuOr = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorbrewer$2f$index$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].PuOr,
    tags: [
        "diverging"
    ]
};
var cb_RdBu = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorbrewer$2f$index$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].RdBu,
    tags: [
        "diverging"
    ]
};
var cb_RdGy = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorbrewer$2f$index$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].RdGy,
    tags: [
        "diverging"
    ]
};
var cb_RdYlBu = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorbrewer$2f$index$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].RdYlBu,
    tags: [
        "diverging"
    ]
};
var cb_RdYlGn = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorbrewer$2f$index$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].RdYlGn,
    tags: [
        "diverging"
    ]
};
var cb_Spectral = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorbrewer$2f$index$2e$es$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].Spectral,
    tags: [
        "diverging"
    ]
};
;
}}),
"[project]/node_modules/d3-color/src/define.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__),
    "extend": (()=>extend)
});
function __TURBOPACK__default__export__(constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
}
function extend(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for(var key in definition)prototype[key] = definition[key];
    return prototype;
}
}}),
"[project]/node_modules/d3-color/src/color.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "Color": (()=>Color),
    "Rgb": (()=>Rgb),
    "brighter": (()=>brighter),
    "darker": (()=>darker),
    "default": (()=>color),
    "hsl": (()=>hsl),
    "hslConvert": (()=>hslConvert),
    "rgb": (()=>rgb),
    "rgbConvert": (()=>rgbConvert)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$color$2f$src$2f$define$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-color/src/define.js [client] (ecmascript)");
;
function Color() {}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`), reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`), reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`), reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`), reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`), reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
    aliceblue: 0xf0f8ff,
    antiquewhite: 0xfaebd7,
    aqua: 0x00ffff,
    aquamarine: 0x7fffd4,
    azure: 0xf0ffff,
    beige: 0xf5f5dc,
    bisque: 0xffe4c4,
    black: 0x000000,
    blanchedalmond: 0xffebcd,
    blue: 0x0000ff,
    blueviolet: 0x8a2be2,
    brown: 0xa52a2a,
    burlywood: 0xdeb887,
    cadetblue: 0x5f9ea0,
    chartreuse: 0x7fff00,
    chocolate: 0xd2691e,
    coral: 0xff7f50,
    cornflowerblue: 0x6495ed,
    cornsilk: 0xfff8dc,
    crimson: 0xdc143c,
    cyan: 0x00ffff,
    darkblue: 0x00008b,
    darkcyan: 0x008b8b,
    darkgoldenrod: 0xb8860b,
    darkgray: 0xa9a9a9,
    darkgreen: 0x006400,
    darkgrey: 0xa9a9a9,
    darkkhaki: 0xbdb76b,
    darkmagenta: 0x8b008b,
    darkolivegreen: 0x556b2f,
    darkorange: 0xff8c00,
    darkorchid: 0x9932cc,
    darkred: 0x8b0000,
    darksalmon: 0xe9967a,
    darkseagreen: 0x8fbc8f,
    darkslateblue: 0x483d8b,
    darkslategray: 0x2f4f4f,
    darkslategrey: 0x2f4f4f,
    darkturquoise: 0x00ced1,
    darkviolet: 0x9400d3,
    deeppink: 0xff1493,
    deepskyblue: 0x00bfff,
    dimgray: 0x696969,
    dimgrey: 0x696969,
    dodgerblue: 0x1e90ff,
    firebrick: 0xb22222,
    floralwhite: 0xfffaf0,
    forestgreen: 0x228b22,
    fuchsia: 0xff00ff,
    gainsboro: 0xdcdcdc,
    ghostwhite: 0xf8f8ff,
    gold: 0xffd700,
    goldenrod: 0xdaa520,
    gray: 0x808080,
    green: 0x008000,
    greenyellow: 0xadff2f,
    grey: 0x808080,
    honeydew: 0xf0fff0,
    hotpink: 0xff69b4,
    indianred: 0xcd5c5c,
    indigo: 0x4b0082,
    ivory: 0xfffff0,
    khaki: 0xf0e68c,
    lavender: 0xe6e6fa,
    lavenderblush: 0xfff0f5,
    lawngreen: 0x7cfc00,
    lemonchiffon: 0xfffacd,
    lightblue: 0xadd8e6,
    lightcoral: 0xf08080,
    lightcyan: 0xe0ffff,
    lightgoldenrodyellow: 0xfafad2,
    lightgray: 0xd3d3d3,
    lightgreen: 0x90ee90,
    lightgrey: 0xd3d3d3,
    lightpink: 0xffb6c1,
    lightsalmon: 0xffa07a,
    lightseagreen: 0x20b2aa,
    lightskyblue: 0x87cefa,
    lightslategray: 0x778899,
    lightslategrey: 0x778899,
    lightsteelblue: 0xb0c4de,
    lightyellow: 0xffffe0,
    lime: 0x00ff00,
    limegreen: 0x32cd32,
    linen: 0xfaf0e6,
    magenta: 0xff00ff,
    maroon: 0x800000,
    mediumaquamarine: 0x66cdaa,
    mediumblue: 0x0000cd,
    mediumorchid: 0xba55d3,
    mediumpurple: 0x9370db,
    mediumseagreen: 0x3cb371,
    mediumslateblue: 0x7b68ee,
    mediumspringgreen: 0x00fa9a,
    mediumturquoise: 0x48d1cc,
    mediumvioletred: 0xc71585,
    midnightblue: 0x191970,
    mintcream: 0xf5fffa,
    mistyrose: 0xffe4e1,
    moccasin: 0xffe4b5,
    navajowhite: 0xffdead,
    navy: 0x000080,
    oldlace: 0xfdf5e6,
    olive: 0x808000,
    olivedrab: 0x6b8e23,
    orange: 0xffa500,
    orangered: 0xff4500,
    orchid: 0xda70d6,
    palegoldenrod: 0xeee8aa,
    palegreen: 0x98fb98,
    paleturquoise: 0xafeeee,
    palevioletred: 0xdb7093,
    papayawhip: 0xffefd5,
    peachpuff: 0xffdab9,
    peru: 0xcd853f,
    pink: 0xffc0cb,
    plum: 0xdda0dd,
    powderblue: 0xb0e0e6,
    purple: 0x800080,
    rebeccapurple: 0x663399,
    red: 0xff0000,
    rosybrown: 0xbc8f8f,
    royalblue: 0x4169e1,
    saddlebrown: 0x8b4513,
    salmon: 0xfa8072,
    sandybrown: 0xf4a460,
    seagreen: 0x2e8b57,
    seashell: 0xfff5ee,
    sienna: 0xa0522d,
    silver: 0xc0c0c0,
    skyblue: 0x87ceeb,
    slateblue: 0x6a5acd,
    slategray: 0x708090,
    slategrey: 0x708090,
    snow: 0xfffafa,
    springgreen: 0x00ff7f,
    steelblue: 0x4682b4,
    tan: 0xd2b48c,
    teal: 0x008080,
    thistle: 0xd8bfd8,
    tomato: 0xff6347,
    turquoise: 0x40e0d0,
    violet: 0xee82ee,
    wheat: 0xf5deb3,
    white: 0xffffff,
    whitesmoke: 0xf5f5f5,
    yellow: 0xffff00,
    yellowgreen: 0x9acd32
};
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$color$2f$src$2f$define$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(Color, color, {
    copy (channels) {
        return Object.assign(new this.constructor, this, channels);
    },
    displayable () {
        return this.rgb().displayable();
    },
    hex: color_formatHex,
    formatHex: color_formatHex,
    formatHex8: color_formatHex8,
    formatHsl: color_formatHsl,
    formatRgb: color_formatRgb,
    toString: color_formatRgb
});
function color_formatHex() {
    return this.rgb().formatHex();
}
function color_formatHex8() {
    return this.rgb().formatHex8();
}
function color_formatHsl() {
    return hslConvert(this).formatHsl();
}
function color_formatRgb() {
    return this.rgb().formatRgb();
}
function color(format) {
    var m, l;
    format = (format + "").trim().toLowerCase();
    return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
     : l === 3 ? new Rgb(m >> 8 & 0xf | m >> 4 & 0xf0, m >> 4 & 0xf | m & 0xf0, (m & 0xf) << 4 | m & 0xf, 1) // #f00
     : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
     : l === 4 ? rgba(m >> 12 & 0xf | m >> 8 & 0xf0, m >> 8 & 0xf | m >> 4 & 0xf0, m >> 4 & 0xf | m & 0xf0, ((m & 0xf) << 4 | m & 0xf) / 0xff) // #f000
     : null) // invalid hex
     : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
     : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
     : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
     : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
     : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
     : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
     : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
     : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
    return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}
function rgba(r, g, b, a) {
    if (a <= 0) r = g = b = NaN;
    return new Rgb(r, g, b, a);
}
function rgbConvert(o) {
    if (!(o instanceof Color)) o = color(o);
    if (!o) return new Rgb;
    o = o.rgb();
    return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
    return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
    this.r = +r;
    this.g = +g;
    this.b = +b;
    this.opacity = +opacity;
}
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$color$2f$src$2f$define$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(Rgb, rgb, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$color$2f$src$2f$define$2e$js__$5b$client$5d$__$28$ecmascript$29$__["extend"])(Color, {
    brighter (k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    darker (k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    rgb () {
        return this;
    },
    clamp () {
        return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
    },
    displayable () {
        return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
    },
    hex: rgb_formatHex,
    formatHex: rgb_formatHex,
    formatHex8: rgb_formatHex8,
    formatRgb: rgb_formatRgb,
    toString: rgb_formatRgb
}));
function rgb_formatHex() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}
function clampa(opacity) {
    return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
    return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
    value = clampi(value);
    return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s, l, a) {
    if (a <= 0) h = s = l = NaN;
    else if (l <= 0 || l >= 1) h = s = NaN;
    else if (s <= 0) h = NaN;
    return new Hsl(h, s, l, a);
}
function hslConvert(o) {
    if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Color)) o = color(o);
    if (!o) return new Hsl;
    if (o instanceof Hsl) return o;
    o = o.rgb();
    var r = o.r / 255, g = o.g / 255, b = o.b / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), h = NaN, s = max - min, l = (max + min) / 2;
    if (s) {
        if (r === max) h = (g - b) / s + (g < b) * 6;
        else if (g === max) h = (b - r) / s + 2;
        else h = (r - g) / s + 4;
        s /= l < 0.5 ? max + min : 2 - max - min;
        h *= 60;
    } else {
        s = l > 0 && l < 1 ? 0 : h;
    }
    return new Hsl(h, s, l, o.opacity);
}
function hsl(h, s, l, opacity) {
    return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s, l, opacity) {
    this.h = +h;
    this.s = +s;
    this.l = +l;
    this.opacity = +opacity;
}
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$color$2f$src$2f$define$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(Hsl, hsl, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$color$2f$src$2f$define$2e$js__$5b$client$5d$__$28$ecmascript$29$__["extend"])(Color, {
    brighter (k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    darker (k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    rgb () {
        var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
        return new Rgb(hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb(h, m1, m2), hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
    },
    clamp () {
        return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
    },
    displayable () {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
    },
    formatHsl () {
        const a = clampa(this.opacity);
        return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
    }
}));
function clamph(value) {
    value = (value || 0) % 360;
    return value < 0 ? value + 360 : value;
}
function clampt(value) {
    return Math.max(0, Math.min(1, value || 0));
}
/* From FvD 13.37, CSS Color Module Level 3 */ function hsl2rgb(h, m1, m2) {
    return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}
}}),
"[project]/node_modules/d3-color/src/color.js [client] (ecmascript) <export default as color>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "color": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$color$2f$src$2f$color$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$color$2f$src$2f$color$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-color/src/color.js [client] (ecmascript)");
}}),
"[project]/node_modules/d3-interpolate/src/basis.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "basis": (()=>basis),
    "default": (()=>__TURBOPACK__default__export__)
});
function basis(t1, v0, v1, v2, v3) {
    var t2 = t1 * t1, t3 = t2 * t1;
    return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
}
function __TURBOPACK__default__export__(values) {
    var n = values.length - 1;
    return function(t) {
        var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
        return basis((t - i / n) * n, v0, v1, v2, v3);
    };
}
}}),
"[project]/node_modules/d3-interpolate/src/basisClosed.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$basis$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-interpolate/src/basis.js [client] (ecmascript)");
;
function __TURBOPACK__default__export__(values) {
    var n = values.length;
    return function(t) {
        var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values[(i + n - 1) % n], v1 = values[i % n], v2 = values[(i + 1) % n], v3 = values[(i + 2) % n];
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$basis$2e$js__$5b$client$5d$__$28$ecmascript$29$__["basis"])((t - i / n) * n, v0, v1, v2, v3);
    };
}
}}),
"[project]/node_modules/d3-interpolate/src/constant.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = (x)=>()=>x;
}}),
"[project]/node_modules/d3-interpolate/src/color.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>nogamma),
    "gamma": (()=>gamma),
    "hue": (()=>hue)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$constant$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-interpolate/src/constant.js [client] (ecmascript)");
;
function linear(a, d) {
    return function(t) {
        return a + t * d;
    };
}
function exponential(a, b, y) {
    return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
        return Math.pow(a + t * b, y);
    };
}
function hue(a, b) {
    var d = b - a;
    return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$constant$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(isNaN(a) ? b : a);
}
function gamma(y) {
    return (y = +y) === 1 ? nogamma : function(a, b) {
        return b - a ? exponential(a, b, y) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$constant$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(isNaN(a) ? b : a);
    };
}
function nogamma(a, b) {
    var d = b - a;
    return d ? linear(a, d) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$constant$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(isNaN(a) ? b : a);
}
}}),
"[project]/node_modules/d3-interpolate/src/rgb.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__),
    "rgbBasis": (()=>rgbBasis),
    "rgbBasisClosed": (()=>rgbBasisClosed)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$color$2f$src$2f$color$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-color/src/color.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$basis$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-interpolate/src/basis.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$basisClosed$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-interpolate/src/basisClosed.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$color$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-interpolate/src/color.js [client] (ecmascript)");
;
;
;
;
const __TURBOPACK__default__export__ = function rgbGamma(y) {
    var color = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$color$2e$js__$5b$client$5d$__$28$ecmascript$29$__["gamma"])(y);
    function rgb(start, end) {
        var r = color((start = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$color$2f$src$2f$color$2e$js__$5b$client$5d$__$28$ecmascript$29$__["rgb"])(start)).r, (end = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$color$2f$src$2f$color$2e$js__$5b$client$5d$__$28$ecmascript$29$__["rgb"])(end)).r), g = color(start.g, end.g), b = color(start.b, end.b), opacity = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$color$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(start.opacity, end.opacity);
        return function(t) {
            start.r = r(t);
            start.g = g(t);
            start.b = b(t);
            start.opacity = opacity(t);
            return start + "";
        };
    }
    rgb.gamma = rgbGamma;
    return rgb;
}(1);
function rgbSpline(spline) {
    return function(colors) {
        var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color;
        for(i = 0; i < n; ++i){
            color = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$color$2f$src$2f$color$2e$js__$5b$client$5d$__$28$ecmascript$29$__["rgb"])(colors[i]);
            r[i] = color.r || 0;
            g[i] = color.g || 0;
            b[i] = color.b || 0;
        }
        r = spline(r);
        g = spline(g);
        b = spline(b);
        color.opacity = 1;
        return function(t) {
            color.r = r(t);
            color.g = g(t);
            color.b = b(t);
            return color + "";
        };
    };
}
var rgbBasis = rgbSpline(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$basis$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"]);
var rgbBasisClosed = rgbSpline(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$basisClosed$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"]);
}}),
"[project]/node_modules/d3-interpolate/src/numberArray.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__),
    "isNumberArray": (()=>isNumberArray)
});
function __TURBOPACK__default__export__(a, b) {
    if (!b) b = [];
    var n = a ? Math.min(b.length, a.length) : 0, c = b.slice(), i;
    return function(t) {
        for(i = 0; i < n; ++i)c[i] = a[i] * (1 - t) + b[i] * t;
        return c;
    };
}
function isNumberArray(x) {
    return ArrayBuffer.isView(x) && !(x instanceof DataView);
}
}}),
"[project]/node_modules/d3-interpolate/src/array.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__),
    "genericArray": (()=>genericArray)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$value$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-interpolate/src/value.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$numberArray$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-interpolate/src/numberArray.js [client] (ecmascript)");
;
;
function __TURBOPACK__default__export__(a, b) {
    return ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$numberArray$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isNumberArray"])(b) ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$numberArray$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"] : genericArray)(a, b);
}
function genericArray(a, b) {
    var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x = new Array(na), c = new Array(nb), i;
    for(i = 0; i < na; ++i)x[i] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$value$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(a[i], b[i]);
    for(; i < nb; ++i)c[i] = b[i];
    return function(t) {
        for(i = 0; i < na; ++i)c[i] = x[i](t);
        return c;
    };
}
}}),
"[project]/node_modules/d3-interpolate/src/date.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
function __TURBOPACK__default__export__(a, b) {
    var d = new Date;
    return a = +a, b = +b, function(t) {
        return d.setTime(a * (1 - t) + b * t), d;
    };
}
}}),
"[project]/node_modules/d3-interpolate/src/number.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
function __TURBOPACK__default__export__(a, b) {
    return a = +a, b = +b, function(t) {
        return a * (1 - t) + b * t;
    };
}
}}),
"[project]/node_modules/d3-interpolate/src/object.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$value$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-interpolate/src/value.js [client] (ecmascript)");
;
function __TURBOPACK__default__export__(a, b) {
    var i = {}, c = {}, k;
    if (a === null || typeof a !== "object") a = {};
    if (b === null || typeof b !== "object") b = {};
    for(k in b){
        if (k in a) {
            i[k] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$value$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(a[k], b[k]);
        } else {
            c[k] = b[k];
        }
    }
    return function(t) {
        for(k in i)c[k] = i[k](t);
        return c;
    };
}
}}),
"[project]/node_modules/d3-interpolate/src/string.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$number$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-interpolate/src/number.js [client] (ecmascript)");
;
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
function zero(b) {
    return function() {
        return b;
    };
}
function one(b) {
    return function(t) {
        return b(t) + "";
    };
}
function __TURBOPACK__default__export__(a, b) {
    var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = []; // number interpolators
    // Coerce inputs to strings.
    a = a + "", b = b + "";
    // Interpolate pairs of numbers in a & b.
    while((am = reA.exec(a)) && (bm = reB.exec(b))){
        if ((bs = bm.index) > bi) {
            bs = b.slice(bi, bs);
            if (s[i]) s[i] += bs; // coalesce with previous string
            else s[++i] = bs;
        }
        if ((am = am[0]) === (bm = bm[0])) {
            if (s[i]) s[i] += bm; // coalesce with previous string
            else s[++i] = bm;
        } else {
            s[++i] = null;
            q.push({
                i: i,
                x: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$number$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(am, bm)
            });
        }
        bi = reB.lastIndex;
    }
    // Add remains of b.
    if (bi < b.length) {
        bs = b.slice(bi);
        if (s[i]) s[i] += bs; // coalesce with previous string
        else s[++i] = bs;
    }
    // Special optimization for only a single match.
    // Otherwise, interpolate each of the numbers and rejoin the string.
    return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t) {
        for(var i = 0, o; i < b; ++i)s[(o = q[i]).i] = o.x(t);
        return s.join("");
    });
}
}}),
"[project]/node_modules/d3-interpolate/src/value.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$color$2f$src$2f$color$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__color$3e$__ = __turbopack_context__.i("[project]/node_modules/d3-color/src/color.js [client] (ecmascript) <export default as color>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$rgb$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-interpolate/src/rgb.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$array$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-interpolate/src/array.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$date$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-interpolate/src/date.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$number$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-interpolate/src/number.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$object$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-interpolate/src/object.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-interpolate/src/string.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$constant$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-interpolate/src/constant.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$numberArray$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-interpolate/src/numberArray.js [client] (ecmascript)");
;
;
;
;
;
;
;
;
;
function __TURBOPACK__default__export__(a, b) {
    var t = typeof b, c;
    return b == null || t === "boolean" ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$constant$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(b) : (t === "number" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$number$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"] : t === "string" ? (c = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$color$2f$src$2f$color$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__color$3e$__["color"])(b)) ? (b = c, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$rgb$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"]) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"] : b instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$color$2f$src$2f$color$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__default__as__color$3e$__["color"] ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$rgb$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"] : b instanceof Date ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$date$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"] : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$numberArray$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isNumberArray"])(b) ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$numberArray$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"] : Array.isArray(b) ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$array$2e$js__$5b$client$5d$__$28$ecmascript$29$__["genericArray"] : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$object$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$number$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(a, b);
}
}}),
"[project]/node_modules/d3-interpolate/src/value.js [client] (ecmascript) <export default as interpolate>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "interpolate": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$value$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$value$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-interpolate/src/value.js [client] (ecmascript)");
}}),
"[project]/node_modules/d3-interpolate/src/number.js [client] (ecmascript) <export default as interpolateNumber>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "interpolateNumber": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$number$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$number$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-interpolate/src/number.js [client] (ecmascript)");
}}),
"[project]/node_modules/d3-interpolate/src/round.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
function __TURBOPACK__default__export__(a, b) {
    return a = +a, b = +b, function(t) {
        return Math.round(a * (1 - t) + b * t);
    };
}
}}),
"[project]/node_modules/d3-interpolate/src/round.js [client] (ecmascript) <export default as interpolateRound>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "interpolateRound": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$round$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$interpolate$2f$src$2f$round$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-interpolate/src/round.js [client] (ecmascript)");
}}),
"[project]/node_modules/d3-format/src/formatDecimal.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__),
    "formatDecimalParts": (()=>formatDecimalParts)
});
function __TURBOPACK__default__export__(x) {
    return Math.abs(x = Math.round(x)) >= 1e21 ? x.toLocaleString("en").replace(/,/g, "") : x.toString(10);
}
function formatDecimalParts(x, p) {
    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
    var i, coefficient = x.slice(0, i);
    // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
    // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
    return [
        coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
        +x.slice(i + 1)
    ];
}
}}),
"[project]/node_modules/d3-format/src/exponent.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$formatDecimal$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-format/src/formatDecimal.js [client] (ecmascript)");
;
function __TURBOPACK__default__export__(x) {
    return x = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$formatDecimal$2e$js__$5b$client$5d$__$28$ecmascript$29$__["formatDecimalParts"])(Math.abs(x)), x ? x[1] : NaN;
}
}}),
"[project]/node_modules/d3-format/src/formatGroup.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
function __TURBOPACK__default__export__(grouping, thousands) {
    return function(value, width) {
        var i = value.length, t = [], j = 0, g = grouping[0], length = 0;
        while(i > 0 && g > 0){
            if (length + g + 1 > width) g = Math.max(1, width - length);
            t.push(value.substring(i -= g, i + g));
            if ((length += g + 1) > width) break;
            g = grouping[j = (j + 1) % grouping.length];
        }
        return t.reverse().join(thousands);
    };
}
}}),
"[project]/node_modules/d3-format/src/formatNumerals.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
function __TURBOPACK__default__export__(numerals) {
    return function(value) {
        return value.replace(/[0-9]/g, function(i) {
            return numerals[+i];
        });
    };
}
}}),
"[project]/node_modules/d3-format/src/formatSpecifier.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
__turbopack_context__.s({
    "FormatSpecifier": (()=>FormatSpecifier),
    "default": (()=>formatSpecifier)
});
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
    if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
    var match;
    return new FormatSpecifier({
        fill: match[1],
        align: match[2],
        sign: match[3],
        symbol: match[4],
        zero: match[5],
        width: match[6],
        comma: match[7],
        precision: match[8] && match[8].slice(1),
        trim: match[9],
        type: match[10]
    });
}
formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof
function FormatSpecifier(specifier) {
    this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
    this.align = specifier.align === undefined ? ">" : specifier.align + "";
    this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
    this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
    this.zero = !!specifier.zero;
    this.width = specifier.width === undefined ? undefined : +specifier.width;
    this.comma = !!specifier.comma;
    this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
    this.trim = !!specifier.trim;
    this.type = specifier.type === undefined ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
    return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === undefined ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
}}),
"[project]/node_modules/d3-format/src/formatTrim.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
function __TURBOPACK__default__export__(s) {
    out: for(var n = s.length, i = 1, i0 = -1, i1; i < n; ++i){
        switch(s[i]){
            case ".":
                i0 = i1 = i;
                break;
            case "0":
                if (i0 === 0) i0 = i;
                i1 = i;
                break;
            default:
                if (!+s[i]) break out;
                if (i0 > 0) i0 = 0;
                break;
        }
    }
    return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}
}}),
"[project]/node_modules/d3-format/src/formatPrefixAuto.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__),
    "prefixExponent": (()=>prefixExponent)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$formatDecimal$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-format/src/formatDecimal.js [client] (ecmascript)");
;
var prefixExponent;
function __TURBOPACK__default__export__(x, p) {
    var d = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$formatDecimal$2e$js__$5b$client$5d$__$28$ecmascript$29$__["formatDecimalParts"])(x, p);
    if (!d) return x + "";
    var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
    return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$formatDecimal$2e$js__$5b$client$5d$__$28$ecmascript$29$__["formatDecimalParts"])(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}
}}),
"[project]/node_modules/d3-format/src/formatRounded.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$formatDecimal$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-format/src/formatDecimal.js [client] (ecmascript)");
;
function __TURBOPACK__default__export__(x, p) {
    var d = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$formatDecimal$2e$js__$5b$client$5d$__$28$ecmascript$29$__["formatDecimalParts"])(x, p);
    if (!d) return x + "";
    var coefficient = d[0], exponent = d[1];
    return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}
}}),
"[project]/node_modules/d3-format/src/formatTypes.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$formatDecimal$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-format/src/formatDecimal.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$formatPrefixAuto$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-format/src/formatPrefixAuto.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$formatRounded$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-format/src/formatRounded.js [client] (ecmascript)");
;
;
;
const __TURBOPACK__default__export__ = {
    "%": (x, p)=>(x * 100).toFixed(p),
    "b": (x)=>Math.round(x).toString(2),
    "c": (x)=>x + "",
    "d": __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$formatDecimal$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"],
    "e": (x, p)=>x.toExponential(p),
    "f": (x, p)=>x.toFixed(p),
    "g": (x, p)=>x.toPrecision(p),
    "o": (x)=>Math.round(x).toString(8),
    "p": (x, p)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$formatRounded$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(x * 100, p),
    "r": __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$formatRounded$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"],
    "s": __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$formatPrefixAuto$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"],
    "X": (x)=>Math.round(x).toString(16).toUpperCase(),
    "x": (x)=>Math.round(x).toString(16)
};
}}),
"[project]/node_modules/d3-format/src/identity.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
function __TURBOPACK__default__export__(x) {
    return x;
}
}}),
"[project]/node_modules/d3-format/src/locale.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$exponent$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-format/src/exponent.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$formatGroup$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-format/src/formatGroup.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$formatNumerals$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-format/src/formatNumerals.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$formatSpecifier$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-format/src/formatSpecifier.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$formatTrim$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-format/src/formatTrim.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$formatTypes$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-format/src/formatTypes.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$formatPrefixAuto$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-format/src/formatPrefixAuto.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$identity$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-format/src/identity.js [client] (ecmascript)");
;
;
;
;
;
;
;
;
var map = Array.prototype.map, prefixes = [
    "y",
    "z",
    "a",
    "f",
    "p",
    "n",
    "µ",
    "m",
    "",
    "k",
    "M",
    "G",
    "T",
    "P",
    "E",
    "Z",
    "Y"
];
function __TURBOPACK__default__export__(locale) {
    var group = locale.grouping === undefined || locale.thousands === undefined ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$identity$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"] : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$formatGroup$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(map.call(locale.grouping, Number), locale.thousands + ""), currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "", currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "", decimal = locale.decimal === undefined ? "." : locale.decimal + "", numerals = locale.numerals === undefined ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$identity$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"] : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$formatNumerals$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(map.call(locale.numerals, String)), percent = locale.percent === undefined ? "%" : locale.percent + "", minus = locale.minus === undefined ? "−" : locale.minus + "", nan = locale.nan === undefined ? "NaN" : locale.nan + "";
    function newFormat(specifier) {
        specifier = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$formatSpecifier$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(specifier);
        var fill = specifier.fill, align = specifier.align, sign = specifier.sign, symbol = specifier.symbol, zero = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type = specifier.type;
        // The "n" type is an alias for ",g".
        if (type === "n") comma = true, type = "g";
        else if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$formatTypes$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"][type]) precision === undefined && (precision = 12), trim = true, type = "g";
        // If zero fill is specified, padding goes after sign and before digits.
        if (zero || fill === "0" && align === "=") zero = true, fill = "0", align = "=";
        // Compute the prefix and suffix.
        // For SI-prefix, the suffix is lazily computed.
        var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
        // What format function should we use?
        // Is this an integer type?
        // Can this type generate exponential notation?
        var formatType = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$formatTypes$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"][type], maybeSuffix = /[defgprs%]/.test(type);
        // Set the default precision if not specified,
        // or clamp the specified precision to the supported range.
        // For significant precision, it must be in [1, 21].
        // For fixed precision, it must be in [0, 20].
        precision = precision === undefined ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
        function format(value) {
            var valuePrefix = prefix, valueSuffix = suffix, i, n, c;
            if (type === "c") {
                valueSuffix = formatType(value) + valueSuffix;
                value = "";
            } else {
                value = +value;
                // Determine the sign. -0 is not less than 0, but 1 / -0 is!
                var valueNegative = value < 0 || 1 / value < 0;
                // Perform the initial formatting.
                value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
                // Trim insignificant zeros.
                if (trim) value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$formatTrim$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(value);
                // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
                if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;
                // Compute the prefix and suffix.
                valuePrefix = (valueNegative ? sign === "(" ? sign : minus : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
                valueSuffix = (type === "s" ? prefixes[8 + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$formatPrefixAuto$2e$js__$5b$client$5d$__$28$ecmascript$29$__["prefixExponent"] / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
                // Break the formatted value into the integer “value” part that can be
                // grouped, and fractional or exponential “suffix” part that is not.
                if (maybeSuffix) {
                    i = -1, n = value.length;
                    while(++i < n){
                        if (c = value.charCodeAt(i), 48 > c || c > 57) {
                            valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                            value = value.slice(0, i);
                            break;
                        }
                    }
                }
            }
            // If the fill character is not "0", grouping is applied before padding.
            if (comma && !zero) value = group(value, Infinity);
            // Compute the padding.
            var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
            // If the fill character is "0", grouping is applied after padding.
            if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
            // Reconstruct the final output based on the desired alignment.
            switch(align){
                case "<":
                    value = valuePrefix + value + valueSuffix + padding;
                    break;
                case "=":
                    value = valuePrefix + padding + value + valueSuffix;
                    break;
                case "^":
                    value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
                    break;
                default:
                    value = padding + valuePrefix + value + valueSuffix;
                    break;
            }
            return numerals(value);
        }
        format.toString = function() {
            return specifier + "";
        };
        return format;
    }
    function formatPrefix(specifier, value) {
        var f = newFormat((specifier = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$formatSpecifier$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$exponent$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(value) / 3))) * 3, k = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
        return function(value) {
            return f(k * value) + prefix;
        };
    }
    return {
        format: newFormat,
        formatPrefix: formatPrefix
    };
}
}}),
"[project]/node_modules/d3-format/src/defaultLocale.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>defaultLocale),
    "format": (()=>format),
    "formatPrefix": (()=>formatPrefix)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$locale$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-format/src/locale.js [client] (ecmascript)");
;
var locale;
var format;
var formatPrefix;
defaultLocale({
    thousands: ",",
    grouping: [
        3
    ],
    currency: [
        "$",
        ""
    ]
});
function defaultLocale(definition) {
    locale = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$locale$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(definition);
    format = locale.format;
    formatPrefix = locale.formatPrefix;
    return locale;
}
}}),
"[project]/node_modules/d3-format/src/formatSpecifier.js [client] (ecmascript) <export default as formatSpecifier>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "formatSpecifier": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$formatSpecifier$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$formatSpecifier$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-format/src/formatSpecifier.js [client] (ecmascript)");
}}),
"[project]/node_modules/d3-format/src/precisionFixed.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$exponent$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-format/src/exponent.js [client] (ecmascript)");
;
function __TURBOPACK__default__export__(step) {
    return Math.max(0, -(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$exponent$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(Math.abs(step)));
}
}}),
"[project]/node_modules/d3-format/src/precisionFixed.js [client] (ecmascript) <export default as precisionFixed>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "precisionFixed": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$precisionFixed$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$precisionFixed$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-format/src/precisionFixed.js [client] (ecmascript)");
}}),
"[project]/node_modules/d3-format/src/precisionPrefix.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$exponent$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-format/src/exponent.js [client] (ecmascript)");
;
function __TURBOPACK__default__export__(step, value) {
    return Math.max(0, Math.max(-8, Math.min(8, Math.floor((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$exponent$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(value) / 3))) * 3 - (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$exponent$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(Math.abs(step)));
}
}}),
"[project]/node_modules/d3-format/src/precisionPrefix.js [client] (ecmascript) <export default as precisionPrefix>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "precisionPrefix": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$precisionPrefix$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$precisionPrefix$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-format/src/precisionPrefix.js [client] (ecmascript)");
}}),
"[project]/node_modules/d3-format/src/precisionRound.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$exponent$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-format/src/exponent.js [client] (ecmascript)");
;
function __TURBOPACK__default__export__(step, max) {
    step = Math.abs(step), max = Math.abs(max) - step;
    return Math.max(0, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$exponent$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(max) - (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$exponent$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(step)) + 1;
}
}}),
"[project]/node_modules/d3-format/src/precisionRound.js [client] (ecmascript) <export default as precisionRound>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "precisionRound": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$precisionRound$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$precisionRound$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/d3-format/src/precisionRound.js [client] (ecmascript)");
}}),
"[project]/node_modules/internmap/src/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "InternMap": (()=>InternMap),
    "InternSet": (()=>InternSet)
});
class InternMap extends Map {
    constructor(entries, key = keyof){
        super();
        Object.defineProperties(this, {
            _intern: {
                value: new Map()
            },
            _key: {
                value: key
            }
        });
        if (entries != null) for (const [key, value] of entries)this.set(key, value);
    }
    get(key) {
        return super.get(intern_get(this, key));
    }
    has(key) {
        return super.has(intern_get(this, key));
    }
    set(key, value) {
        return super.set(intern_set(this, key), value);
    }
    delete(key) {
        return super.delete(intern_delete(this, key));
    }
}
class InternSet extends Set {
    constructor(values, key = keyof){
        super();
        Object.defineProperties(this, {
            _intern: {
                value: new Map()
            },
            _key: {
                value: key
            }
        });
        if (values != null) for (const value of values)this.add(value);
    }
    has(value) {
        return super.has(intern_get(this, value));
    }
    add(value) {
        return super.add(intern_set(this, value));
    }
    delete(value) {
        return super.delete(intern_delete(this, value));
    }
}
function intern_get({ _intern, _key }, value) {
    const key = _key(value);
    return _intern.has(key) ? _intern.get(key) : value;
}
function intern_set({ _intern, _key }, value) {
    const key = _key(value);
    if (_intern.has(key)) return _intern.get(key);
    _intern.set(key, value);
    return value;
}
function intern_delete({ _intern, _key }, value) {
    const key = _key(value);
    if (_intern.has(key)) {
        value = _intern.get(key);
        _intern.delete(key);
    }
    return value;
}
function keyof(value) {
    return value !== null && typeof value === "object" ? value.valueOf() : value;
}
}}),
}]);

//# sourceMappingURL=node_modules_6f62648a._.js.map